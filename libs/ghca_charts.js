ghca_charts =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	var ghca_charts = {};
	
	//create folder object
	ghca_charts.effet = {};
	ghca_charts.events = {};
	ghca_charts.layout = {};
	ghca_charts.layout.model = {};
	ghca_charts.view = {};
	ghca_charts.view.component = {};
	ghca_charts.view.component.charts = {};
	ghca_charts.view.component.gis = {};
	ghca_charts.view.component.importcomponents = {};
	ghca_charts.view.component.utilcomponents = {};
	ghca_charts.view.elements = {};
	ghca_charts.view.elements.plugins = {};
	ghca_charts.view.elements.plugins.label = {};
	ghca_charts.view.elements.plugins.links = {};
	ghca_charts.view.elements.plugins.nodes = {};
	ghca_charts.view.elements.plugins.tool = {};
	ghca_charts.view.elements.shape = {};
	ghca_charts.view.util = {};
	
	//sava folder object
	var folders = [];
	function saveFolders(obj) {
	    for(var key in obj) {
	        folders.push(obj[key]);
	        saveFolders(obj[key]);
	    }
	}
	saveFolders(ghca_charts);
	
	//import js files
	ghca_charts.effet.Effet = __webpack_require__(1);
	ghca_charts.effet.eraserEffet = __webpack_require__(3);
	ghca_charts.events.BaseEvent = __webpack_require__(4);
	ghca_charts.global = __webpack_require__(5);
	ghca_charts.layout.barLayout = __webpack_require__(6);
	ghca_charts.layout.calendarLayout = __webpack_require__(7);
	ghca_charts.layout.horizontalLayout = __webpack_require__(8);
	ghca_charts.layout.layout = __webpack_require__(9);
	ghca_charts.layout.layoutFeatures = __webpack_require__(10);
	ghca_charts.layout.model.sankeyModel = __webpack_require__(11);
	ghca_charts.layout.packLayout = __webpack_require__(12);
	ghca_charts.layout.pieLayout = __webpack_require__(13);
	ghca_charts.layout.progressBarLayout = __webpack_require__(14);
	ghca_charts.layout.sankeyLayout = __webpack_require__(15);
	ghca_charts.layout.scatterLayout = __webpack_require__(16);
	ghca_charts.layout.sunburstLayout = __webpack_require__(17);
	ghca_charts.layout.topoLayout = __webpack_require__(18);
	ghca_charts.layout.treelayout = __webpack_require__(19);
	ghca_charts.layout.treemapLayout = __webpack_require__(20);
	ghca_charts.layout.verticalLayout = __webpack_require__(21);
	ghca_charts.view.component.baseComponent = __webpack_require__(22);
	ghca_charts.view.component.chartMap = __webpack_require__(23);
	ghca_charts.view.component.charts.area = __webpack_require__(24);
	ghca_charts.view.component.charts.axis = __webpack_require__(25);
	ghca_charts.view.component.charts.bar = __webpack_require__(26);
	ghca_charts.view.component.charts.baseAxis = __webpack_require__(27);
	ghca_charts.view.component.charts.baseChart = __webpack_require__(28);
	ghca_charts.view.component.charts.bizTopology = __webpack_require__(29);
	ghca_charts.view.component.charts.calendar = __webpack_require__(30);
	ghca_charts.view.component.charts.chart = __webpack_require__(31);
	ghca_charts.view.component.charts.editorTopology = __webpack_require__(32);
	ghca_charts.view.component.charts.heading = __webpack_require__(33);
	ghca_charts.view.component.charts.horAxis = __webpack_require__(34);
	ghca_charts.view.component.charts.legend = __webpack_require__(35);
	ghca_charts.view.component.charts.legendItem = __webpack_require__(36);
	ghca_charts.view.component.charts.line = __webpack_require__(37);
	ghca_charts.view.component.charts.pack = __webpack_require__(38);
	ghca_charts.view.component.charts.pie = __webpack_require__(39);
	ghca_charts.view.component.charts.progressBar = __webpack_require__(40);
	ghca_charts.view.component.charts.sankey = __webpack_require__(41);
	ghca_charts.view.component.charts.scatter = __webpack_require__(42);
	ghca_charts.view.component.charts.sunburst = __webpack_require__(43);
	ghca_charts.view.component.charts.topology = __webpack_require__(44);
	ghca_charts.view.component.charts.tree = __webpack_require__(45);
	ghca_charts.view.component.charts.treemap = __webpack_require__(46);
	ghca_charts.view.component.charts.verAxis = __webpack_require__(47);
	ghca_charts.view.component.eagleEye = __webpack_require__(48);
	ghca_charts.view.component.eagleEyeContainer = __webpack_require__(49);
	ghca_charts.view.component.gis.gisMap = __webpack_require__(50);
	ghca_charts.view.component.importcomponents.comboBox = __webpack_require__(51);
	ghca_charts.view.component.importcomponents.dateTimeBox = __webpack_require__(52);
	ghca_charts.view.component.importcomponents.iFrame = __webpack_require__(53);
	ghca_charts.view.component.importcomponents.linkButton = __webpack_require__(54);
	ghca_charts.view.component.importcomponents.multiTextLabel = __webpack_require__(55);
	ghca_charts.view.component.importcomponents.textLabel = __webpack_require__(56);
	ghca_charts.view.component.svg = __webpack_require__(57);
	ghca_charts.view.component.svgCanvas = __webpack_require__(58);
	ghca_charts.view.component.table = __webpack_require__(59);
	ghca_charts.view.component.tagContainer = __webpack_require__(60);
	ghca_charts.view.component.utilcomponents.evDataDispatcher = __webpack_require__(61);
	ghca_charts.view.component.utilcomponents.timer = __webpack_require__(62);
	ghca_charts.view.elements.baseElement = __webpack_require__(63);
	ghca_charts.view.elements.circleElement = __webpack_require__(64);
	ghca_charts.view.elements.imageElement = __webpack_require__(65);
	ghca_charts.view.elements.mulitextElement = __webpack_require__(66);
	ghca_charts.view.elements.pathElement = __webpack_require__(67);
	ghca_charts.view.elements.plugins.imageTag = __webpack_require__(68);
	ghca_charts.view.elements.plugins.label.baseLabel = __webpack_require__(69);
	ghca_charts.view.elements.plugins.label.groupLabel = __webpack_require__(70);
	ghca_charts.view.elements.plugins.label.label = __webpack_require__(71);
	ghca_charts.view.elements.plugins.label.packLabel = __webpack_require__(72);
	ghca_charts.view.elements.plugins.label.pieLabel = __webpack_require__(73);
	ghca_charts.view.elements.plugins.label.topoLabel = __webpack_require__(74);
	ghca_charts.view.elements.plugins.linkMap = __webpack_require__(75);
	ghca_charts.view.elements.plugins.links.baseLink = __webpack_require__(76);
	ghca_charts.view.elements.plugins.links.configLink = __webpack_require__(77);
	ghca_charts.view.elements.plugins.links.curveLink = __webpack_require__(78);
	ghca_charts.view.elements.plugins.links.link = __webpack_require__(79);
	ghca_charts.view.elements.plugins.links.parallelLink = __webpack_require__(80);
	ghca_charts.view.elements.plugins.links.sankeyLink = __webpack_require__(81);
	ghca_charts.view.elements.plugins.nodeMap = __webpack_require__(82);
	ghca_charts.view.elements.plugins.nodes.arcClass = __webpack_require__(83);
	ghca_charts.view.elements.plugins.nodes.baseNode = __webpack_require__(84);
	ghca_charts.view.elements.plugins.nodes.circle = __webpack_require__(85);
	ghca_charts.view.elements.plugins.nodes.configGroupNode = __webpack_require__(86);
	ghca_charts.view.elements.plugins.nodes.demoImageNode = __webpack_require__(87);
	ghca_charts.view.elements.plugins.nodes.expandTool = __webpack_require__(88);
	ghca_charts.view.elements.plugins.nodes.groupNode = __webpack_require__(89);
	ghca_charts.view.elements.plugins.nodes.hBarNode = __webpack_require__(90);
	ghca_charts.view.elements.plugins.nodes.hProgressBarNode = __webpack_require__(91);
	ghca_charts.view.elements.plugins.nodes.IconNode = __webpack_require__(92);
	ghca_charts.view.elements.plugins.nodes.imageNode = __webpack_require__(93);
	ghca_charts.view.elements.plugins.nodes.lineNode = __webpack_require__(94);
	ghca_charts.view.elements.plugins.nodes.moreTool = __webpack_require__(95);
	ghca_charts.view.elements.plugins.nodes.node = __webpack_require__(96);
	ghca_charts.view.elements.plugins.nodes.packNode = __webpack_require__(97);
	ghca_charts.view.elements.plugins.nodes.pathNode = __webpack_require__(98);
	ghca_charts.view.elements.plugins.nodes.rect = __webpack_require__(99);
	ghca_charts.view.elements.plugins.nodes.sankeyNode = __webpack_require__(100);
	ghca_charts.view.elements.plugins.nodes.sunburstNode = __webpack_require__(101);
	ghca_charts.view.elements.plugins.nodes.treemapNode = __webpack_require__(102);
	ghca_charts.view.elements.plugins.nodes.usePlugin = __webpack_require__(103);
	ghca_charts.view.elements.plugins.nodes.vBarNode = __webpack_require__(104);
	ghca_charts.view.elements.plugins.nodes.verTool = __webpack_require__(105);
	ghca_charts.view.elements.plugins.plugin = __webpack_require__(106);
	ghca_charts.view.elements.plugins.pluginMap = __webpack_require__(107);
	ghca_charts.view.elements.plugins.tool.percentageInfo = __webpack_require__(108);
	ghca_charts.view.elements.plugins.tool.toolTip = __webpack_require__(109);
	ghca_charts.view.elements.rectElement = __webpack_require__(110);
	ghca_charts.view.elements.shape.baseShape = __webpack_require__(111);
	ghca_charts.view.elements.shape.circleShape = __webpack_require__(112);
	ghca_charts.view.elements.shape.rectShape = __webpack_require__(113);
	ghca_charts.view.graph = __webpack_require__(114);
	ghca_charts.view.util.classFactory = __webpack_require__(115);
	ghca_charts.view.util.colorUtil = __webpack_require__(116);
	ghca_charts.view.util.commonUtil = __webpack_require__(117);
	ghca_charts.view.util.constant = __webpack_require__(118);
	ghca_charts.view.util.dataParser = __webpack_require__(119);
	ghca_charts.view.util.elementUtil = __webpack_require__(120);
	ghca_charts.view.util.eventUtil = __webpack_require__(121);
	ghca_charts.view.util.fileUtil = __webpack_require__(122);
	ghca_charts.view.util.math = __webpack_require__(123);
	ghca_charts.view.util.mouseUtil = __webpack_require__(124);
	ghca_charts.view.util.objectUtil = __webpack_require__(125);
	ghca_charts.view.util.regexUtil = __webpack_require__(126);
	ghca_charts.view.util.selectUtil = __webpack_require__(127);
	ghca_charts.view.util.stringUtil = __webpack_require__(128);
	ghca_charts.view.util.svgUtil = __webpack_require__(129);
	ghca_charts.view.util.tableColFormatterUtil = __webpack_require__(130);
	ghca_charts.view.util.UUIDUtil = __webpack_require__(131);
	
	//call struct function
	function callStruct(obj) {
	    for(var key in obj) {
	        var value = obj[key];
	        if(value instanceof Function && value.hasOwnProperty('struct')) {
	            value.struct(ghca_charts);
	        } else if(folders.indexOf(value) !== -1) {
	            callStruct(value);
	        }
	    }
	}
	callStruct(ghca_charts);
	
	module.exports = ghca_charts;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {var Effet = function () {
	    var self = this;
	    self.dispatch = d3.dispatch("play","end","stop");
	
	    /**
	     * 配置
	     * @returns {string}
	     */
	    var config = {};
	    this.config = function(value){
	        if(!arguments.length)return config;
	        config = value;
	        return this;
	    }
	    /**
	     * 目标对象
	     */
	    var target;
	    this.target = function(value){
	        if(!arguments.length)return target;
	        target = value;
	        return this;
	    }
	    /**
	     * 开始播放效果
	     */
	    this.play = function(){
	
	    }
	    /**
	     * 停止播放效果
	     */
	    this.stop = function(){
	
	    }
	
	    /**
	     * 播放结束效果
	     */
	    this.end = function(){
	
	    }
	    /**
	     * 添加事件监听
	     */
	    this.addEventListener = function() {
	        var value = self.dispatch.on.apply(self.dispatch, arguments);
	        return value === self.dispatch ? self : value;
	    };
	};
	
	
	Effet.struct = function(ghca_charts) {
	    Effet.prototype.constructor = Effet;
	};
	
	module.exports = Effet;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 2 */
/***/ (function(module, exports) {

	module.exports = d3;

/***/ }),
/* 3 */
/***/ (function(module, exports) {

	var EraserEffet = function () {
	
	    // --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	
	    const BaseEvent = ghca_charts.events.BaseEvent;
	    const UUIDUtil = ghca_charts.view.util.UUIDUtil;
	    const RegexUtil = ghca_charts.view.util.regexUtil;
	    const EventUtil = ghca_charts.view.util.eventUtil;
	
	    var self = this;
	    self.config({
	        dasharray:"5,5",
	        borderWidth:2,
	        borderColor:"{color}",
	        borderOpacity:.6,
	    });
	
	    var templete =     "<clipPath class='eraserEffet'>"+
	    "<path ></path>"+
	    "</clipPath>";
	
	    this.play = function(){
	
	    }
	
	    this.stop = function(){
	
	    }
	
	    this.end = function(){
	
	    }
	
	};
	
	EraserEffet.struct = function(ghca_charts) {
	    var Plugin = ghca_charts.view.elements.plugins.plugin;
	    Plugin.struct(ghca_charts);
	    EraserEffet.prototype = Object.create(Plugin.prototype);
	    EraserEffet.prototype.constructor = EraserEffet;
	};
	module.exports = EraserEffet;

/***/ }),
/* 4 */
/***/ (function(module, exports) {

	var BaseEvent = function (_target,_data) {
	    var self = this;
	    self.data = _data;
	    self.target = _target;
	};
	
	BaseEvent.struct = function(ghca_charts) {
		BaseEvent.prototype.constructor = BaseEvent;
	};
	
	// --------------------------------------------------------------------------
	//
	// Const
	//
	// --------------------------------------------------------------------------
	
	BaseEvent.LEGEND_ITEM_CLICK         = "legendItemClick";            //图例项鼠标点击事件
	BaseEvent.CHART_VISIBLE             = "chartVisible";               //图表显示或者隐藏
	BaseEvent.NODE_MOUSE_OVER           = "nodeMouseOver";              //鼠标经过节点
	BaseEvent.NODE_MOUSE_OUT            = "nodeMouseOut";               //鼠标移出节点
	BaseEvent.NODE_CLICK                = "nodeClick";                  //鼠标单击节点
	BaseEvent.LINK_CLICK                = "linkClick";                  //鼠标单击连线
	
	BaseEvent.SELECT_CHANGE             = "selectChange";               //选项更改
	BaseEvent.RING_LABEL_CLICK          = "ringLabelClick";             //鼠标单击环标签
	BaseEvent.SHOW_TOOL_TIP             = "showToolTip";                //显示tooltip
	BaseEvent.HIDE_TOOL_TIP             = "hideToolTip";                //隐藏tooltip
	BaseEvent.UPDATE_TOOL_TIP           = "updateToolTip";              //更新tooltip内容
	BaseEvent.MODE_CHANGE               = "modeChange";                 //变更图表当前模式
	BaseEvent.ADD_ITEMS                 = "addItems";                   //变更图表当前模式
	//BaseEvent.OPERATION_TYPE            = "operationType";              //变更图表操作类型
	BaseEvent.OPEN_FLUX_TYPE            = "openFlux";                   //开启流量
	BaseEvent.OPEN_ALARM_TYPE           = "openAlarm";                  //开启告警
	BaseEvent.TOPO_EDIT_POSITON           = "topo_edit_positon";                  //拓扑图编辑位置
	// BaseEvent.OPERATION_END             = "operationEnd";               //操作完成
	// BaseEvent.OPERATION_CLEAR           = "operationClear";          //清除操作状态
	BaseEvent.REMOVE_ITEMS              = "removeItems";                //变更图表当前模式
	BaseEvent.REOMVE_ALL_SELECTED_ITEMS = "removeAllSelectedItems";     //变更图表当前模式
	BaseEvent.SEARCH_TEXT               = "searchText";                 //搜索字符串
	BaseEvent.UPDATE_PROPERTIES         = "updateProperties";           //更新属性
	BaseEvent.HIDDEN_PROPERTIES         = "hiddeProperties";            //隐藏属性
	BaseEvent.TOPO_NODE_FOCUS_IN        = "topoNodeFocusIn";            //拓扑节点凸显
	BaseEvent.SLIDER_RANGE_CHANGE       = "sliderRangeChange";          //范围选择组件范围改变
	BaseEvent.SLIDER_MOVE_END       = "slider_move_end";          //范围选择组件范围改变
	BaseEvent.EV_EVENT_DATA_STORAGE     = "chart_eventDataStorage";     //保存数据
	BaseEvent.EV_EVENT_OPEN_EDIT        = "chart_eventOpenEdit";        //可编辑组件开始编辑
	BaseEvent.SET_CON_CSS               = "setConCss";                  //设置外层容器css
	BaseEvent.SCALE_CHANGE  			= "scale_change";
	
	BaseEvent.TIMER_CONTROL             = "timerControl";               //命令计时器执行行为，需传行为类型{action:start|stop|reset}
	BaseEvent.TIMER_STRAT               = "timerStart";                 //计时器开始抛出事件
	BaseEvent.TIMER_EVENT               = "timerEvent";                 //计时器心跳抛出事件
	BaseEvent.TIMER_STOP               	= "timerStop";                 	//计时器停止抛出事件
	
	BaseEvent.REQ_DATA_COMPLETE         = "reqDataComplete";            //请求数据完毕抛出事件
	
	//------------------------ eagleEye event start -----------------------------
	//主视图位置变更事件
	BaseEvent.POSITION_CHANGE  = "positionChange";
	//视图可视大小变更事件
	BaseEvent.SIZE_CHANGE      = "sizeChange";
	//视图内容变更事件
	BaseEvent.CONTENT_CHANGE   = "contentChange";
	//鹰眼拖动事件
	BaseEvent.EAGLE_EYE_DRAG   = "eagleEyeDrag";
	//鹰眼是否可操控
	BaseEvent.EAGLE_EYE_DRAG_CHANGE      = "eagleEyeDragChange";
	//------------------------ eagleEye event end -----------------------------
	
	//------------------------ notice event start -----------------------------
	BaseEvent.CUSTOM_EVENT_PREFIX   = "ev_";            //通知graph外层事件中的自定义事件名称前缀
	BaseEvent.NOTICE_EVENT_NAME     = "eventNotice";    //通知graph外层事件名称
	
	//type
	BaseEvent.NOTICE_EVENT_TYPE_TRIGGER     = 1;    //触发
	BaseEvent.NOTICE_EVENT_TYPE_RESPONSE    = 2;    //响应
	
	//bindEvent
	BaseEvent.NOTICE_REFRESH_DATA     = "noticeRefreshData";         //刷新数据
	BaseEvent.NOTICE_SYN_TOOL_TIP     = "noticeSynToolTip";          //同步悬浮提示
	//------------------------ notice event end -----------------------------
	
	module.exports = BaseEvent;


/***/ }),
/* 5 */
/***/ (function(module, exports) {

	//全局对象
	var Global = {};
	
	//---release config start
	//是否测试版本，发布时注意更改
	Global.isDebug = false;
	//是否用于ev可视化平台，发布时注意更改
	Global.isUseByEVPlatform = true;
	//---release config end
	
	//可视化平台编辑器中，当前是否处于编辑页面
	Global.isEVPlatformEditPage = window.location.href.indexOf('visual/stage') !== -1;
	
	//外部插件映射关系
	Global.outerPlugins = {
		componentMap:{},
		chartMap:{},
		layoutMap:{},
		pluginMap:{},
		nodeMap:{},
		linkMap:{}
	};
	
	module.exports = Global;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {//柱状图默认布局类，继承自Layout，有normal|stack|percentStack|overlap等类型
	    
	/**
	 * 构造方法
	 * @param _target 要使用该布局的容器或者组件对象引用
	 * @param _data 布局配置数据
	 */
	var BarLayout = function (_target, _data) {
	    
	    // --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const Layout = ghca_charts.layout.layout;
	    const Global = ghca_charts.global;
	
	    Layout.apply(this, arguments);
	    
	    var self = this;
	    
	    //--------------------------------------------------------------------------
	    //
	    //  Attributes
	    //
	    //--------------------------------------------------------------------------
	    
	    //------------------------------
	    //  items
	    //------------------------------
	    
	    /**
	     * 项数据数组
	     */
	    var items = [];
	    this.items = function(value) {
	        if (!arguments.length)
	            return items;
	        items = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  barType
	    //------------------------------
	    
	    /**
	     * 柱状图类型 normal|stack|percentStack|overlap
	     */
	    var barType = "normal";
	    this.barType = function(value) {
	        if (!arguments.length) return barType;                
	        barType = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  isReverse
	    //------------------------------
	    
	    /**
	     * 柱状图是否倒置显示
	     */
	    var isReverse = false;
	    this.isReverse = function(value) {
	        if (!arguments.length) return isReverse;                
	        isReverse = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  stackName
	    //------------------------------
	    
	    /**
	     * 柱状图stack名称，仅当barType为stack|percentStack时有效
	     */
	    var stackName = null;
	    this.stackName = function(value) {
	        if (!arguments.length) return stackName;                
	        stackName = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  padding
	    //------------------------------
	    
	    /**
	     * enum类型坐标轴bar间隔距离，为bandWidth的百分比小数, 范围[0-1]
	     */
	    var padding = 0.1;
	    this.padding = function(value) {
	        if (!arguments.length) return padding;   
	        padding = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  maxBarSize
	    //------------------------------
	    
	    /**
	     * 垂直柱的最大宽度，水平柱的最大高度
	     */
	    var maxBarSize = NaN;
	    this.maxBarSize = function(value) {
	        if (!arguments.length) return maxBarSize;                
	        maxBarSize = value;
	        return this;
	    };
	    
	    //--------------------------------------------------------------------------
	    //
	    //  public Methods
	    //
	    //--------------------------------------------------------------------------
	    
	    /**
	     * override度量方法
	     */
	    this.measure = function(isResize) {
	    	var xScale, yScale, xKey, yKey, xType, yType, horAxis, verAxis, childScale,
	            barNum = 0,//一个枚举刻度对应的柱个数
	    	    target = self.target(),
	    	    seriesData = target.seriesData();
	    	
	        if(target.horAxis()) {
	            horAxis = target.horAxis();
	            xScale = horAxis.scaleIns();
	            xScale = xScale.rangeRound(xScale.range());
	            xKey = horAxis.key();
	            xType = horAxis.type();
	        }
	        if(target.verAxis()) {
	            verAxis = target.verAxis();
	            yScale = verAxis.scaleIns();
	            yScale = yScale.rangeRound(yScale.range());
	            yKey = verAxis.key();
	            yType = verAxis.type();
	        }
	        var horInterval = horAxis.interval(), 
	            verInterval = verAxis.interval(), 
	            data = target.visibleItems(),
	            isVerBar = xType === "enum" && yType !== "enum",
	            valueKey = isVerBar ? yKey : xKey;
	            
	        //统计所有series中bar的信息
	        if(seriesData && seriesData.length > 0) {
	            var seriesIndex = target.seriesIndex();
	            var selfData = seriesData[seriesIndex];
	            var stackIndex, stackNum, barKey, barIndex = NaN, stacks = {}, barKeys = [];
	            for(var i = 0, len1 = seriesData.length; i < len1; i++) {
	            	var chartData = seriesData[i];
	            	var items = chartData.data;
	            	var visibleItems = items.filter(function(d) {
	            		return !d.hasOwnProperty("visible") || d.visible;
	            	});
	            	if(visibleItems.length === 0) {
	            		continue;
	            	}
	                var layout = chartData.layout;
	                stackNum = 0;
	                if(layout.type.toLowerCase() === "barlayout") {
	                	var barType = layout.barType;
	                	barKey = getBarKey(layout, i);
	                    if(barKeys.indexOf(barKey) === -1) {
	                        barKeys.push(barKey);
	                    }
	                    if(!layout.hasOwnProperty("barType") || barType === "normal") {
	                        barNum++;
	                    } else if(barType === "stack" || barType === "percentStack") {
	                    	if(!stacks.hasOwnProperty(barKey)) {
	                    		stacks[barKey] = [];
	                            barNum++;
	                    	}
	                    	stacks[barKey].push(items);
	                    	stackNum = stacks[barKey].length;
	                    } else if(barType === "overlap") {
	                    	barNum = 1;
	                    }
	                    if(seriesIndex === i) {
	                        barIndex = barKeys.indexOf(barKey);//本seriechart所在所有柱队列的索引值
	                        stackIndex = stackNum - 1;//本seriechart所在柱中栈的索引值
	                        var stack = stacks[barKey];
	                        for(var j = 0, len2 = items.length; j < len2; j++) {
	                            var item = items[j];
	                            var stackValue = 0;
	                            for(var k = 0; k < stackIndex; k++) {
	                            	stackValue += stack[k][j][valueKey];
	                            }
	                            item.stackValue = stackValue;
	                        }
	                    }
	                }
	            }
	            
	            if(barNum === 0) {
	                return;
	            }
	            
	            //计算total
	            var stack, items, item, totals = [];
	            for(var key in stacks) {
	            	totals.length = 0;
	            	stack = stacks[key];
	            	for(var i = 0, len1 = stack.length; i < len1; i++) {
	            		items = stack[i];
	            		for(var j = 0, len2 = items.length; j < len2; j++) {
	                        item = items[j];
	                        if(i === 0) {
	                        	totals.push(item[valueKey]);
	                        } else {
	                        	totals[j] += item[valueKey];
	                        }
	                    }
	            	}
	            	for(var i = 0, len1 = stack.length; i < len1; i++) {
	                    items = stack[i];
	                    for(var j = 0, len2 = items.length; j < len2; j++) {
	                        item = items[j];
	                        item.total = totals[j];
	                    }
	                }
	            }
	            
	            if(barNum > 0) {
	            	var axis = target.parent().axis();
	            	var rect = axis.getAxisContentArea();
	                if(isVerBar && xScale) {
	                    xScale.padding(self.padding());
	                    //horAxis.axisContainer.call(horAxis.axisIns());//刷新坐标轴
	                    horAxis.renderGridLine(rect);
	                } else if(!isVerBar && yScale) {
	                    yScale.padding(self.padding());
	                    //verAxis.axisContainer.call(verAxis.axisIns());//刷新坐标轴
	                    verAxis.renderGridLine(rect);
	                }
	            }
	            
	            if(barNum > 1) {
	            	var childDomain = [];
	                for(var i = 0; i < barNum; i++) {
	                    childDomain.push(i);
	                }
	            	childScale = d3.scaleBand().domain(childDomain).padding(self.padding());
	            	if(isVerBar) {
	            		childScale = childScale.rangeRound([0, xScale.bandwidth()]);
	            	} else {
	            		childScale = childScale.rangeRound([0, yScale.bandwidth()]);
	            	}
	            }
	        }
	        
	    	var axis = isVerBar ? verAxis : horAxis
	    	if(axis) {
	    		//直接修改配置数据，update方法会重新从配置中读取所有的属性
	    		var axisData = axis.data();
	    		if(!axisData.tick) {
	                axisData.tick = {};
	            }
	    		var barType = self.barType();
	    		//百分比stack修改坐标轴刻度
	            if(barType === "percentStack") {
	        		axisData.useDomain = true;
	        		axisData.domain = [0, 1];
	        		axisData.tick.tickArguments = [10, "%"];
	            } else {
	            	//非百分比stack还原坐标轴刻度默认设置
	            	axisData.useDomain = false;
	            	var tickArguments = axisData.tick.tickArguments;
	                if(tickArguments && tickArguments.toString() === [10, "%"].toString()) {
	                	axisData.tick.tickArguments = [5];
	                }
	            }
	    		axis.update();
	    	}
	        
	        //计算bar矩形相关数据
	        var innerPadding, startX, startY, vx, vy;
	        for(var d, i = 0, len = data.length; i < len; i++) {
	            d = data[i];
	            vx = d[xKey];
	            vy = d[yKey];
	            if(xScale && xKey && xType === "enum") {//垂直柱状
	            	d.x = (isVerBar && childScale) ? xScale(vx) + childScale(barIndex) : xScale(vx);
	                d.dx = childScale ? childScale.bandwidth() : xScale.bandwidth();
	                if(yScale && yKey) {
	                	if(barType === "normal" || barType === "stack" || barType === "overlap") {
	                		if(isReverse) {
	                			d.y = yScale(d.total);
	                		} else {
	                			d.y = yScale(vy) - (verAxis.height() - yScale(d.stackValue));
	                		}
	                        d.dy = verAxis.height() - yScale(vy);
	                	} else if(barType === "percentStack") {
	                        d.y = d.stackValue / d.total * verAxis.height();
	                        d.dy = vy / d.total * verAxis.height();
	                	}
	                }
	            } else if(yScale && yKey && yType === "enum") {//水平柱状
	                d.y = (!isVerBar && childScale) ? yScale(vy) + childScale(barIndex) : yScale(vy);
	                d.dy = childScale ? childScale.bandwidth() : yScale.bandwidth();
	                if(xScale && xKey) {
	                	if(barType === "normal" || barType === "stack" || barType === "overlap") {
	                		if(isReverse) {
	                            d.x = xScale(d.total) - xScale(vx);
	                        } else {
	                        	d.x = 1 + xScale(d.stackValue);
	                        }
	                        d.dx = xScale(vx);
	                    } else if(barType === "percentStack") {
	                    	d.x = 1 + d.stackValue / d.total * horAxis.width();
	                        d.dx = vx / d.total * horAxis.width();
	                    }
	                }
	            }
	            //bar矩形边界判断
	            if(isVerBar && !isNaN(maxBarSize) && d.dx > maxBarSize && xScale && xKey) {//垂直bar矩形边界判断
	            	if(childScale) {
	            		innerPadding = childScale.step() * childScale.padding();
	            		startX = (xScale.bandwidth() - maxBarSize * barNum - innerPadding * (barNum - 1)) / 2;
	            		d.x = xScale(vx) + startX + (maxBarSize + innerPadding) * barIndex;
	            	} else {
	            		d.x += (d.dx - maxBarSize) / 2
	            	}
	                d.dx = maxBarSize;
	            } else if(!isVerBar && !isNaN(maxBarSize) && d.dy > maxBarSize && yScale && yKey) {//水平bar矩形边界判断
	                if(childScale) {
	                    innerPadding = childScale.step() * childScale.padding();
	                    startY = (yScale.bandwidth() - maxBarSize * barNum - innerPadding * (barNum - 1)) / 2;
	                    d.y = yScale(vy) + startY + (maxBarSize + innerPadding) * barIndex;
	                } else {
	                    d.y += (d.dy - maxBarSize) / 2
	                }
	                d.dy = maxBarSize;
	            } 
	        }
	        
	        //这里再刷新一次是因为layout.measure方法在baseChart.update()中调用，调用之后才会有最新的total数据在bar图表中，根据该total数据值刷新坐标轴刻度才正确
	        if((barType === "stack" || barType === "percentStack" || barType === "overlap") && 
	        isResize !== true && target.parent() && target.parent().axis()) {
	//        	//优化只在最后update axis一次，以替代每个baseChart都update axis一次
	//        	if(BarLayout.prototype.barTimer) {
	//        		clearTimeout(BarLayout.prototype.barTimer);
	//        	}
	//        	BarLayout.prototype.barTimer = setTimeout(function() {
	//        		clearTimeout(BarLayout.prototype.barTimer);
	//        		delete BarLayout.prototype.barTimer;
	//                target.parent().axis().update();
	//                if(barNum > 0) {
	//                    if(target.horAxis()) {
	//                        horAxis = target.horAxis();
	//                        xScale = horAxis.scaleIns();
	//                    }
	//                    if(target.verAxis()) {
	//                        verAxis = target.verAxis();
	//                        yScale = verAxis.scaleIns();
	//                    }
	//                    if(isVerBar && xScale) {
	//                        xScale.padding(self.padding());
	//                        horAxis.axisContainer.call(horAxis.axisIns());//刷新坐标轴
	//                    } else if(!isVerBar && yScale) {
	//                        yScale.padding(self.padding());
	//                        verAxis.axisContainer.call(verAxis.axisIns());//刷新坐标轴
	//                    }
	//                }
	//                target.parent().resize();
	//        	}, 0);
	        	
	        	var axis = target.parent().axis();
	            axis.update();
	            if(barNum > 0) {
	                if(target.horAxis()) {
	                    horAxis = target.horAxis();
	                    xScale = horAxis.scaleIns();
	                }
	                if(target.verAxis()) {
	                    verAxis = target.verAxis();
	                    yScale = verAxis.scaleIns();
	                }
	                var rect = axis.getAxisContentArea();
	                if(isVerBar && xScale) {
	                    xScale.padding(self.padding());
	                    //horAxis.axisContainer.call(horAxis.axisIns());//刷新坐标轴
	                    horAxis.renderGridLine(rect);
	                } else if(!isVerBar && yScale) {
	                    yScale.padding(self.padding());
	                    //verAxis.axisContainer.call(verAxis.axisIns());//刷新坐标轴
	                    verAxis.renderGridLine(rect);
	                }
	            }
	        }
	                
	        Global.isDebug && console.log("BarLayout::measure()");
	    };
	    
	    /**
	     * override toString方法，用于打印本对象的一些基本信息
	     */
	    this.toString = function () {
	        return ("BarLayout info: "   +
	                "\n   size:"         + this.target().width() + "," + this.target().height());
	    };
	    
	    //--------------------------------------------------------------------------
	    //
	    //  private Methods
	    //
	    //--------------------------------------------------------------------------
	    
	    /**
	     * 初始化方法
	     */
	    var init = function() {
	        //刷新传入配置数据到相应布局参数
	        self.refreshData(_data);
	    };
	    
	    var getBarKey = function(layout, index) {
	    	if(layout.barType !== "stack" && layout.barType !== "percentStack") {
	    		return "bar" + index;
	    	}
	    	var stackName = layout.stackName;
	    	if(stackName === null || stackName === undefined || stackName === "") {
	    		return "bar" + index;
	    	}
	    	return stackName;
	    };
	    
	    // 初始化
	    init();
	};
	
	BarLayout.struct = function(ghca_charts) {
	    var Layout = ghca_charts.layout.layout;
	    Layout.struct(ghca_charts);
	    BarLayout.prototype = Object.create(Layout.prototype);
	    BarLayout.prototype.constructor = BarLayout;
	};
	
	module.exports = BarLayout;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {//Calendar布局类，继承自Layout
	
	var CalendarLayout = function (_target, _data) {
	       
	    // --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const Layout = ghca_charts.layout.layout;
	    const ObjectUtil = ghca_charts.view.util.objectUtil;
	    
	    Layout.apply(this, arguments);
	    
	    var self = this;
	    
	    //--------------------------------------------------------------------------
	    //
	    //  Attributes
	    //
	    //--------------------------------------------------------------------------
	    
	    //------------------------------
	    //  horizontalAlign
	    //------------------------------
	    
	    /**
	     * 水平对齐方式，left|center|right(默认值left)
	     */
	    var horizontalAlign = "left";
	    this.horizontalAlign = function(value) {
	        if (!arguments.length) return horizontalAlign;                
	        horizontalAlign = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  verticalAlign
	    //------------------------------
	    
	    /**
	     * 垂直对齐方式，top|middle|bottom(默认值top)
	     */
	    var verticalAlign = "top";
	    this.verticalAlign = function(value) {
	        if (!arguments.length) return verticalAlign;                
	        verticalAlign = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  fit
	    //------------------------------
	    
	    /**
	     * 自动撑满父容器，根据实际高宽计算gap(默认值false)
	     */
	    var fit = false;
	    this.fit = function(value) {
	        if (!arguments.length) return fit;
	        fit = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  paddingBottom
	    //------------------------------
	    
	    /**
	     * 布局项底边距离(默认值0)
	     */
	    var paddingBottom = 0;
	    this.paddingBottom = function(value) {
	        if (!arguments.length) return paddingBottom;                
	        paddingBottom = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  paddingLeft
	    //------------------------------
	    
	    /**
	     * 布局项左边距离(默认值0)
	     */
	    var paddingLeft = 0;
	    this.paddingLeft = function(value) {
	        if (!arguments.length) return paddingLeft;                
	        paddingLeft = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  paddingRight
	    //------------------------------
	    
	    /**
	     * 布局项右边距离(默认值0)
	     */
	    var paddingRight = 0;
	    this.paddingRight = function(value) {
	        if (!arguments.length) return paddingRight;                
	        paddingRight = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  paddingTop
	    //------------------------------
	    
	    /**
	     * 布局项顶边距离(默认值0)
	     */
	    var paddingTop = 0;
	    this.paddingTop = function(value) {
	        if (!arguments.length) return paddingTop;                
	        paddingTop = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  gap
	    //------------------------------
	    
	    /**
	     * 布局项间距(默认值40)
	     */
	    var gap = 40;
	    this.gap = function(value) {
	        if (!arguments.length) return gap;                
	        gap = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  cellWidth
	    //------------------------------
	
	    /**
	     * 单元格宽度(默认值17)
	     */
	    var cellWidth = 17;
	    this.cellWidth = function() {
	        if(!arguments.length) return cellWidth;
	        cellWidth = arguments[0];
	        return this;
	    };
	    
	    //------------------------------
	    //  cellHeight
	    //------------------------------
	
	    /**
	     * 单元格高度(默认值17)
	     */
	    var cellHeight = 17;
	    this.cellHeight = function() {
	        if(!arguments.length) return cellHeight;
	        cellHeight = arguments[0];
	        return this;
	    };
	    
	    //------------------------------
	    //  range
	    //------------------------------
	    
	    /**
	     * 时间范围，字符串类型日期或者"auto"(根据数据中的时间范围自动生成)，或者一个数组[beginDate, endDate](默认值"auto")
	     */
	    var range = "auto";
	    this.range = function() {
	        if(!arguments.length) return range;
	        range = arguments[0];
	        return this;
	    };
	    
	    //------------------------------
	    //  beginDate
	    //------------------------------
	    
	    /**
	     * 开始时间
	     */
	    var beginDate;
	    this.beginDate = function() {
	        if(!arguments.length) return beginDate;
	        beginDate = arguments[0];
	        return this;
	    };
	    
	    //------------------------------
	    //  endDate
	    //------------------------------
	    
	    /**
	     * 结束时间
	     */
	    var endDate;
	    this.endDate = function() {
	        if(!arguments.length) return endDate;
	        endDate = arguments[0];
	        return this;
	    };
	    
	    //------------------------------
	    //  dateKey
	    //------------------------------
	
	    /**
	     * 数据中日期属性名称(默认值"date")
	     */
	    var dateKey = "date";
	    this.dateKey = function() {
	        if(!arguments.length) return dateKey;
	        dateKey = arguments[0];
	        return this;
	    };
	    
	    //------------------------------
	    //  yearSort
	    //------------------------------
	
	    /**
	     * 年份排序，asc|desc|function(a, b){return a-b;}(默认值"desc")
	     */
	    var yearSort = "desc";
	    this.yearSort = function() {
	        if(!arguments.length) return yearSort;
	        yearSort = arguments[0];
	        return this;
	    };
	    
	    //------------------------------
	    //  mode
	    //------------------------------
	
	    /**
	     * 显示模式，normal|fullYear(默认值"normal")
	     */
	    var mode = CalendarLayout.MODE_NORMAL;
	    this.mode = function() {
	        if(!arguments.length) return mode;
	        mode = arguments[0];
	        return this;
	    };
	    
	    //------------------------------
	    //  yearsData
	    //------------------------------
	
	    /**
	     * 用来渲染的年份数据。
	     */
	    var yearsData = [];
	    this.yearsData = function() {
	        return yearsData;
	    };
	    
	    //------------------------------
	    //  monthsData
	    //------------------------------
	
	    /**
	     * 用来渲染的月份数据。
	     */
	    var monthsData = [];
	    this.monthsData = function() {
	        return monthsData;
	    };
	    
	    //------------------------------
	    //  daysData
	    //------------------------------
	
	    /**
	     * 用来渲染的天数据。
	     */
	    var daysData = [];
	    this.daysData = function() {
	        return daysData;
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // private Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    /**
	     * 初始化方法
	     */
	    var init = function() {
	        //刷新传入配置数据到相应布局参数
	        self.refreshData(_data);
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // public Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    this.getDateRange = function(year) {
	        var beginTime = new Date(self.beginDate()).getTime();
	        var endTime = new Date(self.endDate()).getTime();
	        var yearBeginTime = new Date(year, 0, 1).getTime();
	        var yearEndTime = new Date(year + 1, 0, 1).getTime();
	        beginTime = beginTime > yearBeginTime ? beginTime : yearBeginTime;
	        endTime = endTime < yearEndTime ? endTime : yearEndTime;
	        var beginDate = new Date(beginTime);
	        var endDate = new Date(endTime);
	        beginDate = new Date(beginDate.getFullYear(), beginDate.getMonth(), 1);
	        endDate = new Date(endDate.getFullYear(), endDate.getFullYear() !== year ? endDate.getMonth() : endDate.getMonth()+1, 1);
	        return [beginDate, endDate];
	    };
	
	    //override
	    this.measure = function() {
	        var target = self.target();
	        var visibleItems = target.visibleItems();
	        
	        //sort all items by date
	        visibleItems.sort(function(a, b) {
	            return new Date(a[dateKey]) - new Date(b[dateKey]);
	        });
	        
	        //find date range
	        if(range === "auto" && visibleItems.length > 0) {
	        	beginDate = visibleItems[0][dateKey];
	        	endDate = visibleItems[visibleItems.length-1][dateKey];
	        } else if(ObjectUtil.isArray(range)) {
	        	if(range.length === 1) {
	        		beginDate = new String(range[0]);
	                endDate = new String(range[0]);
	        	} else if(range.length > 1) {
	        		beginDate = new String(range[0]);
	                endDate = new String(range[1]);
	        	}
	        } else if(range) {
	            beginDate = new String(range);
	            endDate = new String(range);
	        } 
	        
	        //create years data
	        yearsData.length = 0;
	        var yearSortFn = ObjectUtil.isFunction(yearSort) ? yearSortFn : 
	            yearSort === "desc" ? function(a, b) {
	            	return b - a;
	            } : function(a, b) {
	                return a - b;
	            };
	        var children = d3.range(new Date(beginDate).getFullYear(), new Date(endDate).getFullYear() + 1)
	            .sort(yearSortFn);
	            
	        if(!target || !children || children.length === 0) {
	            return;
	        }
	            
	        var paddingTop = self.paddingTop(),
	            paddingLeft = self.paddingLeft(),
	            paddingRight = self.paddingRight(),
	            paddingBottom = self.paddingBottom(),
	            horAlign = self.horizontalAlign(),
	            verAlign = self.verticalAlign(),
	            gap = self.gap(),
	            targetW = target.width() - paddingLeft - paddingRight,
	            targetH = target.height() - paddingTop - paddingBottom;
	        
	        var x, y, child, rangeDate, len= children.length, totalH = 0, i = 0, childW = self.cellWidth() * 53, childH = self.cellHeight() * 7;
	        
	        if(fit || verAlign === "middle") {
	            for(i = 0; i < len; i++) {
	                child = children[i];
	                totalH += childH;
	            };
	            if(fit) {
	                gap = len > 1 ? (targetH - totalH)/(len - 1) : 0;
	            }
	            totalH += gap * (len - 1);
	        }
	        
	        for(i = 0; i < len; i++) {
	            child = children[i];
	            if(self.mode() === CalendarLayout.MODE_NORMAL) {
	            	rangeDate = self.getDateRange(child);
	                childW = d3.timeWeek.count(rangeDate[0], rangeDate[1]) * self.cellWidth();
	            }
	            if(horAlign === "left") {
	                x = paddingLeft;
	            } else if(horAlign === "center") {
	                x = paddingLeft + (targetW - childW) / 2;
	            } else if(horAlign === "right") {
	                x = paddingLeft + targetW - childW;
	            }
	            
	            if(fit || verAlign === "middle") {
	                y = paddingTop + (targetH - totalH) / 2 + (childH + gap) * i;
	            } else if(verAlign === "top") {
	                y = paddingTop + (childH + gap) * i;
	            } else if(verAlign === "bottom") {
	                y = paddingTop + targetH - childH * (i + 1) - gap * i;
	            }
	            yearsData.push({
	                year:child, 
	                x:x,
	                y:y
	            });
	        }
	        target.renderPosition();
	    };
	    
	    init();
	};
	
	CalendarLayout.struct = function(ghca_charts) {
	    var Layout = ghca_charts.layout.layout;
	    Layout.struct(ghca_charts);
	    CalendarLayout.prototype = Object.create(Layout.prototype);
	    CalendarLayout.prototype.constructor = CalendarLayout;
	};
	
	CalendarLayout.MODE_NORMAL   = "normal";
	CalendarLayout.MODE_FULLYEAR = "fullYear";
	
	module.exports = CalendarLayout;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 8 */
/***/ (function(module, exports) {

	//水平布局类，继承自Layout
	
	/**
	 * 构造方法
	 * @param _target 要使用该布局的容器或者组件对象引用
	 * @param _data 布局配置数据
	 */
	var HorizontalLayout = function (_target, _data) {
		
		// --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const Layout = ghca_charts.layout.layout;
	    const Global = ghca_charts.global;
	
	    Layout.apply(this, arguments);
	    
	    var self = this;
	    self.isChartLayout(false);
	    
	    //--------------------------------------------------------------------------
	    //
	    //  Attributes
	    //
	    //--------------------------------------------------------------------------
	    
	    //------------------------------
	    //  model
	    //------------------------------
	    
	    /**
	     * 水平布局模型
	     */
	    var model = null;
	    this.model = function(){
	        return model;
	    };
	    
	    //------------------------------
	    //  horizontalAlign
	    //------------------------------
	    
	    /**
	     * 水平对齐方式，left|center|right(默认值left)
	     */
	    var horizontalAlign = "left";
	    this.horizontalAlign = function(value) {
	        if (!arguments.length) return horizontalAlign;                
	        horizontalAlign = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  verticalAlign
	    //------------------------------
	    
	    /**
	     * 垂直对齐方式，top|middle|bottom(默认值top)
	     */
	    var verticalAlign = "top";
	    this.verticalAlign = function(value) {
	        if (!arguments.length) return verticalAlign;                
	        verticalAlign = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  gap
	    //------------------------------
	    
	    /**
	     * 布局项间距(默认值6)
	     */
	    var gap = 6;
	    this.gap = function(value) {
	        if (!arguments.length) return gap;                
	        gap = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  fit
	    //------------------------------
	    
	    /**
	     * 自动撑满父容器，根据实际高宽计算gap(默认值false)
	     */
	    var fit = false;
	    this.fit = function(value) {
	        if (!arguments.length) return fit;
	        fit = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  paddingBottom
	    //------------------------------
	    
	    /**
	     * 布局项底边距离(默认值0)
	     */
	    var paddingBottom = 0;
	    this.paddingBottom = function(value) {
	        if (!arguments.length) return paddingBottom;                
	        paddingBottom = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  paddingLeft
	    //------------------------------
	    
	    /**
	     * 布局项左边距离(默认值0)
	     */
	    var paddingLeft = 0;
	    this.paddingLeft = function(value) {
	        if (!arguments.length) return paddingLeft;                
	        paddingLeft = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  paddingRight
	    //------------------------------
	    
	    /**
	     * 布局项右边距离(默认值0)
	     */
	    var paddingRight = 0;
	    this.paddingRight = function(value) {
	        if (!arguments.length) return paddingRight;                
	        paddingRight = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  paddingTop
	    //------------------------------
	    
	    /**
	     * 布局项顶边距离(默认值0)
	     */
	    var paddingTop = 0;
	    this.paddingTop = function(value) {
	        if (!arguments.length) return paddingTop;                
	        paddingTop = value;
	        return this;
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // private Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    /**
	     * 初始化方法
	     */
	    var init = function() {
	        //刷新传入配置数据到相应布局参数
	        self.refreshData(_data);
	    };
	    
	    //--------------------------------------------------------------------------
	    //
	    //  public Methods
	    //
	    //--------------------------------------------------------------------------
	    
	    /**
	     * override度量方法
	     */
	    this.measure = function() {
	        var self = this, 
	            target = self.target(),
	            children = target.children();
	            
	        if(!target || !children || children.length === 0) {
	            return;
	        }
	            
	        var paddingTop = self.paddingTop(),
	            paddingLeft = self.paddingLeft(),
	            paddingRight = self.paddingRight(),
	            paddingBottom = self.paddingBottom(),
	            horAlign = self.horizontalAlign(),
	            verAlign = self.verticalAlign(),
	            gap = self.gap(),
	            targetW = target.width() - paddingLeft - paddingRight,
	            targetH = target.height() - paddingTop - paddingBottom;
	        
	        var x, y, child, len = children.length, totalW = 0, i = 0;
	        
	        if(fit || horAlign === "center") {
	            for(i = 0; i < len; i++) {
	                child = children[i];
	                totalW += child.width();
	            }
	            if(fit) {
	                gap = len > 1 ? (targetW - totalW)/(len - 1) : 0;
	            }
	            totalW += gap * (len - 1);
	        }
	        
	        for(i = 0; i < len; i++) {
	        	child = children[i];
	        	if(fit || horAlign === "center") {
	                x = paddingLeft + (targetW - totalW) / 2 + (child.width() + gap) * i;
	            } else if(horAlign === "left") {
	                x = paddingLeft + (child.width() + gap) * i;
	            } else if(horAlign === "right") {
	                x = paddingLeft + targetW - child.width() * (i + 1) - gap * i;
	            }
	            
	            if(verAlign === "top") {
	                y = paddingTop;
	            } else if(verAlign === "middle") {
	                y = paddingTop + (targetH - child.height()) / 2;
	            } else if(verAlign === "bottom") {
	                y = paddingTop + targetH - child.height();
	            }
	            child.x(x);
	            child.y(y);
	            
	            //渲染子组件位置
	            child.renderTransform();
	        }
	        
	        Global.isDebug && console.log("HorizontalLayout::measure()");
	    };
	    
	    /**
	     * override toString方法，用于打印本对象的一些基本信息
	     */
	    this.toString = function () {
	        return ("HorizontalLayout info: ");
	    };
	    
	    // 初始化
	    init();
	};
	
	HorizontalLayout.struct = function(ghca_charts) {
		var Layout = ghca_charts.layout.layout;
		Layout.struct(ghca_charts);
	    HorizontalLayout.prototype = Object.create(Layout.prototype);
	    HorizontalLayout.prototype.constructor = HorizontalLayout;
	};
	
	module.exports = HorizontalLayout;


/***/ }),
/* 9 */
/***/ (function(module, exports) {

	//布局基类
	
	/**
	 * 构造方法
	 * @param _target 要使用该布局的容器或者组件对象引用
	 * @param _data 布局配置数据
	 */
	var Layout = function (_target, _data) {
		   
	    // --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const Const = ghca_charts.view.util.constant;
	
		if(arguments.length < 1) {
	        throw new Error('传入参数个数错误,当前个数' + arguments.length + ",应至少传入1个参数");
	    }
	    
	    var self = this;
	    
	    //--------------------------------------------------------------------------
	    //
	    //  Attributes
	    //
	    //--------------------------------------------------------------------------
	    
	    //------------------------------
	    //  target
	    //------------------------------
	    
	    /**
	     * 要使用该布局的容器或者组件对象引用
	     */
	    var target = _target;
	    this.target = function(value) {
	        if (!arguments.length) return target;
	        target = value;
	        return this;
	    };
	    
	    // ------------------------------
	    // data
	    // ------------------------------
	
	    /**
	     * 布局配置数据
	     */
	    var data = _data;
	    this.data = function(value) {
	        if (!arguments.length)
	            return data;
	        data = value;
	        self.refreshData(data);
	        return this;
	    };
	    
	    //------------------------------
	    //  model
	    //------------------------------
	    
	    /**
	     * 布局算法模型
	     */
	    var model = null;
	    this.model = function(value) {
	        if (!arguments.length) return model;
	        model = value;
	        return this;
	    };
	    
	    // ------------------------------
	    // scale
	    // ------------------------------
	
	    /**
	     * 布局关系缩放系数(默认值1)
	     */
	    var scale = 1;
	    this.scale = function(value) {
	        if (!arguments.length)
	            return scale;
	        scale = value;
	        return this;
	    };
	    
	    // ------------------------------
	    // maxScale
	    // ------------------------------
	
	    /**
	     * 布局关系最大缩放系数(默认值3)
	     */
	    var maxScale = 3;
	    this.maxScale = function(value) {
	        if (!arguments.length)
	            return maxScale;
	        maxScale = value;
	        return this;
	    };
	    
	    // ------------------------------
	    // minScale
	    // ------------------------------
	
	    /**
	     * 布局关系最小缩放系数(默认值0.3)
	     */
	    var minScale = 0.3;
	    this.minScale = function(value) {
	        if (!arguments.length)
	            return minScale;
	        minScale = value;
	        return this;
	    };
	    
	    // ------------------------------
	    // scaleDelta
	    // ------------------------------
	
	    /**
	     * 布局关系最大缩放系数(默认值3)
	     */
	    var scaleDelta = 0.05;
	    this.scaleDelta = function(value) {
	        if (!arguments.length)
	            return scaleDelta;
	        scaleDelta = value;
	        return this;
	    };
	    
	    // ------------------------------
	    // isChartLayout
	    // ------------------------------
	
	    /**
	     * 是否是图表布局
	     */
	    var isChartLayout = true;
	    this.isChartLayout = function(value) {
	        if (!arguments.length)
	            return isChartLayout;
	        isChartLayout = value;
	        return this;
	    };
	    
	    // ------------------------------
	    // useSeriesConfig
	    // ------------------------------
	
	    /**
	     * 是否使用seriesConfig
	     */
	    var useSeriesConfig = false;
	    this.useSeriesConfig = function(value) {
	        if (!arguments.length)
	            return useSeriesConfig;
	        useSeriesConfig = value;
	        return this;
	    };
	    
	    //--------------------------------------------------------------------------
	    //
	    //  public Methods
	    //
	    //--------------------------------------------------------------------------
	    
	    /**
	     * 更新布局
	     * @isResize 是否在resize中调用本方法
	     */
	    this.update = function(isResize) {
	    	//判断是否有seriesConfig，若有则需重新设置data,因为每次刷新layout的data都是从seriesConfig.layout中克隆的
	        if(self.isChartLayout() && target && target.data() && target.data().useSeriesConfig !== false 
	        && target.parent() && target.parent().data().seriesConfig && target.parent().data().seriesConfig.layout) {
	            _data = target.parent().data().seriesConfig.layout;
	            self.data(_data);
	            self.useSeriesConfig(true);
	        } else {
	        	self.useSeriesConfig(false);
	        	self.refreshData(_data);
	        }
	    	self.measure(isResize);
	    };
	    
	    /**
	     * 度量方法,在子类中具体实现
	     */
	    this.measure = function() {
	    };
	    
	    /**
	     * 布局关系缩放方法,在子类中具体实现
	     * @param isEnlarge 是否放大
	     */
	    this.zoom = function(isEnlarge) {
	         
	    };
	    
	    /**
	     * 刷新传入配置数据到相应布局参数的方法
	     * @param data 布局配置数据
	     */
	    this.refreshData = function(data) {
	        if(data) {
	           for(var key in data) {
	                if(self.hasOwnProperty(key)) {
	                    self[key](data[key]);
	                    
	                }
	            }
	        }
	    };
	    
	    this.toString = function () {
	         return ("Layout info: "    +
	                "\n   target:"      + this.target()    + 
	                "\n   data:"        + this.data()      + 
	                "\n   tx:"          + this.tx()        + 
	                "\n   ty:"          + this.ty()        + 
	                "\n   scale:"       + this.scale()     + 
	                "\n   minScale:"    + this.minScale()  + 
	                "\n   maxScale:"    + this.maxScale()  + 
	                "\n   scaleDelta:"  + this.scaleDelta());
	    };
	};
	
	Layout.struct = function(ghca_charts) {
	    Layout.prototype.constructor = Layout;
	};
	
	module.exports = Layout;


/***/ }),
/* 10 */
/***/ (function(module, exports) {

	/** 
	 * 布局特征类
	 * 用于记录父容器布局计算出的本容器的相关特征记录类实例，包括记录本容器的x,y,width,height等属性，
	 * 渲染和容器返回的相关x,y,width,height等属性值都为该类实例的对应属性值，而忽略容器自身的相关属性设置。
	 */
	
	/**
	 * 构造方法
	 */
	var LayoutFeatures = function () {
	    
	    var self = this;
	    
	    //--------------------------------------------------------------------------
	    //
	    //  Attributes
	    //
	    //--------------------------------------------------------------------------
	    
	    //------------------------------
	    //  x
	    //------------------------------
	    
	    var x = 0;
	    this.x = function(value) {
	        if (!arguments.length) return x;
	        x = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  y
	    //------------------------------
	    
	    var y = 0;
	    this.y = function(value) {
	        if (!arguments.length) return y;
	        y = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  z
	    //------------------------------
	    
	    var z = 0;
	    this.z = function(value) {
	        if (!arguments.length) return z;
	        z = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  width
	    //------------------------------
	    
	    var width = 0;
	    this.width = function(value) {
	        if (!arguments.length) return width;
	        width = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  height
	    //------------------------------
	    
	    var height = 0;
	    this.height = function(value) {
	        if (!arguments.length) return height;
	        height = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  scaleX
	    //------------------------------
	    
	    var scaleX = 1;
	    this.scaleX = function(value) {
	        if (!arguments.length) return scaleX;
	        scaleX = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  scaleY
	    //------------------------------
	    
	    var scaleY = 1;
	    this.scaleY = function(value) {
	        if (!arguments.length) return scaleY;
	        scaleY = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  rotate
	    //------------------------------
	    
	    var rotate = 0;
	    this.rotate = function(value) {
	        if (!arguments.length) return rotate;
	        rotate = value;
	        return this;
	    };
	    
	    this.toString = function () {
	         return ("LayoutFeatures info: "         +
	                "\n   x:"       + this.x()       + 
	                "\n   y:"       + this.y()       + 
	                "\n   z:"       + this.z()       + 
	                "\n   width:"   + this.width()   + 
	                "\n   height:"  + this.height()  + 
	                "\n   scaleX:"  + this.scaleX()  + 
	                "\n   scaleY:"  + this.scaleY()  + 
	                "\n   rotate:"  + this.rotate());
	    };
	};
	
	LayoutFeatures.struct = function(ghca_charts) {
	    LayoutFeatures.prototype.constructor = LayoutFeatures;
	};
	
	module.exports = LayoutFeatures;


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {// 自定义sankey模型
	
	/**
	 * 构造方法
	 */
	var SankeyModel = function() {
		
		// --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const Const = ghca_charts.view.util.constant;
	
		var self = this,
		    nodeWidth = 24, 
		    nodePadding = 8, 
		    size = [1, 1], // sankey layout width and height
		    nodes = [], 
		    links = [];
	
		// --------------------------------------------------------------------------
		//
		// Attributes
		//
		// --------------------------------------------------------------------------
	
		// ------------------------------
		// nodeWidth
		// ------------------------------
		
		this.nodeWidth = function(value) {
			if (!arguments.length)
				return nodeWidth;
			nodeWidth = +value;
			return this;
		};
		
		// ------------------------------
	    // nodePadding
	    // ------------------------------
	
		this.nodePadding = function(value) {
			if (!arguments.length)
				return nodePadding;
			nodePadding = +value;
			return this;
		};
		
		// ------------------------------
	    // nodes
	    // ------------------------------
	
		this.nodes = function(value) {
			if (!arguments.length)
				return nodes;
			nodes = value;
			return this;
		};
		
		// ------------------------------
	    // links
	    // ------------------------------
	
		this.links = function(value) {
			if (!arguments.length)
				return links;
			links = value;
			return this;
		};
		
		// ------------------------------
	    // scale
	    // ------------------------------
	
		/**
	     * 缩放系数，默认为1
	     */
		var scale = 1;
	    this.scale = function(value) {
	        if (!arguments.length)
	            return scale;
	        scale = value;
	        return this;
	    };
	    
	    // ------------------------------
	    // scaleType
	    // ------------------------------
	
	    /**
	     * 缩放类型，整体缩放0、如连线缩放1
	     */
	    var scaleType = Const.LAYOUT_SCALE_TYPE;
	    this.scaleType = function(value) {
	        if (!arguments.length)
	            return scaleType;
	        scaleType = value;
	        return this;
	    };
		
		// ------------------------------
	    // size
	    // ------------------------------
	
	    /**
	     * 布局大小范围，格式为[width, height]
	     */
		this.size = function(value) {
			if (!arguments.length)
				return size;
			size = value;
			return this;
		};
		
		// ------------------------------
	    // isLikeTree
	    // ------------------------------
	
	    /**
	     * 是否像树节点一样布局，若为true,则所有节点从根节点开始依照层级左对齐，若为false,则所有节点右对齐
	     */
	    var isLikeTree = false;
	    this.isLikeTree = function(value) {
	        if (!arguments.length)
	            return isLikeTree;
	        isLikeTree = value;
	        return this;
	    };
	    
	    // ------------------------------
	    // maxNodeSize
	    // ------------------------------
	    
	    /**
	     * 最大节点尺寸
	     */
	    var maxNodeSize = 1000;
	    this.maxNodeSize = function(value) {
	        if (!arguments.length)
	            return maxNodeSize;
	        maxNodeSize = +value;
	        return this;
	    };
		
		// --------------------------------------------------------------------------
	    //
	    // public Methods
	    //
	    // --------------------------------------------------------------------------
	
		this.layout = function(iterations) {
			computeNodeLinks();
			computeNodeValues();
			computeNodeBreadths();
			computeNodeDepths(iterations);
			computeLinkDepths();
			return this;
		};
	
		this.relayoutLinkDepths = function() {
			computeLinkDepths();
			return this;
		};
		
		this.relayout = function() {
			computeNodeLinks();
	        computeNodeValues();
	        computeNodeBreadths();
	        return this;
	    };
	
		this.linkPath = function() {
	        var curvature = .5;
	    
	        function link(d) {
	          var x0 = d.source.x + d.source.dx,
	              x1 = d.target.x,
	              xi = d3.interpolateNumber(x0, x1),
	              x2 = xi(curvature),
	              x3 = xi(1 - curvature),
	              y0 = d.source.y + d.sy + d.dy / 2,
	              y1 = d.target.y + d.ty + d.dy / 2;
	          return "M" + x0 + "," + y0
	               + "C" + x2 + "," + y0
	               + " " + x3 + "," + y1
	               + " " + x1 + "," + y1;
	        }
	
	        link.curvature = function(_) {
	          if (!arguments.length) return curvature;
	          curvature = +_;
	          return link;
	        };
	    
	        return link;
	    };
		
		// --------------------------------------------------------------------------
	    //
	    // private Methods
	    //
	    // --------------------------------------------------------------------------
	
		// Populate the sourceLinks and targetLinks for each node.
		// Also, if the source and target are not objects, assume they are
		// indices.
		function computeNodeLinks() {
	//			nodes.forEach(function(node) {
	//						node.sourceLinks = [];
	//						node.targetLinks = [];
	//					});
	//			links.forEach(function(link) {
	//						var source = link.source, target = link.target;
	//						if (typeof source === "number")
	//							source = link.source = nodes[link.source];
	//						if (typeof target === "number")
	//							target = link.target = nodes[link.target];
	//						source.sourceLinks.push(link);
	//						target.targetLinks.push(link);
	//					});
		}
	
		// Compute the value (size) of each node by summing the associated
		// links.
		function computeNodeValues() {
			nodes.forEach(function(node) {
				node.value = Math.max(d3.sum(node.sourceLinks, value), d3.sum(node.targetLinks, value));
			});
		}
	
		// Iteratively assign the breadth (x-position) for each node.
		// Nodes are assigned the maximum breadth of incoming neighbors plus
		// one;
		// nodes with no incoming links are assigned breadth zero, while
		// nodes with no outgoing links are assigned the maximum breadth.
		function computeNodeBreadths() {
			var remainingNodes = nodes, nextNodes, x = 0;
	
			while (remainingNodes.length) {
				nextNodes = [];
				remainingNodes.forEach(function(node) {
					node.x = x;
					node.dx = nodeWidth;
					node.sourceLinks.forEach(function(link) {
						nextNodes.push(link.target);
					});
				});
				remainingNodes = nextNodes;
				++x;
			}
	
			if(self.isLikeTree() === false) {
				moveSinksRight(x);
			}
			var kx = (size[0] - nodeWidth) / (x - 1);
			scaleNodeBreadths(kx);
		}
	
		function moveSourcesRight() {
			nodes.forEach(function(node) {
				if (!node.targetLinks.length) {
					node.x = d3.min(node.sourceLinks, function(d) {
						return d.target.x;
					}) - 1;
				}
			});
		}
	
		function moveSinksRight(x) {
			nodes.forEach(function(node) {
				if (!node.sourceLinks.length) {
					node.x = x - 1;
				}
			});
		}
	
		function scaleNodeBreadths(kx) {
			nodes.forEach(function(node) {
				node.x *= kx;
			});
		}
	
		function computeNodeDepths(iterations) {
			var nodesByBreadth = d3.nest().key(function(d) {
				return d.x;
			}).sortKeys(d3.ascending).entries(nodes).map(function(d) {
				return d.values;
			});
	
			initializeNodeDepth();
			resolveCollisions();
			validateNodeSize();
			for (var alpha = 1; iterations > 0; --iterations) {
				relaxRightToLeft(alpha *= 0.99);
				resolveCollisions();
				relaxLeftToRight(alpha);
				resolveCollisions();
			}
			moveMiddle();
	
			function initializeNodeDepth() {
				var ky = d3.min(nodesByBreadth, function(nodes) {
					return (size[1] - (nodes.length - 1) * nodePadding)
							/ d3.sum(nodes, value);
				});
				
				if(ky <= 0) {
				    ky = 1;
				}
	
				nodesByBreadth.forEach(function(nodes) {
					nodes.forEach(function(node, i) {
						node.y = i;
						node.dy = node.value * ky;
					});
				});
	
				links.forEach(function(link) {
					link.dy = link.value * ky;
				});
			}
	
			function relaxLeftToRight(alpha) {
				nodesByBreadth.forEach(function(nodes, breadth) {
					nodes.forEach(function(node) {
						if (node.targetLinks.length) {
							var y = d3.sum(node.targetLinks, weightedSource) / d3.sum(node.targetLinks, value);
							node.y += (y - center(node)) * alpha;
						}
					});
				});
	
				function weightedSource(link) {
					return center(link.source) * link.value;
				}
			}
	
			function relaxRightToLeft(alpha) {
				nodesByBreadth.slice().reverse().forEach(function(nodes) {
					nodes.forEach(function(node) {
						if (node.sourceLinks.length) {
							var y = d3.sum(node.sourceLinks, weightedTarget) / d3.sum(node.sourceLinks, value);
							node.y += (y - center(node)) * alpha;
						}
					});
				});
	
				function weightedTarget(link) {
					return center(link.target) * link.value;
				}
			}
			
			//根据最大节点高度处理布局
	        function validateNodeSize() {
	            var maxNodeSize = self.maxNodeSize(), maxDy = 0;
	            self.nodes().forEach(function(d){
	                maxDy = d.dy > maxDy ? d.dy : maxDy;
	            });
	            if(maxDy > maxNodeSize) {
	                var k = maxNodeSize / maxDy;
	                self.nodes().forEach(function(d){
	                    d.dy *= k;
	                });
	                self.links().forEach(function(d){
	                    d.dy *= k;
	                    d.sy *= k;
	                });
	            }
	        }
	        
	        //内容垂直居中
	        function moveMiddle() {
	            var minY = Infinity;
	            self.nodes().forEach(function(d){
	                minY = minY > d.y ? d.y : minY;
	            });
	            var moveY = -minY / 2;
	            self.nodes().forEach(function(d){
	                d.y += moveY;
	            });
	        }
	
			function resolveCollisions() {
				nodesByBreadth.forEach(function(nodes) {
					var node, dy, y0 = 0, n = nodes.length, i;
	
					// Push any overlapping nodes down.
					nodes.sort(ascendingDepth);
					for (i = 0; i < n; ++i) {
						node = nodes[i];
						dy = y0 - node.y;
						if (dy > 0)
							node.y += dy;
						y0 = node.y + node.dy + nodePadding;
					}
	
					// If the bottommost node goes outside the bounds,
					// push it back up.
					dy = y0 - nodePadding - size[1];
					if (dy > 0) {
						y0 = node.y -= dy;
	
						// Push any overlapping nodes back up.
						for (i = n - 2; i >= 0; --i) {
							node = nodes[i];
							dy = node.y + node.dy + nodePadding - y0;
							if (dy > 0)
								node.y -= dy;
							y0 = node.y;
						}
					}
				});
			}
	
			function ascendingDepth(a, b) {
				return a.y - b.y;
			}
		}
		
		function computeLinkDepths() {
			nodes.forEach(function(node) {
				node.sourceLinks.sort(ascendingTargetDepth);
				node.targetLinks.sort(ascendingSourceDepth);
			});
			nodes.forEach(function(node) {
				var sy = 0, ty = 0;
				node.sourceLinks.forEach(function(link) {
					link.sy = sy;
					sy += link.dy;
				});
				node.targetLinks.forEach(function(link) {
					link.ty = ty;
					ty += link.dy;
				});
			});
	
			function ascendingSourceDepth(a, b) {
				return a.source.y - b.source.y;
			}
	
			function ascendingTargetDepth(a, b) {
				return a.target.y - b.target.y;
			}
		}
	
		function center(node) {
			return node.y + node.dy / 2;
		}
	
		function value(link) {
			return link.value;
		}
	};
	
	SankeyModel.struct = function(ghca_charts) {
	    SankeyModel.prototype.constructor = SankeyModel;
	};
	
	module.exports = SankeyModel;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {//Pack布局类，继承自Layout
	
	var PackLayout = function (_target, _data) {
		   
	    // --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const Layout = ghca_charts.layout.layout;
	    
	    Layout.apply(this, arguments);
	    
	    var self = this;
	    this.model(d3.pack());
	    
	    //--------------------------------------------------------------------------
	    //
	    //  Attributes
	    //
	    //--------------------------------------------------------------------------
	    
	    //------------------------------
	    //  visibleData
	    //------------------------------
	
	    var visibleData = [];
	    this.visibleData = function(){
	        if(!arguments.length)return visibleData;
	        visibleData = arguments[0];
	        return this;
	    };
	    
	    //------------------------------
	    //  radius
	    //------------------------------
	
	    var radius = 100;
	    this.radius = function(){
	        if(!arguments.length)return radius;
	        radius = arguments[0];
	        return this;
	    };
	    
	    //------------------------------
	    //  padding
	    //------------------------------
	    
	    var padding = 0;
	    this.padding = function(){
	        if(!arguments.length) return padding;
	        padding = arguments[0];
	        return this;
	    };
	    
	    //------------------------------
	    //  nodes
	    //------------------------------
	    
	    var nodes = [];
	    this.nodes = function(){
	        if(!arguments.length)return nodes;
	        nodes = arguments[0];
	        return this;
	    };
	    
	    //------------------------------
	    //  root
	    //------------------------------
	    
	    var root = null;
	    this.root = function(value) {
	        if (!arguments.length)
	            return root;
	        root = value;
	        return this;
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // public Methods
	    //
	    // --------------------------------------------------------------------------
	
	    //override
	    this.measure = function() {
	    	var target = self.target();
	        var radius = self.radius()*self.scale();
	        root = d3.stratify()(self.visibleData());
	        root = d3.hierarchy(root)
	            .sum(function(d) {
	                return d.data.value;
	            })
	            .sort(function(a, b) {
	                return b.data.value - a.data.value;
	            });
	        self.nodes(self.model().size([radius*2, radius*2]).padding(self.padding())(root)
	            .each(function(d) {
	            	//消除一个多余的data层级
	                d.data = d.data.data;
	                d.startAngle    = 0;
	                d.endAngle      = Math.PI * 2;
	                d.innerRadius   = 0;
	                d.outerRadius   = d.r;
	                //复制数据到data下
	                d.data.startAngle   = d.startAngle;
	                d.data.endAngle     = d.endAngle;
	                d.data.innerRadius  = d.innerRadius;
	                d.data.outerRadius  = d.outerRadius;
	                d.data.x            = d.x;
	                d.data.y            = d.y;
	                //删除多余的数据
	                delete d.x;
	                delete d.y;
	                delete d.r;
	            })
	            .descendants());
	        //渲染点和线的位置
	        target.renderPosition();
	    };
	    
	    //override
	    this.zoom = function(isEnlarge) {
	        var _rate = self.scaleDelta();
	        var _scaleRate = self.scale();
	        var _maxScaleRate = self.maxScale();
	        var _minScaleRate = self.minScale();
	        if(isEnlarge) {
	            _scaleRate += _rate;
	            if(_scaleRate>_maxScaleRate)
	                _scaleRate = _maxScaleRate;//最大放大率
	        } else {
	            _scaleRate -= _rate;
	            if(_scaleRate<_minScaleRate)
	                _scaleRate = _minScaleRate;//最小
	        }
	        self.scale(_scaleRate);
	        self.target().update();
	    };
	};
	
	PackLayout.struct = function(ghca_charts) {
		var Layout = ghca_charts.layout.layout;
		Layout.struct(ghca_charts);
	    PackLayout.prototype = Object.create(Layout.prototype);
	    PackLayout.prototype.constructor = PackLayout;
	};
	
	module.exports = PackLayout;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {//饼图默认布局类，继承自Layout
		
	/**
	 * 构造方法
	 * @param _target 要使用该布局的容器或者组件对象引用
	 * @param _data 布局配置数据
	 */
	var PieLayout = function (_target, _data) {
		
		// --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const Layout = ghca_charts.layout.layout;
	    const Constant = ghca_charts.view.util.constant;
	    const Global = ghca_charts.global;
	
	    Layout.apply(this, arguments);
	    
	    var self = this;
	    
	    //--------------------------------------------------------------------------
	    //
	    //  Attributes
	    //
	    //--------------------------------------------------------------------------
	    
	    //------------------------------
	    //  model
	    //------------------------------
	    
	    /**
	     * pie模型
	     */
	    var model = d3.pie();
	    this.model = function() {
	        return model;
	    };
	    
	    //------------------------------
	    //  items
	    //------------------------------
	    
	    /**
	     * 项数据数组
	     */
	    var items = [];
	    this.items = function(value) {
	        if (!arguments.length)
	            return items;
	        items = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  dataKey
	    //------------------------------
	    
	    /**
	     * pie数据项的键名称，默认为"value"
	     */
	    var dataKey = "value";
	    this.dataKey = function(value) {
	        if (!arguments.length)
	            return dataKey;
	        dataKey = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  roseType
	    //------------------------------
	    
	    /**
	     * 玫瑰图类型，no|radius，若为no，则为普通饼图，默认为no
	     */
	    var roseType = PieLayout.ROSE_TYPE_NO;
	    this.roseType = function(value) {
	        if (!arguments.length)
	            return roseType;
	        roseType = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  roseKey
	    //------------------------------
	    
	    /**
	     * 玫瑰图数据项的键名称，默认为dataKey的值，即"value",roseType不为no时有效
	     */
	    var roseKey = dataKey;
	    this.roseKey = function(value) {
	        if (!arguments.length)
	            return roseKey;
	        roseKey = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  startAngle
	    //------------------------------
	    
	    /**
	     * pie开始弧度，默认为0
	     */
	    var startAngle = 0;
	    this.startAngle = function(value) {
	        if (!arguments.length)
	            return startAngle;
	        startAngle = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  endAngle
	    //------------------------------
	    
	    /**
	     * pie结束弧度，默认为2pi
	     */
	    var endAngle = Math.PI*2;
	    this.endAngle = function(value) {
	        if (!arguments.length)
	            return endAngle;
	        endAngle = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  sort
	    //------------------------------
	    
	    /**
	     * 排序方法(默认禁用排序) desc|asc|none
	     */
	    var sort = Constant.SORT_NONE;
	    this.sort = function(value) {
	        if (!arguments.length)
	            return sort;
	        sort = value;
	        return this;
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // private Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    /**
	     * 初始化方法
	     */
	    var init = function() {
	        //刷新传入配置数据到相应布局参数
	        self.refreshData(_data);
	    };
	    
	    /**
	     * 根据传入的sort方法创建真正的排序方法
	     */
	    var getSortFn = function(a1, a2) {
	    	var sortFn = self.sort();
	    	if(!sortFn || sortFn === Constant.SORT_NONE) {
	    		return null;
	    	}
	    	if(sortFn === Constant.SORT_DESC) {
	    		sortFn = function(v1, v2) {
	                return v2 - v1; 
	            };
	    	} else if (sortFn === Constant.SORT_ASC) {
	    		sortFn = function(v1, v2) {
	                return v1 - v2; 
	            };
	    	} else {
	    		return null;
	    	}
	    	var dataKey = self.dataKey();
	    	return function(a1, a2) {
	    		return sortFn.call(self, a1[dataKey], a2[dataKey]);
	    	};
	    };
	    
	    //--------------------------------------------------------------------------
	    //
	    //  public Methods
	    //
	    //--------------------------------------------------------------------------
	    
	    /**
	     * override度量方法
	     */
	    this.measure = function() {
	        var model = self.model()
	            .startAngle(self.startAngle()).endAngle(self.endAngle())
	            .sort(getSortFn())
	            .value(function(d) { 
	                return d[self.dataKey()]; 
	            });
	        var target = self.target();
	        //计算布局内容，重新组装data数据
	        var data = target.visibleItems();
	        var itemsData = model(data);
	        var roseKey, roseValue, maxRoseValue = NaN;
	        if(self.roseType() === PieLayout.ROSE_TYPE_RADIUS) {
	        	roseKey = self.roseKey();
	//        	itemsData.forEach(function(item) {
	//        		roseValue = item.data[roseKey];
	//        		if(isNaN(maxRoseValue) || maxRoseValue < roseValue) {
	//        			maxRoseValue = roseValue;
	//        		}
	//        	});
	        }
	        var isRose = roseKey !== undefined;
	        var total = 0;
	        itemsData.forEach(function(item) {
	        	var value = item.data[self.dataKey()];
	        	total += value;
	        	if(isRose) {
	        		item.radiusPercent = item.data[roseKey] / value;
	        	}
	        	var bindKey = item.hasOwnProperty("data") ? item.data.bindKey : null;
	            data.forEach(function(n) {
	                if(n.bindKey === bindKey) {
	                	if(!isRose && n.hasOwnProperty("radiusPercent")) {
	            			delete n["radiusPercent"];
	            		}
	                    for(var key in item) {
	                    	if(key !== "data") {
	                    		n[key] = item[key];
	                    	}
	                    }
	                }
	            });
	        });
	        itemsData.forEach(function(item) {
	        	if(item.data) {
	        		var value = item.data[self.dataKey()];
	        		item.data.percent = value / total;
	        	}
	        });
	        //渲染点和线的位置
	        target.renderPosition();
	            
	        Global.isDebug && console.log("PieLayout::measure()");
	    };
	    
	    /**
	     * override toString方法，用于打印本对象的一些基本信息
	     */
	    this.toString = function () {
	        return ("PieLayout info: "   +
	                "\n   size:"         + this.target().width() + "," + this.target().height());
	    };
	    
	    // 初始化
	    init();
	};
	
	PieLayout.struct = function(ghca_charts) {
		var Layout = ghca_charts.layout.layout;
		Layout.struct(ghca_charts);
	    PieLayout.prototype = Object.create(Layout.prototype);
	    PieLayout.prototype.constructor = PieLayout;
	};
	
	//--------------------------------------------------------------------------
	//
	// Const
	//
	// --------------------------------------------------------------------------
	
	PieLayout.ROSE_TYPE_NO 		= "no";		//非玫瑰图类型
	PieLayout.ROSE_TYPE_RADIUS 	= "radius";	//半径类型玫瑰图
	
	module.exports = PieLayout;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 14 */
/***/ (function(module, exports) {

	//进度条布局类，继承自Layout
	
	/**
	 * 构造方法
	 * @param _target 要使用该布局的容器或者组件对象引用
	 * @param _data 布局配置数据
	 */
	var ProgressBarLayout = function (_target, _data) {
	    
	    // --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const Layout = ghca_charts.layout.layout;
	    const Global = ghca_charts.global;
	
	    Layout.apply(this, arguments);
	    
	    var self = this;
	    self.isChartLayout(true);
	    
	    //--------------------------------------------------------------------------
	    //
	    //  Attributes
	    //
	    //--------------------------------------------------------------------------
	    
	    //------------------------------
	    //  model
	    //------------------------------
	    
	    /**
	     * 水平布局模型
	     */
	    var model = null;
	    this.model = function(){
	        return model;
	    };
	    
	    //------------------------------
	    //  itemMinHeight
	    //------------------------------
	    
	    /**
	     * 布局项最小高度值(默认值2)
	     */
	    var itemMinHeight = 2;
	    this.itemMinHeight = function(value) {
	        if (!arguments.length) return itemMinHeight;                
	        itemMinHeight = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  itemMaxHeight
	    //------------------------------
	    
	    /**
	     * 布局项最大高度值(默认值100)
	     */
	    var itemMaxHeight = 100;
	    this.itemMaxHeight = function(value) {
	        if (!arguments.length) return itemMaxHeight;                
	        itemMaxHeight = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  horizontalAlign
	    //------------------------------
	    
	    /**
	     * 水平对齐方式，left|center|right(默认值left)
	     */
	    var horizontalAlign = "left";
	    this.horizontalAlign = function(value) {
	        if (!arguments.length) return horizontalAlign;                
	        horizontalAlign = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  verticalAlign
	    //------------------------------
	    
	    /**
	     * 垂直对齐方式，top|middle|bottom(默认值top)
	     */
	    var verticalAlign = "top";
	    this.verticalAlign = function(value) {
	        if (!arguments.length) return verticalAlign;                
	        verticalAlign = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  gap
	    //------------------------------
	    
	    /**
	     * 布局项间距(默认值6)
	     */
	    var gap = 6;
	    this.gap = function(value) {
	        if (!arguments.length) return gap;                
	        gap = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  fit
	    //------------------------------
	    
	    /**
	     * 自动撑满父容器，根据实际高宽计算gap(默认值false)
	     */
	    var fit = false;
	    this.fit = function(value) {
	        if (!arguments.length) return fit;
	        fit = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  paddingBottom
	    //------------------------------
	    
	    /**
	     * 布局项底边距离(默认值0)
	     */
	    var paddingBottom = 0;
	    this.paddingBottom = function(value) {
	        if (!arguments.length) return paddingBottom;                
	        paddingBottom = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  paddingLeft
	    //------------------------------
	    
	    /**
	     * 布局项左边距离(默认值0)
	     */
	    var paddingLeft = 0;
	    this.paddingLeft = function(value) {
	        if (!arguments.length) return paddingLeft;                
	        paddingLeft = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  paddingRight
	    //------------------------------
	    
	    /**
	     * 布局项右边距离(默认值0)
	     */
	    var paddingRight = 0;
	    this.paddingRight = function(value) {
	        if (!arguments.length) return paddingRight;                
	        paddingRight = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  paddingTop
	    //------------------------------
	    
	    /**
	     * 布局项顶边距离(默认值0)
	     */
	    var paddingTop = 0;
	    this.paddingTop = function(value) {
	        if (!arguments.length) return paddingTop;                
	        paddingTop = value;
	        return this;
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // private Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    /**
	     * 初始化方法
	     */
	    var init = function() {
	        //刷新传入配置数据到相应布局参数
	        self.refreshData(_data);
	    };
	    
	    //--------------------------------------------------------------------------
	    //
	    //  public Methods
	    //
	    //--------------------------------------------------------------------------
	    
	    /**
	     * override度量方法
	     */
	    this.measure = function() {
	        var self = this, 
	            target = self.target(),
	            children = target.visibleItems();
	            
	        if(!target || !children || children.length === 0) {
	            return;
	        }
	            
	        var paddingTop = self.paddingTop(),
	            paddingLeft = self.paddingLeft(),
	            paddingRight = self.paddingRight(),
	            paddingBottom = self.paddingBottom(),
	            horAlign = self.horizontalAlign(),
	            verAlign = self.verticalAlign(),
	            gap = self.gap(),
	            targetW = target.width() - paddingLeft - paddingRight,
	            targetH = target.height() - paddingTop - paddingBottom;
	        var x, y, child, len= children.length, totalH = 0, i = 0;
	        var itemHeight = targetH / len;
	        if(itemHeight < self.itemMinHeight()) {
	            itemHeight = self.itemMinHeight();
	        } else if(itemHeight > self.itemMaxHeight()) {
	        	itemHeight = self.itemMaxHeight();
	        }
	        if(fit || verAlign === "middle") {
	            for(i = 0; i < len; i++) {
	                totalH += itemHeight;
	            };
	            if(fit) {
	                gap = len > 1 ? (targetH - totalH)/(len - 1) : 0;
	            }
	            totalH += gap * (len - 1);
	        }
	        
	        for(i = 0; i < len; i++) {
	            child = children[i];
	            child.width = parseInt(targetW * child.value/child.total);
	            child.height = itemHeight;
	            child.bgWidth = targetW;
	            child.bgHeight = itemHeight;
	            if(horAlign === "left") {
	                x = paddingLeft;
	            } else if(horAlign === "center") {
	                x = paddingLeft;
	            } else if(horAlign === "right") {
	                x = paddingLeft;
	            }
	            
	            if(fit || verAlign === "middle") {
	                y = paddingTop + (targetH - totalH) / 2 + (itemHeight + gap) * i;
	            } else if(verAlign === "top") {
	                y = paddingTop + (itemHeight + gap) * i;
	            } else if(verAlign === "bottom") {
	                y = paddingTop + targetH - itemHeight * (i + 1) - gap * i;
	            }
	            child.x = x;
	            child.y = y;
	        }
	        
	        Global.isDebug && console.log("ProgressBarLayout::measure()");
	    };
	    
	    /**
	     * override toString方法，用于打印本对象的一些基本信息
	     */
	    this.toString = function () {
	        return ("ProgressBarLayout info: ");
	    };
	    
	    // 初始化
	    init();
	};
	
	ProgressBarLayout.struct = function(ghca_charts) {
	    var Layout = ghca_charts.layout.layout;
	    Layout.struct(ghca_charts);
	    ProgressBarLayout.prototype = Object.create(Layout.prototype);
	    ProgressBarLayout.prototype.constructor = ProgressBarLayout;
	};
	
	module.exports = ProgressBarLayout;


/***/ }),
/* 15 */
/***/ (function(module, exports) {

	//sankey图默认布局类，继承自Layout
	
	/**
	 * 构造方法
	 * @param _target 要使用该布局的容器或者组件对象引用
	 * @param _data 布局配置数据
	 */
	var SankeyLayout = function (_target, _data) {
		
	    // --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const Layout = ghca_charts.layout.layout;
	    const Const = ghca_charts.view.util.constant;
	    const MouseUtil = ghca_charts.view.util.mouseUtil;
	    const SankeyModel = ghca_charts.layout.model.sankeyModel;
	    const Global = ghca_charts.global;
	    
	    Layout.apply(this, arguments);
	    
	    var self = this;
	    
	    //--------------------------------------------------------------------------
	    //
	    //  Attributes
	    //
	    //--------------------------------------------------------------------------
	    
	    //------------------------------
	    //  model
	    //------------------------------
	    
	    /**
	     * sankey模型
	     */
	    var model = new SankeyModel();
	    this.model = function(){
	        return model;
	    };
	    
	    //------------------------------
	    //  nodes
	    //------------------------------
	    
	    /**
	     * 节点数据数组
	     */
	    var nodes = [];
	    this.nodes = function(){
	        return nodes;
	    };
	    
	    //------------------------------
	    //  links
	    //------------------------------
	    
	    /**
	     * 连线数据数组
	     */
	    var links = [];
	    this.links = function(){
	        return links;
	    };
	    
	    // ------------------------------
	    // nodeWidth
	    // ------------------------------
	    
	    /**
	     * 节点宽度
	     */
	    var nodeWidth = 24;
	    this.nodeWidth = function(value) {
	        if (!arguments.length)
	            return nodeWidth;
	        nodeWidth = +value;
	        return this;
	    };
	    
	    // ------------------------------
	    // maxNodeSize
	    // ------------------------------
	    
	    /**
	     * 最大节点尺寸
	     */
	    var maxNodeSize = 1000;
	    this.maxNodeSize = function(value) {
	        if (!arguments.length)
	            return maxNodeSize;
	        maxNodeSize = +value;
	        return this;
	    };
	    
	    // ------------------------------
	    // nodePadding
	    // ------------------------------
	
	    /**
	     * 同级别节点间距
	     */
	    var nodePadding = 12;
	    this.nodePadding = function(value) {
	        if (!arguments.length)
	            return nodePadding;
	        nodePadding = +value;
	        return this;
	    };
	    
	    // ------------------------------
	    // isLikeTree
	    // ------------------------------
	
	    /**
	     * 是否像树节点一样布局，若为true,则所有节点从根节点开始依照层级左对齐，若为false,则所有节点右对齐
	     */
	    var isLikeTree = false;
	    this.isLikeTree = function(value) {
	        if (!arguments.length)
	            return isLikeTree;
	        isLikeTree = value;
	        return this;
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // private Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    /**
	     * 初始化方法
	     */
	    var init = function() {
	    	//刷新传入配置数据到相应布局参数
	        self.refreshData(_data);
	    };
	    
	    this.scaleLayout = function(isEnlarge, scaleType) {
	        //如果为固定点模式，则使用以鼠标当前坐标为中心点的缩放方式进行缩放，且只改变点的位置，其他容器都不改变
	        var ds, scale = self.scale(), scaleDelta = self.scaleDelta();
	        if(isEnlarge) {
	            ds = scaleDelta;
	            if(scale + ds > self.maxScale()) {
	                return;
	            }
	        } else {
	            ds = -scaleDelta;
	            if(scale + ds < self.minScale()) {
	                return;
	            }
	        }
	        var ratio = (ds + scale) / scale;
	        if(scaleType === Const.LAYOUT_SCALE_TYPE) {
	            this.target().nodes.forEach(function(node) {
	                node.x = node.x * ratio;
	                node.y = node.y * ratio;
	            });
	        } else if(scaleType === Const.LAYOUT_HOR_SCALE_TYPE) {
	            this.target().nodes.forEach(function(node) {
	                node.x = node.x * ratio;
	            });
	        } else if(scaleType === Const.LAYOUT_VER_SCALE_TYPE) {
	            this.target().nodes.forEach(function(node) {
	                node.y = node.y * ratio;
	            });
	        }
	        
	        ratio = ds / scale;
	        var target = self.target(), x = target.x(), y = target.y(), bg = target.parent().bgNode();
	        var localP = MouseUtil.mouse(bg);
	        if(scaleType === Const.LAYOUT_SCALE_TYPE) {
	            x -= (localP[0] - x) * ratio;
	            y -= (localP[1] - y) * ratio;
	        } else if(scaleType === Const.LAYOUT_HOR_SCALE_TYPE) {
	            x -= (localP[0] - x) * ratio;
	        } else if(scaleType === Const.LAYOUT_VER_SCALE_TYPE) {
	            y -= (localP[1] - y) * ratio;
	        }
	        target.x(x);
	        target.y(y);
	        self.scale(scale + ds);
	    };
	    
	    
	    //--------------------------------------------------------------------------
	    //
	    //  public Methods
	    //
	    //--------------------------------------------------------------------------
	    
	    /**
	     * override度量方法
	     */
	    this.measure = function() {
	        var model = this.model();
	        var self = this, target = self.target();
	        //计算布局内容，判断是否全部重新布局
	        if(arguments.length !== 1 || arguments[0] !== false) {
	            model
	                .nodeWidth(this.nodeWidth())
	                .nodePadding(this.nodePadding())
	                .size([target.width(), target.height()])
	                .nodes(this.nodes())
	                .links(this.links())
	                .scaleType(target.scaleType())
	                .scale(this.scale())
	                .maxNodeSize(this.maxNodeSize())
	                .isLikeTree(this.isLikeTree())
	                .layout(32);
	        }
	            
	        //渲染点和线的位置
	        self.target().renderPosition();
	            
	        Global.isDebug && console.log("SankeyLayout::measure()");
	    };
	    
	    /**
	     * override缩放方法
	     * @param isEnlarge 是否放大
	     */
	    this.zoom = function(isEnlarge) {
	        var self = this;
	        //判断是否是对所有元素进行缩放
	        var scaleType = self.target().scaleType();
	        self.scaleLayout(isEnlarge, scaleType);
	         
	        this.measure(false);
	    };
	    
	    /**
	     * override toString方法，用于打印本对象的一些基本信息
	     */
	    this.toString = function () {
	        return ("SankeyLayout info: "   +
	                "\n   nodeWidth:"       + this.nodeWidth()              + 
	                "\n   nodePadding:"     + this.nodePadding()            + 
	                "\n   maxNodeSize:"     + this.maxNodeSize()            + 
	                "\n   scaleType:"       + this.scaleType()              + 
	                "\n   isLikeTree:"      + this.isLikeTree()             + 
	                "\n   size:"            + this.target().width() + "," + this.target().height());
	    };
	    
	    // 初始化
	    init();
	};
	
	SankeyLayout.struct = function(ghca_charts) {
		var Layout = ghca_charts.layout.layout;
		Layout.struct(ghca_charts);
	    SankeyLayout.prototype = Object.create(Layout.prototype);
	    SankeyLayout.prototype.constructor = SankeyLayout;
	};
	
	module.exports = SankeyLayout;


/***/ }),
/* 16 */
/***/ (function(module, exports) {

	//散点图默认布局类，继承自Layout
	    
	/**
	 * 构造方法
	 * @param _target 要使用该布局的容器或者组件对象引用
	 * @param _data 布局配置数据
	 */
	var ScatterLayout = function (_target, _data) {
	    
	    // --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const Layout = ghca_charts.layout.layout;
	    const Global = ghca_charts.global;
	
	    Layout.apply(this, arguments);
	    
	    var self = this;
	    
	    //--------------------------------------------------------------------------
	    //
	    //  Attributes
	    //
	    //--------------------------------------------------------------------------
	    
	    //------------------------------
	    //  isTimeLine
	    //------------------------------
	    
	    /**
	     * scatter布局类型是否是时间轴类型
	     */
	    var isTimeLine = false;
	    this.isTimeLine = function(value) {
	        if (!arguments.length)
	            return isTimeLine;
	        isTimeLine = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  items
	    //------------------------------
	    
	    /**
	     * 项数据数组
	     */
	    var items = [];
	    this.items = function(value) {
	        if (!arguments.length)
	            return items;
	        items = value;
	        return this;
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // private Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    /**
	     * 初始化方法
	     */
	    var init = function() {
	        //刷新传入配置数据到相应布局参数
	        self.refreshData(_data);
	    };
	    
	    //--------------------------------------------------------------------------
	    //
	    //  const
	    //
	    //--------------------------------------------------------------------------
	    
	    //--------------------------------------------------------------------------
	    //
	    //  public Methods
	    //
	    //--------------------------------------------------------------------------
	    
	    /**
	     * override度量方法
	     */
	    this.measure = function() {
	    	var xScale, yScale, xKey, yKey, xType, yType, horAxis, verAxis, 
	    	    target = self.target();
	    	    
	        if(target.horAxis()) {
	            horAxis = target.horAxis();
	            xScale = horAxis.scaleIns();
	            xKey = horAxis.key();
	            xType = horAxis.type();
	        }
	        if(target.verAxis()) {
	            verAxis = target.verAxis();
	            yScale = verAxis.scaleIns();
	            yKey = verAxis.key();
	            yType = verAxis.type();
	        }
	        var horInterval = horAxis.interval(), 
	            verInterval = verAxis.interval(), 
	            data = target.visibleItems();
	        for(var d, vx, vy, i = 0, len = data.length; i < len; i++) {
	        	d = data[i];
	            if(xScale && xKey) {
	            	vx = d[xKey];
	            	d.x = xScale(vx);
	                if(xType === "enum") {
	                	if(!self.isTimeLine()) {
	                		d.x += xScale.bandwidth() / 2;
	                	}
	                    d.dx = xScale.bandwidth();
	                } else if(xType === "value" && horInterval > 0) {
	                    d.dx = xScale(vx + horInterval) - d.x;
	                } else if(xType === "time" && horInterval > 0) {
	                    d.dx = xScale(new Date(vx.getTime() + horInterval * 1000)) - d.x;
	                }
	            }
	            if(yScale && yKey) {
	            	vy = d[yKey];
	            	d.y = yScale(vy);
	                if(yType === "enum") {
	                	if(!self.isTimeLine()) {
	                		d.y += yScale.bandwidth() / 2;
	                	}
	                    d.dy = yScale.bandwidth();
	                } else if(yType === "value" && horInterval > 0) {
	                    d.dy = d.y - yScale(vy + verInterval);
	                } else if(yType === "time" && horInterval > 0) {
	                    d.dy = d.y - yScale(new Date(vy.getTime() + verInterval * 1000));
	                }
	            }
	        }
	                
	        Global.isDebug && console.log("ScatterLayout::measure()");
	    };
	    
	    /**
	     * override toString方法，用于打印本对象的一些基本信息
	     */
	    this.toString = function () {
	        return ("ScatterLayout info: "   +
	                "\n   size:"             + this.target().width() + "," + this.target().height());
	    };
	    
	    // 初始化
	    init();
	};
	
	ScatterLayout.struct = function(ghca_charts) {
	    var Layout = ghca_charts.layout.layout;
	    Layout.struct(ghca_charts);
	    ScatterLayout.prototype = Object.create(Layout.prototype);
	    ScatterLayout.prototype.constructor = ScatterLayout;
	};
	
	module.exports = ScatterLayout;


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {//Sunburst布局类，继承自Layout
	
	var SunburstLayout = function (_target, _data) {
		   
	    // --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const Layout = ghca_charts.layout.layout;
	    
	    var self = this;
	
	    Layout.apply(this, arguments);
	
	    var visibleData = [];
	    this.visibleData = function(){
	        if(!arguments.length)return visibleData;
	        visibleData = arguments[0];
	        return this;
	    }
	
	    var radius = 0;
	    this.radius = function(){
	        if(!arguments.length)return radius;
	        radius = arguments[0];
	        return this;
	    }
	    
	    var nodes = [];
	    this.nodes = function(){
	        if(!arguments.length)return nodes;
	        nodes = arguments[0];
	        return this;
	    }
	    this.model(d3.partition());
	
	    //override
	    this.measure = function() {
	    	var target = self.target();
	        var radius = self.radius()*self.scale();
	        var root = d3.stratify()(self.visibleData());
	        root = d3.hierarchy(root)
	            .sum(function(d) {
	                return d.children ? 0 : d.data.value;
	            })
	            .sort(function(a, b) {
	                return b.data.value - a.data.value;
	            });
	        self.nodes(self.model().size([2 * Math.PI, radius])(root)
	            .each(function(d) {
	            	//消除一个多余的data层级
	                d.data = d.data.data;
	                d.startAngle    = d.x0;
	                d.endAngle      = d.x1;
	                d.innerRadius   = self.target().isFillMiddle() ? (d.depth > 1 ? d.y0 : 0) : d.y0;
	                d.outerRadius   = d.y1;
	                //复制数据到data下
	                d.data.startAngle   = d.startAngle;
	                d.data.endAngle     = d.endAngle;
	                d.data.innerRadius  = d.innerRadius;
	                d.data.outerRadius  = d.outerRadius;
	                //删除无用数据
	                delete d.x0;
	                delete d.x1;
	                delete d.y0;
	                delete d.y1;
	            })
	            .descendants()
	            .filter(function(d) {
	                return (d.endAngle - d.startAngle > 0.005); // 0.005 radians = 0.29 degrees
	            }));
	        //渲染点和线的位置
	        target.renderPosition();
	    };
	    //override
	    this.zoom = function(isEnlarge) {
	        var _rate = self.scaleDelta();
	        var _scaleRate = self.scale();
	        var _maxScaleRate = self.maxScale();
	        var _minScaleRate = self.minScale();
	        if(isEnlarge) {
	            _scaleRate+=_rate;
	            if(_scaleRate>_maxScaleRate)_scaleRate = _maxScaleRate;//最大放大率
	        } else {
	            _scaleRate-=_rate;
	            if(_scaleRate<_minScaleRate)_scaleRate = _minScaleRate;//最小
	        }
	        self.scale(_scaleRate);
	        self.target().update();
	    };
	};
	
	SunburstLayout.struct = function(ghca_charts) {
		var Layout = ghca_charts.layout.layout;
		Layout.struct(ghca_charts);
	    SunburstLayout.prototype = Object.create(Layout.prototype);
	    SunburstLayout.prototype.constructor = SunburstLayout;
	};
	
	module.exports = SunburstLayout;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {//拓扑图默认布局类，继承自Layout
		
	/**
	 * 构造方法
	 * @param _target 要使用该布局的容器或者组件对象引用
	 * @param _data 布局配置数据
	 */
	var TopoLayout = function (_target, _data) {
		
		// --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const Layout = ghca_charts.layout.layout;
	    const Const = ghca_charts.view.util.constant;
	    const MouseUtil = ghca_charts.view.util.mouseUtil;
	    const EventUtil = ghca_charts.view.util.eventUtil;
	    const BaseEvent =  ghca_charts.events.BaseEvent;
	    const Global = ghca_charts.global;
	
	    Layout.apply(this, arguments);
	    
	    var self = this;
	    var superRefreshData=self.refreshData;
	    //--------------------------------------------------------------------------
	    //
	    //  Attributes
	    //
	    //--------------------------------------------------------------------------
	    
	    //------------------------------
	    //  model
	    //------------------------------
	    
	    /**
	     * d3力导向模型
	     */
	    var model = d3.forceSimulation();
	    this.model = function(){
	        return model;
	    };
	    
	    //------------------------------
	    //  isCluster
	    //------------------------------
	    
	    /**
	     * 是否使用聚合模式布局(默认为否)
	     */
	    var isCluster = false;
	    this.isCluster = function(value){
	        if (!arguments.length) return isCluster;
	        isCluster = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  fixed
	    //------------------------------
	    
	    /**
	     * 是否固定所有点
	     */
	    var fixed = false;
	    this.fixed = function(value){
	        if (!arguments.length) return fixed;
	        fixed = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  isAutoLayout
	    //------------------------------
	    
	    /**
	     * 是否自动布局
	     */
	    var isAutoLayout = true;
	    this.isAutoLayout = function(value){
	        if (!arguments.length) return isAutoLayout;
	        isAutoLayout = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  nodes
	    //------------------------------
	    
	    /**
	     * 节点数据数组
	     */
	    var nodes = [];
	    this.nodes = function(){
	        return nodes;
	    };
	    
	    //------------------------------
	    //  links
	    //------------------------------
	    
	    /**
	     * 连线数据数组
	     */
	    var links = [];
	    this.links = function(){
	        return links;
	    };
	    
	    //------------------------------
	    //  alpha
	    //------------------------------
	    
	    /**
	     * 力布局的冷却参数
	     */
	    var alpha = 1;
	    this.alpha = function(value){
	        if (!arguments.length) return alpha;
	        alpha = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  distance
	    //------------------------------
	    
	    /**
	     * 节点间的距离
	     */
	    var distance = 30;
	    this.distance = function(value){
	        if (!arguments.length) return distance;
	        distance = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  distanceMin
	    //------------------------------
	    
	    /**
	     * 节点间的最小距离
	     */
	    var distanceMin = 20;
	    this.distanceMin = function(value){
	        if (!arguments.length) return distanceMin;
	        distanceMin = value;
	        return this;
	    };
	
	    var alphaMin=0.001;
	    this.alphaMin=function(value){
	        if (!arguments.length) return alphaMin;
	        alphaMin = value;
	        return this;
	    }
	    
	    //------------------------------
	    //  distanceMax
	    //------------------------------
	    
	    /**
	     * 节点间的最大距离
	     */
	    var distanceMax = 200;
	    this.distanceMax = function(value){
	        if (!arguments.length) return distanceMax;
	        distanceMax = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  chargeStrength
	    //------------------------------
	    
	    /**
	     * 电荷强度，负值导致节点排斥，而正值导致节点吸引
	     */
	    var chargeStrength = -30;
	    this.chargeStrength = function(value){
	        if (!arguments.length) return chargeStrength;
	        chargeStrength = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  theta
	    //------------------------------
	    
	    /**
	     * Barnes–Hut逼近算法中用来确定计算精度
	     */
	    var theta = 0.9;
	    this.theta = function(value){
	        if (!arguments.length) return theta;
	        theta = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  collideRadius
	    //------------------------------
	    
	    /**
	     * 节点间碰撞半径，若该值小于节点半径，则节点有可能会重叠
	     */
	    var collideRadius = 20;
	    this.collideRadius = function(value){
	        if (!arguments.length) return collideRadius;
	        collideRadius = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  collideStrength
	    //------------------------------
	    
	    /**
	     * 节点间碰撞力量
	     */
	    var collideStrength = 0.7;
	    this.collideStrength = function(value){
	        if (!arguments.length) return collideStrength;
	        collideStrength = value;
	        return this;
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // private Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    /**
	     * 初始化方法
	     */
	    this.init = function() {
	        self.isFirstMeasure = true;//判读是否第一次计算布局的标志量
	        nodes=[];
	        links=[];
	    	//刷新传入配置数据到相应布局参数
	        self.refreshData(_data);    
	    };
	    // 初始化
	    this.init();
	
	    
	    /**
	     * 重新计算布局内容
	     */
	    var refreshModel = function() {
	        //计算布局内容
	    	if(isCluster) {
	    		self.model()
	                .nodes(self.target().visibleItems())
	                .force("charge", d3.forceManyBody())
	                .force("link", d3.forceLink(self.links()).distance(self.distance()).strength(self.chargeStrength()).iterations(1)
	                .id(function(d) {
	                    return d.id;
	                }))
	                .force("x", d3.forceX().strength(0.1))
	                .force("y", d3.forceY().strength(0.1))
	                .force("center", d3.forceCenter(self.target().width() / 2, self.target().height() / 2));
	    	} else {
	    		self.model()
	            .nodes(self.target().visibleItems())
	            .alpha(self.alpha())
	            .alphaMin(self.alphaMin())
	            .force("link",   d3.forceLink(self.links()).distance(self.distance()))
	            .force("charge", d3.forceManyBody().strength(self.chargeStrength()).theta(self.theta()))
	            .force("collide",d3.forceCollide().radius(self.collideRadius()).strength(self.collideStrength()))
	            .force("center", d3.forceCenter(self.target().width() / 2, self.target().height() / 2))
	    	}
	    };
	    
	    //--------------------------------------------------------------------------
	    //
	    //  public Methods
	    //
	    //--------------------------------------------------------------------------
	    
	    /**
	     * override度量方法
	     * @isResize 是否在resize中调用本方法
	     */
	    this.measure = function(isResize) {
	        var nodes = self.target().visibleItems();
	        if(nodes.length === 0) {
	        	return;
	        }
	        
	        var model = self.model();
	        //初始化后是否固定节点
	        if(self.fixed()) {
	            //若使用自动布局，则自动分散点，然后再渲染点和线的位置
	            if(self.isAutoLayout() && !isResize) {
	            	//计算布局内容
	                refreshModel();
	                //停用力布局模式
	                model.stop();
	                //自动分散节点位置
	            	for (var i = 0, n = Math.ceil(Math.log(model.alphaMin()) / Math.log(1 - model.alphaDecay())); i < n; ++i) {
	                    model.tick();
	                }
	            } else {
	            	//若使用非自动布局，补全节点属性，然后直接渲染点和线的位置
	            	for (var node, i = 0, len = nodes.length; i < len; i++) {
	                    node = nodes[i];
	                    if(!node.hasOwnProperty("x")) node.x = 0;
	                    if(!node.hasOwnProperty("y")) node.y = 0;
	                    if(!node.hasOwnProperty("vx")) node.vx = 0;
	                    if(!node.hasOwnProperty("vy")) node.vy = 0;
	                    node.index = i;
	                }
	            }
	//            self.target().renderPosition();
	        } else {
	        	//计算布局内容
	            refreshModel();
	            //若为非固定点模式，则重新开启力布局模式
	            model.restart();
	        }
	        
	        Global.isDebug && console.log("TopoLayout::measure()");
	    };
	    
	    this.zoomToPosition=function(pos,scale){
	        var isEnlarge=scale>self.scale();
	        if(self.target().scaleType() === Const.LAYOUT_SCALE_TYPE) {
	            if(self.fixed()) {
	                self.scaleLinkWithNodeFixedUseValue(isEnlarge,pos,scale);
	            } else {
	                self.scaleLinkWithNodeFree(isEnlarge);
	            }
	        }
	        
	        if(self.fixed()) {
	             self.target().renderPosition();
	        } else {
	        	refreshModel();
	        }
	        self.target().mainContainer().node().dispatchEvent(EventUtil.createEvent(BaseEvent.SCALE_CHANGE,true,true));
	    }
	
	    /**
	     * override缩放方法
	     * @param isEnlarge 是否放大
	     */
	    this.zoom = function(isEnlarge) {
	        if(self.target().scaleType() === Const.LAYOUT_SCALE_TYPE) {
	            if(self.fixed()) {
	                self.scaleLinkWithNodeFixed(isEnlarge);
	            } else {
	                self.scaleLinkWithNodeFree(isEnlarge);
	            }
	        }
	        
	        if(self.fixed()) {
	             self.target().renderPosition();
	        } else {
	        	refreshModel();
	        }
	        self.target().mainContainer().node().dispatchEvent(EventUtil.createEvent(BaseEvent.SCALE_CHANGE,true,true));
	    };
	
	    this.scaleLinkWithNodeFixedUseValue=function(isEnlarge,pos,scale){
	        if(scale>self.maxScale()){
	            scale=self.maxScale();
	        }
	        if(scale<self.minScale()){
	            scale=self.minScale();
	        }
	
	        var currentScale=self.scale();
	        var ratio = (scale) / currentScale;
	        var nodes = self.target().nodes;
	        for (var node, i = 0; i < nodes.length; i++) {
	        	node = nodes[i];
	            node.x = node.x * ratio;
	            node.y = node.y * ratio;
	            node.fx = node.x;
	            node.fy = node.y;
	        }
	
	        var target = self.target();
	        target.x(pos.x);
	        target.y(pos.y);
	        self.scale(currentScale);
	    }
	    
	    this.scaleLinkWithNodeFixed = function(isEnlarge) {
	        //如果为固定点模式，则使用以鼠标当前坐标为中心点的缩放方式进行缩放，且只改变点的位置，其他容器都不改变
	        var ds, scale = self.scale(), scaleDelta = self.scaleDelta();
	        if(isEnlarge) {
	            ds = scaleDelta;
	            if(scale + ds > self.maxScale()) {
	                return;
	            }
	        } else {
	            ds = -scaleDelta;
	            if(scale + ds < self.minScale()) {
	                return;
	            }
	        }
	        var ratio = (ds + scale) / scale;
	        var nodes = self.target().nodes;
	        for (var node, i = 0; i < nodes.length; i++) {
	        	node = nodes[i];
	            node.x = node.x * ratio;
	            node.y = node.y * ratio;
	            node.fx = node.x;
	            node.fy = node.y;
	        }
	        ratio = ds / scale;
	        var target = self.target(), x = target.x(), y = target.y(), bg = target.parent().bgNode();
	        var localP = MouseUtil.mouse(bg);
	        x -= (localP[0] - x) * ratio;
	        y -= (localP[1] - y) * ratio;
	        target.x(x);
	        target.y(y);
	        self.scale(scale + ds);
	    };
	    
	    this.scaleLinkWithNodeFree = function(isEnlarge) {
	        //如果为非固定点模式，则缩放时只改变连线的长度，并且重新布局，其他容器都不改变
	        var delta = 25,
	            distance = self.distance(),
	            chargeStrength = self.chargeStrength(); 
	        if(isEnlarge) {
	            distance += delta;
	            if(distance > self.distanceMax()) return;
	            chargeStrength -= delta;
	        } else {
	            distance -= delta;
	            if(distance < self.distanceMin()) return;
	            chargeStrength += delta;
	        }
	        self.distance(distance);
	        self.chargeStrength(chargeStrength);
	    };
	    
	    /**
	     * override toString方法，用于打印本对象的一些基本信息
	     */
	    this.toString = function () {
	        return ("TopoLayout info: "     +
	                "\n   fixed:"           + this.fixed()              + 
	                "\n   distance:"        + this.distance()           + 
	                "\n   distanceMin:"     + this.distanceMin()        + 
	                "\n   distanceMax:"     + this.distanceMax()        + 
	                "\n   chargeStrength:"  + this.chargeStrength()     + 
	                "\n   theta:"           + this.theta()              + 
	                "\n   collideRadius:"   + this.collideRadius()      + 
	                "\n   collideStrength:" + this.collideStrength()    + 
	                "\n   alpha:"           + this.alpha()              + 
	                "\n   size:"            + this.target().width() + "," + this.target().height());
	    };
	};
	
	TopoLayout.struct = function(ghca_charts) {
		var Layout = ghca_charts.layout.layout;
		Layout.struct(ghca_charts);
	    TopoLayout.prototype = Object.create(Layout.prototype);
	    TopoLayout.prototype.constructor = TopoLayout;
	};
	
	module.exports = TopoLayout;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {//Tree布局类，继承自Layout
	
	/**
	 * 构造方法
	 * @param _target 要使用该布局的容器或者组件对象引用
	 * @param _data 布局配置数据
	 */
	var TreeLayout = function (_target, _data) {
		   
	    // --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const Layout       = ghca_charts.layout.layout;
	    const Constant     = ghca_charts.view.util.constant;
	    const math = ghca_charts.view.util.math;
	
	    Layout.apply(this, arguments);
	
	    var self = this;
	    var autoLayout = true;
	    this.autoLayout = function(value){
	        if(!arguments.length)return autoLayout;
	        autoLayout = value;
	        return this;
	    }
	
	    /**
	     * 节点固定间距，横竖间距 [x,y]
	     * @type {undefined}
	     */
	    var nodeSize = undefined;
	    this.nodeSize = function(f){
	        if (!arguments.length) return nodeSize;
	        nodeSize = f;
	        return this;
	    }
	    /**
	     * 视图大小，如没有固定节点间距则使用高宽自动计算 [width,height]
	     * @type {undefined}
	     */
	    var size = undefined;
	    this.size = function(f){
	        if (!arguments.length) return size;
	        size = f;
	        return this;
	    }
	    /**
	     * 树根节点，转换树节点后的根节点
	     * @type {null}
	     */
	    var treeRootNode = null;
	    this.treeRootNode = function(p){
	        if (!arguments.length) return treeRootNode;
	        treeRootNode = p;
	        return this;
	    };
	
	    /**
	     * 树布局放心纵向 默认纵向 环形布局
	     * @type {string}
	     */
	    var direction = Constant.TREE_VER_TYPE;
	    this.direction = function(p){
	        if (!arguments.length) return direction;
	        direction = p;
	        return this;
	    };
	
	    /**
	     * 节点间的固定距离,默认为NaN,此时默认用图表的宽、高设置布局范围
	     */
	    var nodeDistance = NaN;
	    this.nodeDistance = function(p){
	        if (!arguments.length) return nodeDistance;
	        nodeDistance = p;
	        return this;
	    };
	
	    /**
	     * 是否包含线条型节点的树结构
	     */
	    var hasPathNode = false;
	    this.hasPathNode = function(p){
	        if (!arguments.length) return hasPathNode;
	        hasPathNode = p;
	        return this;
	    };
	
	    var model = d3.tree();
	    this.model = function(){
	        return model;
	    };
	
	    /**
	     * 缩放差值
	     * @type {number}
	     */
	    var scaleDiff = 0;
	    this.scaleDiff = function(diff){
	        if (!arguments.length) return scaleDiff;
	        scaleDiff = diff;
	        return this;
	    };
	
	    /**
	     * 初始化方法
	     */
	    var init = function() {
	        self.refreshData(_data);
	        // self.model().separation(function(a, b) { return (a.parent == b.parent ? 1 : 2) / a.depth; });//子节点中同异父节点间间距算法
	    };
	    
	    /**
	     * 环形算法
	     */
	    this.radialTreeMeasure = function(){
	        self.model()(self.treeRootNode());
	        var root =  self.treeRootNode();
	        var cx = self.target().width()/2,cy = self.target().height()/2;
	        self.treeRootNode().descendants().forEach(function(node,i){
	            var x = node.x,y=node.y;
	            var rotateAngle =  node.children ? x - 90 : x + 90;
	            node.labelPosition = "start";
	            //翻转
	            if(x < 180 === !node.children) {
	                rotateAngle -= 180;
	                node.labelPosition = "end"
	            }
	            node.angle  = (x - 90) / 180 * Math.PI;
	            node.labelRotateAngle  = rotateAngle;
	
	            var xy = math.circumferencePoint(y,node.angle);
	            node.x = xy[0]+cx,node.y = xy[1]+cy;
	            node.cx = cx,node.cy=cy;
	            node.r = Math.abs(Math.sqrt(Math.pow(root.x-node.x,2)+Math.pow(root.y-node.y,2)));
	            node.data.x = node.x;
	            node.data.y = node.y;
	        });
	    }
	    /**
	     * 竖向算法
	     */
	    this.verTreeMeasure = function(){
	        var root = self.treeRootNode();
	        self.model()(root);
	        var cx = self.target().width()/2,
	        xlength = cx - root.x;
	        self.treeRootNode().descendants().forEach(function(node,i){
	            var x = node.x,y=node.y;
	            node.x = x+xlength,node.y = y+50;//y坐标暂定50
	            node.children? node.labelPosition = "start":node.labelPosition = "end";
	            node.labelRotateAngle = 90;
	            node.data.x = node.x;
	            node.data.y = node.y;
	        });
	    }
	    /**
	     * 横向算法
	     */
	    this.horTreeMeasure = function(rateDiff){
	        var root = self.treeRootNode();
	        self.model().size();//根据节点计算需要把size置空
	        self.model()(root);
	        var cy = self.target().height()/2,
	        ylength = cy - root.x;
	        self.treeRootNode().descendants().forEach(function(node,i){
	            var x = node.x,y=node.y;
	            node.x = y+50,node.y = x+ylength;
	            node.labelRotateAngle = 0;
	            node.children? node.labelPosition = "start":node.labelPosition = "end";
	            node.data.x = node.x;
	            node.data.y = node.y;
	        });
	    }
	
	    //--------------------------------------------------------------------------
	    //
	    //  public Methods
	    //
	    //--------------------------------------------------------------------------
	    
	    /**
	     * override度量方法
	     */
	    this.measure = function() {
	        var root =  self.treeRootNode();
	        if(this.autoLayout()==false && root.data.x!=undefined){
	            var nodes = root.descendants();
	            nodes.forEach(function(node){
	               node.x = node.data.x;
	               node.y = node.data.y;
	            });
	            return;
	        }
	
	        var direction = this.direction().toLowerCase();
	        var Constant     = ghca_charts.view.util.constant;
	        var scaleDiff  = this.scaleDiff();
	        var size = this.size(),width=size[0],height=size[1];
	        this.model().size([width+width*scaleDiff,height+height*scaleDiff]);
	        if(this.nodeSize()){
	            var nodeSize = this.nodeSize(),x=nodeSize[0],y=nodeSize[1];
	            this.model().nodeSize([x+x*scaleDiff,y+y*scaleDiff]);
	        }
	        switch(direction){
	            case Constant.TREE_RADIAL_TYPE: {
	                this.model().size([360,this.size()[1]+this.size()[1]*scaleDiff]);
	                self.radialTreeMeasure(scaleDiff);
	                break;
	            }
	            case Constant.TREE_HOR_TYPE:{
	                self.horTreeMeasure(scaleDiff);
	                break;
	            }
	            case Constant.TREE_VER_TYPE:{
	                self.verTreeMeasure(scaleDiff);
	                break;
	            }
	        }
	    };
	    /**
	     * override缩放方法
	     * @param isEnlarge 是否放大
	     */
	    this.zoom = function(isEnlarge) {
	        var _rate = this.scaleDelta();
	        var _scaleRate = this.scale()+_rate;
	        var _maxScaleRate = this.maxScale();
	        var _minScaleRate = this.minScale();
	        if(_scaleRate>_maxScaleRate||_scaleRate<_minScaleRate)return;
	        if(isEnlarge) {
	            this.scaleDiff(_rate+this.scaleDiff());
	        } else {
	            this.scaleDiff(-_rate+this.scaleDiff());
	        }
	        var callback = function(){
	            var self = arguments[0];
	            self.measure();
	            self.target().updatePosition();
	        };
	        if(Window.Concurrent)Concurrent.Thread.create(callback,this)
	        else callback(this);
	    };
	    
	    // 初始化
	    init();
	};
	
	TreeLayout.struct = function(ghca_charts) {
		var Layout = ghca_charts.layout.layout;
		Layout.struct(ghca_charts);
	    TreeLayout.prototype = Object.create(Layout.prototype);
	    TreeLayout.prototype.constructor = TreeLayout;
	};
	
	module.exports = TreeLayout;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {//treemap默认布局类，继承自Layout
		
	/**
	 * 构造方法
	 * @param _target 要使用该布局的容器或者组件对象引用
	 * @param _data 布局配置数据
	 */
	var TreemapLayout = function (_target, _data) {
		
		// --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const Layout = ghca_charts.layout.layout;
	    const ObjectUtil = ghca_charts.view.util.objectUtil;
	    const StringUtil = ghca_charts.view.util.stringUtil;
	    const RegexUtil = ghca_charts.view.util.regexUtil;
	    const Global = ghca_charts.global;
	
	    Layout.apply(this, arguments);
	    
	    var self = this;
	    
	    //--------------------------------------------------------------------------
	    //
	    //  Attributes
	    //
	    //--------------------------------------------------------------------------
	    
	    //------------------------------
	    //  model
	    //------------------------------
	    
	    /**
	     * treemap模型
	     */
	    var model = d3.treemap();
	    this.model = function() {
	        return model;
	    };
	    
	    //------------------------------
	    //  items
	    //------------------------------
	    
	    /**
	     * 项数据数组
	     */
	    var items = [];
	    this.items = function(value) {
	        if (!arguments.length)
	            return items;
	        items = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  dataKey
	    //------------------------------
	    
	    /**
	     * treemap数据项的键名称，默认为"value"
	     */
	    var dataKey = "value";
	    this.dataKey = function(value) {
	        if (!arguments.length)
	            return dataKey;
	        dataKey = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  tile
	    //------------------------------
	    
	    /**
	     * treemapSquarify(default)|treemapBinary|treemapDice|
	     * treemapSlice|treemapSliceDice|treemapResquarify
	     */
	    var tile = "treemapSquarify";
	    this.tile = function(value) {
	        if (!arguments.length)
	            return tile;
	        tile = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  size
	    //------------------------------
	    
	    /**
	     * 内容尺寸，[width, height]，若为百分比，则返回[parentWidth*percentWidth, parentHeight*percentHeight]
	     */
	    var size = ['80%', '80%'];
	    this.size = function(value) {
	        if(!arguments.length) {
	        	var w = size[0], h = size[1], parent = self.target().parent();
	        	w = parent && RegexUtil.percentRegex.test(w) ? parseInt(StringUtil.parsePercent(w) * parent.width() / 100) : w;
	        	h = parent && RegexUtil.percentRegex.test(h) ? parseInt(StringUtil.parsePercent(h) * parent.height() / 100) : h;
	        	return [w, h];
	        }
	        size = ObjectUtil.isArray(value) ? value :　ObjectUtil.isString(value) ? eval(value) : size;
	        return this;
	    };
	    
	    //------------------------------
	    //  round
	    //------------------------------
	    
	    /**
	     * 计算结果是否四舍五入，true|false
	     */
	    var round = false;
	    this.round = function(value) {
	        if (!arguments.length)
	            return round;
	        round = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  padding
	    //------------------------------
	    
	    /**
	     * 设置paddingInner和paddingOuter，number|function, default NaN
	     */
	    var padding = NaN;
	    this.padding = function(value) {
	        if (!arguments.length)
	            return padding;
	        padding = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  paddingInner
	    //------------------------------
	    
	    /**
	     * number|function
	     */
	    var paddingInner = NaN;
	    this.paddingInner = function(value) {
	        if (!arguments.length)
	            return paddingInner;
	        paddingInner = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  paddingOuter
	    //------------------------------
	    
	    /**
	     * (top, right, bottom and left padding)，number|function, default NaN
	     */
	    var paddingOuter = NaN;
	    this.paddingOuter = function(value) {
	        if (!arguments.length)
	            return paddingOuter;
	        paddingOuter = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  paddingTop
	    //------------------------------
	    
	    /**
	     * number|function
	     */
	    var paddingTop = NaN;
	    this.paddingTop = function(value) {
	        if (!arguments.length)
	            return paddingTop;
	        paddingTop = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  paddingBottom
	    //------------------------------
	    
	    /**
	     * number|function
	     */
	    var paddingBottom = NaN;
	    this.paddingBottom = function(value) {
	        if (!arguments.length)
	            return paddingBottom;
	        paddingBottom = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  paddingLeft
	    //------------------------------
	    
	    /**
	     * number|function
	     */
	    var paddingLeft = NaN;
	    this.paddingLeft = function(value) {
	        if (!arguments.length)
	            return paddingLeft;
	        paddingLeft = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  paddingRight
	    //------------------------------
	    
	    /**
	     * number|function
	     */
	    var paddingRight = NaN;
	    this.paddingRight = function(value) {
	        if (!arguments.length)
	            return paddingRight;
	        paddingRight = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  sumType
	    //------------------------------
	    
	    /**
	     * 求和类型，"size"|"count"
	     */
	    var sumType = "size";
	    this.sumType = function(value) {
	        if (!arguments.length)
	            return sumType;
	        sumType = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  sizeKey
	    //------------------------------
	    
	    /**
	     * sumType为"size"类型时对应的求和数据键值名称，仅当sumType为"size"时有效
	     */
	    var sizeKey = "size";
	    this.sizeKey = function(value) {
	        if (!arguments.length)
	            return sizeKey;
	        sizeKey = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  root
	    //------------------------------
	    
	    var root = null;
	    this.root = function(value) {
	        if (!arguments.length)
	            return root;
	        root = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  leaves
	    //------------------------------
	    
	    var leaves = [];
	    this.leaves = function(value) {
	        if (!arguments.length)
	            return leaves;
	        leaves = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  stratifyId
	    //------------------------------
	    
	    var stratifyId = "id";
	    this.stratifyId = function(value) {
	        if (!arguments.length)
	            return stratifyId;
	        stratifyId = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  stratifyParentId
	    //------------------------------
	    
	    var stratifyParentId = "parentId";
	    this.stratifyParentId = function(value) {
	        if (!arguments.length)
	            return stratifyParentId;
	        stratifyParentId = value;
	        return this;
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // private Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    /**
	     * 初始化方法
	     */
	    var init = function() {
	        //刷新传入配置数据到相应布局参数
	        self.refreshData(_data);
	    };
	    
	    var sumByCount = function(d) {
	        return d.children ? 0 : 1;
	    };
	    
	    var sumBySize = function(d) {
	        return d[self.sizeKey()];
	    };
	    
	    var getTileFn = function(titeName) {
	    	switch(titeName) {
	            case "treemapBinary":
	                return d3.treemapBinary;
	            case "treemapDice":
	                return d3.treemapDice;
	            case "treemapSlice":
	                return d3.treemapSlice;
	            case "treemapSliceDice":
	                return d3.treemapSliceDice;
	            case "treemapResquarify":
	                return d3.treemapResquarify;
	            case "treemapSquarify":
	            default:
	                return d3.treemapSquarify;
	    	}
	    }
	    
	    //--------------------------------------------------------------------------
	    //
	    //  public Methods
	    //
	    //--------------------------------------------------------------------------
	    
	    /**
	     * override度量方法
	     */
	    this.measure = function() {
	        var model = self.model()
	            .tile(getTileFn(self.tile())).size(self.size()).round(self.round());
	        if(!isNaN(self.padding())) {
	        	model.padding(self.padding());
	        }
	        if(!isNaN(self.paddingInner())) {
	            model.paddingInner(self.paddingInner());
	        }
	        if(!isNaN(self.paddingOuter())) {
	            model.paddingOuter(self.paddingOuter());
	        }
	        if(!isNaN(self.paddingTop())) {
	            model.paddingTop(self.paddingTop());
	        }
	        if(!isNaN(self.paddingBottom())) {
	            model.paddingBottom(self.paddingBottom());
	        }
	        if(!isNaN(self.paddingLeft())) {
	            model.paddingLeft(self.paddingLeft());
	        }
	        if(!isNaN(self.paddingRight())) {
	            model.paddingRight(self.paddingRight());
	        }
	        
	        var target = self.target();
	        //计算布局内容，重新组装data数据
	        var data = target.data().data.concat();
	        root = d3.stratify().id(function(d){
	            return d[self.stratifyId()];
	        }).parentId(function(d){
	            return d[self.stratifyParentId()];
	        })(data);
	        //删除不可见元素
	        var nodes = root.descendants();
	        for(var node, data, i = 0, len = nodes.length; i < len; i++) {
	            node = nodes[i];
	            data = node.data;
	            if(data.visible === false){
	                var parent = node.parent,
	                    children = parent ? parent.children : undefined;
	                if(children) {
	                	children.splice(children.indexOf(node), 1);
	                }
	            }
	        }
	        //计算路径和大小
	        root = d3.hierarchy(root)
	            .eachBefore(function(d) { 
	            	d.data = d.data.data;
	                d.data.path = (d.parent ? d.parent.data.path + "." : "") + d.data.name; 
	            })
	            .sum(sumType === "size" ? sumBySize : sumByCount)
	            .sort(function(a, b) { 
	                return b.height - a.height || b.value - a.value; 
	            });
	        model(root);
	        self.leaves(root.leaves());
	        //渲染节点的位置
	        target.renderPosition();
	            
	        Global.isDebug && console.log("TreemapLayout::measure()");
	    };
	    
	    /**
	     * override toString方法，用于打印本对象的一些基本信息
	     */
	    this.toString = function () {
	        return ("TreemapLayout info: " +
	                "\n   size:" + this.target().width() + "," + this.target().height());
	    };
	    
	    // 初始化
	    init();
	};
	
	TreemapLayout.struct = function(ghca_charts) {
		var Layout = ghca_charts.layout.layout;
		Layout.struct(ghca_charts);
	    TreemapLayout.prototype = Object.create(Layout.prototype);
	    TreemapLayout.prototype.constructor = TreemapLayout;
	};
	
	module.exports = TreemapLayout;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 21 */
/***/ (function(module, exports) {

	//水平布局类，继承自Layout
		
	/**
	 * 构造方法
	 * @param _target 要使用该布局的容器或者组件对象引用
	 * @param _data 布局配置数据
	 */
	var VerticalLayout = function (_target, _data) {
		
		// --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const Layout = ghca_charts.layout.layout;
	    const Global = ghca_charts.global;
	
	    Layout.apply(this, arguments);
	    
	    var self = this;
	    self.isChartLayout(false);
	    
	    //--------------------------------------------------------------------------
	    //
	    //  Attributes
	    //
	    //--------------------------------------------------------------------------
	    
	    //------------------------------
	    //  model
	    //------------------------------
	    
	    /**
	     * 水平布局模型
	     */
	    var model = null;
	    this.model = function(){
	        return model;
	    };
	    
	    //------------------------------
	    //  horizontalAlign
	    //------------------------------
	    
	    /**
	     * 水平对齐方式，left|center|right(默认值left)
	     */
	    var horizontalAlign = "left";
	    this.horizontalAlign = function(value) {
	        if (!arguments.length) return horizontalAlign;                
	        horizontalAlign = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  verticalAlign
	    //------------------------------
	    
	    /**
	     * 垂直对齐方式，top|middle|bottom(默认值top)
	     */
	    var verticalAlign = "top";
	    this.verticalAlign = function(value) {
	        if (!arguments.length) return verticalAlign;                
	        verticalAlign = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  gap
	    //------------------------------
	    
	    /**
	     * 布局项间距(默认值6)
	     */
	    var gap = 6;
	    this.gap = function(value) {
	        if (!arguments.length) return gap;                
	        gap = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  fit
	    //------------------------------
	    
	    /**
	     * 自动撑满父容器，根据实际高宽计算gap(默认值false)
	     */
	    var fit = false;
	    this.fit = function(value) {
	        if (!arguments.length) return fit;
	        fit = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  paddingBottom
	    //------------------------------
	    
	    /**
	     * 布局项底边距离(默认值0)
	     */
	    var paddingBottom = 0;
	    this.paddingBottom = function(value) {
	        if (!arguments.length) return paddingBottom;                
	        paddingBottom = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  paddingLeft
	    //------------------------------
	    
	    /**
	     * 布局项左边距离(默认值0)
	     */
	    var paddingLeft = 0;
	    this.paddingLeft = function(value) {
	        if (!arguments.length) return paddingLeft;                
	        paddingLeft = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  paddingRight
	    //------------------------------
	    
	    /**
	     * 布局项右边距离(默认值0)
	     */
	    var paddingRight = 0;
	    this.paddingRight = function(value) {
	        if (!arguments.length) return paddingRight;                
	        paddingRight = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  paddingTop
	    //------------------------------
	    
	    /**
	     * 布局项顶边距离(默认值0)
	     */
	    var paddingTop = 0;
	    this.paddingTop = function(value) {
	        if (!arguments.length) return paddingTop;                
	        paddingTop = value;
	        return this;
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // private Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    /**
	     * 初始化方法
	     */
	    var init = function() {
	        //刷新传入配置数据到相应布局参数
	        self.refreshData(_data);
	    };
	    
	    //--------------------------------------------------------------------------
	    //
	    //  public Methods
	    //
	    //--------------------------------------------------------------------------
	    
	    /**
	     * override度量方法
	     */
	    this.measure = function() {
	        var self = this, 
	            target = self.target(),
	            children = target.children();
	            
	        if(!target || !children || children.length === 0) {
	            return;
	        }
	            
	        var paddingTop = self.paddingTop(),
	            paddingLeft = self.paddingLeft(),
	            paddingRight = self.paddingRight(),
	            paddingBottom = self.paddingBottom(),
	            horAlign = self.horizontalAlign(),
	            verAlign = self.verticalAlign(),
	            gap = self.gap(),
	            targetW = target.width() - paddingLeft - paddingRight,
	            targetH = target.height() - paddingTop - paddingBottom;
	        
	        var x, y, child, len= children.length, totalH = 0, i = 0;
	        
	        if(fit || verAlign === "middle") {
	            for(i = 0; i < len; i++) {
	                child = children[i];
	                totalH += child.height();
	            };
	            if(fit) {
	                gap = len > 1 ? (targetH - totalH)/(len - 1) : 0;
	            }
	            totalH += gap * (len - 1);
	        }
	        
	        for(i = 0; i < len; i++) {
	            child = children[i];
	            if(horAlign === "left") {
	                x = paddingLeft;
	            } else if(horAlign === "center") {
	                x = paddingLeft + (targetW - child.width()) / 2;
	            } else if(horAlign === "right") {
	                x = paddingLeft + targetW - child.width();
	            }
	            
	            if(fit || verAlign === "middle") {
	                y = paddingTop + (targetH - totalH) / 2 + (child.height() + gap) * i;
	            } else if(verAlign === "top") {
	                y = paddingTop + (child.height() + gap) * i;
	            } else if(verAlign === "bottom") {
	                y = paddingTop + targetH - child.height() * (i + 1) - gap * i;
	            }
	            child.x(x);
	            child.y(y);
	            
	            //渲染子组件位置
	            child.renderTransform();
	        }
	        
	        Global.isDebug && console.log("VerticalLayout::measure()");
	    };
	    
	    /**
	     * override toString方法，用于打印本对象的一些基本信息
	     */
	    this.toString = function () {
	        return ("VerticalLayout info: ");
	    };
	    
	    // 初始化
	    init();
	};
	
	VerticalLayout.struct = function(ghca_charts) {
		var Layout = ghca_charts.layout.layout;
		Layout.struct(ghca_charts);
	    VerticalLayout.prototype = Object.create(Layout.prototype);
	    VerticalLayout.prototype.constructor = VerticalLayout;
	};
	
	module.exports = VerticalLayout;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {// 可视组件基类，所有的可视组件都必须继承该基类
		
	/**
	 * 构造方法 
	 * @param _data 配置数据
	 * @param _layout 布局对象，不传就为默认布局
	 */
	var BaseComponent = function(_data, _layout) {
		
		// --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const Layout = ghca_charts.layout.layout;
	    const LayoutFeatures = ghca_charts.layout.layoutFeatures;
	    const HorizontalLayout = ghca_charts.layout.horizontalLayout;
	    const VerticalLayout = ghca_charts.layout.verticalLayout;
	    const MouseUtil = ghca_charts.view.util.mouseUtil;
	    const SvgUtil = ghca_charts.view.util.svgUtil;
	    const Const = ghca_charts.view.util.constant;
	    const ObjectUtil = ghca_charts.view.util.objectUtil;
	    const EventUtil = ghca_charts.view.util.eventUtil;
	    const BaseEvent =  ghca_charts.events.BaseEvent;
	    const RegexUtil = ghca_charts.view.util.regexUtil;
	    const CommonUtil = ghca_charts.view.util.commonUtil;
	    const UUID = ghca_charts.view.util.UUIDUtil;
	    const Global = ghca_charts.global;
	
	    var self = this,
	        layoutFeatures = null,
	        defaultWidth = 0,
	        defaultHeight = 0,
	        defaultMaxWidth = 10000,
	        defaultMaxHeight = 10000;
	        
	    self.isWaitEyeUpdate= false;//当前是否正在等待刷新鹰眼中
	    self.eyeTimer;//鹰眼延时刷新计时器
	     
	    self.dispatch = d3.dispatch("event");
	
	    // --------------------------------------------------------------------------
	    //
	    // Attributes
	    //
	    // --------------------------------------------------------------------------
	    
	    //------------------------------
	    //  id
	    //------------------------------
	    
	    /**
	     * 该类实例唯一标识符，自动生成?
	     */
	    var id = UUID.generateUUID();
	    this.id = function(value){
	       if (!arguments.length) {
	            return id;                
	        }
	        id = value;
	        return this;
	    }
	    
	    //------------------------------
	    //  className
	    //------------------------------
	    
	    /**
	     * 类名称，默认作为该容器的css样式名称，比如<g class='mainContainer'>
	     */
	    var className = "mainContainer";
	    this.className = function(value){
	       if (!arguments.length) {
	            return className;                
	        }
	        className = value;
	        return this;
	    }
	    
	    // ------------------------------
	    // data
	    // ------------------------------
	
	    /**
	     * 配置数据
	     */
	    var data = _data;
	    this.data = function(value) {
	        if (!arguments.length) {
	            return data;            	
	        }
	        self.setAttributes(value);
	        data = value;
	        return this;
	    };
	    
	    // ------------------------------
	    // graph
	    // ------------------------------
	
	    /**
	     * 组件所在的graph实例
	     */
	    var graph = null;
	    this.graph = function(value) {
	        if (!arguments.length) {
	            return graph;                
	        }
	        graph = value;
	        return this;
	    };
	    
	    // ------------------------------
	    // layout
	    // ------------------------------
	
	    /**
	     * 布局对象，控制本容器的子对象的布局，不传就为默认布局
	     */
	    var layout = _layout;
	    this.layout = function(value) {
	        if (!arguments.length)
	            return layout;
	        layout = value;
	        // 若该layout的target为空，则设置为本对象实例
	        if (layout && !layout.target()) {
	            layout.target(self);
	        }
	        return this;
	    };
	    
	    //------------------------------
	    //  parent
	    //------------------------------
	    
	    /**
	     * 该类实例的父类实例引用
	     */
	    var parent = null;
	    this.parent = function(value) {
	        if (!arguments.length) {
	        	return parent;
	        }
	        parent = value;
	        //若父容器设置了非图表类的布局，则本容器自动生成一个用于记录父容器布局计算出的本容器的相关特征记录类实例，包括记录本容器的x,y,width,height等属性
	        if(parent instanceof BaseComponent && 
	        parent.layout() && !parent.layout().isChartLayout() && layoutFeatures === null) {
	        	layoutFeatures = new LayoutFeatures();
	        } else {
	        	layoutFeatures = null;
	        }
	        return this;
	    };
	    
	    //------------------------------
	    //  children
	    //------------------------------
	    
	    /**
	     * 该类实例的子类实例引用数组
	     */
	    var children = [];
	    this.children = function(value) {
	        if (!arguments.length) {
	            return children;
	        }
	        children = value;
	        return this;
	    };
	    
	    // ------------------------------
	    // numChildren
	    // ------------------------------
	    
	    /**
	     * 本组件包含的直接子对象数目(只计入baseComponent类型的子对象)
	     */
	    this.numChildren = function(value) {
	        return self.children.length;
	    };
	    
	    // ------------------------------
	    // parentWidth
	    // ------------------------------
	    
	    /**
	     * 父容器宽度
	     */
	    this.parentWidth = function() {
	    	return self.parent() ? self.parent().getBBox().width : 0;
	    };
	    
	    // ------------------------------
	    // parentHeight
	    // ------------------------------
	    
	    /**
	     * 父容器高度
	     */
	    this.parentHeight = function() {
	        return self.parent() ? self.parent().getBBox().height : 0;
	    };
	    
	    //------------------------------
	    //  percentX
	    //------------------------------
	    
	    /**
	     * 该组件相对父容器的水平位置(x轴)百分比 ，只能设置具体数值，比如100相当于父容器宽度的100%，
	     * 在配置中设置x:"100%"，则解析数据的时候，设置成percentX:100，
	     * 若设置了percentX，则忽略对x的设置
	     */
	    var percentX = NaN;
	    this.percentX = function(value) {
	        if (!arguments.length) {
	            return percentX;
	        }
	        percentX = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  percentY
	    //------------------------------
	    
	    /**
	     * 该组件相对父容器的垂直位置(y轴)百分比 ，只能设置具体数值，比如100相当于父容器高度的100%，
	     * 在配置中设置y:"100%"，则解析数据的时候，设置成percentY:100，
	     * 若设置了percentY，则忽略对y的设置
	     */
	    var percentY = NaN;
	    this.percentY = function(value) {
	        if (!arguments.length) {
	            return percentY;
	        }
	        percentY = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  percentZ
	    //------------------------------
	    
	    /**
	     * 该组件相对父容器的深度位置(z轴)百分比 ，只能设置具体数值，比如100相当于父容器深度的100%，
	     * 在配置中设置z:"100%"，则解析数据的时候，设置成percentZ:100，
	     * 若设置了percentZ，则忽略对z的设置
	     */
	    var percentZ = NaN;
	    this.percentZ = function(value) {
	        if (!arguments.length) {
	            return percentZ;
	        }
	        percentZ = value;
	        return this;
	    };
	
	    //------------------------------
	    //  x
	    //------------------------------
	    
	    /**
	     * 该组件相对父容器的水平位置，只能设置具体数值，返回的始终是容器的实际x坐标值(默认值0)
	     */
	    var x = 0;
	    this.x = function(value) {
	        if (!arguments.length) {
	        	if(layoutFeatures !== null) {
	        		return layoutFeatures.x();
	        	}
	            return isNaN(percentX) ? x : (this.parentWidth() * percentX / 100);
	        }
	        if(layoutFeatures === null) {
	        	x = value;
	        } else {
	        	layoutFeatures.x(value);
	        }
	        return this;
	    };
	    
	    //------------------------------
	    //  y
	    //------------------------------
	    
	    /**
	     * 该组件相对父容器的垂直位置，只能设置具体数值，返回的始终是容器的实际y坐标值(默认值0)
	     */
	    var y = 0;
	    this.y = function(value) {
	        if (!arguments.length) {
	        	if(layoutFeatures !== null) {
	                return layoutFeatures.y();
	            }
	            return isNaN(percentY) ? y : (this.parentHeight() * percentY / 100);
	        }
	        if(layoutFeatures === null) {
	            y = value;
	        } else {
	            layoutFeatures.y(value);
	        }
	        return this;
	    };
	    
	    //------------------------------
	    //  z
	    //------------------------------
	    
	    /**
	     * 3d模型中的z轴位置(预留)，只能设置具体数值，返回的始终是容器的实际z坐标值(默认值0)
	     */
	    var z = 0;
	    this.z = function(value) {
	        if (!arguments.length) {
	        	if(layoutFeatures !== null) {
	                return layoutFeatures.z();
	            }
	            return isNaN(percentZ) ? z : NaN;
	        }
	        if(layoutFeatures === null) {
	            z = value;
	        } else {
	            layoutFeatures.z(value);
	        }
	        return this;
	    };
	    
	    // ------------------------------
	    // maxWidth
	    // ------------------------------
	    
	    /**
	     * 当前组件的最大宽度
	     */
	    var maxWidth = defaultMaxWidth;
	    this.maxWidth = function(value) {
	        if (!arguments.length) {
	            return maxWidth;
	        }
	        maxWidth = value;
	        return this;
	    };
	    
	    // ------------------------------
	    // maxHeight
	    // ------------------------------
	    
	    /**
	     * 当前组件的最大高度
	     */
	    var maxHeight = defaultMaxHeight;
	    this.maxHeight = function(value) {
	        if (!arguments.length) {
	            return maxHeight;
	        }
	        maxHeight = value;
	        return this;
	    };
	    
	    // ------------------------------
	    // minWidth
	    // ------------------------------
	    
	    /**
	     * 当前组件的最小宽度
	     */
	    var minWidth = 0;
	    this.minWidth = function(value) {
	        if (!arguments.length) {
	            return minWidth;
	        }
	        minWidth = value;
	        return this;
	    };
	    
	    // ------------------------------
	    // minHeight
	    // ------------------------------
	    
	    /**
	     * 当前组件的最小高度
	     */
	    var minHeight = 0;
	    this.minHeight = function(value) {
	        if (!arguments.length) {
	            return minHeight;
	        }
	        minHeight = value;
	        return this;
	    };
	    
	    // ------------------------------
	    // percentWidth
	    // ------------------------------
	    
	    /**
	     * 当前组件的宽度相对于父容器宽度的百分比，只能设置具体数值，比如100相当于父容器宽度的100%，
	     * 在配置中设置width:"100%"，则解析数据的时候，设置成percentWidth:100，
	     * 若设置了percentWidth，则忽略对width的设置
	     */
	    var percentWidth = NaN;
	    this.percentWidth = function(value) {
	        if (!arguments.length) {
	            return percentWidth;
	        }
	        percentWidth = value;
	        return this;
	    };
	    
	    // ------------------------------
	    // percentHeight
	    // ------------------------------
	    
	    /**
	     * 当前组件的高度相对于父容器高度的百分比，只能设置具体数值，比如100相当于父容器高度的100%，
	     * 在配置中设置height:"100%"，则解析数据的时候，设置成percentHeight:100，
	     * 若设置了percentHeight，则忽略对height的设置
	     */
	    var percentHeight = NaN;
	    this.percentHeight = function(value) {
	        if (!arguments.length) {
	            return percentHeight;
	        }
	        percentHeight = value;
	        return this;
	    };
	    
	    // ------------------------------
	    // width
	    // ------------------------------
	    
	    /**
	     * 当前组件的宽度，只能设置具体数值，返回的始终是容器的实际宽度
	     */
	    var width = NaN;
	    this.width = function(value) {
	        if (!arguments.length) {
	        	var w;
	        	if(isNaN(percentWidth)) {
	        		w = isNaN(width) ? defaultWidth : width;
	        	} else {
	        		w = this.parentWidth() * percentWidth / 100;
	        	}
	            if(w < minWidth) {
	            	w = minWidth;
	            } else if(w > maxWidth) {
	            	w = maxWidth;
	            }
	            return w;
	        }
	        width = value;
	        return this;
	    };
	    
	    // ------------------------------
	    // height
	    // ------------------------------
	    
	    /**
	     * 当前组件的高度，只能设置具体数值，返回的始终是容器的实际高度
	     */
	    var height = NaN;
	    this.height = function(value) {
	        if (!arguments.length) {
	            var h;
	            if(isNaN(percentHeight)) {
	                h = isNaN(height) ? defaultHeight : height;
	            } else {
	                h = this.parentHeight() * percentHeight / 100;
	            }
	            if(h < minHeight) {
	                h = minHeight;
	            } else if(h > maxHeight) {
	                h = maxHeight;
	            }
	            return h;
	        }
	        height = value;
	        return this;
	    };
	    
	    // ------------------------------
	    // getBBox
	    // ------------------------------
	    
	    /**
	     * 获取本容器外接矩形
	     */
	    var bBox = {x:0, y:0, width:0, height:0};
	    this.getBBox = function() {
	    	bBox.x = self.x();
	    	bBox.y = self.y();
	    	bBox.width = self.width();
	    	bBox.height = self.height();
	        return bBox;
	    };
	    
	    // ------------------------------
	    // scaleX
	    // ------------------------------
	    
	    /**
	     * 当前组件的水平缩放系数
	     */
	    var scaleX = 1;
	    this.scaleX = function(value) {
	        if (!arguments.length) {
	            return scaleX;
	        }
	        scaleX = value;
	        return this;
	    };
	    
	    // ------------------------------
	    // scaleY
	    // ------------------------------
	    
	    /**
	     * 当前组件的垂直缩放系数
	     */
	    var scaleY = 1;
	    this.scaleY = function(value) {
	        if (!arguments.length) {
	            return scaleY;
	        }
	        scaleY = value;
	        return this;
	    };
	    
	    // ------------------------------
	    // rotate
	    // ------------------------------
	    
	    /**
	     * 当前组件的旋转角度(deg)，默认旋转中心为组件(0,0)点
	     */
	    var rotate = 0;
	    this.rotate = function(value) {
	        if (!arguments.length) {
	            return rotate;
	        }
	        rotate = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  visible
	    //------------------------------
	    
	    /**
	     * 控制组件是否显示
	     */
	    var visible = true;
	    this.visible = function(value) {
	        if (!arguments.length) {
	            return visible;                
	        }
	        visible = value;
	        return this;
	    };
	    
	    // ------------------------------
	    // title
	    // ------------------------------
	
	    /**
	     * 组件的title(浏览器自带的悬浮提示)内容字符串，若设置非空内容，则创建title元素并显示内容，
	     * 可使用js脚本设置动态内容，格式为：{#...#}，其中的...内容是可执行的js，比如数据var d = {name:"张三"}，
	     * 则title可以传入字符串"我叫：{#d.name#}"，就会在鼠标移动到该组件上时显示悬浮提示框，内容为"我叫：张三"。
	     */
	    var title = null;
	    this.title = function(value) {
	        if (!arguments.length) {
	        	return title;
	        }
	        title = value;
	        return this;
	    };
	
	    // ------------------------------
	    // titleFunction
	    // ------------------------------
	
	    /**
	     * title(浏览器自带的悬浮提示)生成规则方法，若注册该方法，则按该方法返回的内容显示title，忽略title属性
	     */
	    var titleFunction = null;
	    this.titleFunction = function(value) {
	        if (!arguments.length) {
	        	return titleFunction;
	        }
	        titleFunction = value;
	        return this;
	    };
	    
	    // ------------------------------
	    // zIndex
	    // ------------------------------
	    
	    /**
	     * 当前容器深度，深度大的容器遮挡深度小的容器
	     */
	    var zIndex = 0;
	    this.zIndex = function(value) {
	        if (!arguments.length) {
	        	return zIndex;
	        }
	        zIndex = value;
	        if(mainContainer && mainContainer.node()) {
	        	mainContainer.node().setAttribute("z-index", zIndex);
	        }
	        return this;
	    };
	    
	    // ------------------------------
	    // maxScale
	    // ------------------------------
	
	    /**
	     * 最大缩放系数
	     */
	    var maxScale = 3;
	    this.maxScale = function(value) {
	        if (!arguments.length)
	            return maxScale;
	        maxScale = value;
	        return this;
	    };
	    
	    // ------------------------------
	    // minScale
	    // ------------------------------
	
	    /**
	     * 最小缩放系数
	     */
	    var minScale = 0.3;
	    this.minScale = function(value) {
	        if (!arguments.length)
	            return minScale;
	        minScale = value;
	        return this;
	    };
	    
	    // ------------------------------
	    // scaleDelta
	    // ------------------------------
	
	    /**
	     * 缩放系数变化量，比如使用鼠标滚轮缩放时，每滚动一个刻度所缩放的变化量
	     */
	    var scaleDelta = 0.05;
	    this.scaleDelta = function(value) {
	        if (!arguments.length)
	            return scaleDelta;
	        scaleDelta = value;
	        return this;
	    };
	    
	    // ------------------------------
	    // scaleType
	    // ------------------------------
	
	    /**
	     * 缩放类型，
	     * -1.禁止缩放;
	     * 0.组件整体缩放;
	     * 1.布局关系缩放;
	     * 2.布局关系缩放，只对水平方向缩放;
	     * 3.布局关系缩放，只对垂直方向缩放;
	     */
	    var scaleType = Const.NO_SCALE_TYPE;
	    this.scaleType = function(value) {
	        if (!arguments.length)
	            return scaleType;
	        scaleType = value;
	        return this;
	    };
	    
	    // ------------------------------
	    // mainContainer
	    // ------------------------------
	    
	    /**
	     * 放置所有内容的最外层容器
	     */
	    var mainContainer = null;
	    this.mainContainer = function(value) {
	        if (!arguments.length) {
	            return mainContainer;
	        }
	        mainContainer = value;
	        return this;
	    };
	    
	    // ------------------------------
	    // bgContainer
	    // ------------------------------
	    
	    /**
	     * 放置背景的容器
	     */
	    var bgContainer = null;
	    this.bgContainer = function(value) {
	        if (!arguments.length) {
	            return bgContainer;
	        }
	        bgContainer = value;
	        return this;
	    };
	    
	    // ------------------------------
	    // borderContainer
	    // ------------------------------
	    
	    /**
	     * 放置边框的容器
	     */
	    var borderContainer = null;
	    this.borderContainer = function(value) {
	        if (!arguments.length) {
	            return borderContainer;
	        }
	        borderContainer = value;
	        return this;
	    };
	    
	    // ------------------------------
	    // titleContainer
	    // ------------------------------
	    
	    /**
	     * 放置悬浮提示的容器
	     */
	    var titleContainer = null;
	    this.titleContainer = function(value) {
	        if (!arguments.length) {
	            return titleContainer;
	        }
	        titleContainer = value;
	        return this;
	    };
	    
	    // ------------------------------
	    // node
	    // ------------------------------
	    
	    /**
	     * 获取本类对象中mainContainer的dom元素，类似于d3的d3.select(this).node()
	     */
	    this.node = function() {
	    	var m = self.mainContainer();
	        return m ? m.node() : null;
	    };
	    
	    // ------------------------------
	    // bgNode
	    // ------------------------------
	    
	    /**
	     * 获取本类对象背景区域矩形元素
	     */
	    this.bgNode = function() {
	        var bg = self.bgContainer();
	        return bg ? bg.node() : null;
	    };
	    
	    //------------------------------
	    //  isRenderer
	    //------------------------------
	    
	    /**
	     * 本组件是否是某组件的渲染器(默认值false)
	     */
	    var isRenderer = false;
	    this.isRenderer = function(value) {
	        if (!arguments.length) 
	            return isRenderer;
	        isRenderer = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  normalChild
	    //------------------------------
	    
	    /**
	     * 本组件包含的非组件类型子容器实例，比如plugin
	     */
	    var normalChild = null;
	    this.normalChild = function(value) {
	        if (!arguments.length) 
	            return normalChild;
	        normalChild = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  clipContent
	    //------------------------------
	    
	    /**
	     * 本组件是否对内容进行遮罩，若是则超出背景边界的内容不显示，否则显示
	     */
	    var clipContent = true;
	    this.clipContent = function(value) {
	        if (!arguments.length) 
	            return clipContent;
	        clipContent = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  ownerSVG
	    //------------------------------
	    
	    /**
	     * 本组件所在的svg
	     */
	    this.ownerSVG = function() {
	    	var parent = self;
	    	while(parent && parent instanceof BaseComponent) {
	    		if(parent.className() === "svgContainer") {
	    			return parent;
	    		}
	    		parent = parent.parent();
	    	}
	        return null;
	    };
	    
	    //------------------------------
	    //  animation
	    //------------------------------
	    
	    /**
	     * 是否开启动画效果
	     */
	    var animation = true;
	    this.animation = function(value) {
	        if (!arguments.length)
	            return animation;
	        animation = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  isTransform
	    //------------------------------
	    
	    /**
	     * 是否开启transform
	     */
	    var isTransform = true;
	    this.isTransform = function(value) {
	        if (!arguments.length)
	            return isTransform;
	        isTransform = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  isLight
	    //------------------------------
	    
	    /**
	     * 是否是轻量级容器，若是则不渲染background,border
	     */
	    var isLight = false;
	    this.isLight = function(value) {
	        if (!arguments.length)
	            return isLight;
	        isLight = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  boundType
	    //------------------------------
	    
	    /**
	     * 容器外接图形类别，用来判断和连线的交点。"rect"|"circle"(默认为矩形:"rect")
	     */
	    var boundType = "rect";
	    this.boundType = function(value){
	        if(!arguments.length)
	            return boundType;
	        boundType = value ? value : "rect";
	        return this;
	    };
	    
	    //------------------------------
	    //  useEagleEye
	    //------------------------------
	    
	    /**
	     * 容器是否使用鹰眼组件。(默认为:false)
	     */
	    var useEagleEye = false;
	    this.useEagleEye = function(value){
	        if(!arguments.length)
	            return useEagleEye;
	        useEagleEye = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  events
	    //------------------------------
	    
	    /**
	     * 组件事件配置，格式如下:
	     * <pre>
	     * <code>
	     * events:[
	     *       {
	     *           eventType:1,               //1：派发,2：响应(必须)
	     *           bindEvent:"click",         //组件支持的事件类型名称(必须)
	     *           eventName:"refresh",       //自定义事件名称(必须)
	     *           defaultParams:null,        //事件抛出默认参数表达式(可选)
	     *           eventParams:null           //事件抛出自定义参数表达式(可选)
	     *       },
	     *       {
	     *           eventType:2,                    //1：派发,2：响应(必须)
	     *           bindEvent:"setDataAndUpdate",   //组件支持的事件类型名称(必须)
	     *           eventName:"refresh"             //自定义事件名称(必须)
	     *       }
	     * ]
	     * </code>
	     * </pre>
	     */
	    var events = [];
	    this.events = function(value) {
	        if (!arguments.length)
	            return events;
	        events = value;
	        return this;
	    };
	    
	    // ------------------------------
	    // attributes
	    // ------------------------------
	    
	    /**
	     * 可从配置文件读取的属性名称
	     */
	    var attributes = [
	        "className", "x", "y", "z", "percentX", "percentY", "percentZ", 
	        "width", "height", "maxWidth", "maxHeight", "minWidth", "minHeight", 
	        "percentWidth", "percentHeight", "title", "zIndex", "scaleX", "scaleY", "rotate", "visible",
	        "minScale", "maxScale", "scaleDelta", "scaleType", "clipContent", "animation", "boundType", "useEagleEye", "events"
	    ];
	    this.attributes = function(value) {
	    	 if (!arguments.length) {
	            return attributes;
	        }
	        attributes = value;
	        return this;
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // listeners
	    //
	    // --------------------------------------------------------------------------
	    
	    // --------------------------------------------------------------------------
	    //
	    // public Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    // --------------------------------------------------------------------------
	    // children control Methods
	    // --------------------------------------------------------------------------
	    
	    this.getChildIndex = function(child) {
	    	if(!(child instanceof BaseComponent)) {
	            return - 1;
	        }
	        return self.children().indexOf(child);
	    };
	    
	    this.getChildAt = function(zIndex) {
	        if(isNaN(zIndex) || !self.isSafeZIndex(zIndex)) {
	            return - 1;
	        }
	        return self.children()[zIndex];
	    };
	    
	    this.addChild = function(child) {
	    	if(!(child instanceof BaseComponent)) {
	            return;
	        }
	    	var children = self.children();
			var index = children.indexOf(child);
			if(index === -1) {
				children.push(child);
				child.parent(this);
				child.graph(self.graph());
				child.render();
				//append没有的child时不调用所有子对象排序，因为当前的默认顺序和数组中的顺序一致，可大量节约效率
				child.node().setAttribute("z-index", children.length - 1);
			} else {
				children.push(children.splice(index, 1)[0]);
				self.refreshChildrenZIndex();
			}
	    };
	    
	    this.addChildAt = function(child, zIndex) {
	    	if(!(child instanceof BaseComponent)) {
	            return;
	        }
	        var children = self.children();
	    	zIndex = self.getSafeZIndex(zIndex);
	        var index = children.indexOf(child);
	        if(index === -1) {
	            children.splice(zIndex, 0, child);
	            child.parent(this);
	            child.graph(self.graph());
	            child.render();
	            self.refreshChildrenZIndex();
	        } else {
	            self.setChildAt(child, zIndex);
	        }
	    };
	    
	    this.setChildAt = function(child, zIndex) {
	    	if(!(child instanceof BaseComponent)) {
	            return;
	        }
	    	var children = self.children();
	    	var index = children.indexOf(child);
	    	if(index === -1 || index === zIndex) {
	    		return;
	    	}
	    	var delChild = children.splice(index, 1)[0];
	    	//当删除的元素在插入位置右侧时
	    	if(index > zIndex) {
	    		zIndex--;
	    	}
	    	//插入元素
	    	children.splice(zIndex, 0, delChild);
	    	self.refreshChildrenZIndex();
	    };
	    
	    this.swapChildrenAt = function(zIndex1, zIndex2) {
	    	if(zIndex1 === zIndex2 || !self.isSafeZIndex(zIndex1) || !self.isSafeZIndex(zIndex2)) {
	    		return false;
	    	}
	    	var children = self.children();
	    	var tempChild = children[zIndex1];
	    	children[zIndex1] = children[zIndex2];
	    	children[zIndex2] = tempChild;
	    	self.refreshChildrenZIndex();
	    	return true;
	    };
	    
	    this.swapChildren = function(child1, child2) {
	    	var zIndex1 = self.getChildIndex(child1);
	    	var zIndex2 = self.getChildIndex(child2);
	        return self.swapChildrenAt(zIndex1, zIndex2);
	    };
	    
	    this.removeChild = function(child) {
	    	if(!(child instanceof BaseComponent)) {
	            return;
	        }
	        var children = self.children();
	        var index = children.indexOf(child);
	        if(index !== -1) {
	            var delChild = children.splice(index, 1)[0];
	            delChild.zIndex(-1);
	        }
	        child.parent(null);
	        child.destroy();
	        self.refreshChildrenZIndex();
	    };
	    
	    this.removeAllChildren = function() {
	    	var children = self.children();
	    	for(var child, i = 0, len = children.length; i < len; i++) {
	    		child = children[i];
	    		if(child instanceof BaseComponent) {
	                child.zIndex(-1);
	                child.parent(null);
	                child.destroy();
	            }
	        };
	        children.length = 0;
	    };
	    
	    this.refreshChildrenZIndex = function() {
	    	for(var i = 0, len = children.length; i < len; i++) {
	            children[i].zIndex(i);
	        };
	        //对组件的所有子组件深度排序
	        self.sortAllChildrenByZIndex();
	    };
	    
	    this.isSafeZIndex = function(zIndex) {
	    	if(isNaN(zIndex)) {
	            return false;
	        }
	        if(zIndex < 0 || zIndex > self.numChildren() - 1) {
	            return false;
	        }
	        return true;
	    };
	    
	    this.getSafeZIndex = function(zIndex) {
	    	var maxZindex = self.numChildren() - 1;
	    	if(isNaN(zIndex)) {
	    		return maxZindex;
	    	}
	    	if(zIndex > maxZindex) {
	            zIndex = maxZindex;
	        }
	        if(zIndex < 0) {
	            zIndex = 0;
	        }
	        return zIndex;
	    };
	    
	    this.contains = function(child) {
	    	if(!(child instanceof BaseComponent)) {
	            return false;
	        }
	        return self.getChildIndex(child) !== -1;
	    };
	    
	    // --------------------------------------------------------------------------
	    // render control Methods
	    // --------------------------------------------------------------------------
	    
	    /**
	     * 创建并使用与本组件相关的defs元素
	     */
	    this.renderDefsElements = function() {
	    	var data = self.data();
	        if(data && data.hasOwnProperty("defs")){
	            var defs = data.defs;
	            for(var i = 0, len = defs.length; i < len; i++) {
	                SvgUtil.createDefElement(svg, defs[i]);
	            }
	        }
	    };
	    
	    /**
	     * 渲染放置所有内容的最外层容器
	     */
	    this.renderMainContainer = function() {
	        if(!self.mainContainer()) {
	            var parentCon = self.parent().mainContainer();
	            self.mainContainer(parentCon.append("g").attr("class", self.className()));
	        }
	        self.validateVisible();
	    };
	    
	    /**
	     * 渲染背景容器，背景容器总在所有子容器的最底层，stroke透明
	     */
	    this.renderBackground = function() {
	        if(!self.bgContainer()) {
	            //创建背景容器
	        	var bgCon = self.mainContainer().append("g").attr("class", "bgContainer");
	            self.bgContainer(bgCon);
	        }
	        if(!self.bgRect) {
	        	//背景矩形区域
	            self.bgRect = self.bgContainer().append("rect").attr("class", "bg");
	        }
	        self.bgRect
	            .attr("width", self.width())
	            .attr("height", self.height())
	            .attr("fill", "white");
	        if(_data && _data.background) {
	        	var background = _data.background;
	        	for(var key in background) {
	        		self.bgRect.attr(key, background[key]);
	        	}
	        	//强制边框笔触透明
	        	self.bgRect.attr("stroke-opacity", 0);
	        } else {
	        	 self.bgRect.attr("opacity", 0);//默认透明白背景，可响应鼠标事件
	        }
	    };
	    
	    /**
	     * 渲染边框容器，边框容器总在所有子容器的最上层，fill透明
	     */
	    this.renderBorder = function() {
	    	if(_data && _data.border) {
	    		if(!self.borderContainer()) {
	                //创建背景容器
	    			var borderCon = self.mainContainer()
	                    .append("g")
	                    .attr("class", "borderContainer")
	                    .attr("z-index", BaseComponent.MAX_Z_INDEX)
	                    .attr("pointer-events", "none");
	                self.borderContainer(borderCon);
	            }
	            if(!self.borderRect) {
	                //边框矩形区域
	                self.borderRect = self.borderContainer().append("rect").attr("class", "border");
	            }
	            var w = self.width(), h = self.height();
	            self.borderRect.attr("width", w).attr("height", h);
	            var border = _data.border;
	            for(var key in border) {
	                self.borderRect.attr(key, border[key]);
	            }
	            //强制填充透明
	            self.borderRect.attr("fill-opacity", 0);
	    	} else {
	    		if(self.borderContainer()) {
	    			self.borderContainer().remove();
	    		}
	    	}
	    };
	    
	    /**
	     * 渲染title(浏览器自带的悬浮提示内容)
	     */
	    this.renderTitle = function() {
	    	//若没有设置提示内容，则移除相关容器
	    	if(!self.title() && !self.titleFunction()) {
	    		if(self.titleContainer()) {
	    			self.titleContainer().remove();
	    		}
	    		return;
	    	}
	    	//若没设置提示内容，且没有创建提示容器，则先创建容器
	        if(!self.titleContainer()) {
	        	var titleClassName = this.className() + "-title";
	            self.titleContainer(self.mainContainer().append("title").attr("class", titleClassName));
	        }
	        //根据提示文本设置要求进行文本内容设置
	        if(self.titleFunction()) {
	            self.titleContainer().text(self.titleFunction());
	        } else if(self.title()) {
	            self.titleContainer().text(formatTitleFn);
	        }
	    };
	    
	    /**
	     * 渲染组件的所有子组件，先判断子组件是否已创建，若已创建，则只刷新子组件内容
	     */
	    this.renderChildren = function() {
	        //渲染放置所有内容的最外层容器
	        self.renderMainContainer();
	        //是否是轻量级容器，若是则不渲染background,border
	        if(!self.isLight()) {
	        	//渲染背景内容
	            self.renderBackground();
	            //渲染边框内容
	            self.renderBorder();
	        }
	        //渲染title
	        self.renderTitle();
	    };
	    
	    /**
	     * 对组件的所有子组件深度排序
	     */
	    this.sortAllChildrenByZIndex = function() {
	        SvgUtil.sortByZIndex(self.node().childNodes, false);
	    };
	    
	    /**
	     * 渲染组件位置变换
	     * @param transition 动画设置对象,若没有传入该对象，则变换时无动画效果
	     */
	    this.renderTransform = function(transition) {
	    	if(!self.isTransform()) {
	    		return;
	    	}
	    	var con = transition ? self.mainContainer().transition(transition) : self.mainContainer();
	        con && con.attr("transform", function(d) {
	            return  "translate(" + self.x() + "," + self.y() + ")" + 
	                    "scale(" + self.scaleX() + "," + self.scaleY() + ")" +
	                    "rotate(" + self.rotate() + ")";
	        });
	        //触发鹰眼变更
	        if(self.useEagleEye()) {
	        	self.mainContainer().node().dispatchEvent(EventUtil.createEvent(BaseEvent.POSITION_CHANGE,true,true));
	        }
	        self.mainContainer().node().dispatchEvent(EventUtil.createEvent(BaseEvent.SCALE_CHANGE,true,true));
	    };
	    
	    /**
	     * 渲染组件尺寸
	     */
	    this.renderSize = function() {
	    	if(self.isLight()) {
	    		return;
	    	}
	    	var con = self.bgContainer();
	    	//重绘背景
	    	var rect = con && con.select("rect.bg");
	    	if(rect) {
	    		rect.attr("width", self.width());
	            rect.attr("height", self.height());
	    	}
	        
	        //重绘边框
	    	con = self.borderContainer();
	    	if(con) {
	    		rect = con.select("rect.border");
	            if(rect) {
	                rect.attr("width", self.width());
	                rect.attr("height", self.height());
	            }
	    	}
	    };
	    
	    /**
	     * 渲染组件内容
	     */
	    this.renderDisplayList = function() {
	        //渲染组件的所有子组件
	        self.renderChildren();
	    	//对组件的所有子组件深度排序
	        self.sortAllChildrenByZIndex();
	    };
	    
	    /**
	     * 渲染组件尺寸和位置变换
	     */
	    this.renderSizeAndPosition = function() {
	        //渲染组件尺寸
	        self.renderSize();
	        //渲染组件位置变换
	        self.renderTransform();
	    };
	    
	    /**
	     * 渲染方法
	     */
	    this.render = function() {
	    	if(!self.parent()) {
	    		return;
	    	}
	        //渲染组件内容
	        self.renderDisplayList();
	        //渲染组件尺寸和位置变换
	        self.renderSizeAndPosition();
	        //创建并使用与本组件相关的defs元素
	        self.renderDefsElements();
	        //添加监听
	        self.addListeners();
	    };
	    
	    // --------------------------------------------------------------------------
	    // event Methods
	    // --------------------------------------------------------------------------
	    
	    /**
	     * 浏览器事件监听  必须渲染后才可添加监听，不做保存
	     * @returns {exports}
	     */
	    this.on = function() {
	        if(self.mainContainer)
	            self.mainContainer.on.apply(self.mainContainer,arguments);
	    };
	
	    /**
	     * 自定义事件监听
	     * @returns {exports}
	     */
	    this.addListener = function() {
	        var value = self.dispatch.on.apply(self.dispatch, arguments);
	        return value === self.dispatch ? self : value;
	    };
	    
	    /**
	     * 注册dom事件监听
	     */
	    this.addEventListener = function() {
	        if(self.node()){
	        	var fn = self.node().addEventListener;
	        	if(fn) {
	        		//添加默认 bubbles值为true，这样写为了兼容IE
	        		if(CommonUtil.isIE() && arguments.length === 2) {
	        			arguments[2] = true;
	        			arguments.length = 3;
	        		}
	        		return fn.apply(self.node(), arguments);
	        	}
	        }
	        return null;
	    };
	    
	    /**
	     * 删除dom事件监听
	     */
	    this.removeEventListener = function() {
	        if(self.node()){
	            var fn = self.node().removeEventListener;
	            if(fn) {
	            	//添加默认 bubbles值为true，这样写为了兼容IE
	            	if(CommonUtil.isIE() && arguments.length === 2) {
	                    arguments[2] = false;
	                }
	                return fn.apply(self.node(), arguments);
	            }
	        }
	        return null;
	    };
	    
	    /**
	     * 抛出dom事件，要传自定义数据，写法如下：
	     * var evt = EventUtil.createCustomEvent("event type", true, true, your data);
	     * self.dispatchEvent(evt);
	     * function(e) {
	     *     e.detail : {data:your data, target:self},
	     *     this : self.node(),
	     * }
	     */
	    this.dispatchEvent = function() {
	        if(self.node()){
	            var fn = self.node().dispatchEvent;
	            if(fn) {
	            	if(arguments && arguments.length > 0 && arguments[0] instanceof CustomEvent) {
	            		var evt = arguments[0];
	            		var p = {};
	            		for(var key in evt) {
	            			p[key] = evt[key];
	            		}
	            		p.detail = {data:evt.detail, target:self};
	            		var customEvent = EventUtil.createCustomEvent(evt.type, p);
	        			arguments[0] = customEvent;
	            	}
	                return fn.apply(self.node(), arguments);
	            }
	        }
	        return null;
	    };
	    
	    // --------------------------------------------------------------------------
	    // other Methods
	    // --------------------------------------------------------------------------
	    
	    /**
	     * 初始化方法，在构造方法中执行，子类重写该方法，已实现部分render操作之前的操作
	     */
	    this.init = function() {
	    	//刷新传入配置数据到所有对应属性值
	    	self.setAttributes(self.data());
	    	//初始化布局内容
	        self.initLayout();
	    };
	    
	    /**
	     * 添加可从配置文件读取的属性名称
	     */
	    this.addAttributes = function() {
			var arg, attributes = self.attributes();
			for(var i = 0, len = arguments.length; i < len; i++) {
				arg = arguments[i];
				if(ObjectUtil.isString(arg) && attributes.indexOf(arg) === -1) {
					attributes.push(arg);
				}
			}
	    };
	    
	    /**
	     * 本实例渲染完成后注册监听方法
	     */
	    this.addListeners = function() {
	    	//添加配置中的绑定事件
	    	addAllConfigEvents();
	    };
	    
	    /**
	     * 初始化布局内容
	     */
	    this.initLayout = function() {
	        //若构造方法没有传入layout实例，则根据传入data信息设置布局，若data中不包括布局信息，则使用默认布局
	        if(!self.layout() && self.data()) {
	            var layoutData = self.data().layout;
	            if(layoutData && layoutData.type) {
	                switch(layoutData.type.toLowerCase()) {
	                    case "horizontallayout":
	                        self.layout(new HorizontalLayout(self, layoutData));
	                        break;
	                    case "verticallayout":
	                        self.layout(new VerticalLayout(self, layoutData));
	                        break;
	                    default:
	                        break;
	                }
	            }
	        }
	    };
	    
	    /**
	     * 更新其他内容，包括组件背景、边框、提示信息
	     */
	    this.updateOthers = function() {
	    	//是否是轻量级容器，若是则不渲染background,border
	        if(!self.isLight()) {
	            //更新背景内容
	            self.renderBackground();
	            //更新边框内容
	            self.renderBorder();
	        }
	        //更新title
	        self.renderTitle();
	        //更新绑定事件
	        addAllConfigEvents();
	    };
	    
	    /**
	     * 更新内容
	     */
	    this.update = function() {
	    	//刷新传入配置数据到所有对应属性值
	        self.setAttributes(self.data());
	        //检测组件是否可见
	    	self.validateVisible();
	        //计算除图表布局以外的所有布局
	        var layout = self.layout();
	        if(layout) {
	            layout.update();
	        }
	        //重新渲染容器尺寸和位置
	        self.renderSizeAndPosition();
	        //重新计算遮罩等defs元素
	        self.renderDefsElements();
	        //刷新背景边框等内容
	        self.updateOthers();
	        //重新计算子容器尺寸和位置
	        var children = self.children();
	        if(children !== null && children.length > 0) {
	            for(var i = 0, len = children.length; i < len; i++) {
	                children[i].update();
	            }
	        }
	        //触发鹰眼变更
	        //self.mainContainer().node().dispatchEvent(EventUtil.createCustomEvent(BaseEvent.SIZE_CHANGE,true,true,{width:self.width(),height:self.height()}));
	    };
	    
	    /**
	     * 重新计算容器尺寸
	     */
	    this.resize = function() {
	        //重新计算除图表布局以外的所有布局，图表布局会在自身的resize方法中重新计算
	        var layout = self.layout();
	        if(layout && !layout.isChartLayout()) {
	            layout.measure();
	        }
	        //重新渲染容器尺寸和位置
	        self.renderSizeAndPosition();
	        //重新计算遮罩等defs元素
	        self.renderDefsElements();
	        //重新计算子容器尺寸和位置
	        var children = self.children();
	        if(children !== null && children.length > 0) {
	            for(var i = 0, len = children.length; i < len; i++) {
	                children[i].resize();
	            };
	        }
	        //触发鹰眼变更
	        self.useEagleEye() && self.sendMsgToEye(function(){
	            self.mainContainer().node().dispatchEvent(
	                EventUtil.createCustomEvent(BaseEvent.SIZE_CHANGE,true,true,{width:self.width(),height:self.height()}));
	        }, 2000);
	    };
	    
	    /**
	     * 对本组件实例的缩放方法
	     * @param isEnlarge 是否放大
	     */
	    this.zoom = function(isEnlarge) {
	        var ds, scaleX = self.scaleX(), scaleY = self.scaleY(), scaleDelta = self.scaleDelta();
	        //判断scaleX,scaleY边界
	        if(isEnlarge) {
	            ds = scaleDelta;
	            if(scaleX >= self.maxScale() || scaleY >= self.maxScale()) {
	                return;
	            }
	            if(scaleX + ds > self.maxScale()) {
	                scaleX = self.maxScale() - ds;
	            }
	            if(scaleY + ds > self.maxScale()) {
	                scaleY = self.maxScale() - ds;
	            }
	        } else {
	            ds = -scaleDelta;
	            if(scaleX <= self.minScale() || scaleY <= self.minScale()) {
	                return;
	            }
	            if(scaleX + ds < self.minScale()) {
	                scaleX = self.minScale() - ds;
	            }
	            if(scaleY + ds < self.minScale()) {
	                scaleY = self.minScale() - ds;
	            }
	        }
	        
	        //以当前鼠标点为中心点的缩放
	        var ratioX = ds / scaleX,
	            ratioY = ds / scaleY,
	            x = self.x(), 
	            y = self.y(), 
	            bg = self.parent().bgNode();
	        var localP = MouseUtil.mouse(bg);
	        x -= d3.event ? (localP[0] - x) * ratioX : 0;
	        y -= d3.event ? (localP[1] - y) * ratioY : 0;
	        self.x(x);
	        self.y(y);
	        self.scaleX(scaleX + ds);
	        self.scaleY(scaleY + ds);
	        
	        //渲染位置变换
	        self.renderTransform();
	    }
	
	    this.zoomToPosition=function(pos,scale){
	        self.x(pos.x);
	        self.y(pos.y);
	        self.scaleX(scale);
	        self.scaleY(scale);
	        
	        //渲染位置变换
	        self.renderTransform();
	    }
	
	    
	    /**
	     * 刷新传入配置数据到所有对应属性值的方法
	     * @param data 配置数据
	     */
	    this.setAttributes = function(data) {
	        if(!data) {
	            return;
	        }
	        for(var name, names = self.attributes(), i = 0, len = names.length; i < len; i++) {
	            name = names[i];
	            if(data.hasOwnProperty(name) && self.hasOwnProperty(name)) {
	        	   self[name](data[name]);
	            }
	        }
	    };
	    
	    /**
	     * 根据指定的元素属性名称和对应的值过滤数组元素
	     * @param arr 要过滤的数组
	     * @param name 属性名称
	     * @param value 属性值
	     * @return 返回过滤后的数组，源数组不变，若没有满足条件的数组，则返回空数组
	     */
	    this.filterArrayByElementProperty = function(arr, name, value) {
	        var result = [];
	        if(!arr || arr.length === 0){
	            return result;
	        }
	        for (var i = 0, len = arr.length; i < len; i++) {
	            if (arr[i][name] === value)
	                result.push(arr[i]);
	        }
	        return result;
	    };
	    
	    /**
	     * 设置配置属性值
	     * @param key 属性键值(包括从该组件到属性的路径，比如legend.xPos或者legend.domain[0])
	     * @param value 属性值
	     * @return 返回是否设置成功
	     */
	    this.setConfigProperty = function(key, value) {
	        if(!ObjectUtil.isString(key) || RegexUtil.whiteSpaceRegex.test(key) || !self.data()) {
	        	return false;
	        }
	        if(ObjectUtil.isString(value)) {
	            try {
	            	//复杂json字符串格式，包括{}[]
	                value = JSON.parse(value);
	            } catch(e) {
	                try {
	                    //这样写是因为JSON.parse("x")非法，要JSON.parse(""x"")才正确
	                    value = "\"" + value + "\"";
	                    value = JSON.parse(value);
	                } catch(e) {
	                    return false;
	                }
	            }
	        }
	        var propertyNames = key.split(".");
	        var arrayReg = RegexUtil.arrayFormatRegex;
	        var configData = self.data();
	        var name, arrayMatch, index;
	        for(var i = 0, len = propertyNames.length, lastIndex = len - 1; i < len; i++) {
	        	name = propertyNames[i];
	        	arrayMatch = name.match(arrayReg);
	        	if(arrayMatch) {
	        		name = arrayMatch[1];
	        		index = parseInt(arrayMatch[2]);
	        		if(!ObjectUtil.isArray(configData[name])) {
	                        configData[name] = [];
	                }
	        		if(i === lastIndex) {
	        			if(configData[name]===value){
	        				return false;
	        			}
	                    configData[name][index] = value;
	        		} else {
	        			configData = configData[name][index];
	        		}
	        	} else {
	        		if(i === lastIndex) {
	        			if(configData[name]===value){
	        				return false;
	        			}
	        			configData[name] = value;
	        		} else {
	        			if(!ObjectUtil.isObject(configData[name])) {
	                        configData[name] = {};
	                    }
	                    configData = configData[name];
	        		}
	        	}
	        }
	        return true;
	    };
	    
	    /**
	     * 设置数据内容
	     * @param value 数据内容，格式为：{data:[]}或者{nodes:[],links:[]}等
	     * @return 返回是否设置成功
	     */
	    this.setData = function(value) {
	        if(!self.data()) {
	        	return false;
	        }
	        if(ObjectUtil.isString(value)) {
	            try {
	            	//是否为复杂json字符串格式
	                if(value.indexOf("{") !== 0 && value.indexOf("[") !== 0) {
	                    //这样写是因为JSON.parse("x")非法，要JSON.parse(""x"")才正确
	                    value = "\"" + value + "\"";
	                }
	                value = JSON.parse(value);
	            } catch(e) {
	                return false;
	            }
	        }
	        var configData = self.data();
	        for(var key in value) {
	        	var d = value[key];
	//        	if(!ObjectUtil.isArray(d)) {
	//                continue;
	//            }
	        	//暂时这样特殊处理 ---start
	        	if(ObjectUtil.isObject(d) && key === "tableConfig") {
	                configData[key] = d;
	                continue;
	            } else if(!ObjectUtil.isArray(d)) {
	                continue;
	            }
	            //暂时这样特殊处理 ---end
	        	if(!ObjectUtil.isArray(configData[key])) {
	        		configData[key] = [];
	        	}
	        	var ary = configData[key];
	        	ary.length = 0;
	        	for(var i = 0, len = d.length; i < len; i++) {
	        		ary.push(d[i]);
	        	}
	        }
	        return true;
	    };
	    
	    /**
	     * 设置配置属性值成功后更新组件内容
	     * @param key 属性键值(包括从该组件到属性的路径，比如legend.xPos或者legend.domain[0])
	     * @param value 属性值
	     * @return 返回是否设置成功
	     */
	    this.setConfigPropertyAndUpdate = function(key, value) {
	        if(self.setConfigProperty(key, value)) {
	        	self.update();
	        	return true;
	        }
	        return false;
	    };
	    
	    /**
	     * 设置数据内容成功后更新组件内容
	     * @param value 数据内容，格式为：{data:[]}或者{nodes:[],links:[]}等
	     * @return 返回是否设置成功
	     */
	    this.setDataAndUpdate = function(value) {
	    	if(self.setData(value)) {
	            self.update();
	            return true;
	        }
	        return false;
	    };
	    
	    /**
	     * 验证当前容器是否可见
	     */
	    this.validateVisible = function() {
	    	//可视化编辑器中
	        if(Global.isUseByEVPlatform && self.mainContainer()) {
	        	var isVisible = self.visible() === true ? true : false;
	            self.mainContainer().style("display", isVisible ? null : "none");
	            self.dispatchEvent(EventUtil.createCustomEvent(
	                   BaseEvent.SET_CON_CSS, true, true, {"pointer-events":isVisible ? null : "none"}));
	        }
	    };
	    
	    /**
	     * 延时发送内容变更到鹰眼，优化效率
	     * @param sendFn 注册自己的发送方法
	     * @param time 发送间隔时间，单位毫秒，默认1000毫秒
	     */
	    this.sendMsgToEye = function(sendFn, time) {
	    	time = isNaN(time) ? 1000 : time;
	        //若正在等待刷新鹰眼中，则不做任何操作，并且重新开始计算延时刷新时间
	        if(self.isWaitEyeUpdate) {
	        	clearTimeout(self.eyeTimer);
	        }
	        self.isWaitEyeUpdate = true;
	        self.eyeTimer = setTimeout(function() {
	            clearTimeout(self.eyeTimer);
	            if(sendFn) {
	                sendFn();
	            }
	            self.isWaitEyeUpdate = false;
	        }, time);
	    };
	    
	    /**
	     * 销毁本类实例的方法
	     */
	    this.destroy = function() {
	        if(self.mainContainer()) {
	            self.mainContainer().remove();
	        }
	    };
	    
	    /**
	     * 转换组件数据内容为json字符串格式。
	     * 如果数据为循环引用，则无法转换，具体修改循环引用的逻辑在子类方法中实现
	     */
	    this.toJSON = function() {
	        var str = "";
	        var d = self.data();
	        if(!d) {
	            return str;
	        }
	        str = JSON.stringify(d);
	        return str;
	    };
	    
	    /**
	     * 用于打印本对象的一些基本信息
	     */
	    this.toString = function() {
	        return ("BaseComponent info: "  +
	                "\n   x:"               + self.x()              + 
	                "\n   y:"               + self.y()              + 
	                "\n   z:"               + self.z()              + 
	                "\n   percentX:"        + self.percentX()       + 
	                "\n   percentY:"        + self.percentY()       + 
	                "\n   percentZ:"        + self.percentZ()       + 
	                "\n   parentWidth:"     + self.parentWidth()    + 
	                "\n   parentHeight:"    + self.parentHeight()   + 
	                "\n   width:"           + self.width()          + 
	                "\n   height:"          + self.height()         + 
	                "\n   percentWidth:"    + self.percentWidth()   + 
	                "\n   percentHeight:"   + self.percentHeight()  + 
	                "\n   minWidth:"        + self.minWidth()       + 
	                "\n   minHeight:"       + self.minHeight()      + 
	                "\n   maxWidth:"        + self.maxWidth()       + 
	                "\n   maxHeight:"       + self.maxHeight()      + 
	                "\n   scaleX:"          + self.scaleX()         + 
	                "\n   scaleY:"          + self.scaleY()         + 
	                "\n   rotate:"          + self.rotate()         + 
	                "\n   visible:"         + self.visible()        + 
	                "\n   title:"           + self.title()          + 
	                "\n   data:"            + JSON.stringify(self.data(), null, 4));
	    };
	
	    // --------------------------------------------------------------------------
	    //
	    // private Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    /**
	     * 替换title中的特殊字符串内容，比如{#d.name#}替换为渲染数据中的name属性的值,{##}中的内容是可执行的js
	     */
	    var formatTitleFn = function(d) {
	        var titleStr = self.title();
	        return titleStr.replace(RegexUtil.jsRegex, function() {
	            return arguments.length > 1 ? eval(arguments[1]) : "";
	        });
	    };
	    
	    // --------------------------------------------------------------------------
	    // config events codes
	    // --------------------------------------------------------------------------
	    
	    var configEvents = [];//已添加的配置事件列表
	    
	    /**
	     * 解析事件参数值字符串，替换为对应的值的方法,str只支持一个"{##}"，且必须整个字符串都是一个"{##}"，
	     * 因为"{##}"会被替换成执行js表达式的值，类型也可能会改变，反回的不一定是字符串类型
	     * @param str 参数值字符串
	     * @param d 数据对象
	     * @return 返回替换后的结果对象，若没有找到替换内容("{##}")，则返回原始值
	     */
	    var parseParamValue = function(str, d) {
	    	try {
	    		str.replace(RegexUtil.jsRegex, function() {
	                str = arguments.length > 1 ? eval(arguments[1]) : "";
	            });
	    	} catch(e) {
	    		return str;
	    	}
	    	return str;
	    };
	    
	    /**
	     * 解析事件参数
	     * @param obj 参数所属对象
	     * @param name 参数属性名称
	     * @param d 数据对象
	     */
	    var parseParams = function(obj, name, d) {
	        if(!obj || d === null || d === undefined) {
	            return;
	        }
	        var p = obj[name];
	        if(!p) {
	        	return;
	        }
	        if(ObjectUtil.isString(p)) {
	        	obj[name] = parseParamValue(p, d);
	        } else if(ObjectUtil.isObject(p) || ObjectUtil.isArray(p)) {
	        	for(var key in p) {
	                var value = p[key];
	                if(ObjectUtil.isString(value)) {
	                    p[key] = parseParamValue(value, d);
	                } else if(ObjectUtil.isObject(value) || ObjectUtil.isArray(value)) {
	                	parseParams(p, key, d);
	                }
	            }
	        }
	    };
	    
	    /**
	     * 添加触发类型配置事件
	     * @param e 事件配置数据
	     */
	    var addTriggerEvent = function(e) {
	        e.fn = function() {
	            var parent = self.parent();
	            if(!parent) {
	            	return;
	            }
	            /*兼容IE,firefox:IE中，不支持直接参数接收，而是通过window.event来接收;在firefox中用d3的on方法注册的事件监听，用d3.event方法获取event*/
	            var evt = (arguments.length > 0 && arguments[0]) || window.event || d3.event;
	            if(evt) {
	            	evt.stopPropagation();
	            }
	            var cloneE = ObjectUtil.cloneObj(e);
	            cloneE.fn = e.fn;
	            if(!cloneE.defaultParams) {
	                cloneE.defaultParams = {};
	            }
	            //detail.data是baseComponent.dispatchEvent抛出的数据，detail是dom.dispatchEvent抛出的数据
	            var d = evt && evt.detail ? (evt.detail.data && evt.detail.target ? evt.detail.data : evt.detail) : null;
	            parseParams(cloneE, "defaultParams", d);//解析defaultParams
	            parseParams(cloneE, "eventParams", d);//解析eventParams
	            if(cloneE.bindEvent === BaseEvent.NOTICE_SYN_TOOL_TIP) {
	            	var dp = cloneE.defaultParams;
	                dp.isShowToolTip = self.isShowToolTip();
	                dp.xAxisValue = self.getXAxisValue();
	                dp.eventType = evt.type;
	            }
	            self.dispatchEvent(EventUtil.createCustomEvent(BaseEvent.NOTICE_EVENT_NAME, true, true, cloneE));
	        };
	        var bindEvent = e.bindEvent;
	        var mainContainer = self.mainContainer();
	        if(bindEvent === BaseEvent.SLIDER_RANGE_CHANGE) {
	            self.isDispatchSliderChange(true);
	            self.addEventListener(BaseEvent.SLIDER_RANGE_CHANGE, e.fn);
	        } else if(bindEvent === BaseEvent.NOTICE_SYN_TOOL_TIP) {
	        	//这里使用on注册事件，否则MouseUtil.mouse()方法鼠标定位会报错
	            mainContainer.on("mouseover.notice", e.fn);
	            mainContainer.on("mousemove.notice", e.fn);
	            mainContainer.on("mouseout.notice", e.fn);
	        } else {
	            self.addEventListener(e.bindEvent, e.fn);
	        }
	    };
	    
	    /**
	     * 添加响应类型配置事件
	     * @param e 事件配置数据
	     */
	    var addResponseEvent = function(e) {
	        e.fn = function() {
	        	/*兼容IE,firefox:IE中，不支持直接参数接收，而是通过window.event来接收;在firefox中用d3的on方法注册的事件监听，用d3.event方法获取event*/
	        	var evt = (arguments.length > 0 && arguments[0]) || window.event || d3.event;
	        	//禁止冒泡
	        	if(evt) {
	        		evt.stopPropagation();
	        	}
	            //console.log(evt);
	            var graph = self.graph();
	            if(!graph) {
	                return;
	            }
	            var data = evt.detail.data;
	            var dp = data ? data.defaultParams : null;
	            var ep = data ? data.eventParams : null;
	            var bindEvent = e.bindEvent;
	            if(bindEvent === BaseEvent.NOTICE_REFRESH_DATA) {
	            	if(!dp && !ep) return;
	            	var d = ep.data ? ep.data : dp.data;
	            	if(d) {
	            		d = ObjectUtil.cloneObj(d);
	            	}
	                graph.setDataAndUpdate(d);
	            } else if(bindEvent === BaseEvent.NOTICE_SYN_TOOL_TIP) {
	            	if(!dp) return;
	                var eventType = dp.eventType;
	                if(eventType === "mouseover") {
	                    self.actionShowToolTip(dp.isShowToolTip, dp.xAxisValue);
	                } else if(eventType === "mousemove") {
	                    self.actionUpdateToolTip(dp.xAxisValue);
	                } else {
	                    self.actionHideToolTip();
	                }
	            } else if(bindEvent === BaseEvent.CHART_VISIBLE) {
	            	var isVisible = ep === true ? true : false;
	            	self.setConfigPropertyAndUpdate("visible", isVisible);
	            	self.dispatchEvent(EventUtil.createCustomEvent(
	            	   BaseEvent.SET_CON_CSS, true, true, {"pointer-events":isVisible ? null : "none"}));
	            } else if(bindEvent === BaseEvent.TIMER_CONTROL) {
	            	self.action && self.action(ep);
	            }
	        };
	        self.addEventListener(BaseEvent.CUSTOM_EVENT_PREFIX + e.eventName, e.fn);
	    };
	    
	    /**
	     * 添加配置事件
	     * @param e 事件配置数据
	     */
	    var addConfigEvent = function(e) {
	        if(hasConfigEvent(e)) {
	            return;
	        }
	        configEvents.push(e);
	        
	        if(e.eventType === BaseEvent.NOTICE_EVENT_TYPE_TRIGGER) {
	            addTriggerEvent(e);
	        } else if(e.eventType === BaseEvent.NOTICE_EVENT_TYPE_RESPONSE) {
	            addResponseEvent(e);
	        }
	    };
	    
	    /**
	     * 添加所有配置事件
	     */
	    var addAllConfigEvents = function() {
	        //刷新事件配置数据到属性中
	        var data = self.data();
	        if(!data) {
	        	return;
	        }
	        
	        removeAllConfigEvents();
	        
	        var events = ObjectUtil.isArray(data.events) ? data.events : [];
	        self.events(events);
	        for(var i = 0, len = events.length; i < len; i++) {
	            addConfigEvent(events[i]);
	        }
	    };
	    
	    /**
	     * 移除配置事件
	     * @param e 事件配置数据
	     */
	    var removeConfigEvent = function(e) {
	        var index = getConfigEventIndex(e);
	        if(index === -1) {
	            return;
	        }
	        configEvents.splice(index, 1);
	        
	        if(e.eventType === BaseEvent.NOTICE_EVENT_TYPE_TRIGGER) {
	            var bindEvent = e.bindEvent;
	            var mainContainer = self.mainContainer();
	            if(bindEvent === BaseEvent.NOTICE_REFRESH_DATA) {
	                self.isDispatchSliderChange(false);
	                self.removeEventListener(BaseEvent.SLIDER_RANGE_CHANGE, e.fn);
	            } else if(bindEvent === BaseEvent.NOTICE_SYN_TOOL_TIP) {
	                mainContainer.on("mouseover.notice", null);
	                mainContainer.on("mousemove.notice", null);
	                mainContainer.on("mouseout.notice", null);
	            } else {
	            	self.removeEventListener(e.bindEvent, e.fn);
	            }
	        } else if(e.eventType === BaseEvent.NOTICE_EVENT_TYPE_RESPONSE) {
	            self.removeEventListener(BaseEvent.CUSTOM_EVENT_PREFIX + e.eventName, e.fn);
	        }
	        delete e.fn;
	    };
	    
	    /**
	     * 移除所有配置事件
	     */
	    var removeAllConfigEvents = function() {
	        while(configEvents.length > 0) {
	            removeConfigEvent(configEvents[0]);
	        }
	    };
	    
	    /**
	     * 是否已经注册该配置事件
	     * @param e 事件配置数据
	     * @return 返回结果
	     */
	    var hasConfigEvent = function(e) {
	        return getConfigEventIndex(e) !== -1;
	    };
	    
	    /**
	     * 获取该配置事件在已注配置事件数组中的索引值
	     * @param e 事件配置数据
	     * @return 返回结果，若没有包含则返回-1
	     */
	    var getConfigEventIndex = function(e) {
	        return configEvents.indexOf(e);
	    };
	    
	    BaseComponent.clazzName = "BaseComponent";
	    
	    self.init();
	};
	
	BaseComponent.struct = function(ghca_charts) {
	    BaseComponent.prototype.constructor = BaseComponent;
	};
	
	// --------------------------------------------------------------------------
	//
	// Const
	//
	// --------------------------------------------------------------------------
	
	module.exports = BaseComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 23 */
/***/ (function(module, exports) {

	var ChartMap = function() {
		
		this.getMap = function() {
			var map = {};
			//注册内部图表类
	        map.sunburst = ghca_charts.view.component.charts.sunburst;
	        map.chart = ghca_charts.view.component.charts.chart;
	        map.pie = ghca_charts.view.component.charts.pie;
	        map.radialtree = ghca_charts.view.component.charts.radialTree;
	        map.sankey = ghca_charts.view.component.charts.sankey;
	        map.topology = ghca_charts.view.component.charts.topology;
	        map.topology_edit = ghca_charts.view.component.charts.editorTopology;
	        map.biztopology = ghca_charts.view.component.charts.bizTopology;
	        map.tree = ghca_charts.view.component.charts.tree;
	        map.scatter = ghca_charts.view.component.charts.scatter;
	        map.area = ghca_charts.view.component.charts.area;
	        map.line = ghca_charts.view.component.charts.line;
	        map.bar = ghca_charts.view.component.charts.bar;
	        map.treemap = ghca_charts.view.component.charts.treemap;
	        map.pack = ghca_charts.view.component.charts.pack;
	        map.calendar = ghca_charts.view.component.charts.calendar;
	        map.progressbar = ghca_charts.view.component.charts.progressBar;
	        
	        //注册外部图表类
	        var outerMap = ghca_charts.global.outerPlugins && ghca_charts.global.outerPlugins.chartMap;
	        if(outerMap) {
	        	for(var name in outerMap) {
	                map[name] = outerMap[name];
	            }
	        }
	        
	        return map;
		};
	};
	
	ChartMap.struct = function(ghca_charts) {
	    ChartMap.prototype.constructor = ChartMap;
	};
	
	module.exports = ChartMap;


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {// 区域图类
	    
	/**
	 * 构造方法 
	 * @param _data 区域图配置数据
	 * @param _layout 区域图布局对象，不传就为默认布局
	 */
	var Area = function(_data, _layout) {
	    
	    // --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const BaseComponent = ghca_charts.view.component.baseComponent;
	    const BaseChart = ghca_charts.view.component.charts.baseChart;
	    const ClassFactory = ghca_charts.view.util.classFactory;
	    const ColorUtil = ghca_charts.view.util.colorUtil;
	    const SvgUtil = ghca_charts.view.util.svgUtil;
	
	    BaseChart.apply(this, arguments);
	    
	    var self = this,
	        nodesInsMap = {},
	        superInit = self.init,
	        superInitAllContainers = self.initAllContainers,
	        superAddListeners = self.addListeners,
	        superRenderPosition = self.renderPosition,
	        superRefreshData = self.refreshData,
	        initDuraton = 1000,
	        updateDuration = 500;
	    
	    self.className("seriesArea");
	    //添加可从配置文件读取的属性名称
	    self.addAttributes("tension", "nodeShow", "isDash");
	
	    // --------------------------------------------------------------------------
	    //
	    // Attributes
	    //
	    // --------------------------------------------------------------------------
	
	    // ------------------------------
	    // tension
	    // ------------------------------
	    
	    /**
	     * 连线弯曲率，范围[0, 1],1时为折线，0和1之间(包括0)值为曲线(默认值为0)
	     */
	    var tension = 0;
	    this.tension = function(value){
	        if (!arguments.length) return tension;
	        tension = value;
	        return this;
	    };
	    
	    // ------------------------------
	    // nodeShow
	    // ------------------------------
	    
	    /**
	     * 是否显示节点(默认值为false)
	     */
	    var nodeShow = false;
	    this.nodeShow = function(value){
	        if (!arguments.length) return nodeShow;
	        nodeShow = value;
	        return this;
	    };
	    
	    // ------------------------------
	    // isDash
	    // ------------------------------
	    
	    /**
	     * 是否开启虚线实线混合显示模式，同时节点数据中要设置isDash为true的节点，
	     * 从该节点前面一个节点到该节点之间才会显示虚线(默认值为false)，例子如下：
	     * series:[{
	            type:"area",
	            isDash:true,
	            linkStyle:{"stroke-dasharray":"5, 5"},
	            data:[
	                {id:1},
	                {id:2},
	                {id:3, isDash:true},
	                {id:4, isDash:true}
	            ]
	        }]
	        1-2实线，2-3-4虚线
	     */
	    var isDash = false;
	    this.isDash = function(value){
	        if (!arguments.length) return isDash;
	        isDash = value;
	        return this;
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // override Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    /**
	     * 初始化方法
	     */
	    this.init = function() {
	        superInit();
	        
	        var items = self.data().data;
	        self.visibleItems(items);
	        self.itemsIns = [];
	    };
	    
	    /**
	     * 初始化添加所有监听的方法
	     */
	    this.addListeners = function() {
	        superAddListeners();
	    };
	    
	    /**
	     * 刷新数据内容，生成需要的属性和相关值
	     */
	   this.refreshData = function() {
	   	    superRefreshData();
	        //生成visible属性，默认值为true
	        var items = self.data().data;
	        for(var item, i = 0, len = items.length; i < len; i++) {
	            item = items[i];
	            item.bindKey = i;
	            if(!item.hasOwnProperty("visible")) {
	                item.visible = true;
	            }
	        }
	    };
	    
	    /**
	     * 渲染图表内容相关位置 
	     */
	    this.renderPosition = function() {
	        superRenderPosition();
	        
	        if(self.areaContainer) {
	        	self.areaContainer.renderTransform();
	        }
	    };
	    
	    this.initAllContainers = function() {
	    	superInitAllContainers();
	    	
	    	//放置所有项的g元素
	    	if(!self.areaContainer) {
	    		var areaContainer = new BaseComponent();
	            areaContainer.className("area-Container");
	            self.addChild(areaContainer);
	            self.areaContainer = areaContainer;
	    	}
	    };
	    
	    /**
	     * 根据当前数据重新渲染内容，并重新计算布局内容
	     */
	    this.update = function() {
	    	self.refreshData();
	    	var items = self.data().data;
	    	self.visibleItems(self.filterArrayByElementProperty(items, "visible", true));
	    	//计算布局，获取项数据数组
	        self.layout().update();
	        
	        /*这里先清除所有的项元素，然后再创建新的数据，否则动态添加的数据显示会有重复的问题。
	                                    但是这样做在ie和edge中会造成闪烁，且效率极低，有待优化。*/
	        var areaContainer = self.areaContainer;
	//        SvgUtil.removeAllChildren(areaContainer.node());
	//        self.itemsIns.length = 0;
	        
	//        //获取节点渲染器配置，并根据legend组件分配的颜色设置节点填充颜色,若没有legend相关配置，则pie组件始终强制使用自动生成的颜色填充
	//        for(var d, i = 0, len = itemsData.length; i < len; i++) {
	//            d = itemsData[i];
	//            if(d.legendColor === null || d.legendColor === undefined || d.legendColor === "") {
	//                d.legendColor = ColorUtil.getColor(i);
	//            }
	//            var config = self.getRendererConfig(d, "fill");
	//            //判断饼图外半径是否为auto,若为auto,则自动填满图表范围;若没有outerRadius属性，则等同于auto
	//            if(!config.hasOwnProperty("clazzProperties")) {
	//                
	//            } else if(config.clazzProperties.hasOwnProperty("outerRadius") && config.clazzProperties.outerRadius === "auto") {
	//                config.clazzProperties.outerRadius = Math.min(self.width(), self.height()) / 2;
	//            }
	//        }
	//        //渲染节点内容
	//        var itemsIns = ClassFactory.newRenderersInstanceByData(areaContainer, self, "itemContainer", itemsData);
	//        if(itemsIns) {
	//            for(var i = 0, len = itemsIns.length; i < len; i++) {
	//                self.itemsIns.push(itemsIns[i]);
	//            }
	//        }
	        
	        //渲染节点
	        var horAxis, verAxis, xScale, yScale, xPadding = 0, yPadding = 0, vAixsHeight = 0;
	        if(self.horAxis()) {
	        	horAxis = self.horAxis();
	        	xPadding = horAxis.padding();
	        	xScale = horAxis.scaleIns();
	        }
	        if(self.verAxis()) {
	        	verAxis = self.verAxis();
	            yPadding = verAxis.padding();
	            yScale = verAxis.scaleIns();
	            vAixsHeight = verAxis.height();
	        }
	        
	        //整体区域虚线或者实线
	        var area = d3.area()
	            .x(function(d) { return d.x; })
	            .curve(d3.curveCardinal.tension(self.tension()));
	        
	        var defaultColor = ColorUtil.getColor(self.seriesIndex());
	        areaContainer = self.areaContainer.mainContainer();
	        self.areaContainer.x(xPadding.left);
	        self.areaContainer.y(yPadding.top);
	        
	        //根据字典中指定的渲染器数据生成节点渲染器数据
	        var visibleItems = self.visibleItems();
	        for(var d, i = 0, len = visibleItems.length; i < len; i++) {
	            d = visibleItems[i];
	            if(d.legendColor === null || d.legendColor === undefined || d.legendColor === "") {
	                d.legendColor = defaultColor;
	            }
	            self.getRendererConfig(d, "fill");
	        }
	        
	        var diffKey = self.diffKey();
	        //render path
	        var pathUpdate = areaContainer.selectAll("path.area-path")
	            .data(visibleItems.length > 0 ? [visibleItems] : []);
	        
	        var pathExit = pathUpdate.exit();
	        pathExit.remove();
	            
	        pathUpdate
	            .transition().duration(self.animation() ? updateDuration : 0)
	            .attr("fill",  function(d) {
	                var color = defaultColor;
	                if(d.hasOwnProperty("legendColor")) {
	                    color = d.legendColor;
	                } else if(d.length > 0 && d[0].hasOwnProperty("legendColor")) {
	                    color = d[0].legendColor;
	                }
	                return ColorUtil.setAlpha(color, 0.15);
	            })
	            .attr("stroke", function(d) {
	                var color = defaultColor;
	                if(d.hasOwnProperty("legendColor")) {
	                    color = d.legendColor;
	                } else if(d.length > 0 && d[0].hasOwnProperty("legendColor")) {
	                    color = d[0].legendColor;
	                }
	                return color;
	            })
	            .attr("d", area.y(vAixsHeight))
	            .attr("d", area.y0(yScale(0)).y1(function(d) { return d.y; }));    
	        
	        var defaultLink = {
	            "stroke-linejoin":"round", 
	            "stroke-linecap":"round", 
	            "stroke-width":1.5, 
	            "stroke-dasharray":""
	        };
	        var linkStyle = self.data().linkStyle;
	        if(linkStyle) {
	        	for(var key in linkStyle) {
	        		defaultLink[key] = linkStyle[key];
	        	}
	        }
	        var path = pathUpdate.enter().append("path");
	        for(var key in linkStyle) {
	            path.attr(key, linkStyle[key]);
	        }
	        path.attr("class", "area-path")
	            .attr("fill",  function(d) {
	                var color = defaultColor;
	                if(d.hasOwnProperty("legendColor")) {
	                    color = d.legendColor;
	                } else if(d.length > 0 && d[0].hasOwnProperty("legendColor")) {
	                    color = d[0].legendColor;
	                }
	                return ColorUtil.setAlpha(color, 0.15);
	            })
	            .attr("stroke", function(d) {
	                var color = defaultColor;
	                if(d.hasOwnProperty("legendColor")) {
	                    color = d.legendColor;
	                } else if(d.length > 0 && d[0].hasOwnProperty("legendColor")) {
	                    color = d[0].legendColor;
	                }
	                return color;
	            })
	            .each(function(d) {
	                if(d.length > 0) {
	                    d[0].legendIns = self.areaContainer;
	                }
	            })
	            .attr("d", area.y(vAixsHeight))
	            .transition().duration(self.animation() ? initDuraton : 0)
	            .attr("d", area.y0(yScale(0)).y1(function(d) { return d.y; }));
	         
	        //部分区域实线，如果有则渲染
	        if(self.isDash()) {
	        	var line = d3.line()
	                .x(function(d) { return d.x; })
	                .curve(d3.curveCardinal.tension(self.tension()));
	            var regExp = /[a-zA-Z]+[^a-zA-Z]*/g;
	            var path1Update = areaContainer.selectAll("path.line-path1")
	                .data(visibleItems.length > 0 ? [visibleItems.filter(function(d){ 
	                    return !d.isDash; 
	                })] : []);
	            
	            var path1Exit = path1Update.exit();
	            path1Exit.remove();
	                
	            path1Update
	                .attr("visibility", "hidden")
	                .transition().duration(self.animation() ? updateDuration : 0)
	                .attr("stroke", function(d) {
	                    var color = defaultColor;
	                    if(d.hasOwnProperty("legendColor")) {
	                        color = d.legendColor;
	                    } else if(d.length > 0 && d[0].hasOwnProperty("legendColor")) {
	                        color = d[0].legendColor;
	                    }
	                    return color;
	                })
	                .attr("d", line.y(vAixsHeight))
	                .attr("d", line.y(function(d) { return d.y; }))
	                .on("end", function() {
	                    var pArray = pathUpdate.attr("d").match(regExp);
	                    var lArray = path1Update.attr("d").match(regExp);
	                    for(var i = 0, len = lArray.length; i < len; i++) {
	                        lArray[i] = pArray[i];
	                    }
	                    path1Update.attr("visibility", "visible").attr("d", lArray.join(""));
	                });    
	            
	            var path1 = path1Update.enter().append("path");
	            for(var key in linkStyle) {
	                path1.attr(key, linkStyle[key]);
	            }
	            path1.attr("class", "line-path1")
	                .attr("visibility", "hidden")
	                .attr("fill", "none")
	                .attr("stroke-dasharray", "")
	                .attr("stroke", function(d) {
	                    var color = defaultColor;
	                    if(d.hasOwnProperty("legendColor")) {
	                        color = d.legendColor;
	                    } else if(d.length > 0 && d[0].hasOwnProperty("legendColor")) {
	                        color = d[0].legendColor;
	                    }
	                    return color;
	                })
	                .attr("d", line.y(vAixsHeight))
	                .transition().duration(self.animation() ? initDuraton : 0)
	                .attr("d", line.y(function(d) { return d.y; }))
	                .on("end", function() {
	                    var pArray = path.attr("d").match(regExp);
	                    var lArray = path1.attr("d").match(regExp);
	                    for(var i = 0, len = lArray.length; i < len; i++) {
	                        lArray[i] = pArray[i];
	                    }
	                    path1.attr("visibility", "visible").attr("d", lArray.join(""));
	                });
	        }
	         
	        //render items
	        if(self.nodeShow()) {
	        	var pointUpdate = areaContainer.selectAll("g.point-item")
	        	   .data(visibleItems, self.bindKeyFn);
	        	var pointExit = pointUpdate.exit();
	        	pointExit.each(function(d) {
	                var key = self.bindKeyFn(d);
	                if(nodesInsMap.hasOwnProperty(key)) {
	                    delete nodesInsMap[key];
	                }
	            }).remove();
	        	
	        	//update
	            pointUpdate.each(function(d) {
	                var key = self.bindKeyFn(d);
	                var ins = nodesInsMap[key];
	                if(ins) {
	                    ins.data(d);
	                    ins.update();
	                    d.ins = ins;
	                    d.legendIns = ins;
	                }
	            });
	            
	            //add
	            var pointsEnter = pointUpdate.enter().append("g").attr("class", "point-item");
	            pointsEnter.each(function(d){
	                if(!d.hasOwnProperty("legendColor")) {
	                    d.legendColor = defaultColor;
	                }
	                var rendererConfig = self.getRendererConfig(d, "stroke");
	                var clazz = d.hasOwnProperty("renderer") ? rendererConfig.clazz : "lineNode";
	                var nodeIns = ClassFactory.newNodeInstance(clazz, [d3.select(this), d]);
	                nodeIns.render();
	                d.ins = nodeIns;
	                d.legendIns = self.areaContainer;
	                var key = self.bindKeyFn(d);
	                nodesInsMap[key] = nodeIns;
	            });
	        } else {
	        	areaContainer.selectAll("g.point-item").remove();
	        }
	            
	        self.renderPosition();
	    };
	    
	    /**
	     * override toString方法，用于打印本对象的一些基本信息
	     */
	    this.toString = function() {
	        return ("Area info: "     +
	                "\n   width:"     + self.width()      + 
	                "\n   height:"    + self.height()     + 
	                "\n   layout:"    + self.layout()     + 
	                "\n   data:"      + JSON.stringify(self.data(), null, 4));
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // listeners
	    //
	    // --------------------------------------------------------------------------
	    
	    // --------------------------------------------------------------------------
	    //
	    // public Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    Area.clazzName = "Area";
	    
	    // 初始化
	    self.init();
	};
	
	Area.struct = function(ghca_charts) {
	    var BaseChart = ghca_charts.view.component.charts.baseChart;
	    BaseChart.struct(ghca_charts);
	    Area.prototype = Object.create(BaseChart.prototype);
	    Area.prototype.constructor = Area;
	};
	
	// --------------------------------------------------------------------------
	//
	// Const
	//
	// --------------------------------------------------------------------------
	
	module.exports = Area;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {/**
	 * 坐标轴渲染控制类，包括多个axis实例，一个坐标轴渲染控制类可控制内容如下：
	 *         |---继承自baseAxis类的horAxis元素(0-2条)---gridLine(可选)
	 * axis--- |---继承自baseAxis类的verAxis元素(0-2条)---gridLine(可选)
	 * 
	 */
	    
	/**
	 * 构造方法 
	 * @param _parent 坐标轴所在组件实例
	 * @param _config 整体配置数据
	 */
	var Axis = function(_parent, _config) {
	    
	    // --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const HorAxis = ghca_charts.view.component.charts.horAxis;
	    const VerAxis = ghca_charts.view.component.charts.verAxis;
	    const BaseEvent = ghca_charts.events.BaseEvent;
	    const ObjectUtil = ghca_charts.view.util.objectUtil;
	    const Global = ghca_charts.global;
	
	    if(arguments.length < 1) {
	        throw new Error('Axis传入参数个数错误,当前个数' + arguments.length + ",应至少传入1个参数");
	    }
	    if (!_parent) {
	        throw new Error('Axis构造方法中传入的容器_parent:' + _parent + "无法找到。");
	    }
	    
	    //判断是否传入有效配置信息
	    if(!_config || !_config.axis || (!_config.axis.xAxis && !_config.axis.yAxis)) {
	        return;
	    }
	    
	    var self = this;
	        
	    var parseTime = d3.timeParse('%Y-%m-%d');
	        parseTimeRegEx = new RegExp(/^\d{4}-\d{2}-\d{2}$/),
	        parseDateTime = d3.timeParse('%Y-%m-%d %H:%M:%S'),
	        parseDateTimeRegEx = new RegExp(/^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}$/);
	//        d3.timeFormatDefaultLocale({
	//            "dateTime": "%x, %X",
	//            "date": "%-m/%-d/%Y",
	//            "time": "%-I:%M:%S %p",
	//            "periods": ["上午", "下午"],
	//            "days": ["星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"],
	//            "shortDays": ["星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"],
	//            "months": ["1月", "2月", "3月", "4月", "5月", "6月", "7月", "8月", "9月", "10月", "11月", "12月"],
	//            "shortMonths": ["1月", "2月", "3月", "4月", "5月", "6月", "7月", "8月", "9月", "10月", "11月", "12月"]
	//        });
	//        d3.timeFormatDefaultLocale({
	//            "dateTime": "%x, %X",
	//            "date": "%-m/%-d/%Y",
	//            "time": "%-I:%M:%S %p",
	//            "periods": ["AM", "PM"],
	//            "days": ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
	//            "shortDays": ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
	//            "months": ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
	//            "shortMonths": ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
	//        });
	    
	    // --------------------------------------------------------------------------
	    //
	    // Attributes
	    //
	    // --------------------------------------------------------------------------
	        
	    //------------------------------
	    //  horAxises
	    //------------------------------
	    
	    /**
	     * 水平坐标轴实例数组
	     */
	    var horAxises = [];
	    this.horAxises = function(value){
	        if (!arguments.length) return horAxises;
	        horAxises = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  verAxises
	    //------------------------------
	    
	    /**
	     * 垂直坐标轴实例数组
	     */
	    var verAxises = [];
	    this.verAxises = function(value){
	        if (!arguments.length) return verAxises;
	        verAxises = value;
	        return this;
	    };
	    
	    // ------------------------------
	    // config
	    // ------------------------------
	
	    /**
	     * 整体配置数据
	     */
	    var config = _config;
	    this.config = function(value) {
	        if (!arguments.length)
	            return config;
	        config = value;
	        return this;
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // public Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    /**
	     * 渲染方法
	     */
	    this.render = function() {
	    	//渲染坐标轴
	    	renderAxis(self.axisContainer, _config);
	    	//渲染坐标轴网格
	    	renderGridLine();
	    };
	    
	    /**
	     * 获取坐标轴有效内容区域矩形
	     */
	    this.getAxisContentArea = function() {
	        var horAxis, verAxis;
	        var horAxises = self.horAxises();
	        if(horAxises && horAxises.length > 0) {
	            horAxis = horAxises[0];
	        }
	        var verAxises = self.verAxises();
	        if(verAxises && verAxises.length > 0) {
	            verAxis = verAxises[0];
	        }
	        var hx = horAxis ? horAxis.x() : 0;
	        var vx = verAxis ? verAxis.x() : 0;
	        var hy = horAxis ? horAxis.y() : 0;
	        var vy = verAxis ? verAxis.y() : 0;
	        var x = hx < vx ? hx : vx;
	        var y = hy < vy ? hy : vy;
	        var w = horAxis ? horAxis.width() : 0;
	        var h = verAxis ? verAxis.height() : 0;
	        return {x:x, y:y, w:w, h:h};
	    };
	    
	    this.update = function() {
	    	//移除所有坐标轴容器
	    	self.axisContainer.selectAll(".xAxis").remove();
	    	self.axisContainer.selectAll(".yAxis").remove();
	    	//清空坐标轴实例数组
	    	horAxises = self.horAxises();
	    	verAxises = self.verAxises();
	    	if(horAxises && horAxises.length > 0) {
	            horAxises.length = 0;
	        }
	        if(verAxises && verAxises.length > 0) {
	            verAxises.length = 0;
	        }
	        //重新实例化坐标轴
	    	renderAxis(self.axisContainer, _config);
	    	//重新设置序列图表对应的坐标轴对象
	    	if(_parent && _parent.children().length > 0) {
	    		_parent.children().forEach(function(seriesChart){
	    			_parent.setAxisForSeriesCharts(seriesChart, seriesChart.data());
	    		});
	    	}
	    	//更新坐标轴
	        if(horAxises && horAxises.length > 0) {
	            horAxises.forEach(function(axis) {
	            	axis.update();
	            });
	        }
	        if(verAxises && verAxises.length > 0) {
	            verAxises.forEach(function(axis) {
	                axis.update();
	            });
	        }
	        //渲染坐标轴网格
	        renderGridLine();
	    };
	    
	    this.toString = function() {
	    };
	    
	    
	    // --------------------------------------------------------------------------
	    //
	    // private Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    // --------------------------------------------------------------------------
	    // axis code
	    // --------------------------------------------------------------------------
	    
	    /**
	     * 初始化方法
	     */
	    var init = function() {
	        self.parent = _parent.mainContainer();
	        
	        //解析配置数据
	        parseConfig();
	        
	        //初始化坐标轴包含的各个层级
	        initAllContainers();
	        
	        //添加监听
	        addListeners();
	    };
	    
	    /**
	     * 解析配置数据
	     */
	    var parseConfig = function() {
	        
	    };
	    
	    /**
	     * 初始化图列包含的各个层级
	     */
	    var initAllContainers = function() {
	        //放置所有内容的最外层g元素
	        self.axisContainer = self.parent.append("g").attr("class", "axis");
	    };
	    
	    /**
	     * 添加所需监听
	     */
	    var addListeners = function() {
	    };
	    
	    /**
	     * 渲染水平坐标轴内容
	     * @param parent 父容器
	     * @param xAxis 水平坐标轴数据数组，即config.xAxis
	     */
	    var renderHorAxises = function(parent, xAxis) {
	    	Global.isDebug && console.log("Axis.renderHorAxises()");
	        for(var i = 0, len = xAxis.length; i < len; i++) {
	            renderHorAxis(parent, xAxis[i], i);
	        }
	    };
	    
	    /**
	     * 渲染垂直坐标轴内容
	     * @param parent 父容器
	     * @param yAxis 垂直坐标轴数据数组，即config.yAxis
	     */
	    var renderVerAxises = function(parent, yAxis) {
	    	Global.isDebug && console.log("Axis.renderVerAxises()");
	        for(var i = 0, len = yAxis.length; i < len; i++) {
	            renderVerAxis(parent, yAxis[i], i);
	        }
	    };
	    
	    /**
	     * 渲染xAxis中水平坐标轴内容
	     * @param parent 父容器
	     * @param axisData 单个水平坐标轴数据，即config.xAxis[n]
	     * @param index 对应的水平坐标轴索引值，若不传则默认为0
	     */
	    var renderHorAxis = function(parent, axisData, index) {
	    	Global.isDebug && console.log("Axis.renderHorAxis(), type is " + axisData.type);
	        //若配置中没有设置刻度范围，则从key的对应值中选择最小和最大的值作为刻度范围
	        setDomain(axisData, axisData.useDomain && axisData.hasOwnProperty("domain") && axisData.domain.length > 0, index, true);
	        //实例化水平坐标轴
	        var axis = new HorAxis(parent, axisData);
	        if(!axis) {
	            throw new Error('当前传入的坐标轴类型' + axisData.type + "尚未支持。");
	        }
	        axis.parentChart(_parent);
	        axis.render();
	        self.horAxises().push(axis);
	    };
	    
	    /**
	     * 渲染yAxis中垂直坐标轴内容
	     * @param parent 父容器
	     * @param axisData 单个垂直坐标轴数据，即config.xAxis[n]
	     * @param index 对应的垂直坐标轴索引值，若不传则默认为0
	     */
	    var renderVerAxis = function(parent, axisData, index) {
	    	Global.isDebug && console.log("Axis.renderVerAxis(), type is " + axisData.type);
	        //若配置中没有设置刻度范围，则从key的对应值中选择最小和最大的值作为刻度范围
	        setDomain(axisData, axisData.useDomain && axisData.hasOwnProperty("domain") && axisData.domain.length > 0, index, false);
	        //实例化垂直坐标轴
	        var axis = new VerAxis(parent, axisData);
	        if(!axis) {
	            throw new Error('当前传入的坐标轴类型' + axisData.type + "尚未支持。");
	        }
	        axis.parentChart(_parent);
	        axis.render();
	        self.verAxises().push(axis);
	    };
	    
	    /**
	     * 渲染坐标轴
	     * @param parent 父容器
	     * @param config 整体渲染配置数据
	     */
	    var renderAxis = function(parent, config) {
	        if(!config.axis.xAxis) {
	            self.horAxises().length = 0;
	        } else {
	            renderHorAxises(parent, config.axis.xAxis);
	        }
	        if(!config.axis.yAxis) {
	            self.verAxises().length = 0;
	        } else {
	            renderVerAxises(parent, config.axis.yAxis);
	        }
	        
	        Global.isDebug && console.log("Axis.renderAxis()");
	    };
	    
	    /**
	     * 渲染坐标轴网格
	     */
	    var renderGridLine = function() {
	    	var rect = self.getAxisContentArea();
	    	var horAxises = self.horAxises(), verAxises = self.verAxises();
	    	horAxises.forEach(function(axis){
	    		axis.renderGridLine(rect);
	    	});
	    	verAxises.forEach(function(axis){
	            axis.renderGridLine(rect);
	        });
	        
	    	Global.isDebug && console.log("Axis.renderGridLine()");
	    };
	    
	    /**
	     * 设置坐标轴连续刻度范围，即设置坐标轴配置数据的minValue和maxValue,
	     * 若为enum类型或者已设置minValue和maxValue，则该方法无效
	     * @param axisData 坐标轴配置数据
	     * @param hasDomain 初始化配置中是否包括domain
	     * @param index 对应的坐标轴索引值，若不传则默认为0
	     * @param isHor 是否为水平坐标轴
	     */
	    var setContinuousDomain = function(axisData, hasDomain, index, isHor) {
	        if(!axisData || axisData.type === "enum" || hasDomain) {
	            return;
	        }
	        var series = config.series;
	        if(!series) {
	            return;
	        }
	        var chartData, data, value, axisIndex, axisIndexKey, layout, minValue = null, maxValue = null, 
	            key = axisData.hasOwnProperty("key") ? axisData.key : "name", 
	            keyPath = axisData.hasOwnProperty("keyPath") ? axisData.keyPath : "",
	            index = index === undefined ? 0 : index;
	        for(var i = 0, len = series.length; i < len; i++) {
	            chartData = series[i];
	            //过滤不相关的坐标轴对应的数据
	            axisIndexKey = isHor ? "xAxisIndex" : "yAxisIndex";
	            axisIndex = chartData.hasOwnProperty(axisIndexKey) ? chartData[axisIndexKey] : 0;
	            if(axisIndex !== index) {
	            	continue;
	            }
	            //bar图表非普通类型,特殊处理key值
	            layout = chartData.layout;
	            if(layout.type === "barLayout" && layout.barType !== "normal" && layout.barType !== undefined) {
	            	key = "total";
	            }
	            data = keyPath === "" ? chartData : eval('chartData.' + keyPath);
	            for(var d, j = 0, len1 = data.length; j < len1; j++) {
	            	d = data[j];
	            	//过滤不可见数据
	            	if(d.hasOwnProperty("visible") && !d["visible"]) {
	            		continue;
	            	}
	                value = d[key];
	                if(value !== undefined && value !== null) {
	                    //替换字符串时间格式为date类型格式
	                    if(axisData.type === "time" && ObjectUtil.isString(value)) {
	                        if(parseDateTimeRegEx.test(value)) {
	                            value = parseDateTime(value);
	                        } else if(parseTimeRegEx.test(value)) {
	                            value = parseTime(value);
	                        }
	                        d[key] = value;
	                    }
	                    if(minValue === null) {
	                        minValue = value;
	                    } else if(value < minValue) {
	                        minValue = value;
	                    }
	                    if(maxValue === null) {
	                        maxValue = value;
	                    } else if(value > maxValue) {
	                        maxValue = value;
	                    }
	                }
	            }
	        }
	        axisData.domain = axisData.type === "time" ? 
	            [minValue, maxValue] : [0 < minValue ? 0 : minValue, maxValue*1.2];
	    }
	    
	    /**
	     * 设置坐标轴枚举刻度范围。
	     * 枚举刻度数据，若设置domain,则直接从domain获取；
	     * 若没有设置domain，则依赖keyPath和key属性从数据中分析获取。
	     * @param axisData 坐标轴配置数据
	     * @param hasDomain 初始化配置中是否包括domain
	     * @param index 对应的坐标轴索引值，若不传则默认为0
	     * @param isHor 是否为水平坐标轴
	     */
	    var setEnumDomain = function(axisData, hasDomain, index, isHor) {
	        if(!axisData || axisData.type !== "enum" || hasDomain) {
	            return;
	        }
	        var series = config.series;
	        if(!series) {
	            return;
	        }
	        var chartData, data, value, axisIndex, axisIndexKey, domain = [], 
	            key = axisData.hasOwnProperty("key") ? axisData.key : "name", 
	            keyPath = axisData.hasOwnProperty("keyPath") ? axisData.keyPath : "",
	            index = index === undefined ? 0 : index;
	        for(var i = 0, len = series.length; i < len; i++) {
	            chartData = series[i];
	            //过滤不相关的坐标轴对应的数据
	            axisIndexKey = isHor ? "xAxisIndex" : "yAxisIndex";
	            axisIndex = chartData.hasOwnProperty(axisIndexKey) ? chartData[axisIndexKey] : 0;
	            if(axisIndex !== index) {
	                continue;
	            }
	            data = keyPath === "" ? chartData : eval('chartData.' + keyPath);
	            if(ObjectUtil.isArray(data)) {
	                for(var d, j = 0, len1 = data.length; j < len1; j++) {
	                    d = data[j];
	                	//过滤不可见数据
	                    if(d.hasOwnProperty("visible") && !d["visible"]) {
	                        continue;
	                    }
	                    value = d[key];
	                    if(value !== undefined && value !== null) {
	                       domain.push(value);
	                    }
	                }
	            } else {
	                value = data[key];
	                if(value !== undefined && value !== null) {
	                   domain.push(value);
	                }
	            }
	        }
	        axisData.domain = domain;
	    }
	    
	    /**
	     * 设置坐标轴枚度范围
	     * @param axisData 坐标轴配置数据
	     * @param hasDomain 初始化配置中是否包括domain
	     * @param index 对应的坐标轴索引值，若不传则默认为0
	     * @param isHor 是否为水平坐标轴
	     */
	    var setDomain = function(axisData, hasDomain, index, isHor) {
	        setEnumDomain(axisData, false, index, isHor);//枚举类型强制重新渲染
	        setContinuousDomain(axisData, hasDomain, index, isHor);//暂时强制重新渲染
	    };
	    
	    // 初始化
	    init();
	};
	
	Axis.struct = function(ghca_charts) {
	    Axis.prototype.constructor = Axis;
	};
	
	// --------------------------------------------------------------------------
	//
	// Const
	//
	// --------------------------------------------------------------------------
	
	module.exports = Axis;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {// 柱状图类
	    
	/**
	 * 构造方法 
	 * @param _data 柱状图配置数据
	 * @param _layout 柱状图布局对象，不传就为默认布局
	 */
	var Bar = function(_data, _layout) {
	    
	    // --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const BaseComponent = ghca_charts.view.component.baseComponent;
	    const BaseChart = ghca_charts.view.component.charts.baseChart;
	    const ClassFactory = ghca_charts.view.util.classFactory;
	    const ColorUtil = ghca_charts.view.util.colorUtil;
	
	    BaseChart.apply(this, arguments);
	    
	    var self = this,
	        nodesInsMap = {},
	        superInit = self.init,
	        superInitAllContainers = self.initAllContainers,
	        superAddListeners = self.addListeners,
	        superRenderPosition = self.renderPosition,
	        superRefreshData = self.refreshData;
	    
	    self.className("seriesBar");
	    
	    // --------------------------------------------------------------------------
	    //
	    // Attributes
	    //
	    // --------------------------------------------------------------------------
	
	    // ------------------------------
	    // attribute
	    // ------------------------------
	    
	    // --------------------------------------------------------------------------
	    //
	    // override Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    /**
	     * 初始化方法
	     */
	    this.init = function() {
	        superInit();
	        
	        var items = self.data().data;
	        self.visibleItems(items);
	        self.itemsIns = [];
	    };
	    
	    /**
	     * 初始化添加所有监听的方法
	     */
	    this.addListeners = function() {
	        superAddListeners();
	    };
	    
	    /**
	     * 刷新数据内容，生成需要的属性和相关值
	     */
	   this.refreshData = function() {
	   	    superRefreshData();
	        //生成visible属性，默认值为true
	        var items = self.data().data;
	        for(var item, i = 0, len = items.length; i < len; i++) {
	            item = items[i];
	            item.bindKey = i;
	            if(!item.hasOwnProperty("visible")) {
	                item.visible = true;
	            }
	        }
	    };
	    
	    /**
	     * 渲染图表内容相关位置 
	     */
	    this.renderPosition = function() {
	        superRenderPosition();
	        
	        if(self.barContainer) {
	            self.barContainer.renderTransform();
	        }
	    };
	    
	    this.initAllContainers = function() {
	        superInitAllContainers();
	        
	        //放置所有项的g元素
	        if(!self.barContainer) {
	            var barContainer = new BaseComponent();
	            barContainer.className("bar-Container");
	            self.addChild(barContainer);
	            self.barContainer = barContainer;
	        }
	    };
	    
	    /**
	     * 根据当前数据重新渲染内容，并重新计算布局内容
	     */
	    this.update = function(isResize) {
	    	self.refreshData();
	        var items = self.data().data;
	        self.visibleItems(self.filterArrayByElementProperty(items, "visible", true));
	        //计算布局，获取项数据数组
	        self.layout().update(isResize);
	        
	        var barContainer = self.barContainer;
	        
	        //渲染节点
	        var horAxis, verAxis, xScale, yScale, xType, yType, barType, xPadding = 0, yPadding = 0, isAxisUpdate = false;
	        if(self.horAxis()) {
	            horAxis = self.horAxis();
	            xPadding = horAxis.padding();
	            xScale = horAxis.scaleIns();
	            xType = horAxis.type();
	            barType = self.layout().barType();
	            if(xType !== "enum" && barType !== "normal" && barType !== "percentStack") {
	            	isAxisUpdate = true;
	            }
	        }
	        if(self.verAxis()) {
	            verAxis = self.verAxis();
	            yPadding = verAxis.padding();
	            yScale = verAxis.scaleIns();
	            yType = verAxis.type();
	            barType = self.layout().barType();
	            if(!isAxisUpdate && yType !== "enum" && barType !== "normal" && barType !== "percentStack") {
	                isAxisUpdate = true;
	            }
	        }
	        
	        if(isAxisUpdate && self.parent()) {
	            self.parent().isUpdateAxisAgain = true;
	        }
	        
	        var defaultColor = ColorUtil.getColor(self.seriesIndex()),
	            isVer = xType === "enum" && yType !== "enum";
	        barContainer = self.barContainer.mainContainer();
	        self.barContainer.x(xPadding.left);
	        self.barContainer.y(yPadding.top);
	        
	        //根据字典中指定的渲染器数据生成节点渲染器数据
	        var visibleItems = self.visibleItems();
	        for(var d, i = 0, len = visibleItems.length; i < len; i++) {
	            d = visibleItems[i];
	            if(d.legendColor === null || d.legendColor === undefined || d.legendColor === "") {
	                d.legendColor = defaultColor;
	            }
	            self.getRendererConfig(d, "fill");
	        }
	        
	        //render items
	        var diffKey = self.diffKey();
	        var barItemsUpdate = barContainer.selectAll("g.bar-item")
	            .data(visibleItems, self.bindKeyFn);
	        //delete
	        var barItemsExit = barItemsUpdate.exit();
	        barItemsExit.each(function(d) {
	            var key = self.bindKeyFn(d);
	            if(nodesInsMap.hasOwnProperty(key)) {
	                delete nodesInsMap[key];
	            }
	        }).remove();
	        //update
	    	barItemsUpdate.each(function(d) {
	            var key = self.bindKeyFn(d);
	            var ins = nodesInsMap[key];
	            if(ins) {
	                ins.data(d);
	                ins.update();
	                d.ins = ins;
	                d.legendIns = ins;
	            }
	    	});
	    	//add
	    	var barItemsEnter = barItemsUpdate.enter().append("g").attr("class", "bar-item");
	    	barItemsEnter.each(function(d){
	            if(!d.hasOwnProperty("legendColor")) {
	                d.legendColor = defaultColor;
	            }
	            d.startY = verAxis.height();
	            var clazz = d.hasOwnProperty("data") && d.data ? d.data.clazz : (isVer ? "vBarNode" : "hBarNode");
	            var nodeIns = ClassFactory.newNodeInstance(clazz, [d3.select(this), d]);
	            nodeIns.render();
	            d.ins = nodeIns;
	            d.legendIns = nodeIns;
	            var key = self.bindKeyFn(d);
	            nodesInsMap[key] = nodeIns;
	        });
	            
	        self.renderPosition();
	    };
	    
	    /**
	     * override toString方法，用于打印本对象的一些基本信息
	     */
	    this.toString = function() {
	        return ("Bar info: "      +
	                "\n   width:"     + self.width()      + 
	                "\n   height:"    + self.height()     + 
	                "\n   layout:"    + self.layout()     + 
	                "\n   data:"      + JSON.stringify(self.data(), null, 4));
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // listeners
	    //
	    // --------------------------------------------------------------------------
	    
	    // --------------------------------------------------------------------------
	    //
	    // public Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    Bar.clazzName = "Bar";
	    
	    // 初始化
	    self.init();
	};
	
	Bar.struct = function(ghca_charts) {
	    var BaseChart = ghca_charts.view.component.charts.baseChart;
	    BaseChart.struct(ghca_charts);
	    Bar.prototype = Object.create(BaseChart.prototype);
	    Bar.prototype.constructor = Bar;
	};
	
	// --------------------------------------------------------------------------
	//
	// Const
	//
	// --------------------------------------------------------------------------
	
	module.exports = Bar;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {//坐标轴基类
	    
	/**
	 * 构造方法 
	 * @param _parent 坐标轴项所在容器对象
	 * @param _data 坐标轴项数据
	 */
	var BaseAxis = function(_parent, _data) {
	    
	    // --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const ObjectUtil = ghca_charts.view.util.objectUtil;
	    const HorAxis = ghca_charts.view.component.charts.horAxis;
	    const VerAxis = ghca_charts.view.component.charts.verAxis;
	    const SvgUtil = ghca_charts.view.util.svgUtil;
	    const StringUtil = ghca_charts.view.util.stringUtil;
	    const CommonUtil = ghca_charts.view.util.commonUtil;
	
	    if(arguments.length < 2) {
	        throw new Error('传入参数个数错误,当前个数' + arguments.length + ",应至少传入2个参数");
	    }
	    
	    var self = this,
	        defaultPadding = 30,
	        defaultPaddingObj = {
	            left:defaultPadding, 
	            top:defaultPadding, 
	            right:defaultPadding, 
	            bottom:defaultPadding
	        },
	        defaultTickArguments = [], 
	        defaultTickValues = null, 
	        defaultTickFormat = null, 
	        defaultTickSize = 6, 
	        defaultTickSizeInner = 6, 
	        defaultTickSizeOuter = 6, 
	        defaultTickPadding = 3,
	        defaultTick = {
	            tickArguments:defaultTickArguments, 
	            tickValues:defaultTickValues, 
	            tickFormat:defaultTickFormat, 
	            tickSize:defaultTickSize, 
	            tickSizeInner:defaultTickSizeInner, 
	            tickSizeOuter:defaultTickSizeOuter, 
	            tickPadding:defaultTickPadding,
	            show:true,
	            style:{stroke:"#000"}
	        },
	        defaultTickLabel = {style:{fontSize:12, fill:"#000"}},
	        defaultGridLine = {
	            tickLine:{show:false, style:{stroke:"#ccc", strokeWidth:1}},
	            innerLine:{show:false, gapNum:2, style:{stroke:"#eee", strokeWidth:1}}
	        },
	        defaultAxisLabel = {text:"", padding:5, style:{fontSize:12, fill:"#000", textAnchor:"middle"}};
	    
	    // --------------------------------------------------------------------------
	    //
	    // Attributes
	    //
	    // --------------------------------------------------------------------------
	        
	    //------------------------------
	    //  data
	    //------------------------------
	    
	    /**
	     * 坐标轴数据
	     */
	    var data = _data;
	    this.data = function(value) {
	        if (!arguments.length)
	            return data;
	        data = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  type
	    //------------------------------
	    
	    /**
	     * 坐标轴刻度类型 value|time|enum(默认值value)
	     */
	    var type = "value";
	    this.type = function(value) {
	        if (!arguments.length)
	            return type;
	        type = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  x
	    //------------------------------
	    
	    /**
	     * 坐标轴x坐标
	     */
	    var x = 0;
	    this.x = function(value) {
	        if (!arguments.length)
	            return x;
	        x = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  y
	    //------------------------------
	    
	    /**
	     * 坐标轴y坐标
	     */
	    var y = 0;
	    this.y = function(value) {
	        if (!arguments.length)
	            return y;
	        y = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  width
	    //------------------------------
	    
	    /**
	     * 坐标轴宽度
	     */
	    var width = 0;
	    this.width = function(value) {
	        if (!arguments.length)
	            return width;
	        width = value;
	        width=width<0?0:width;
	        return this;
	    };
	    
	    //------------------------------
	    //  height
	    //------------------------------
	    
	    /**
	     * 坐标轴高度
	     */
	    var height = 0;
	    this.height = function(value) {
	        if (!arguments.length)
	            return height;
	        height = value;
	        height=height<0?0:height;
	        return this;
	    };
	    
	    //------------------------------
	    //  position
	    //------------------------------
	    
	    /**
	     * 坐标轴位置 left|right|top|bottom(默认值"")
	     * 
	     */
	    var position = "";
	    this.position = function(value) {
	        if (!arguments.length)
	            return position;
	        position = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  padding
	    //------------------------------
	    
	    /**
	     * 坐标轴距离边界的位置对象,默认值defaultPaddingObj)
	     * 
	     */
	    var padding = defaultPaddingObj;
	    this.padding = function(value) {
	        if (!arguments.length)
	            return padding;
	        padding = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  tick
	    //------------------------------
	    
	    /**
	     * 坐标轴刻度配置对象(默认值defaultTick)
	     * 
	     */
	    var tick = defaultTick;
	    this.tick = function(value) {
	        if (!arguments.length)
	            return tick;
	        tick = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  tickLabel
	    //------------------------------
	    
	    /**
	     * 坐标轴刻度标签配置对象(默认值defaultTickLabel)
	     * 
	     */
	    var tickLabel = defaultTickLabel;
	    this.tickLabel = function(value) {
	        if (!arguments.length)
	            return tickLabel;
	        tickLabel = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  visible
	    //------------------------------
	    
	    /**
	     * 坐标轴是否可见，(默认值true)
	     */
	    var visible = true;
	    this.visible = function(value) {
	        if (!arguments.length) return visible;
	        visible = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  keyPath
	    //------------------------------
	    
	    /**
	     * 针对下面key属性，设置该key所在对象路径，从图表数据本身开始，图表本身数据所在路径为xxx..series[n]，
	     * 要取topo的节点为坐标轴，则这里传"nodes",相当于xxx..series[n].nodes， 
	     * 要取topo的连线为坐标轴，则这里传"links",,相当于xxx..series[n].links，
	     * 若不传，则下面的key就是var array = xxx..series[n];array[n].key(默认值"")
	     */
	    var keyPath = "";
	    this.keyPath = function(value) {
	        if (!arguments.length) return keyPath;
	        keyPath = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  key
	    //------------------------------
	    
	    /**
	     * 用来进行坐标轴项刻度值计算的键名称，比如"level"，(默认值name)
	     */
	    var key = "name";
	    this.key = function(value) {
	        if (!arguments.length) return key;
	        key = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  domain
	    //------------------------------
	    
	    /**
	     * 刻度值范围
	     */
	    var domain = [0, 1];
	    this.domain = function(value) {
	        if (!arguments.length) return domain;
	        domain = StringUtil.parseArray(value);
	        return this;
	    };
	    
	    //------------------------------
	    //  interval
	    //------------------------------
	    
	    /**
	     * 两个数据间隔值，只在type为非enum时有效
	     * 若type为time,则为时间间隔，单位秒；
	     * 若type为value,则为数值间隔；
	     */
	    var interval = NaN;
	    this.interval = function(value) {
	        if (!arguments.length) {
	            return isNaN(interval) ? 0 : interval;
	        }
	        interval = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  scaleIns
	    //------------------------------
	    
	    /**
	     * d3缩放比例实例,如d3.scaleTime()
	     */
	    var scaleIns = null;
	    this.scaleIns = function(value) {
	        if (!arguments.length) return scaleIns;
	        scaleIns = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  axisIns
	    //------------------------------
	    
	    /**
	     * d3坐标轴实例,如d3.axisTop()
	     */
	    var axisIns = null;
	    this.axisIns = function(value) {
	        if (!arguments.length) return axisIns;
	        axisIns = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  gridLine
	    //------------------------------
	    
	    /**
	     * 坐标轴网格配置数据
	     */
	    var gridLine = null;
	    this.gridLine = function(value) {
	        if (!arguments.length) return gridLine;
	        gridLine = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  axisLabel
	    //------------------------------
	    
	    /**
	     * 坐标轴说明标签配置数据
	     */
	    var axisLabel = null;
	    this.axisLabel = function(value) {
	        if (!arguments.length) return axisLabel;
	        axisLabel = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  parentChart
	    //------------------------------
	    
	    /**
	     * 拥有该坐标轴的图表组件实例
	     */
	    var parentChart = null;
	    this.parentChart = function(value) {
	        if (!arguments.length) return parentChart;
	        parentChart = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  isReverse
	    //------------------------------
	    
	    /**
	     * 坐标轴刻度是否倒置显示
	     */
	    var isReverse = false;
	    this.isReverse = function(value) {
	        if (!arguments.length) return isReverse;                
	        isReverse = value;
	        return this;
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // public Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    /**
	     * 刷新传入配置数据到相应坐标轴参数的方法
	     */
	    this.refreshData = function() {
	        var axis = self.data();
	        self.type(axis.hasOwnProperty("type") ? axis.type : "value");
	        self.position(axis.hasOwnProperty("position") ? axis.position : "");
	        self.visible(axis.hasOwnProperty("visible") ? axis.visible : true);
	        self.keyPath(axis.hasOwnProperty("keyPath") ? axis.keyPath : "");
	        self.interval(axis.hasOwnProperty("interval") ? axis.interval : NaN);
	        self.isReverse(axis.hasOwnProperty("isReverse") ? axis.isReverse : false);
	        
	        //parse key
	        if(axis.hasOwnProperty("key") && ObjectUtil.isString(axis.key)) {
	            self.key(axis.key);
	        } else {
	            self.key("name");
	        }
	        
	        //parse padding
	        var newPadding = {left:defaultPadding, top:defaultPadding, right:defaultPadding, bottom:defaultPadding};
	        if(axis.hasOwnProperty("padding") && ObjectUtil.isObject(axis.padding)) {
	        	var padding = axis.padding;
	        	for(var k in newPadding) {
	                if(padding.hasOwnProperty(k))
	                    newPadding[k] = padding[k];
	            }
	        }
	        self.padding(newPadding);
	        
	        //parse tick
	        var newTick = {
	        	tickArguments:defaultTickArguments, 
	            tickValues:defaultTickValues, 
	            tickFormat:defaultTickFormat, 
	            tickSize:defaultTickSize, 
	            tickSizeInner:defaultTickSizeInner, 
	            tickSizeOuter:defaultTickSizeOuter, 
	            tickPadding:defaultTickPadding,
	            show:true,
	            style:{stroke:"#000"}
	        };
	        if(axis.hasOwnProperty("tick") && ObjectUtil.isObject(axis.tick)) {
	            newTick = CommonUtil.createConfig(defaultTick, axis.tick);
	            //tickArguments可识别字符串类型数组
	            var tickArguments = newTick.tickArguments;
	            if(ObjectUtil.isString(tickArguments)) {
	                if(newTick.tickArguments === "") {
	                    newTick.tickArguments = [];
	                } else {
	                    newTick.tickArguments = StringUtil.parseArray(tickArguments);
	                }
	            }
	            //tickValues可识别字符串类型数组
	            var tickValues = newTick.tickValues;
	            if(ObjectUtil.isString(tickValues)) {
	            	if(newTick.tickValues === "") {
	                    newTick.tickValues = null;
	                } else {
	                	newTick.tickValues = StringUtil.parseArray(tickValues);
	                }
	            }
	            //tickFormat可识别字符串类型js代码,字符串里面的引号必须为单引号，比如"d3.timeFormat('%Y-%m-%d %H:%M:%S')(d)"
	            var tickFormat = newTick.tickFormat;
	            if(ObjectUtil.isString(tickFormat)) {
	            	if(tickFormat === "") {
	                    newTick.tickFormat = null;
	                } else {
	                	newTick.tickFormat = function(d) {
	                		try {
	                            return eval(tickFormat);
	                		} catch(e) {
	                            return tickFormat;
	                		}
	                	};
	                }
	            }
	        }
	        self.tick(newTick);
	        
	        //parse tickLabel
	        var newTickLabel = defaultTickLabel;
	        if(axis.hasOwnProperty("tickLabel") && ObjectUtil.isObject(axis.tickLabel)) {
	            newTickLabel = CommonUtil.createConfig(defaultTickLabel, axis.tickLabel);
	        }
	        self.tickLabel(newTickLabel);
	        
	        //parse domain
	        if(axis.hasOwnProperty("domain") && ObjectUtil.isArray(axis.domain)) {
	        	var domain = axis.domain;
	        	if(self.type() === "time") {
	                //时间类型且有时间间隔参数，则最大值再加上一个间隔数值
	                if(self.interval() !== 0) {
	                	var lastIndex = domain.length - 1;
	                	if(domain[lastIndex]) {
	                		var time = domain[lastIndex].getTime();
	                        domain[lastIndex] = new Date(time + self.interval() * 1000);
	                	}
	                }
	            }
	            self.domain(axis.domain);
	        } else {
	        	self.domain([0, 1]);
	        }
	        
	        //parse gridLine
	        var newGridLine = defaultGridLine;
	        if(axis.hasOwnProperty("gridLine") && ObjectUtil.isObject(axis.gridLine)) {
	            var gridLine = axis.gridLine,
	                tickLine = gridLine.tickLine,
	                innerLine = gridLine.innerLine;
	            if(tickLine) {
	                newGridLine.tickLine = CommonUtil.createConfig(defaultGridLine.tickLine, gridLine.tickLine);
	            }
	            if(innerLine) {
	                newGridLine.innerLine = CommonUtil.createConfig(defaultGridLine.innerLine, gridLine.innerLine);
	            }
	        }
	        self.gridLine(newGridLine);
	        
	        //parse axisLabel
	        var newAxisLabel = defaultAxisLabel;
	        if(axis.hasOwnProperty("label") && ObjectUtil.isObject(axis.label)) {
	        	if(self instanceof HorAxis) {
	        		newAxisLabel.pos = "right";
	        	} else {
	        		newAxisLabel.pos = "top";
	        	}
	            if(axis.label) {
	            	newAxisLabel = CommonUtil.createConfig(defaultAxisLabel, axis.label);
	            }
	        }
	        self.axisLabel(newAxisLabel);
	    };
	    
	    this.update = function() {
	    	self.refreshData();
	    	self.renderChildren();
	    };
	    
	    /**
	     * 渲染方法
	     */
	    this.render = function() {
	    	self.refreshData();
	    	self.renderChildren();
	    };
	    
	    this.renderChildren = function() {
	    	//渲染坐标轴
	        self.renderAxis();
	        //设置刻度对应轴线样式
	        self.setTickPathStyle();
	        //设置刻度对应标签样式
	        self.setTickLabelStyle();
	        //渲染坐标轴说明标签
	        self.renderAxisLabel();
	    };
	    
	    /**
	     * 渲染坐标轴
	     */
	    this.renderAxis = function() {
	    	
	    };
	    
	    /**
	     * 渲染坐标轴说明标签
	     */
	    this.renderAxisLabel = function() {
	        
	    };
	    
	    /**
	     * 渲染网格
	     * @rect 网格区域矩形
	     */
	    this.renderGridLine = function(rect) {
	    	if(!self.gridLine().tickLine.show && !self.gridLine().innerLine.show) {
	    		return;
	    	}
	    	
	    	//render grid line container
	        if(!self.gridLineContainer) {
	            self.gridLineContainer = self.axisContainer
	                .insert("g", ":first-child")
	                .attr("class", "gridLine-container");
	        }
	        SvgUtil.removeAllChildren(self.gridLineContainer.node());
	        
	        //render tick line
	        if(self.gridLine().tickLine.show) {
	        	self.renderTickLine(rect);
	        	self.setTickLineStyle();
	        }
	        
	        //render inner line
	        if(self.gridLine().innerLine.show) {
	            self.renderInnerLine(rect);
	            self.setInnerLineStyle(rect);
	        }
	    };
	    
	    /**
	     * 渲染刻度对应网格
	     * @rect 网格区域矩形
	     */
	    this.renderTickLine = function(rect) {
	    	
	    };
	    
	    /**
	     * 渲染刻度间对应网格
	     * @rect 网格区域矩形
	     */
	    this.renderInnerLine = function(rect) {
	        
	    };
	    
	    /**
		 * 设置刻度对应标签样式
		 */
	    this.setTickLabelStyle = function() {
	    	var group = self.axisContainer.selectAll("g.tick text");
	    	var style = self.tickLabel().style;
	    	if(style) {
	    		var fontSize = style.fontSize;
	            if(!fontSize) {
	                fontSize = defaultTickLabel.style.fontSize;
	            }
	            var maxWidth = style.maxWidth;
	            var textLine = style.hasOwnProperty("textLine") ? style.textLine : 1;
	            if(!isNaN(maxWidth)) {
	            	if(maxWidth < 0) {
	            		maxWidth = 0;
	            	}
	            	group.each(function(d){
	                    var text = d3.select(this);
	                    var content = text.text();
	                    var textX = text.attr("x");
	                    textX === null && (textX = 0);
	                    texts = StringUtil.splitByLine(content, maxWidth, fontSize, textLine);
	                    text.text("");
	                    text.selectAll("tspan")
	                        .data(texts)
	                        .enter()
	                        .append("tspan")
	                        .attr("x", textX)
	                        .attr("dy", function(d, i) {
	                        	return self instanceof HorAxis ? 
	                        			"1em" : 
	                    				i === 0 ? ((1 - 0.5 * texts.length) + "em") : "1em";
	                        })
	                        .text(function(d) {
	                            return d;
	                        });
	                    text.append("title").text(content);
	                });
	            }
	            CommonUtil.setGroupStyle(group, style);
	    	}
	    	CommonUtil.setGroupAttr(group, self.tickLabel().attr);
	    };
	    
	    /**
	     * 设置刻度对应轴线样式
	     */
	    this.setTickPathStyle = function() {
	    	var tick = self.tick();
	        var group1 = self.axisContainer.selectAll("g.tick line");
	        group1.style("visibility", self.visible() === false || tick.show === false ? "hidden" : "visible");
	        CommonUtil.setGroupStyle(group1, tick.style);
	        CommonUtil.setGroupAttr(group1, tick.attr);
	        
	        var group2 = self.axisContainer.selectAll("path.domain");
	        group2.style("visibility", self.visible() === false || tick.show === false ? "hidden" : "visible");
	        CommonUtil.setGroupStyle(group2, tick.style);
	        CommonUtil.setGroupAttr(group2, tick.attr);
	    };
	    
	    /**
	     * 设置刻度对应的网格样式
	     */
	    this.setTickLineStyle = function() {
	    	var group = self.axisContainer.selectAll("g.gridLine-container line.tickLine");
	    	CommonUtil.setGroupStyle(group, self.gridLine().tickLine.style);
	    	CommonUtil.setGroupAttr(group, self.gridLine().tickLine.attr);
	    };
	    
	    /**
	     * 设置刻度间对应的网格样式
	     */
	    this.setInnerLineStyle = function() {
	    	var group = self.axisContainer.selectAll("g.gridLine-container line.innerLine");
	        CommonUtil.setGroupStyle(group, self.gridLine().innerLine.style);
	        CommonUtil.setGroupAttr(group, self.gridLine().innerLine.attr);
	    };
	    
	    /**
	     * 设置坐标轴说明标签样式
	     */
	    this.setAxisLabelStyle = function() {
	    	var group = self.axisContainer.selectAll("text.axisLabel");
	        CommonUtil.setGroupStyle(group, self.axisLabel().style);
	        CommonUtil.setGroupAttr(group, self.axisLabel().attr);
	    };
	    
	    /**
	     * 获取刻度坐标数据数组，该数组按升序排序。
	     * 若为水平坐标轴，则格式为[x1,...,xn]；若为垂直坐标轴，则格式为[y1,...,yn]
	     */
	    this.getTicksPos = function() {
	    	
	    };
	    
	    /**
	     * 获取刻度标签字符串数据数组
	     */
	    this.getTicksText = function() {
	    	var result = [];
	    	var texts = self.axisContainer.selectAll("g.tick text title");
	    	if(texts.nodes().length === 0) {
	    		texts = self.axisContainer.selectAll("g.tick text");
	    	}
	    	texts.each(function() {
	    		var text = d3.select(this).text();
	    		result.push(text);
	    	});
	    	return result;
	    }
	    
	    this.toString = function() {
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // private Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    /**
	     * 初始化方法
	     */
	    var init = function() {
	    	//获取渲染容器实例
	        if (typeof(_parent) === 'string') {
	            _parent = document.getElementById(_parent);
	        }
	        if (!_parent) {
	            throw new Error('BaseAxis构造方法中传入的容器_parent:' + _parent + "无法找到。");
	        }
	        self.parent = _parent;
	    };
	    
	    // 初始化
	    init();
	};
	
	BaseAxis.struct = function(ghca_charts) {
	    BaseAxis.prototype.constructor = BaseAxis;
	};
	
	// --------------------------------------------------------------------------
	//
	// Const
	//
	// --------------------------------------------------------------------------
	
	module.exports = BaseAxis;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {/**
	 * 图表基类，所有的图表series元素类都必须继承该基类，一个图表组件组成结构为
	 *          |---继承自baseChart类的series元素(所有的位置变换都是对该元素进行操作)
	 * chart--- |---legend
	 *          |---axis
	 */
		
	/**
	 * 构造方法 
	 * @param _data 图表配置数据
	 * @param _layout 图表布局对象，不传就为默认布局
	 */
	var BaseChart = function(_data, _layout) {
		
		// --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const Layout = ghca_charts.layout.layout;
	    const Const = ghca_charts.view.util.constant;
	    const BaseComponent = ghca_charts.view.component.baseComponent;
	    const TopoLayout = ghca_charts.layout.topoLayout;
	    const TreeLayout = ghca_charts.layout.treelayout;
	    const SankeyLayout = ghca_charts.layout.sankeyLayout;
	    const SunburstLayout = ghca_charts.layout.sunburstLayout;
	    const PackLayout = ghca_charts.layout.packLayout;
	    const PieLayout = ghca_charts.layout.pieLayout;
	    const ScatterLayout = ghca_charts.layout.scatterLayout;
	    const BarLayout = ghca_charts.layout.barLayout;
	    const TreemapLayout = ghca_charts.layout.treemapLayout;
	    const CalendarLayout = ghca_charts.layout.calendarLayout;
	    const ProgressBarLayout = ghca_charts.layout.progressBarLayout;
	    const ObjectUtil = ghca_charts.view.util.objectUtil;
	    const EventUtil = ghca_charts.view.util.eventUtil;
	    const BaseEvent =  ghca_charts.events.BaseEvent;
	
		BaseComponent.apply(this, arguments);
		
	    var self = this, 
	        canDragContent = false,
	        superInit = self.init,
	        superResize = self.resize,
	        superRenderBackground = self.renderBackground,
	        superRenderChildren = self.renderChildren,
	        superAddListeners = self.addListeners;
	
	    self.className("seriesChart");
	    //添加可从配置文件读取的属性名称
	    self.addAttributes("key", "keyPath", "dragable", "diffKey");
	    
	    // --------------------------------------------------------------------------
	    //
	    // Attributes
	    //
	    // --------------------------------------------------------------------------
	    
	    //------------------------------
	    //  visibleItems
	    //------------------------------
	    
	    /**
	     * 该图表可见项数据
	     */
	    var visibleItems = [];
	    this.visibleItems = function(value) {
	        if (!arguments.length) 
	            return visibleItems;
	        visibleItems = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  horAxis
	    //------------------------------
	    
	    /**
	     * 该图表(series chart)对应的水平坐标轴，一个图表(series chart)只能对应一个水平坐标轴
	     */
	    var horAxis = null;
	    this.horAxis = function(value) {
	        if (!arguments.length) 
	            return horAxis;
	        horAxis = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  verrAxis
	    //------------------------------
	    
	    /**
	     * 该图表(series chart)对应的垂直坐标轴，一个图表(series chart)只能对应一个垂直坐标轴
	     */
	    var verAxis = null;
	    this.verAxis = function(value) {
	        if (!arguments.length) 
	            return verAxis;
	        verAxis = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  keyPath
	    //------------------------------
	    
	    /**
	     * 针对下面key属性，设置该key所在对象路径，从图表数据本身开始，图表本身数据所在路径为xxx..series[n]，
	     * 要取topo的节点为图例，则这里传"nodes",相当于xxx..series[n].nodes， 
	     * 要取topo的连线为图例，则这里传"links",,相当于xxx..series[n].links，
	     * 若不传，则下面的key就是var array = xxx..series[n];array[n].key(默认值"")
	     */
	    var keyPath = "";
	    this.keyPath = function(value) {
	        if (!arguments.length) 
	            return keyPath;
	        keyPath = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  key
	    //------------------------------
	    
	    /**
	     * 用来进行图表数据所在键值对的键名称，比如"{values:[data]}"中的values，(默认值"")，
	     * 若不传，则keyPath属性无效，且使用图表数据固定的key值，比如topo数据用nodes和links
	     */
	    var key = "";
	    this.key = function(value) {
	        if (!arguments.length) 
	            return key;
	        key = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  itemRenderer
	    //------------------------------
	    
	    /**
	     * 渲染器键值名称，对应renderers中的键值，若没有设置，则从renderers中随机选择一个作为渲染器
	     */
	    var itemRenderer = "";
	    this.itemRenderer = function(value) {
	        if (!arguments.length) 
	            return itemRenderer;
	        itemRenderer = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  dragable
	    //------------------------------
	    
	    /**
	     * 图表整体内容是否可以通过拖动鼠标移动(默认值true)
	     */
	    var dragable = true;
	    this.dragable = function(value) {
	        if (!arguments.length) 
	            return dragable;
	        dragable = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  seriesIndex
	    //------------------------------
	    
	    /**
	     * 本图表在series chart中的索引值(默认值-1)
	     */
	    var seriesIndex = -1;
	    this.seriesIndex = function(value) {
	        if (!arguments.length) 
	            return seriesIndex;
	        seriesIndex = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  seriesData
	    //------------------------------
	    
	    /**
	     * 本series chart所在chart的series数据
	     */
	    var seriesData = null;
	    this.seriesData = function(value) {
	        if (!arguments.length) 
	            return seriesData;
	        seriesData = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  diffKey
	    //------------------------------
	    
	    /**
	     * 数据差异变化判断依据的属性key
	     */
	    var diffKey = null;
	    this.diffKey = function(value) {
	        if (!arguments.length) 
	            return diffKey;
	        diffKey = value;
	        return this;
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // listeners
	    //
	    // --------------------------------------------------------------------------
	    
	    /**
	     * 图表内容开始拖动平移监听处理方法
	     */
	    this.chartDragStartHandler = function() {
	    	//若鼠标点击到图例项上，则不允许拖动内容
	    	canDragContent = !isLegendItemClick();
	    	if(!canDragContent) {
	    		//抛出图例项鼠标点击事件，若不抛出，则点击事件被chart drag事件覆盖，无法收到点击图例项监听
	            var evt = EventUtil.createEvent("click.legendItem", {bubbles:true, cancelable:true});
	            event.target.parentNode && event.target.parentNode.dispatchEvent(evt);
	    	}
	    };
	    
	    /**
	     * 图表内容拖动平移进行中监听处理方法
	     */
	    this.chartDragHandler = function() {
	    	if(!canDragContent || !self.dragable()) {
	            return;
	        }
	    	var x = self.x(), y = self.y();
	        self.x(x+d3.event.dx);
	        self.y(y+d3.event.dy);
	        self.renderTransform();
	    };
	    
	    /**
	     * 整个图表缩放的监听相关处理方法，鼠标滚轮触发
	     */
	    this.zoomHandler = function() {
	    	var scaleType = self.scaleType();
	    	//判断是否开启缩放功能
	    	if(scaleType === Const.NO_SCALE_TYPE) {
	    		return;
	    	}
	    	//判断是否是对布局关系的缩放
	        var isLayoutZoom = self.scaleType() !== Const.COMPONENT_SCALE_TYPE;
	        if(isLayoutZoom) {
	        	if(self.layout()) {
	        		self.layout().zoom(d3.event.deltaY > 0);
	        	}
	        } else {
	        	self.zoom(d3.event.deltaY > 0);
	        }
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // public Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    /**
	     * 初始化方法
	     */
	    this.init = function() {
	        superInit();
	        
	        self.model = self.layout().model();
	        self.lastX = 0,    //上次鼠标点击的x坐标值
	        self.lastY = 0;    //上次鼠标点击的y坐标值
	    };
	    
	    /**
	     * 初始化布局内容
	     * @param defaultLayout 默认布局类构造器
	     */
	    this.initLayout = function() {
	        //若构造方法没有传入layout实例，则根据传入data信息设置布局，若data中不包括布局信息，则使用默认布局
	        if(!self.layout()) {
	            var layoutData = self.data().layout;
	            if(layoutData) {
	            	//检查外部注册的布局类
	            	var outerPlugins = ghca_charts.global.outerPlugins;
	                var LayoutClass = outerPlugins && outerPlugins.layoutMap && outerPlugins.layoutMap[layoutData.type];
	                if(LayoutClass) {
	                    self.layout(new LayoutClass(self, layoutData));
	                } else {
	                	//若没有查到则检查内部布局类
	                	switch(layoutData.type.toLowerCase()) {
	                        case "topolayout":
	                            self.layout(new TopoLayout(self, layoutData));
	                            break;
	                        case "treelayout":
	                            self.layout(new TreeLayout(self, layoutData));
	                            break;
	                        case "sankeylayout":
	                            self.layout(new SankeyLayout(self, layoutData));
	                            break;
	                        case "pielayout":
	                            self.layout(new PieLayout(self, layoutData));
	                            break;
	                        case "sunburstlayout":
	                            self.layout(new SunburstLayout(self, layoutData));
	                            break;
	                        case "packlayout":
	                            self.layout(new PackLayout(self, layoutData));
	                            break;
	                        case "scatterlayout":
	                            self.layout(new ScatterLayout(self, layoutData));
	                            break;
	                         case "barlayout":
	                            self.layout(new BarLayout(self, layoutData));
	                            break;
	                        case "treemaplayout":
	                            self.layout(new TreemapLayout(self, layoutData));
	                            break;
	                        case "calendarlayout":
	                            self.layout(new CalendarLayout(self, layoutData));
	                            break;
	                        case "progressbarlayout":
	                            self.layout(new ProgressBarLayout(self, layoutData));
	                            break;
	                        default:
	                            self.layout(new Layout(self, layoutData));
	                            break;
	                    }
	                }
	            }
	        }
	    };
	    
	    /**
	     * 初始化图表包含的各个层级
	     */
	    this.initAllContainers = function() {
	    };
	    
	    /**
	     * 初始化添加所有监听的方法
	     */
	    this.addListeners = function() {
	    	superAddListeners();
	    	
	    	//本组件所在的chart是否是某组件的渲染器，若是则不添加缩放和图表类容拖动监听
	    	if(!self.parent() || self.parent().isRenderer()) {
	    		return;
	    	}
	        self.parent().mainContainer().node().addEventListener(BaseEvent.EAGLE_EYE_DRAG,function(e){
	            var detail = e.detail;
	            self.x(detail.x);
	            self.y(detail.y);
	        });
	        //添加缩放监听
	        self.parent().mainContainer().on("wheel", self.zoomHandler);
	        
	        //添加图表内容拖动平移监听
	        self.addDragListeners();
	    };
	    
	    this.addDragListeners = function() {
	    	self.parent().mainContainer().call(d3.drag()
	            .on("start", self.chartDragStartHandler)
	            .on("drag", self.chartDragHandler)
	        );
	    };
	    
	    this.removeDragListeners = function() {
	        self.parent().mainContainer().on("mousedown.drag", null);
	    };
	    
	    /**
	     * 渲染图表组件相对于父容器的位置 
	     */
	    this.renderPosition = function() {
	    	self.renderTransform();
	    };
	    
	//    /**
	//     * 根据当前数据重新渲染内容，并重新计算布局内容
	//     */
	//    this.update = function() {
	//    };
	    
	    /**
	     * 刷新数据内容，生成需要的属性和相关值
	     */
	    this.refreshData = function() {
	    	var data = self.data();
	    	if(!data) {
	    		return;
	    	}
	    	//从配置读取指定的属性值
	    	var attrs = self.attributes();
	    	if(attrs) {
	           for(var key, i = 0, len = attrs.length; i < len; i++) {
	           	    key = attrs[i];
	                if(self.hasOwnProperty(key) && data.hasOwnProperty(key)) {
	                    self[key](data[key]);
	                }
	            }
	        }
	    };
	    
	    //override
	    this.renderBackground = function() {
	    	superRenderBackground();
	    	if(self.bgRect) {
	    		self.bgRect.attr("pointer-events", "none");
	    	}
	    };
	    
	    this.renderChildren = function() {
	        superRenderChildren();
	        
	        //初始化图表包含的各个层级
	        self.initAllContainers();
	        //刷新数据内容，生成需要的属性
	        self.refreshData();
	        //根据当前数据重新布局并且渲染内容
	        self.update();
	    };
	    
	    this.resize = function() {
	        superResize();
	        
	        self.update(true, true);
	    };
	    
	    /**
	     * 刷新某个节点或连线渲染器的配置数据，并放入d.data中
	     * @param d 节点或连线数据
	     * @param colorPropertyName 节点或连线控制渲染颜色的属性名称字符串
	     * @param rendererName 渲染器名称键值，默认"renderer"
	     * @return 返回渲染器的配置数据
	     */
	    this.getRendererConfig = function(d, colorPropertyName, rendererName) {
	        if(!d) {
	            return null;
	        }
	        //只有渲染器是组件且已经有渲染数据的情况下不克隆，若克隆则会把已有渲染器的data数据清除掉，导致无法正常渲染；
	        //若其他普通渲染器必须克隆，否则会导致update时不会更新renderer数据
	        if(d.data && d.data.type && d.data.type === "chart" && d.data.series) {
	        	return d.data;
	        }
	        var rendererConfig = null;
	        var rendererName = rendererName ? rendererName : "renderer";
	        //获取节点渲染器配置，并根据legend组件分配的颜色设置节点填充颜色
	        if(d[rendererName]) {
	            rendererConfig = self.data().renderers[d[rendererName]];
	            if(!rendererConfig) {
	            	return null;
	            }
	        	rendererConfig = ObjectUtil.cloneObj(rendererConfig);
	            //若已分配了图例颜色，则使用该图例颜色渲染
	            if(d.legendColor) {
	                if(rendererConfig.useProperties) {
	                    rendererConfig.useProperties[colorPropertyName] = d.legendColor;
	                } else {
	                    var useProperties = {};
	                    useProperties[colorPropertyName] = d.legendColor;
	                    rendererConfig.useProperties = useProperties;
	                }
	            }
	        }
	        d.data = rendererConfig;
	        return rendererConfig;
	    };
	    
	    /**
	     * 用于绑定数据区别是否变更的属性内容获取方式回调，用于selectAll("").data(data, bindKeyFn);
	     */
	    this.bindKeyFn = function(d) {
	    	var diffKey = self.diffKey();
	    	return (diffKey && d[diffKey]) ? d[diffKey] : d.bindKey;
	    };
	    
	    /**
	     * 用于打印本对象的一些基本信息
	     */
	    this.toString = function() {
	        return ("BaseChart info: " +
	                "\n   width:"     + self.width()      + 
	                "\n   height:"    + self.height()     + 
	                "\n   layout:"    + self.layout()     + 
	                "\n   data:"      + JSON.stringify(this.data(), null, 4));
	    };
	
	    // --------------------------------------------------------------------------
	    //
	    // private Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    /**
	     * 判断当前鼠标点击的是否是图例项
	     */
	    var isLegendItemClick = function() {
	    	var e = (arguments.length > 0 && arguments[0]) || window.event || d3.event;
	        var target = e.target;
	        return target && target.parentNode 
	               && target.parentNode.getAttribute
	               && target.parentNode.getAttribute("class") === "legendItem";
	    };
	    
	    BaseChart.clazzName = "BaseChart";
	};
	
	BaseChart.struct = function(ghca_charts) {
		var BaseComponent = ghca_charts.view.component.baseComponent;
		BaseComponent.struct(ghca_charts);
	    BaseChart.prototype = Object.create(BaseComponent.prototype);
	    BaseChart.prototype.constructor = BaseChart;
	};
	
	module.exports = BaseChart;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {// 业务拓扑图类
	    
	/**
	 * 构造方法 
	 * @param _data 拓扑图配置数据
	 * @param _layout 拓扑图布局对象，不传就为默认布局
	 */
	var BizTopology = function(_data, _layout) {
	    
	    // --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const BaseComponent = ghca_charts.view.component.baseComponent;
	    const BaseChart = ghca_charts.view.component.charts.baseChart;
	    const TopoLayout = ghca_charts.layout.topoLayout;
	    const ClassFactory = ghca_charts.view.util.classFactory;
	    const DataParser = ghca_charts.view.util.dataParser;
	    const Const = ghca_charts.view.util.constant;
	    const ObjectUtil = ghca_charts.view.util.objectUtil;
	    const BaseEvent = ghca_charts.events.BaseEvent;
	    const Node = ghca_charts.view.elements.plugins.nodes.node;
	    const GroupNode = ghca_charts.view.elements.plugins.nodes.groupNode;
	    const math = ghca_charts.view.util.math;
	    const EventUtil = ghca_charts.view.util.eventUtil;
	    const MouseUtil = ghca_charts.view.util.mouseUtil;
	    const RegexUtil = ghca_charts.view.util.regexUtil;
	
	    BaseChart.apply(this, arguments);
	    
	    var self = this,
	        superInit = self.init,
	        superInitAllContainers = self.initAllContainers,
	        superAddListeners = self.addListeners,
	        superRenderPosition = self.renderPosition,
	        superRefreshData = self.refreshData,
	        superSetData = self.setData,
	        isValidateMode = false;
	
	    self.className("seriesTopo");
	    //添加可从配置文件读取的属性名称
	    self.addAttributes("showLevel", "mode", "focusEffect");
	    
	    // --------------------------------------------------------------------------
	    //
	    // Attributes
	    //
	    // --------------------------------------------------------------------------
	
	    // ------------------------------
	    // showLevel
	    // ------------------------------
	    
	    /**
	     * 设置节点显示层级，默认全部节点都显示
	     * (暂时没有实现)
	     */
	    var showLevel = BizTopology.SHOW_ALL_LEVEL_NODES;
	    this.showLevel = function(value) {
	        if (!arguments.length)
	            return showLevel;
	        showLevel = value;
	        if(_data) {
	            _data.showLevel = value;
	        }
	        return this;
	    };
	    
	    // ------------------------------
	    // mode
	    // ------------------------------
	    
	    /**
	     * 组件模式，normal|edit，默认为普通模式
	     */
	    var mode = "normal";
	    this.mode = function(value) {
	        if (!arguments.length)
	            return mode;
	        if(mode !== value) {
	            isValidateMode = true;
	        }
	        mode = value;
	        if(_data) {
	            _data.mode = value;
	        }
	        return this;
	    };
	    
	    // ------------------------------
	    // focusEffect
	    // ------------------------------
	        
	    /**
	     * 鼠标单击节点时，是否显示凸显效果(默认值true)
	     */
	    var focusEffect = true;
	    this.focusEffect = function(value) {
	        if (!arguments.length) return focusEffect;
	        focusEffect = value;
	        if(_data) {
	            _data.focusEffect = value;
	        }
	        return this;
	    };
	    
	    // ------------------------------
	    // isEditMode
	    // ------------------------------
	    
	    /**
	     * 组件是否处于编辑模式，默认为否
	     */
	    this.isEditMode = function() {
	        return mode === "edit";
	    };
	    
	    // ------------------------------
	    // selectedItems
	    // ------------------------------
	    
	    /**
	     * 当前选中的项数据对象数组
	     */
	    var selectedNodeItems = [];
	    this.selectedNodeItems = function(value) {
	        if (!arguments.length)
	            return selectedNodeItems;
	        selectedNodeItems = value;
	        return this;
	    };
	    /**
	     * 当前选中的项数据对象数组
	     */
	    var selectedLinkItems = [];
	    this.selectedLinkItems = function(value) {
	        if (!arguments.length)
	            return selectedLinkItems;
	        selectedLinkItems = value;
	        return this;
	    };
	    /**
	     * 当前选中的项数据对象数组
	     */
	    var selectedGroupItems = [];
	    this.selectedGroupItems = function(value) {
	        if (!arguments.length)
	            return selectedGroupItems;
	        selectedGroupItems = value;
	        return this;
	    };
	
	
	    // --------------------------------------------------------------------------
	    //
	    // override Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    var autoGroupKeys;
	
	    /**
	     * 初始化方法
	     */
	    this.init = function() {
	        superInit();
	        self.layout().init();
	        self.nodes = self.layout().nodes();
	        self.links = self.layout().links();
	
	        self.groups = [];
	        self.nodesIns = [];
	        self.linksIns = [];
	        self.groupsIns = [];
	        autoGroupKeys=self.data().renderers.groupNode&&self.data().renderers.groupNode.autoGroupKeys&&self.data().renderers.groupNode.autoGroupKeys.split(",");//以逗号为分割的属性名，属性值相同的就是一个组     
	        autoGroupKeys=autoGroupKeys?autoGroupKeys:"";
	        //添加初始化数据中的所有节点和连线和节点分组内容
	        self.addNodes(self.data().nodes);
	        self.addLinks(self.data().links);
	        self.addGroups(self.data().groups);
	        self.addAutoGroupNodes(self.data().nodes);
	        
	        self.visibleItems(self.nodes);
	    };
	    
	    /**
	     * 初始化图表包含的各个层级
	     */
	    this.initAllContainers = function() {
	        superInitAllContainers();
	        
	        //放置所有连线节点组背景的g元素
	        var groupsContainer = new BaseComponent();
	        groupsContainer.className("topo-groupsContainer");
	        self.addChild(groupsContainer);
	        groupsContainer.mainContainer().attr("pointer-events", "none");
	        self.groupsContainer = groupsContainer;
	        
	        //放置所有连线的g元素
	        var linksContainer = new BaseComponent();
	        linksContainer.className("topo-linksContainer");
	        self.addChild(linksContainer);
	        self.linksContainer = linksContainer;
	        
	        //放置所有节点的g元素
	        var nodesContainer = new BaseComponent();
	        nodesContainer.className("topo-nodesContainer");
	        self.addChild(nodesContainer);
	        self.nodesContainer = nodesContainer;
	    };
	    
	    /**
	     * 初始化添加所有监听的方法
	     */
	    this.addListeners = function() {
	        superAddListeners();
	        //若点不固定，则添加实时刷新数据监听
	
	        self.model.on("tick", self.tickHandler);
	        self.model.on("end", self.tickEndHandler);
	
	        self.addEventListener(BaseEvent.MODE_CHANGE, modeChangeHandler);
	        //self.addEventListener(BaseEvent.EV_EVENT_OPEN_EDIT, openEditHandler);
	        self.addEventListener(BaseEvent.SEARCH_TEXT, searchTextHandler);
	        self.addEventListener(BaseEvent.TOPO_NODE_FOCUS_IN, topoNodeFocusInHandler);
	        
	        self.mainContainer().node().addEventListener(BaseEvent.EAGLE_EYE_DRAG, function(e) {
	            event.stopImmediatePropagation();
	            var detail = e.detail;
	            self.x(detail.x);
	            self.y(detail.y);
	            self.renderTransform();
	        });
	    };
	    
	    /**
	     * 刷新数据内容，生成需要的属性和相关值
	     */
	   this.refreshData = function() {
	        superRefreshData();
	        var  data = self.data(),
	             nodes = data.nodes,
	             level = self.showLevel();
	        
	        //根据showLevel设置每一个节点是否可见，以及是否展开
	        for(var node, nodeLevel, nodeEnabledExpand, i = 0, len = nodes.length; i < len; i++) {
	            node = nodes[i];
	            if(node.hasOwnProperty("visible")) {
	                continue;
	            }
	            nodeLevel = node.level === undefined ? 0 : node.level;  
	            nodeEnabledExpand = node.enabledExpand === undefined ? false : node.enabledExpand;  
	            if(nodeLevel < level) {
	                node.visible = true;
	                if(nodeEnabledExpand) {
	                    node.isExpanded = true;
	                }
	            } else if(nodeLevel == level) {
	                node.visible = true;
	                if(nodeEnabledExpand) {
	                    node.isExpanded = false;
	                }
	            } else {
	                node.visible = false;
	                if(nodeEnabledExpand) {
	                    node.isExpanded = false;
	                }
	            }
	        }
	    };
	    
	    /**
	     * 渲染图表内容相关位置 
	     */
	    this.renderPosition = function() {
	        superRenderPosition();
	        
	        var nodesIns = self.nodesIns;
	        for(var nodeIns, i = 0, len = nodesIns.length; i < len; i++) {
	            nodeIns = nodesIns[i];
	            nodeIns.mainContainer().each(function(d) {
	               nodeIns.x(Math.round(d.x));
	               nodeIns.y(Math.round(d.y));
	               nodeIns.renderTransform();
	            });
	        }
	        
	        var linksIns = self.linksIns;
	        for(var linkIns, i = 0, len = linksIns.length; i < len; i++) {
	            linkIns = linksIns[i];
	            if(linkIns.normalChild()){
	                linkIns.normalChild().update();
	            } else {
	                linkIns.render();
	            }
	        }
	        
	        //刷新所有节点组path数据
	        refreshGroupsData();
	        var groupsIns = self.groupsIns;
	        for(var groupIns, i = 0, len = groupsIns.length; i < len; i++) {
	            groupIns = groupsIns[i];
	            if(groupIns.normalChild()){
	                groupIns.normalChild().update();
	            } else {
	                groupIns.render();
	            }
	        }
	
	        //触发鹰眼变更
	        self.sendMsgToEye(fireContentChange, 1000);
	    };
	    
	    /**
	     * 根据当前数据重新渲染内容，并重新计算布局内容
	     */
	    this.update = function() {
	        self.refreshData();
	        //只用当前可见的项作为渲染数据源
	        self.visibleItems(self.filterArrayByElementProperty(self.nodes, "visible", true));
	        
	        //计算布局
	        self.layout().update();
	        
	        /*这里先清除所有的连线和节点元素，然后再创建新的数据，否则动态添加的数据显示会有重复的问题。
	                                    但是这样做在ie和edge中会造成闪烁，且效率极低，有待优化。*/
	        var linksContainer = self.linksContainer;
	        linksContainer.removeAllChildren();
	        self.linksIns.length = 0;
	        var nodesContainer = self.nodesContainer;
	        nodesContainer.removeAllChildren();
	        self.nodesIns.length = 0;
	        var groupsContainer = self.groupsContainer;
	        groupsContainer.removeAllChildren();
	        self.groupsIns.length = 0;
	        
	        //只用当前可见的节点作为渲染数据源
	        var nodesData = self.visibleItems();
	        //若节点渲染器是一个组件，则重新设置一些配置数据
	        for(var i = 0, len = nodesData.length; i < len; i++) {
	            var nodeData = nodesData[i];
	            var rendererConfig = self.getRendererConfig(nodeData, "fill");
	            if(rendererConfig && rendererConfig.type === "chart" && rendererConfig.series) {
	                var chartData, series = rendererConfig.series;
	                for(var j = 0, len1 = series.length; j < len1; j++) {
	                    chartData = series[j];
	                    //这里config设置的width和height值无效，渲染器组件宽高为线的高度值
	                    chartData.width = rendererConfig.width ? rendererConfig.width : 0;
	                    chartData.height = rendererConfig.height ? rendererConfig.height : 0;
	                    //pie的位置特殊处理
	                    if(chartData.type === "pie") {
	                        rendererConfig.x = -chartData.width / 2;
	                        rendererConfig.y = -chartData.height / 2;
	                    }
	                    //组装图表数据
	                    DataParser.createChartData(chartData, nodeData);
	                }
	            }
	        }
	        //渲染节点内容
	        var nodesIns = ClassFactory.newRenderersInstanceByData(nodesContainer, self, "nodeContainer", nodesData);
	        if(nodesIns) {
	            for(var nodeIns, i = 0, len = nodesIns.length; i < len; i++) {
	                nodeIns = nodesIns[i];
	                //添加子节点收放按钮点击监听，可控制节点的展开,合拢
	                nodeIns.addEventListener("expandTool_collapsed", expandToolClickHandler);
	                //添加节点单击监听，点击节点自动居中，显示子级节点，淡化其他节点
	                nodeIns.addEventListener("click", nodeClickHandler);              
	                self.nodesIns.push(nodeIns);
	                //添加节点拖拽监听
	                nodeIns.mainContainer().call(d3.drag()
	                    .on("start", self.node_dragStartHandler)
	                    .on("drag", self.node_dragHandler)
	                    .on("end", self.node_dragEndHandler));
	            }
	        }
	        //只用当前可见的连线作为渲染数据源
	        var linksData = self.getVisibleLinks(self.links);
	        //渲染连线内容   
	        var linksIns = ClassFactory.newRenderersInstanceByData(linksContainer, self, "linkContainer", linksData, false, "stroke");
	        if(linksIns) {
	            for(var linkIns, i = 0, len = linksIns.length; i < len; i++) {
	                linkIns = linksIns[i];
	                self.linksIns.push(linkIns);
	            }
	        }
	        
	        //用当前可见的点渲染节点组
	        resetAutoGroups();
	        var groupsData = self.groups;
	        //刷新所有节点组path数据
	        refreshGroupsData();
	        var groupsIns = ClassFactory.newRenderersInstanceByData(groupsContainer, self, "groupContainer", groupsData);
	        if(groupsIns) {
	            for(var groupIns, i = 0, len = groupsIns.length; i < len; i++) {
	                groupIns = groupsIns[i];
	                self.groupsIns.push(groupIns);
	            }
	        }
	        
	        if(self.layout().fixed()) {
	            self.renderPosition();
	        }
	        
	        //等待初始化完成再验证mode是否改变，否则会出现各种问题
	        var timer = setTimeout(function() {
	            clearTimeout(timer);
	            validateMode();
	        }, 0);
	    };
	    
	    /**
	     * 设置数据内容
	     * @param value 数据内容，格式为：{data:[]}或者{nodes:[],links:[]}等
	     * @return 返回是否设置成功
	     */
	    this.setData = function(value) {
	        var result = superSetData(value);
	        
	        self.layout().nodes().length = 0;
	        self.layout().links().length = 0;
	        self.nodes.length = 0;
	        self.links.length = 0;
	        self.groups.length = 0;
	        self.nodesIns.length = 0;
	        self.linksIns.length = 0;
	        self.groupsIns.length = 0;
	        autoGroupKeys=self.data().renderers.groupNode&&self.data().renderers.groupNode.autoGroupKeys&&self.data().renderers.groupNode.autoGroupKeys.split(",");
	        autoGroupKeys=autoGroupKeys?autoGroupKeys:"";
	        //添加初始化数据中的所有节点和连线
	        self.addNodes(self.data().nodes);
	        self.addLinks(self.data().links);
	        self.addGroups(self.data().groups);
	        self.addAutoGroupNodes(self.data().nodes);
	        return result;
	    };
	
	    /**
	     * 刷新节点分组路径数据
	     */
	    var refreshGroupsData = function() {
	        var groupsData = self.groups;
	        for(var groupData, i = 0, len = groupsData.length; i < len; i++) {
	            groupData = groupsData[i];
	            setGroupPath(groupData);
	        }
	    };
	    
	    /**
	     * 设置节点分组路径字符串数据到节点分组数据对象中
	     * @param groupData 节点分组数据对象
	     */
	    var setGroupPath = function(groupData) {
	        //判断整个节点分组是否可见
	        if(groupData.visible === false) {
	            groupData.path = "";
	            groupData.pathPoints = [];
	            return;
	        }
	        var nodesData = groupData.nodes, points = [], 
	        radius = (groupData.data &&　groupData.data.hasOwnProperty("radius")) ?RegexUtil.replace(RegexUtil.dataRegex,groupData.data.radius,groupData): 20, 
	        extendedSize = (groupData.data &&　groupData.data.hasOwnProperty("extendedSize")) ? groupData.data.extendedSize : 10;
	        if(ObjectUtil.isString(radius)&&radius.indexOf("{")!=-1){
	            radius=20;
	        }
	        for(var ins, node, box, halfW, halfH, i = 0, len = nodesData.length; i < len; i++) {
	            node = nodesData[i];
	            if(!node.visible || !node.ins) {
	                continue;
	            }
	            ins = node.ins;
	//            box = ins instanceof BaseComponent ? ins.node().getBBox() : ins.mainPlugin.el.node().getBBox();
	            box = ins instanceof BaseComponent ? ins.node().getBBox() : ins.mainPlugin.getBBox();
	            halfW = box.width/2 + extendedSize;
	            halfH = box.height/2 + extendedSize;
	            points.push([node.x - halfW, node.y - halfH]);
	            points.push([node.x + halfW, node.y - halfH]);
	            points.push([node.x + halfW, node.y + halfH]);
	            points.push([node.x - halfW, node.y + halfH]);
	        }
	        var path = math.pointsToPolygonHullRoundPath(points, radius, false);
	        groupData.path = path;
	        groupData.pathPoints = points;
	    };
	    
	    var addNodeDragListeners = function() {
	        for(var nodeIns, nodesIns = self.nodesIns, i = 0, len = nodesIns.length; i < len; i++) {
	            nodeIns = nodesIns[i];
	            //添加节点拖拽监听
	            nodeIns.mainContainer().call(d3.drag()
	                .on("start", self.node_dragStartHandler)
	                .on("drag", self.node_dragHandler)
	                .on("end", self.node_dragEndHandler));
	        }
	    };
	    
	    var removeNodeDragListeners = function() {
	        for(var nodeIns, nodesIns = self.nodesIns, i = 0, len = nodesIns.length; i < len; i++) {
	            nodeIns = nodesIns[i];
	            //移除节点拖拽监听
	            nodeIns.mainContainer().on("mousedown.drag", null);
	        }
	    };
	    
	    var setListenersInNormal = function() {
	        self.addDragListeners();
	        addNodeDragListeners();
	    };
	    
	    var setListenersInEditLink = function() {
	        self.removeDragListeners();
	        removeNodeDragListeners();
	    };
	    
	    //override
	    this.toJSON = function(isData) {
	        var str = "";
	        var d = self.data();
	        if(!d) {
	            return str;
	        }
	        //清除数据属性节点的内容，然后克隆除数据内容外的配置内容，这样做是因为循环引用在toJson的时候会报错
	        var nodes = d.nodes;
	        var links = d.links;
	        var groups = d.groups;
	        if(nodes) {
	            d.nodes = [];
	        }
	        if(links) {
	            d.links = [];
	        }
	        if(groups) {
	            d.groups = [];
	        }
	        //根据需要的属性复制数据内容，下面是要排除的属性名称数组
	        var nodeKeys = ["collapsed", "data", "ins", "legendIns", "vx", "vy","index","links","cx","cy"];
	        var linkKeys = ["data", "ins","legendIns","lineIndex", "__proto__"];
	        var groupKeys = ["data", "ins","legendIns", "path","pathPoints"];
	        var getData = function(keys, data, isLink) {
	            var result = [];
	            if(isLink) {
	                var d, obj;
	                var  len = data.length;
	                for(i = 0; i < len; i++) {
	                    d = data[i];
	                    obj = {};
	                    result.push(obj);
	                    for(var k in d) {  
	                        if(keys.indexOf(k)==-1){
	                            obj[k]=d[k];
	                            if(k==="source"||k==="target"){
	                                obj[k]=d[k].id;
	                            }
	                        }
	                    }  
	                }
	            } else{
	                for(var d, obj, i = 0, len = data.length; i < len; i++) {
	                    d = data[i];
	                    obj = {};
	                    result.push(obj);
	                    for(var k in d) {  
	                        if(keys.indexOf(k)==-1){
	                            if(k==="nodes"&&keys===groupKeys){
	                                var nodes=d[k];
	                                obj[k]=[];
	                                for(var j=0;j<nodes.length;j++){
	                                    obj[k].push(nodes[j].id);
	                                }
	                            }else{
	                                obj[k]=d[k];
	                            }                           
	
	                        }
	                    }  
	                }
	            }
	            return result;
	        };
	        var cloneData = isData === true ? {} : ObjectUtil.cloneObj(d);
	        cloneData.nodes = getData(nodeKeys, self.nodes);
	        cloneData.links = getData(linkKeys, self.links, true);
	        cloneData.groups = getData(groupKeys, self.groups);
	        //还原数据
	        if(nodes) {
	            d.nodes = nodes;
	        }
	        if(links) {
	            d.links = links;
	        }
	        if(groups) {
	            d.groups = groups;
	        }
	        //把该baseChart的数据转换成json字符串
	        str = JSON.stringify(cloneData);
	        return str;
	    };
	    
	    /**
	     * override toString方法，用于打印本对象的一些基本信息
	     */
	    this.toString = function() {
	        return ("BizTopology info: " +
	                "\n   width:"     + self.width()      + 
	                "\n   height:"    + self.height()     + 
	                "\n   layout:"    + self.layout()     + 
	                "\n   showLevel:" + self.showLevel()  +
	                "\n   data:"      + JSON.stringify(self.data(), null, 4));
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // listeners
	    //
	    // --------------------------------------------------------------------------
	    
	    var searchTextHandler = function(event) {
	        var str = event.detail;
	        var nodes = self.searchNodesByName(str);
	        self.centerNodesAndSelected(nodes, true);
	    };
	    
	    /**
	     * 外部抛事件代码如下:
	     * <code><pre>
	     * const BaseEvent = ghca_charts.events.BaseEvent;
	     * const EventUtil = ghca_charts.view.util.eventUtil;
	     * const evt = EventUtil.createCustomEvent(BaseEvent.TOPO_NODE_FOCUS_IN, true, true, "10.4.42.1");
	     * d3.selectAll("g.seriesTopo").node().dispatchEvent(evt);
	     * </pre></code>
	     */
	    var topoNodeFocusInHandler = function(event) {
	        var id = event.detail;
	        //移动该节点到中心位置并选中，然后突出显示节点
	        self.centerAndFocusInNode(id)
	    };
	    
	    /**
	     * 节点单击事件的监听相关处理方法
	     */
	    var nodeClickHandler = function(event) {
	        if(self.isEditMode() || !self.focusEffect()) {
	            return;
	        }
	        //获取当前双击的节点数据对象
	        var data = d3.select(event.currentTarget).data();
	        if(data.length === 0) {
	            return;
	        }
	        var node = data[0];
	        var nodeIns = node.ins;
	        if(nodeIns && nodeIns.selected()) {
	            //若该节点已经处于选中状态，则取消选选中和聚焦状态
	            self.focusOutAllNodes();
	        } else {
	            //移动该节点到中心位置并选中，然后突出显示节点
	            self.centerAndFocusInNode(node);
	        }
	    };
	    
	    /**
	     * 子节点收放按钮点击事件的监听相关处理方法
	     */
	    var expandToolClickHandler = function(event) {
	        event.stopImmediatePropagation();
	        var node = event.detail;
	        if(!node) {
	            return;
	        }
	        self.expandOrCollapseNodeInUI(node);
	    };
	    
	    /**
	     * 实时更新渲染数据的监听相关处理方法
	     */
	    this.tickHandler = function() {        
	        if(!self.layout().fixed()) {
	            self.renderPosition();
	            self.mainContainer().node().dispatchEvent(EventUtil.createCustomEvent(BaseEvent.EAGLE_EYE_DRAG_CHANGE,true,true,{enable:false}));
	        }       
	    };
	    this.tickEndHandler = function() {
	        if(!self.layout().fixed()) {
	            self.mainContainer().node().dispatchEvent(EventUtil.createCustomEvent(BaseEvent.EAGLE_EYE_DRAG_CHANGE,true,true,{enable:true}));
	        }
	    };
	    
	    /**
	     * 节点开始拖动
	     */
	    this.node_dragStartHandler = function(d) {
	        if(self.layout().fixed()) {
	            d.x = d3.event.x;
	            d.y = d3.event.y;
	            d.fx = d.x;
	            d.fy = d.y;
	            self.renderPosition();
	        } else {
	             if (!d3.event.active) {
	                self.model.alphaTarget(0.3).restart();
	            }
	            d.fx = d.x;
	            d.fy = d.y;
	        }
	    };
	    
	    /**
	     * 节点拖动中
	     */
	    this.node_dragHandler = function(d) {
	        if(self.layout().fixed()) {
	            d.x = d3.event.x;
	            d.y = d3.event.y;
	            d.fx = d.x;
	            d.fy = d.y;
	            self.renderPosition();
	        } else {
	            d.fx = d3.event.x;
	            d.fy = d3.event.y;
	        }
	    };
	    
	    /**
	     * 节点结束拖动
	     */
	    this.node_dragEndHandler = function(d) {
	        if(self.layout().fixed()) {
	            d.x = d3.event.x;
	            d.y = d3.event.y;
	            d.fx = d.x;
	            d.fy = d.y;
	            self.renderPosition();
	        } else {
	            if (!d3.event.active) {
	                self.model.alphaTarget(0);
	            }
	            d.fx = null;
	            d.fy = null;
	        }
	    };
	    
	    /**
	     * 点击保存按钮事件处理方法
	     */
	    var saveBtnClickHandler = function() {
	        //向外部抛出保存数据
	        self.node().dispatchEvent(EventUtil.createCustomEvent(
	           BaseEvent.EV_EVENT_DATA_STORAGE, true, true, {data:self.toJSON(true)}));
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // public Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    /**
	     * 设置传入的对象是否显示选中状态
	     * @param selected 对象是否显示选中状态
	     * @param insArray 要设置的对象数组，若不传则为图表中的所有对象(节点+连线)
	     */
	    this.setSelected = function(selected, insArray) {
	        if(insArray) {
	            for (var i = 0, len = insArray.length; i < len; i++) {
	                insArray[i].selected(selected);
	            }
	        } else {
	            var nodes = self.nodes;
	            for (var i = 0, len = nodes.length; i < len; i++) {
	                nodes[i].ins.selected(selected);
	            }
	            var links = self.links;
	            for (var i = 0, len = links.length; i < len; i++) {
	                links[i].ins.selected(selected);
	            }
	        }
	    };
	    
	    /**
	     * 将当前框选项显示选中效果
	     */
	    this.setSelectedItemsInSelectArea = function() {
	        var rect = self.editCon.mainContainer().select("rect.select");
	        var rectNode = rect.node();
	        if(rectNode) {
	            selectedNodeItems.length = 0;
	            selectedLinkItems.length = 0;
	            selectedGroupItems.length = 0;
	            //选中区域内的所有节点
	            var node, link, ins, insRect, source, target, intersections, isCollision, 
	                nodes = self.nodes, 
	                links = self.links,
	                groups = self.groups,
	                rect = {},
	                selectRect = rectNode.getBBox();
	
	            for (var i = 0, len = nodes.length; i < len; i++) {
	                node = nodes[i];
	                ins = node.ins;
	//                insRect = ins instanceof BaseComponent ? ins.node().getBBox() : ins.mainPlugin.el.node().getBBox();
	                insRect = ins instanceof BaseComponent ? ins.node().getBBox() : ins.mainPlugin.getBBox();
	                //这样重新创建一个对象是因为ie中getBBox()返回的对象属性是只读的
	                rect.x = node.x + insRect.x;
	                rect.y = node.y + insRect.y;
	                rect.width = insRect.width;
	                rect.height = insRect.height;
	                if(math.isCollisionInTwoRects(selectRect, rect)) {
	                    ins.selected(true);
	                    selectedNodeItems.push(node);
	                } else {
	                    ins.selected(false);
	                }
	            }
	            selectedNodeItems.forEach(function(node){
	                groups.forEach(function(g){
	                    if(ObjectUtil.contains(g.nodes,node)&&!ObjectUtil.contains(selectedGroupItems,g)){
	                        selectedGroupItems.push(g);
	                    }
	                });
	            });
	
	            //选中区域内的所有连线
	            var rectPath =  "M"+selectRect.x+","+selectRect.y +
	                            " L"+(selectRect.x+selectRect.width)+","+selectRect.y+
	                            " L"+(selectRect.x+selectRect.width)+","+(selectRect.y+selectRect.height)+
	                            " L"+(selectRect.x)+","+(selectRect.y+selectRect.height) + "Z";
	            for (var i = 0, len = links.length; i < len; i++) {
	                link = links[i];
	                ins = link.ins;
	                source = link.source;
	                target = link.target;
	                //矩形框选区域是否包含该连线
	                if(math.isPointInsideBBox(source.x, source.y, selectRect) && 
	                   math.isPointInsideBBox(target.x, target.y, selectRect)) {
	                    isCollision = true;
	                } else {
	                    //若不包含则判断是否有交点
	                    intersections = Raphael.pathIntersection(ins.el.select("path").attr("d"), rectPath);
	                    if(intersections.length > 0) {
	                        isCollision = true;
	                    } else {
	                        isCollision = false;
	                    }
	                }
	                if(isCollision) {
	                    ins.selected(true);
	                    selectedLinkItems.push(link);
	                } else {
	                    ins.selected(false);
	                }
	            }
	        }
	    };
	    
	    /**
	     * 移动该节点到中心位置并选中，然后突出显示节点
	     * @param arguments[0] 节点id或者节点数据对象
	     */
	    this.centerAndFocusInNode = function() {
	        if(arguments.length === 0) {
	            return;
	        }
	        var node;
	        if(ObjectUtil.isString(arguments[0])) {
	            node = self.findNode(arguments[0]);
	        } else if(ObjectUtil.isObject(arguments[0])) {
	            node = arguments[0];
	        }
	        if(!node) {
	            return;
	        }
	        //移动该节点到中心位置并选中
	        self.centerNodesAndSelected(node);
	        //突出显示节点
	        self.focusInNode(node);
	    };
	    
	    /**
	     * 突出显示节点
	     * @param node 要突出显示的节点数据对象
	     */
	    this.focusInNode = function(node) {
	        if(!node || !node.id) {
	            return;
	        }
	        var i, len, ins, nodeIns, linkIns, groupIns, nodeData, linkData, links, id = node.id, opacity = 0.1, 
	            nodesIns = self.nodesIns, linksIns = self.linksIns, groupsIns = self.groupsIns, insAry = [];
	        var duration = self.animation() ? 300 : 0;
	        //找到目标对象，并淡化所有节点、连线、分组的显示效果
	        for(i = 0, len = nodesIns.length; i < len; i++) {
	            nodeIns = nodesIns[i];
	            nodeIns.mainContainer().attr("opacity", opacity);
	            if(nodeIns.mainContainer().data()[0].id === id) {
	                ins = nodesIns[i];
	            }
	        }
	        for(i = 0, len = linksIns.length; i < len; i++) {
	            linkIns = linksIns[i];
	            linkIns.mainContainer().attr("opacity", opacity);
	        }
	        for(i = 0, len = groupsIns.length; i < len; i++) {
	            groupIns = groupsIns[i];
	            groupIns.mainContainer().attr("opacity", opacity);
	        }
	        //添加要突出显示的对象到数组中
	        nodeData = ins.mainContainer().data()[0];
	        insAry.push(nodeData.ins);
	        links = nodeData.links;
	        if(links) {
	            for(i = 0, len = links.length; i < len; i++) {
	                linkData = links[i];
	                insAry.push(linkData.ins);
	                if(linkData.target && linkData.target.ins) {
	                    insAry.push(linkData.target.ins);
	                }
	                if(linkData.source && linkData.source.ins) {
	                    insAry.push(linkData.source.ins);
	                }
	            }
	        }
	        //突出显示
	        for(i = 0, len = insAry.length; i < len; i++) {
	            ins = insAry[i];
	            if(ins instanceof BaseComponent) {
	                ins = ins.mainContainer();
	            } else {
	                ins = d3.select(ins.el.node().parentNode);
	            }
	            ins && ins.attr("opacity", 1);
	        }
	    };
	    
	    /**
	     * 取消所有节点的突出显示效果
	     */
	    this.focusOutAllNodes = function() {
	        if(!self.nodesIns || !self.linksIns) {
	            return;
	        }
	        var i, len, ins, opacity = 1, nodesIns = self.nodesIns, 
	            linksIns = self.linksIns, groupsIns = self.groupsIns;
	        for(i = 0, len = nodesIns.length; i < len; i++) {
	            ins = nodesIns[i];
	            ins.mainContainer().attr("opacity", opacity);
	        }
	        for(i = 0, len = linksIns.length; i < len; i++) {
	            ins = linksIns[i];
	            ins.mainContainer().attr("opacity", opacity);
	        }
	        for(i = 0, len = groupsIns.length; i < len; i++) {
	            ins = groupsIns[i];
	            ins.mainContainer().attr("opacity", opacity);
	        }
	    };
	    
	    /**
	     * 对传入的节点居中并设置显示选中状态(选中状态根据传入参数设置)
	     * @param arguments[0] 节点数据对象数组或者单个节点数据对象
	     * @param arguments[1] 是否选中传入的节点，默认为否
	     */
	    this.centerNodesAndSelected = function() {
	        var nodes = self.nodes;
	        var isSelect = arguments.length > 1 ? arguments[1] === true : false;
	        //取消所有节点选中状态
	        var nodesIns = [];
	        for (var i = 0, len = nodes.length; i < len; i++) {
	            nodesIns.push(nodes[i].ins);
	        }
	        self.setSelected(false, nodesIns);
	        
	        var ratio = 1, currentX = NaN, currentY = NaN;
	        if (ObjectUtil.isArray(arguments[0])) {//传入参数为数组
	            nodes = arguments[0];
	            if(nodes.length === 0) {
	                return;
	            }
	            //计算搜索结果点外接矩形中心
	            var minX = NaN, minY = NaN, maxX = NaN, maxY = NaN,
	                leftNodeW = NaN, rightNodeW = NaN, topNodeH = NaN, bottomNodeH = NaN;
	            for (var node, nodeIns, i = 0, len = nodes.length; i < len; i++) {
	                node = nodes[i];
	                nodeIns = node.ins;
	                if(isSelect) {
	                    nodeIns.selected(true);
	                }
	                if(isNaN(minX) || node.x < minX) {
	                    minX = node.x;
	                    leftNodeW = nodeIns.actualWidth();
	                }
	                if(isNaN(minY) || node.y < minY) {
	                    minY = node.y;
	                    topNodeH = nodeIns.actualHeight();
	                }
	                if(isNaN(maxX) || node.x > maxX) {
	                    maxX = node.x;
	                    rightNodeW = nodeIns.actualWidth();
	                }
	                if(isNaN(maxY) || node.y > maxY) {
	                    maxY = node.y;
	                    bottomNodeH = nodeIns.actualHeight();
	                }
	            }
	            currentX = (maxX + minX)/2, currentY = (maxY + minY)/2;
	            //搜索结果点外接矩形是否大于图表显示范围，若是则缩小内容
	            var ratioX = 1, ratioY = 1, 
	                areaW = maxX - minX + (leftNodeW + rightNodeW) / 2, 
	                areaH = maxY - minY + (topNodeH + bottomNodeH) / 2;
	            if(areaW > self.width()) {
	                ratioX = self.width() / areaW;
	            }
	            if(areaH > self.height()) {
	                ratioY = self.height() / areaH;
	            }
	            ratio = ratioX > ratioY ? ratioY : ratioX;
	            self.scaleX(ratio);
	            self.scaleY(ratio);
	        } else if(ObjectUtil.isObject(arguments[0])) {//传入参数为单个点
	            var node = arguments[0];
	            var nodeIns = node.ins;
	            if(isSelect) {
	                nodeIns.selected(true);
	            }
	            currentX = node.x;
	            currentY = node.y;
	        }
	        if(isNaN(currentX) || isNaN(currentY)) {
	            return;
	        }
	        
	        //把搜索结果点外接矩形中心点移动到图 表中心位置
	        var x = self.x(), y = self.y(), 
	            moveX = self.width()/2, moveY = self.height()/2;
	        x = (moveX - currentX * self.scaleX()) * self.graph().scaleX();
	        y = (moveY - currentY * self.scaleY()) * self.graph().scaleY();
	        self.x(Math.round(x));
	        self.y(Math.round(y));
	        self.layout().model().stop();
	        var transition = d3.transition().duration(self.animation() ? 500 : 0).ease(d3.easeExpOut);
	        self.renderTransform(transition);
	    };
	    
	    // --------------------------------------------------------------------------
	    // data control
	    // --------------------------------------------------------------------------
	    
	    /**
	     * 增加一个节点 
	     * @param node 节点数据对象
	     */
	    this.addNode = function(node) {
	        self.nodes.push(node);        
	    };
	
	    /**
	     * 批量增加节点 
	     * @param nodes 节点数据对象数组
	     */
	    this.addNodes = function(nodes) {
	        if (ObjectUtil.isArray(nodes)) {
	            for(var i = 0, len = nodes.length; i < len; i++) {
	                self.addNode(nodes[i]);
	            }
	        }
	    };
	
	    this.addAutoGroupNodes = function(nodes) {
	        if (ObjectUtil.isArray(nodes)) {
	            for(var i = 0, len = nodes.length; i < len; i++) {
	                self.addNodeToAutoGroup(nodes[i]);
	            }
	        }
	    };
	
	    /**
	     * 增加一条连线 
	     * @param link 连线数据对象 
	     */
	    this.addLink = function(link) {
	        //寻找该连线起点和终点
	        link.source = self.findNode(link.source);
	        link.target = self.findNode(link.target);
	        var source = link.source, 
	            target = link.target;
	        //寻找具有相同起点和终点的连线，生成lineIndex，并把该连线添加到起点和终点对应的连线数据数组里面
	        if(!source.hasOwnProperty("links")) {
	            source.links = [];
	        }
	        //刷新lineIndex
	        var lineIndex = self.refreshLineIndex(link);
	        link.lineIndex = lineIndex > 0 ? lineIndex : 0;
	        source.links.push(link);
	        if(!target.hasOwnProperty("links")) {
	            target.links = [];
	        }
	        target.links.push(link);
	        self.links.push(link);
	    };
	
	    /**
	     * 批量增加连线 
	     * @param links 连线数据对象数组
	     */
	    this.addLinks = function(links) {
	        if (ObjectUtil.isArray(links)) {
	            for(var i = 0, len = links.length; i < len; i++) {
	                self.addLink(links[i]);
	            }
	        }
	    };
	    
	    /**
	     * 删除节点 
	     * @param node 要删除的节点data
	     */
	    this.removeNode = function(node) {
	        var i = 0,id=node.id, n = self.findNode(id), links = self.links;
	        //删除该节点相关的连线
	        while (i < links.length) {
	            links[i]['source'] === n || links[i]['target'] === n ? links.splice(i, 1) : ++i;
	        }
	        //删除该节点
	        self.nodes.splice(self.findNodeIndex(id), 1);
	        //在所有分组中删除该节点
	        self.removeNodeFromAllGroup(n);
	    };
	    
	    /**
	     * 批量删除节点 
	     * @param ids 要删除的节点id数组
	     */
	    this.removeNodes = function(nodes) {
	        if (ObjectUtil.isArray(nodes)) {
	            for(var i = 0, len = nodes.length; i < len; i++) {
	                self.removeNode(nodes[i]);
	            }
	        }
	    };
	    
	    /**
	     * 删除连线 
	     * @param link 要删除的连线数据对象
	     */
	    this.removeLink = function(link) {
	        //删除连线自身
	        var links = self.links;
	        var index = links.indexOf(link);
	        if(index !== -1) {
	            links.splice(index, 1);
	        }
	        var source = link.source, 
	            target = link.target;
	        //删除连线起点中对应的该连线
	        self.removeLinkFromNode(source, link);
	        //删除连线终点中对应的该连线
	        self.removeLinkFromNode(target, link);
	        //刷新lineIndex
	        self.refreshLineIndex(link);
	    };
	    
	    /**
	     * 批量删除连线 
	     * @param links 要删除的连线数据对象数组
	     */
	    this.removeLinks = function(links) {
	        if (ObjectUtil.isArray(links)) {
	            for(var i = 0, len = links.length; i < len; i++) {
	                self.removeLink(links[i]);
	            }
	        }
	    };
	    
	    /**
	     * 删除节点中对应的连线引用
	     * @param node 包含该连线引用的节点数据对象
	     * @param link 要删除的连线数据对象
	     */
	    this.removeLinkFromNode = function(node, link) {
	        if(node && node.links) {
	            links = node.links;
	            for(var l, i = 0, len = links.length; i < len; i++) {
	                l = links[i];
	                if(l === link) {
	                    links.splice(i, 1);
	                    break;
	                }
	            }
	        }
	    };
	    
	    /**
	     * 删除节点下的子节点，同时清除link信息 
	     * @param id 要删除的节点id
	     */
	    this.removeChildNodes = function(id) {
	        var   node = self.findNode(id), //要删除的节点
	              nodes = self.nodes,       //所有节点
	              link = null,
	              links = self.links,       //所有连线 
	              delateLinks = [],         //要删除的连线索引数组
	              childNodes = [];          //当前节点的所有子节点数组
	
	        //找到所有要删除的连线索引，以及当前节点的所有子节点
	        links.forEach(function(link, index) {
	            //若节点是此条连线的起点
	            if(link['source'] === node) {
	                delateLinks.push(index);
	                childNodes.push(link['target']);
	            }
	        });
	
	        //删除上面找到的所有需要删除的连线
	        delateLinks.reverse().forEach(function(index) {
	            links.splice(index, 1);
	        });
	
	        //迭代删除节点
	        var remove = function(node) {
	            var length = links.length;
	            for (var i = length - 1; i >= 0; i--) {
	                if (links[i]['source'] === node) {
	                    var target = links[i]['target'];
	                    links.splice(i, 1);
	                    nodes.splice(self.findNodeIndex(node.id), 1);
	                    remove(target);
	                }
	            }
	        };
	
	        //删除上面找到当前节点的所有子节点
	        childNodes.forEach(function(node) {
	            remove(node);
	        });
	
	        //清除没有连线的节点
	        for (var i = nodes.length - 1, len = links.length; i >= 0; i--) {
	            var isFoundNode = false;
	            node = nodes[i];
	            for (var j = 0; j < len; j++) {
	                link = links[j];
	                if(link['source'] === node || link['target'] === node) {
	                    isFoundNode = true;
	                }
	            }
	            if(!isFoundNode) {
	                nodes.splice(i, 1);
	            }
	        }
	    };
	
	    /**
	     * 查找节点
	     * @param id 要查找的节点id
	     * @return 返回查找到的节点数据对象，若没有查找到则返回null
	     */
	    this.findNode = function(id) {
	        var nodes = self.nodes;
	        for (var i = 0, len = nodes.length; i < len; i++) {
	            if (nodes[i]['id'] === id)
	                return nodes[i];
	        }
	        return null;
	    };
	
	    /**
	     * 获取LINk
	     * @param id
	     * @returns {*}
	     */
	    this.findLink = function(id) {
	        var links = self.links;
	        for (var i = 0, len = links.length; i < len; i++) {
	            if (links[i]['id'] === id)
	                return links[i];
	        }
	        return null;
	    };
	    
	    /**
	     * 查找节点数据对象所在数组的索引值
	     * @param id 要查找的节点id
	     * @return 返回查找到的节点数据对象所在数组的索引值，若没有查找到则返回-1
	     */
	    this.findNodeIndex = function(id) {
	        var nodes = self.nodes;
	        for (var i = 0, len = nodes.length; i < len; i++) {
	            if (nodes[i]['id'] === id)
	                return i;
	        }
	        return -1;
	    };
	    
	    /**
	     * 刷新变更(添加、删除)目标连线所在的两端点之间的连线的索引值
	     * @param link 变更(添加、删除)目标连线数据对象
	     * @return 返回下一个要添加的连线索引值
	     */
	    this.refreshLineIndex = function(link) {
	        var sourceLink, 
	            lineIndex = 0, 
	            source = link.source, 
	            target = link.target,
	            sourceLinks = source.links;
	        for(var i = 0, len = sourceLinks.length; i < len; i++) {
	            sourceLink = sourceLinks[i];
	            //寻找具有相同节点的连线
	            if((sourceLink.target === source || sourceLink.source === source) && 
	               (sourceLink.target === target || sourceLink.source === target)) {
	                sourceLink.lineIndex = lineIndex;
	                lineIndex++;
	            }
	        }
	        return lineIndex;
	    };
	    
	    /**
	     * 增加一个节点组
	     * @param group 节点数据对象
	     */
	    this.addGroup = function(group) {
	        var nodes = group.nodes;
	        //替换group中的节点id为对应的节点数据对象
	        for (var node, i = 0, len = nodes.length; i < len; i++) {
	            node = self.findNode(nodes[i]);
	            nodes[i] = node;
	        }
	        self.groups.push(group);
	    };
	    
	    /**
	     * 批量增加节点组
	     * @param groups 节点组数据对象数组
	     */
	    this.addGroups = function(groups) {
	        if (ObjectUtil.isArray(groups)) {
	            for(var i = 0, len = groups.length; i < len; i++) {
	                self.addGroup(groups[i]);
	            }
	        }
	    };
	    
	    /**
	     * 删除一个节点组
	     * @param group 节点数据对象
	     */
	    this.removeGroup = function(group) {
	        var groups = self.groups;
	        var index = groups.indexOf(group);
	        if(index !== -1) {
	            //删除该节点组
	            groups.splice(index, 1);
	        }
	    };
	
	    var resetAutoGroups=function(){
	        autoGroupKeys=self.data().renderers.groupNode&&self.data().renderers.groupNode.autoGroupKeys&&self.data().renderers.groupNode.autoGroupKeys.split(",");
	        autoGroupKeys=autoGroupKeys?autoGroupKeys:"";
	        var groups=self.groups;
	        groups.forEach(function(group){
	            if(group.groupKey&&autoGroupKeys.indexOf(group.groupKey)==-1){
	                 self.removeGroup(group);
	            }
	//            //by lizheng 此处分组存在与否，不应与业务逻辑挂钩
	//            else if(group.nodes.length<2){
	//                self.removeGroup(group);
	//            }
	        })
	
	        self.addAutoGroupNodes(self.nodes);
	    }
	
	
	      /**
	     * 添加节点到自动组
	     */
	    this.addNodeToAutoGroup=function(nodeData){
	        var allgroup=self.groups;
	        var num=allgroup.length;
	        var putGkeys=[];
	        for(var i=0;i<num;i++){
	            var group=allgroup[i];
	            var index=autoGroupKeys.indexOf(group.groupKey);
	            if(index!=-1&&group.nodes.length>0&&group.nodes[0][group.groupKey]===nodeData[group.groupKey]){
	                node = self.findNode(nodeData.id);
	                self.addNodeToGroup(node,group);
	                putGkeys.push(group.groupKey);
	            }  
	        }
	
	        var nodes = self.nodes;
	        for(var k=0;k<autoGroupKeys.length;k++){
	            var key=autoGroupKeys[k];
	            var groupIDs=[];
	            if(putGkeys.indexOf(key)===-1){
	                for(var j=0;j<nodes.length;j++){
	                    var gNode=nodes[j];
	                    if(gNode.id!=nodeData.id&&gNode[key]&&nodeData[key]&&gNode[key]===nodeData[key]){
	                        groupIDs.push(gNode.id);
	                    }
	                }
	            }
	            
	            if(groupIDs.length!=0){
	                groupIDs.push(nodeData.id);
	                var data = [{
	                     renderer: "groupNode", 
	                     name: "自动组", 
	                     nodes: groupIDs, 
	                     visible: true,
	                     groupKey:key,
	                     radius:20,
	                     fill:"#e3dec8",
	                     fillOp: 1,
	                     lbBgFill:"#f8f8f8",
	                     lbFill:"#2c2c2c",                     
	                     lbOp:1
	                    }];
	                self.addGroups(data);    
	            }
	        }  
	    }
	    
	    /**
	     * 为指定的节点组中添加一个节点
	     * @param node 要删除的节点
	     * @param group 节点组
	     */
	    this.addNodeToGroup = function(node, group) {
	        if(!group.nodes) {
	            group.nodes = [];
	        }
	        var groupNodes = group.nodes;
	        var index = groupNodes.indexOf(node);
	        if(index === -1) {
	            groupNodes.push(node);
	        }
	    };
	    
	    /**
	     * 从指定的节点组中删除一个节点
	     * @param node 要删除的节点
	     * @param group 节点组
	     */
	    this.removeNodeFromGroup = function(node, group) {
	        var groupNodes = group.nodes;
	        var index = groupNodes.indexOf(node);
	        if(index !== -1) {
	            groupNodes.splice(index, 1);
	        }
	    };
	    
	    /**
	     * 从所有的节点组中删除一个节点
	     * @param node 要删除的节点
	     */
	    this.removeNodeFromAllGroup = function(node) {
	        var groups = self.groups;
	        for(var group, i = 0, len = groups.length; i < len; i++) {
	            group = groups[i];
	            self.removeNodeFromGroup(node, group);
	        }
	    };
	    
	    /**
	     * 根据指定节点的id找到该节点的所有子孙节点
	     * @param id 指定节点的id
	     * @param isAll 是否返回所有子孙节点(无论是否展开)，默认为是，若为false，则只返回展开的子孙节点
	     * @return 返回定节点的所有子孙节点数据对象数组，若没有找到则返回空数组
	     */
	    this.findAllChildNodes = function(id, isAll) {
	        var nodes = [];
	        var node = self.findNode(id);
	        if(!node) return nodes;
	        if(isAll === undefined) {
	            isAll = true;
	        }
	        
	        //有待优化--start
	        var getNode;
	        if(isAll) {
	            getNode = function(nodeId) {
	                self.nodes.forEach(function(node) {
	                    if(node.parentId === nodeId) {
	                        nodes.push(node);
	                        getNode(node.id);
	                    }
	                });
	            };
	            getNode(id);
	        } else {
	            getNode = function(parentNode, isFirst) {
	                var isExpanded = isFirst 
	                    || parentNode.isExpanded === undefined 
	                    || parentNode.isExpanded === true;
	                self.nodes.forEach(function(node) {
	                    if(isExpanded && node.parentId === parentNode.id) {
	                        nodes.push(node);
	                        getNode(node, false);
	                    }
	                });
	            };
	            getNode(node, true);
	        }
	        //有待优化--end
	        
	        return nodes;
	    }
	    
	    /**
	     * 设置指定节点是否可见
	     * @param nodes 要设置的指定节点对象数组
	     * @param visible 设置指定节点是否可见
	     */
	    this.setNodesVisible = function(nodes, visible) {
	        if(!nodes || nodes.length === 0) return;
	        if(visible === undefined)  {
	            visible = true;
	        }
	        for(var i = 0, len = nodes.length; i < len; i++) {
	            nodes[i].visible = visible;
	        }
	    };
	    
	    /**
	     * 展开节点
	     * @param id 要展开的节点id
	     * @param isExpandAll 是否强制展开所有子孙节点，默认为false,
	     * 若为false则原先合拢的子孙节点在父节点展开后保持原有状态；若为true则强制展开所有子孙节点
	     */
	    this.expandNode = function(id, isExpandAll) {
	        var nodes = self.findAllChildNodes(id, isExpandAll === undefined ? false : isExpandAll);
	        self.setNodesVisible(nodes, true);
	    };
	    
	    /**
	     * 合拢节点
	     * @param id 要合拢的节点id
	     */
	    this.collapseNode = function(id) {
	        var nodes = self.findAllChildNodes(id, true);
	        self.setNodesVisible(nodes, false);
	    };
	    
	    /**
	     * 展开或者合拢节点
	     * @param node 当前要展开或者合拢的节点数据对象
	     */
	    this.expandOrCollapseNode = function(node) {
	        if(!node.enabledExpand) {
	            return;
	        }
	        if(node.isExpanded) {
	            self.collapseNode(node.id);
	            node.isExpanded = false;
	        } else {
	            self.expandNode(node.id, false);
	            node.isExpanded = true;
	        }
	    };
	    
	    /**
	     * 从指定的连线数据数组中获取可见的所有连线
	     * @param links 指定的连线数据数组
	     * @return 返回可见的所有连线数组，若没有满足条件的数组，则返回空数组
	     */
	    this.getVisibleLinks = function(links) {
	        var result = [];
	        if(!links || links.length === 0){
	            return result;
	        }
	        var link;
	        for (var i = 0, len = links.length; i < len; i++) {
	            link = links[i];
	            if (link.source.visible && link.target.visible) {
	                if(link.hasOwnProperty("visible")) {
	                    if(link.visible) {
	                        result.push(link);
	                    }
	                } else {
	                    result.push(link);
	                }
	            }
	        }
	        return result;
	    };
	    
	    /**
	     * 根据搜索字符串内容从节点的name属性中搜索匹配的节点，并把所有满足搜索条件的节点数据放入一个数组中
	     * @param str 搜索条件字符串
	     * @return 所有满足搜索条件的节点数据数组，若没有搜索到则返回空数组
	     */
	    this.searchNodesByName = function(str) {
	        var result = [];
	        if(str === undefined || str === null || str.replace(/ /g,'') === "") {
	            return result;
	        }
	        var nodes = self.nodes;
	        for (var node, i = 0, len = nodes.length; i < len; i++) {
	            node = nodes[i];
	            if(node.name.indexOf(str) > -1) {
	                result.push(node);
	            }
	        }
	        return result;
	    }
	    
	    // --------------------------------------------------------------------------
	    //
	    // edit code
	    //
	    // --------------------------------------------------------------------------
	    
	    var drawlinkIns,
	        drawLinkSource,
	        oldDragable = false,
	        selectRectX = 0, 
	        selectRectY = 0;
	        
	    var modeChangeHandler = function(evt) {
	        self.mode((evt || window.event).detail ? "edit" : "normal");
	        validateMode();
	    };
	    
	    /**
	     * 监听外部抛出开启和关闭编辑模式的事件
	     */
	    var openEditHandler = function(evt) {
	        self.mode((evt || window.event).detail.data === true ? "edit" : "normal");
	        validateMode();
	    };
	    
	    var validateMode = function() {
	        if(!isValidateMode) {
	            return;
	        }
	        isValidateMode = false;
	        if(self.isEditMode()) {
	            self.focusOutAllNodes();
	            addEditContainer();
	            setListenersInEditLink();
	            // self.addEventListener(BaseEvent.OPERATION_TYPE, operationChangeHandler);
	            self.addEventListener(BaseEvent.OPEN_FLUX_TYPE, openFluxChangeHandler);
	            self.addEventListener(BaseEvent.OPEN_ALARM_TYPE, openAlarmChangeHandler);
	            // self.addEventListener(BaseEvent.OPERATION_CLEAR, operationClearHandler);
	            self.addEventListener(BaseEvent.ADD_ITEMS, addItemsHandler);
	            self.addEventListener(BaseEvent.REMOVE_ITEMS, removeItemsHandler);
	            // self.addEventListener(BaseEvent.REOMVE_ALL_SELECTED_ITEMS, removeAllSelectedItemsHandler);
	            self.parent().mainContainer().on("mousedown.edit", edit_mouseDownHandler);
	            self.parent().mainContainer().on("mousemove.edit", edit_mouseMoveHandler);
	            self.parent().mainContainer().on("mouseup.edit", edit_mouseUpHandler);
	        } else {
	            removeEditContainer();
	            // self.removeEventListener(BaseEvent.OPERATION_TYPE, operationChangeHandler);
	            // self.removeEventListener(BaseEvent.OPERATION_CLEAR, operationClearHandler);
	            self.removeEventListener(BaseEvent.ADD_ITEMS, addItemsHandler);
	            self.removeEventListener(BaseEvent.REMOVE_ITEMS, removeItemsHandler);
	            // self.removeEventListener(BaseEvent.REOMVE_ALL_SELECTED_ITEMS, removeAllSelectedItemsHandler);
	            // self.parent().mainContainer().on("mousedown.edit", null);
	            self.parent().mainContainer().on("mousedown.edit", null);
	            self.parent().mainContainer().on("mousemove.edit", null);
	            self.parent().mainContainer().on("mouseup.edit", null);
	            setListenersInNormal();
	        }
	    };
	 
	
	    /**
	     * 开启流量
	     * @param event
	     */
	    var openFluxChangeHandler = function(event){
	        if(event.detail){
	            var detail = event.detail;
	            //[{id:1,flux:{}}]
	            var link = self.findLink(detail.id);
	            if(link){
	                link.flux = detail.flux;
	                if(link.ins)
	                    link.ins.render();
	            }
	        }else{
	            self.links.forEach(function(link){
	                delete link.flux;
	                if(link.ins)
	                    link.ins.render();
	            });
	        }
	    }
	
	    /**
	     * 开启告警
	     * @param event
	     */
	    var openAlarmChangeHandler = function(event){
	        if(event.detail){
	            //[{id:1,type:"link/node",value:{}}]
	            var detail = event.detail;
	            switch(detail.type){
	                case "link":{
	                    var link = self.findLink(detail.id);
	                    if(link){
	                        link.value = detail.value;
	                        if(link.ins)
	                            link.ins.render();
	                    }
	                    break;
	                }
	                case "node":{
	                    var node = self.findNode(detail.id);
	                    console.log(node);
	                    if(node){
	                        node.value = detail.value;
	                        console.log(node);
	                        if(node.ins)
	                            node.ins.render();
	                    }
	                    break;
	                }
	            }
	        }else{
	            self.links.forEach(function(link){
	                console.log(link);
	                delete link.value;
	                if(link.ins)
	                    link.ins.render();
	            });
	            self.nodes.forEach(function(node){
	                console.log(node);
	                delete node.value;
	                if(node.ins)
	                    node.ins.render();
	            });
	        }
	    }
	
	    var addItemsHandler = function(event) {
	        var data = event.detail;
	        switch (data.type){
	            case "link":{
	                self.addLinksInUI(data.data)
	                break;
	            }
	            case "group":{
	                self.addGroupsInUI(data.data)
	                break;
	            }
	
	            default:{
	                self.addNodesInUI(data.data);
	                break;
	            }
	
	        }
	    };
	
	
	    var _mouseDownHandler=undefined;
	    this.addMouseDownHandler=function(handler){
	        _mouseDownHandler=handler;
	    }
	    var _mouseMoveHandler=undefined;
	    this.addMouseMoveHandler=function(handler){
	        _mouseMoveHandler=handler;
	    }
	    var _mouseUpHandler=undefined;
	    this.addMouseUpHandler=function(handler){
	        _mouseUpHandler=handler;
	    }
	
	    //缓存 mouse down 响应对象
	    var downTargetD = undefined;
	    var edit_mouseDownHandler = function() {    
	        if(_mouseDownHandler){
	            _mouseDownHandler(self);
	        }    
	        /* if(!operationData)return;
	        var target = d3.event.target;
	        var d = target.__data__;
	        if(d && d.ins) {
	            downTargetD = d;
	        }
	        switch(operationData.type){
	            case "node":{
	                break;
	            }
	            case "delete":{
	                var coordinates  = MouseUtil.mouse(self.mainContainer().node(), self.graph());
	                createSelectRect(coordinates[0], coordinates[1]);
	                break;
	            }
	            case "group":{
	                var coordinates  = MouseUtil.mouse(self.mainContainer().node(), self.graph());
	                createSelectRect(coordinates[0], coordinates[1]);
	                break;
	            }
	            case "link":{
	                endDrawLink();
	                drawLinkSource = undefined;
	                if(downTargetD) {
	                    var ins = downTargetD.ins;
	                    var linkData = {renderer:operationData.renderer, name:"", lineIndex:0, visible:true};
	                    if(ins instanceof Node) {
	                        drawLinkSource = d;
	                        startDrawLink(d.x, d.y, linkData);
	                    }
	                }
	                break;
	            }
	        } */
	    };
	    
	    var edit_mouseMoveHandler = function() {
	        if(_mouseMoveHandler){
	            _mouseMoveHandler(self);
	        }
	        /* if(self.isEditMode()&&drawLinkSource){
	            var coordinates  = MouseUtil.mouse(self.mainContainer().node(), self.graph());
	            drawLink(drawLinkSource.x, drawLinkSource.y, coordinates[0], coordinates[1]);
	        } */
	    };
	    
	    var edit_mouseUpHandler = function() {
	        if(_mouseUpHandler){
	            _mouseUpHandler(self);
	        }
	        
	        /* if(self.isEditMode()){
	            var target = d3.event.target;
	            var coordinates  = MouseUtil.mouse(self.mainContainer().node(), self.graph());
	            var d = target.__data__;
	            var data = {};
	            data.type="mouse_up";
	            data.x = coordinates[0];
	            data.y = coordinates[1];
	            self.node().dispatchEvent(EventUtil.createCustomEvent(BaseEvent.TOPO_EDIT_POSITON,true,true,data));
	        } */
	        
	        /* switch(operationData.type){
	            case "node":{
	                var data = ObjectUtil.cloneObj(operationData);
	                data.x = coordinates[0];
	                data.y = coordinates[1];
	                self.node().dispatchEvent(EventUtil.createCustomEvent(BaseEvent.OPERATION_END,true,true,data));
	                break;
	            }
	            case "group":{
	                self.setSelectedItemsInSelectArea();
	                removeSelectRect();
	                var data = ObjectUtil.cloneObj(operationData);
	                data.items = selectedNodeItems;
	                self.node().dispatchEvent(EventUtil.createCustomEvent(BaseEvent.OPERATION_END,true,true,data));
	                break;
	            }
	            case "link":{
	                var d = target.__data__;
	                if(d && d.ins) {
	                    var ins = d.ins;
	                    if(drawLinkSource && ins instanceof Node && drawLinkSource!==d) {
	                        var data = ObjectUtil.cloneObj(operationData);
	                        data.source = drawLinkSource;
	                        data.target = d;
	                        self.node().dispatchEvent(EventUtil.createCustomEvent(BaseEvent.OPERATION_END,true,true,data));
	                    }
	                }
	                drawLinkSource = null;
	                endDrawLink();
	                break;
	            }
	            case "delete":{
	                var d = target.__data__;
	                if(d && d.ins) {
	                    var ins = d.ins;
	                    if(ins instanceof GroupNode)
	                        selectedGroupItems.push(d);
	                    if(ins instanceof Node)
	                        selectedNodeItems.push(d);
	                }
	                self.setSelectedItemsInSelectArea();
	                removeSelectRect();
	                var data = ObjectUtil.cloneObj(operationData);
	                data.nodeItems = selectedNodeItems;
	                data.linkItems = selectedLinkItems;
	                data.groupItems = selectedGroupItems;
	                self.node().dispatchEvent(EventUtil.createCustomEvent(BaseEvent.OPERATION_END,true,true,data));
	                break;
	            }
	        } */
	    };
	    
	    var removeItemsHandler = function(event) {
	        self.removeAllSelectedInUI();
	    };
	
	    
	    /**
	     * 当处于编辑状态时添加编辑容器
	     */
	    var addEditContainer = function() {
	        var editCon = new BaseComponent();
	        editCon.className("edit-container");
	        editCon.percentWidth(100);
	        editCon.percentHeight(100);
	        self.addChild(editCon);
	        editCon.mainContainer().attr("pointer-events", "none");
	        self.editCon = editCon;
	    };
	    
	    /**
	     * 移除编辑容器
	     */
	    var removeEditContainer = function() {
	        if(self.editCon) {
	            self.removeChild(self.editCon);
	            delete self.editCon;
	        }
	    };
	    
	    /**
	     * 创建框选矩形
	     */
	    this.createSelectRect = function() {
	        if(self.editCon) {
	            var coordinates  = MouseUtil.mouse(self.mainContainer().node(), self.graph());
	            var con = self.editCon.mainContainer();
	            var rect = con.select("rect.select");
	            if(rect.node() === null) {
	                selectRectX = coordinates[0];
	                selectRectY = coordinates[1];
	                con.append("rect")
	                    .attr("class", "select")
	                    .attr("x", selectRectX)
	                    .attr("y", selectRectY)
	                    .attr("stroke", "#0078d7")
	                    .attr("stroke-width", 1)
	                    .attr("fill", "#0078d7")
	                    .attr("fill-opacity", 0.1);
	            }
	        }
	    };
	    
	    /**
	     * 绘制框选矩形
	     */
	    this.drawSelectRect = function() {
	        if(self.editCon) {
	            var con = self.editCon.mainContainer();
	            var rect = con.select("rect.select");
	            if(rect.node()) {
	                var sx, sy, mp = MouseUtil.mouse(self.mainContainer().node(), self.graph());//d3.mouse(con.node());
	                if(mp[0] < selectRectX) {
	                    w = selectRectX - mp[0];
	                    sx = mp[0];
	                } else {
	                    w = mp[0] - selectRectX;
	                    sx = selectRectX;
	                }
	                if(mp[1] < selectRectY) {
	                    h = selectRectY - mp[1];
	                    sy = mp[1];
	                } else {
	                    h = mp[1] - selectRectY;
	                    sy = selectRectY;
	                }
	                rect.attr("x", sx).attr("y", sy)
	                    .attr("width", w).attr("height", h);
	            }
	        }
	    };
	    
	     /**
	     * 移除框选矩形
	     */
	    this.removeSelectRect = function() {
	        if(self.editCon) {
	            self.editCon.mainContainer().select("rect.select").remove();
	        }
	    };
	    
	    /**
	     * 准备开始画连线
	     * @param x1, y1 起点坐标
	     * @param d 连线数据对象
	     */
	    this.startDrawLink = function(x1, y1, d) {
	        // if(!isDrawLink) {
	        //     return;
	        // }
	        d.source = {x:x1, y:y1};
	        d.target = {x:x1+1, y:y1+1};
	        var rendererConfig;
	        //获取节点渲染器配置
	        if(d.renderer) {
	            rendererConfig = self.data().renderers[d.renderer];
	        }
	        drawlinkIns = ClassFactory.newLinkInstance(rendererConfig.clazz, [self.linksContainer.mainContainer(), d]);
	        drawlinkIns.config(rendererConfig.config)
	        drawlinkIns.render();
	    };
	    
	    /**
	     * 画连线
	     * @param x1, y1 起点坐标
	     * @param x2, y2 终点坐标
	     */
	    this.drawLink = function(x1, y1, x2, y2) {
	        if(drawlinkIns) {
	            var d = drawlinkIns.itemData();
	            d.source.x = x1;
	            d.source.y = y1;
	            d.target.x = x2;
	            d.target.y = y2;
	            drawlinkIns.update();
	        }
	    };
	    
	    /**
	     * 结束画连线
	     */
	    this.endDrawLink = function() {
	        // if(!isDrawLink) {
	        //     return;
	        // }
	        if(drawlinkIns) {
	            drawlinkIns.el.remove();
	            drawlinkIns = null;
	        }
	    };
	
	    /**
	     * 增加一个节点界面操作
	     * @param node 节点数据对象
	     */
	    this.addNodeInUI = function(node) {
	        self.addNode(node);
	        self.update();
	    };
	
	    /**
	     * 批量增加节点界面操作 
	     * @param nodes 节点数据对象数组
	     */
	    this.addNodesInUI = function(nodes) {
	        self.addNodes(nodes);
	        self.addAutoGroupNodes(nodes);
	        self.update();
	    };
	
	    /**
	     * 增加一条连线界面操作
	     * @param link 连线数据对象 
	     */
	    this.addLinkInUI = function(link) {
	        self.addLink(link);
	        self.update();
	    };
	
	    /**
	     * 批量增加连线界面操作
	     * @param links 连线数据对象数组
	     */
	    this.addLinksInUI = function(links) {
	        self.addLinks(links);
	        self.update();
	    };
	
	    /**
	     * 批量增加组操作
	     * @param groups 组对象数组
	     */
	    this.addGroupsInUI = function(groups) {
	        self.addGroups(groups);
	        self.update();
	    };
	
	    /**
	     * 批量增加组操作
	     * @param groups 组对象数组
	     */
	    this.removeGroupsInUI = function(groups) {
	        if(!groups.length)return;
	        groups.forEach(function(group){
	            self.removeGroup(group);
	        })
	        self.update();
	    }
	    
	
	    /**
	     * 删除节点界面操作 
	     * @param id 要删除的节点id
	     */
	    this.removeNodeInUI = function(node) {
	        self.removeNode(node);
	        self.update();
	    };
	    
	    /**
	     * 批量删除节点界面操作 
	     * @param ids 要删除的节点id数组
	     */
	    this.removeNodesInUI = function(nodes) {
	        if(!nodes.length)return;
	        self.removeNodes(nodes);
	        self.update();
	    };
	    
	    /**
	     * 删除连线界面操作 
	     * @param link 要删除的连线数据对象
	     */
	    this.removeLinkInUI = function(link) {
	        self.removeLink(link);
	        self.update();
	    };
	    
	    /**
	     * 批量删除连线界面操作 
	     * @param links 要删除的连线数据对象数组
	     */
	    this.removeLinksInUI = function(links) {
	        if(!links.length)return;
	        self.removeLinks(links);
	        self.update();
	    };
	    
	    /**
	     * 批量删除选中节点和连线界面操作 
	     */
	    this.removeAllSelectedInUI = function() {
	        // var plugin, links = [], nodeIds = [];
	        // self.nodesIns.forEach(function(ins) {
	        //     plugin = ins.normalChild();
	        //     if(plugin && plugin.selected()){
	        //         nodeIds.push(plugin.el.data()[0].id);
	        //     }
	        // });
	        // self.linksIns.forEach(function(ins) {
	            // plugin = ins.normalChild();
	        //     if(plugin && plugin.selected()){
	        //      links.push(plugin.el.data()[0]);
	        //     }
	        // });
	        // self.removeNodes(nodeIds);
	        self.removeGroupsInUI(selectedGroupItems);
	        self.removeLinksInUI(selectedLinkItems)
	        self.removeNodesInUI(selectedNodeItems);
	    };
	    
	    /**
	     * 删除节点下的子节点，同时清除link信息界面操作 
	     * @param id 要删除的节点id
	     */
	    this.removeChildNodesInUI = function(id) {
	        self.removeChildNodes(id);
	        self.update();
	    };
	    
	    /**
	     * 展开节点界面操作
	     * @param id 要展开的节点id
	     * @param isExpandAll 是否强制展开所有子孙节点，默认为false,
	     *                    若为false则原先合拢的子孙节点在父节点展开后保持原有状态；若为true则强制展开所有子孙节点
	     */
	    this.expandNodeInUI = function(id, isExpandAll) {
	        self.expandNode(id, isExpandAll);
	        self.update();
	    };
	    
	    /**
	     * 合拢节点界面操作
	     * @param id 要合拢的节点id
	     */
	    this.collapseNodeInUI = function(id) {
	        self.collapseNode(id);
	        self.update();
	    };
	    
	    /**
	     * 展开或者合拢节点界面操作
	     * @param node 当前要展开或者合拢的节点数据对象
	     */
	    this.expandOrCollapseNodeInUI = function(node) {
	        if(!node.enabledExpand) {
	            return;
	        }
	        self.expandOrCollapseNode(node);
	        self.update();
	    };
	    
	    /**
	     * 触发鹰眼变更
	     */
	    function fireContentChange(){
	        self.mainContainer().node().dispatchEvent(EventUtil.createEvent(BaseEvent.CONTENT_CHANGE,true,true));
	    }
	    
	    BizTopology.clazzName = "BizTopology";
	    
	    // 初始化
	    this.init();
	};
	
	BizTopology.struct = function(ghca_charts) {
	    var BaseChart = ghca_charts.view.component.charts.baseChart;
	    BaseChart.struct(ghca_charts);
	    BizTopology.prototype = Object.create(BaseChart.prototype);
	    BizTopology.prototype.constructor = BizTopology;
	};
	
	// --------------------------------------------------------------------------
	//
	// Const
	//
	// --------------------------------------------------------------------------
	
	//显示所有节点
	BizTopology.SHOW_ALL_LEVEL_NODES = 99999;
	
	//显示第一层级所有节点
	BizTopology.SHOW_FIRST_LEVEL_NODES = 0;
	
	module.exports = BizTopology;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {// 日历图类
	    
	/**
	 * 构造方法 
	 * @param _data 日历图配置数据
	 * @param _layout 日历图布局对象，不传就为默认布局
	 */
	var Calendar = function(_data, _layout) {
	    
	    // --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const BaseComponent = ghca_charts.view.component.baseComponent;
	    const BaseChart = ghca_charts.view.component.charts.baseChart;
	    const ClassFactory = ghca_charts.view.util.classFactory;
	    const ColorUtil = ghca_charts.view.util.colorUtil;
	    const StringUtil = ghca_charts.view.util.stringUtil;
	    const ObjectUtil = ghca_charts.view.util.objectUtil;
	    const RegexUtil = ghca_charts.view.util.regexUtil;
	    const CommonUtil = ghca_charts.view.util.commonUtil;
	    const CalendarLayout = ghca_charts.layout.calendarLayout;
	
	    BaseChart.apply(this, arguments);
	    
	    var self = this,
	        isInit = true,
	        superInit = self.init,
	        superInitAllContainers = self.initAllContainers,
	        superAddListeners = self.addListeners,
	        superRenderPosition = self.renderPosition,
	        superRefreshData = self.refreshData,
	        firstDaysMap,
	        defaultMonthBorder = {
	            style:{
	                fill:"none", 
	                stroke: "#000"
	            }
	        },
	        defaultDayBorder = {
	            style:{
	                fill:"none", 
	                stroke: "#ccc"
	            }
	        },
	        defaultYearLabel = {
	            show:true,          //标签是否显示
	            labelFormat:"{v}",  //标签内容
	            padding:5,          //标签和主体内容间隔
	            xPos:"left",        //标签水平位置left|center|right|具体数值
	            yPos:"middle",      //标签垂直位置top|middle|bottom|具体数值
	            rotate:0,           //标签旋转角度
	            style:{             //内容样式，兼容css style
	                fontSize:12, 
	                fontFamily:"sans-serif", 
	                fill:"#000", 
	                textAnchor:"middle"
	            }
	        },
	        defaultMonthLabel = {
	            show:true,              //标签是否显示
	            labelFormat: "{v}月",    //标签内容
	            padding:5,              //标签和主体内容间隔
	            xPos:"center",          //标签水平位置left|center|right|具体数值
	            yPos:"top",             //标签垂直位置top|middle|bottom|具体数值
	            rotate:0,               //标签旋转角度
	            style:{                 //内容样式，兼容css style
	                fontSize:12, 
	                fontFamily:"sans-serif", 
	                fill:"#000", 
	                textAnchor:"middle"
	            }
	        };
	    
	    self.className("seriesCalendar");
	    //添加可从配置文件读取的属性名称
	//    self.addAttributes("attribute");
	
	    // --------------------------------------------------------------------------
	    //
	    // Attributes
	    //
	    // --------------------------------------------------------------------------
	
	    //------------------------------
	    //  yearLabel
	    //------------------------------
	    
	    /**
	     * 年份标签配置数据
	     */
	    var yearLabel = null;
	    this.yearLabel = function(value) {
	        if (!arguments.length) return yearLabel;
	        yearLabel = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  monthLabel
	    //------------------------------
	    
	    /**
	     * 月份标签配置数据
	     */
	    var monthLabel = null;
	    this.monthLabel = function(value) {
	        if (!arguments.length) return monthLabel;
	        monthLabel = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  monthBorder
	    //------------------------------
	    
	    /**
	     * 月份边框配置数据
	     */
	    var monthBorder = null;
	    this.monthBorder = function(value) {
	        if (!arguments.length) return monthBorder;
	        monthBorder = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  dayBorder
	    //------------------------------
	    
	    /**
	     * 日期边框配置数据
	     */
	    var dayBorder = null;
	    this.dayBorder = function(value) {
	        if (!arguments.length) return dayBorder;
	        dayBorder = value;
	        return this;
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // override Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    /**
	     * 初始化方法
	     */
	    this.init = function() {
	        superInit();
	        
	        var items = self.data().data;
	        self.visibleItems(items);
	        self.itemsIns = [];
	    };
	    
	    /**
	     * 初始化图表包含的各个层级
	     */
	    this.initAllContainers = function() {
	        superInitAllContainers();
	        //放置所有项的g元素
	        var itemsContainer = new BaseComponent();
	        itemsContainer.className("calendar-ItemsContainer");
	        self.addChild(itemsContainer);
	        self.itemsContainer = itemsContainer;
	    };
	    
	    /**
	     * 初始化添加所有监听的方法
	     */
	    this.addListeners = function() {
	        superAddListeners();
	    };
	    
	    /**
	     * 刷新数据内容，生成需要的属性和相关值
	     */
	   this.refreshData = function() {
	        superRefreshData();
	        
	        var items = self.data().data;
	        for(var item, i = 0, len = items.length; i < len; i++) {
	            item = items[i];
	            //生成visible属性，默认值为true
	            if(!item.hasOwnProperty("visible")) {
	                item.visible = true;
	            }
	        };
	        
	        var calendar = self.data().calendar;
	        //parse monthBorder
	        var newMonthBorder = defaultMonthBorder;
	        if(calendar && ObjectUtil.isObject(calendar.monthBorder)) {
	            if(calendar.monthBorder) {
	                newMonthBorder = CommonUtil.createConfig(defaultMonthBorder, calendar.monthBorder);
	            }
	        }
	        self.monthBorder(newMonthBorder);
	        
	        //parse dayBorder
	        var newDayBorder = defaultDayBorder;
	        if(calendar && ObjectUtil.isObject(calendar.dayBorder)) {
	            if(calendar.dayBorder) {
	                newDayBorder = CommonUtil.createConfig(defaultDayBorder, calendar.dayBorder);
	            }
	        }
	        self.dayBorder(newDayBorder);
	        
	        //parse yearLabel
	        var newYearLabel = defaultYearLabel;
	        if(calendar && ObjectUtil.isObject(calendar.yearLabel)) {
	            if(calendar.yearLabel) {
	                newYearLabel = CommonUtil.createConfig(defaultYearLabel, calendar.yearLabel);
	            }
	        }
	        self.yearLabel(newYearLabel);
	        
	        //parse monthLabel
	        var newMonthLabel = defaultMonthLabel;
	        if(calendar && ObjectUtil.isObject(calendar.monthLabel)) {
	            if(calendar.monthLabel) {
	                newMonthLabel = CommonUtil.createConfig(defaultMonthLabel, calendar.monthLabel);
	            }
	        }
	        self.monthLabel(newMonthLabel);
	        
	        //parse dayLabel
	    };
	    
	    /**
	     * 根据当前数据重新渲染内容，并重新计算布局内容
	     */
	    this.update = function() {
	        self.refreshData();
	        //只用当前可见的项作为渲染数据源
	        var items = self.data().data;
	        self.visibleItems(self.filterArrayByElementProperty(items, "visible", true));
	        
	        //计算布局，获取项数据数组
	        self.layout().update();
	        
	        //update background
	        updateBackground();
	        
	        //update content cells
	        updateCells();
	        
	        self.renderPosition();
	        
	        isInit = false;
	    };
	    
	    /**
	     * override toString方法，用于打印本对象的一些基本信息
	     */
	    this.toString = function() {
	        return ("Calendar info: "   +
	                "\n   width:"     + self.width()      + 
	                "\n   height:"    + self.height()     + 
	                "\n   layout:"    + self.layout()     + 
	                "\n   data:"      + JSON.stringify(self.data(), null, 4));
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // listeners
	    //
	    // --------------------------------------------------------------------------
	    
	    // --------------------------------------------------------------------------
	    //
	    // private Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    var getTimeDays = function(year) {
	    	var layout = self.layout();
	        var dateRange = layout.mode() === CalendarLayout.MODE_NORMAL ? 
	            layout.getDateRange(year) : 
	            [new Date(year, 0, 1), new Date(year + 1, 0, 1)];
	        return d3.timeDays(dateRange[0], dateRange[1]); 
	    };
	    
	    var getTimeMonths = function(year) {
	        var layout = self.layout();
	        var dateRange = layout.mode() === CalendarLayout.MODE_NORMAL ? 
	            layout.getDateRange(year) : 
	            [new Date(year, 0, 1), new Date(year + 1, 0, 1)];
	        return d3.timeMonths(dateRange[0], dateRange[1]); 
	    };
	    
	    var updateBackground = function() {
	    	 //update background cells
	        updateBgCells();
	        
	        //update background labels
	        updateYearLabel();
	        updateMonthLabel();
	        updateDayLabel();
	    };
	    
	    var updateBgCells = function() {
	    	var cellWidth = self.layout().cellWidth();
	    	var cellHeight = self.layout().cellHeight();
	    	var monthBorder = self.monthBorder();
	    	var dayBorder = self.dayBorder();
	    	
	    	//years
	    	var yearItemsUpdate = self.itemsContainer.mainContainer().selectAll("g.year-item")
	            .data(self.layout().yearsData(), function(d) {
	                return d.year;
	            });
	        //add
	        var addYearItems = yearItemsUpdate.enter().append("g")
	            .attr("class", "year-item")
	            .attr("transform", function(d) {
	                return "translate(" + (-cellWidth*53) + "," + d.y + ")";
	            })
	            .transition()
	            .duration(self.animation() ? 500 : 0)
	            .delay(function (d, i) {
	                return self.animation() ? 100 * i : 0
	            })
	            .attr("transform", function(d) {
	                return "translate(" + d.x + "," + d.y + ")";
	            })
	            .selection();
	        //update
	        yearItemsUpdate.each(function(d){
	            d3.select(this)
	                .transition()
	                .duration(self.animation() ? 500 : 0)
	                .attr("transform", function(d) {
	                    return "translate(" + d.x + "," + d.y + ")";
	                });
	        });
	        
	        //days
	        firstDaysMap = {};
	        var addDayConItems = addYearItems.append("g").attr("class", "days-con");
	        var dayItemsUpdate = self.itemsContainer.mainContainer().selectAll("g.days-con")
	            .selectAll("g.day-itemCon")
	            .data(function(d) {
	            	var days = getTimeDays(d.year);
	            	firstDaysMap[d.year] = days[0];
	                return days; 
	            }, function(d) {
	                return d.toString(); 
	            });
	        //add    
	        var addDayItems = dayItemsUpdate.enter().append("g").attr("class", "day-itemCon")
	            .attr("transform", function(d) {
	            	var tx = d3.timeWeek.count(firstDaysMap[d.getFullYear()], d) * cellWidth;
	            	var ty = d.getDay() * cellHeight;
	                return "translate(" + tx + "," + ty + ")";
	            })
	            .append("rect").attr("class", "day-item-bg")
	            .attr("width", cellWidth)
	            .attr("height", cellHeight);
	        CommonUtil.setGroupStyle(addDayItems, dayBorder.style);
	        CommonUtil.setGroupAttr(addDayItems, dayBorder.attr);
	        //update
	        var dayItems = dayItemsUpdate.transition()
	            .duration(self.animation() ? 500 : 0)
	            .attr("transform", function(d) {
	                var tx = d3.timeWeek.count(firstDaysMap[d.getFullYear()], d) * cellWidth;
	                var ty = d.getDay() * cellHeight;
	                return "translate(" + tx + "," + ty + ")";
	            })
	            .selectAll("rect.day-item-bg")
	            .attr("width", cellWidth)
	            .attr("height", cellHeight)
	            .selection();
	        CommonUtil.setGroupStyle(dayItems, dayBorder.style);
	        CommonUtil.setGroupAttr(dayItems, dayBorder.attr);
	        lastGroup = null;
	        //delete
	        var dayItemsExit = dayItemsUpdate.exit();
	        dayItemsExit.remove();
	        
	        
	        //months
	        var addMonthConItem = addYearItems.append("g").attr("class", "months-con");
	        var monthItemsUpdate = self.itemsContainer.mainContainer().selectAll("g.months-con")
	            .selectAll("g.month-item")
	            .data(function(d) { 
	                return getTimeMonths(d.year);
	            }, function(d) {
	                return d.toString(); 
	            });
	        //add   
	        var addMonthItems = monthItemsUpdate.enter()
	            .append("g")
	            .attr("class", "month-item")
	            .append("path")
	            .attr("d", pathMonth);
	        CommonUtil.setGroupStyle(addMonthItems, monthBorder.style);
	        CommonUtil.setGroupAttr(addMonthItems, monthBorder.attr);
	        //update
	        var monthItems = monthItemsUpdate.each(function(d) {
	            d3.select(this).selectAll("path").attr("d", pathMonth);
	        }).select("path");
	        CommonUtil.setGroupStyle(monthItems, monthBorder.style);
	        CommonUtil.setGroupAttr(monthItems, monthBorder.attr);
	        //delete
	        var monthItemsExit = monthItemsUpdate.exit();
	        monthItemsExit.remove();
	            
	        //delete
	        var yearItemsExit = yearItemsUpdate.exit();
	        yearItemsExit.remove();
	    };
	    
	    var updateYearLabel = function() {
	    	var yearLabel = self.yearLabel();
	    	var yearItems = self.itemsContainer.mainContainer().selectAll("g.year-item");
	    	var show = yearLabel.show === true;
	    	if(!show) {
	    		yearItems.selectAll("text.year-label").remove();
	    	} else {
	    		yearItems.each(function(d) {
	    			var parent = d3.select(this);
	    			var label = parent.select("text.year-label");
	    			if(!label.node()) {
	    				label = parent.append("text").attr("class", "year-label");
	    			}
	    			var text = getResultLabel(yearLabel.labelFormat, d.year, d.year, self.visibleItems(),d);
	    			label.text(text);
	    			CommonUtil.setGroupStyle(label, yearLabel.style);
	    			CommonUtil.setGroupAttr(label, yearLabel.attr);
	    			
	    			//计算布局
	                var x = 0,
	                    y = 0,
	                    xPos = yearLabel.xPos,
	                    yPos = yearLabel.yPos,
	                    padding = yearLabel.padding,
	                    rotate = yearLabel.rotate,
	                    parentBox = parent.select("g.days-con").node().getBBox(),
	                    parentW = parentBox.width,
	                    parentH = parentBox.height,
	                    labelBox = label.node().getBBox(),
	                    labelW = labelBox.width,
	                    labelH = labelBox.height;
	                //计算水平定位
	                if(!isNaN(xPos)) {
	                    x = xPos;
	                } else if(xPos === "left") {
	                    x = -labelW/2 - padding;
	                } else if(xPos === "right")  {
	                    x = parentW + labelW/2 + padding;
	                } else {//default center
	                    x = parentW / 2;
	                }
	                
	                //计算垂直定位
	                if(!isNaN(yPos)) {
	                    y = yPos;
	                } else if(yPos === "middle") {
	                    y = parentH/2;
	                } else if(yPos === "bottom")  {
	                    y = parentH + labelH/2 + padding;
	                } else {//defult top
	                    y = -labelH/2 - padding;
	                }
	                
	                label.transition().duration(self.animation() ? 500 : 0).delay(self.animation() ? 200 : 0)
	                    .attr("transform", "translate(" + x + "," + y + ")rotate(" + rotate + ")");
	    		});
	    	}
	    };
	    
	    var updateMonthLabel = function() {
	    	var cellWidth = self.layout().cellWidth();
	        var cellHeight = self.layout().cellHeight();
	        var monthLabel = self.monthLabel();
	        var monthItems = self.itemsContainer.mainContainer().selectAll("g.month-item");
	        var show = monthLabel.show === true;
	        if(!show) {
	            monthItems.selectAll("text.month-label").remove();
	        } else {
	            monthItems.each(function(d) {
	            	var monthItem = d3.select(this);
	                var monthPath = monthItem.select("path");
	                var label = monthItem.select("text.month-label");
	                if(!label.node()) {
	                    label = monthItem.append("text").attr("class", "month-label");
	                }
	                var month = new Date(d).getMonth() + 1;
	                var text = getResultLabel(monthLabel.labelFormat, month, month, self.visibleItems(), d);
	                label.text(text);
	                CommonUtil.setGroupStyle(label, monthLabel.style);
	                CommonUtil.setGroupAttr(label, monthLabel.attr);
	                
	                //计算布局
	                var x = 0,
	                    y = 0,
	                    xPos = monthLabel.xPos,
	                    yPos = monthLabel.yPos,
	                    padding = monthLabel.padding,
	                    rotate = monthLabel.rotate,
	                    pathBox = monthPath.node().getBBox(),
	                    pathW = pathBox.width,
	                    pathH = pathBox.height,
	                    pathX = pathBox.x,
	                    pathY = pathBox.y,
	                    labelBox = label.node().getBBox(),
	                    labelW = labelBox.width,
	                    labelH = labelBox.height;
	                //计算水平定位
	                if(!isNaN(xPos)) {
	                    x = xPos;
	                } else if(xPos === "left") {
	                    x = labelW/2 + padding + pathX;
	                } else if(xPos === "right")  {
	                    x = pathW - labelW/2 - padding + pathX;
	                } else {//default center
	                    x = pathW / 2 + pathX;
	                }
	                
	                var yDiff = 2;
	                //计算垂直定位
	                if(!isNaN(yPos)) {
	                    y = yPos;
	                } else if(yPos === "middle") {
	                    y = pathH/2 + labelH/2 + pathY;
	                } else if(yPos === "bottom")  {
	                    y = pathH + labelH + padding + pathY - yDiff;
	                } else {//defult top
	                    y = pathY - padding - yDiff;
	                }
	                
	                label.transition().duration(self.animation() ? 500 : 0).delay(self.animation() ? 200 : 0)
	                    .attr("transform", "translate(" + x + "," + y + ")rotate(" + rotate + ")");
	            });
	        }
	    };
	    
	    var updateDayLabel = function() {
	    };
	    
	    var updateCells = function() {
	        var visibleItems = self.visibleItems();
	        var itemMap = {};
	        var dateKey = self.layout().dateKey();
	        var cellWidth = self.layout().cellWidth();
	        var cellHeight = self.layout().cellHeight();
	        var timeFormatFn = d3.timeFormat("%Y-%m-%d");
	        
	        //获取节点渲染器配置，并根据legend组件分配的颜色设置节点填充颜色,若没有legend相关配置，则组件始终强制使用自动生成的颜色填充
	        for(var d, i = 0, len = visibleItems.length; i < len; i++) {
	            d = visibleItems[i];
	            if(d.legendColor === null || d.legendColor === undefined || d.legendColor === "") {
	                d.legendColor = ColorUtil.getColor(i);
	            }
	            var config = self.getRendererConfig(d, "fill");
	            itemMap[d[dateKey]] = d;
	        }
	        
	        var renderItems = d3.selectAll("g.day-itemCon").filter(function(d) { 
	            return timeFormatFn(d) in itemMap; 
	        });
	        
	        //render node items
	        renderItems.each(function(d) {
	        	var data = itemMap[timeFormatFn(d)];
	        	data.x = 0;
	        	data.y = 0;
	        	data.width = cellWidth;
	        	data.height = cellHeight;
	            var itemsUpdate = d3.select(this).selectAll("g.day-item")
	                .data([data], function(d) {
	                    return d[dateKey];
	                });
	            //update
	            itemsUpdate.each(function(d){
	                d.ins && d.ins.update(true);
	            });
	            //add
	            var itemsEnter = itemsUpdate.enter().append("g").attr("class", "day-item");
	            itemsEnter.each(function(d){
	                var clazz = d.hasOwnProperty("data") && d.data ? d.data.clazz : "rectShape";
	                var nodeIns = ClassFactory.newNodeInstance(clazz, [d3.select(this), d]);
	                nodeIns.isChartFirstInit && nodeIns.isChartFirstInit(isInit);
	                nodeIns.graph && nodeIns.graph(self.graph());
	                nodeIns.render();
	                d.ins = nodeIns;
	                d.legendIns = d3.select(this);
	            });
	        });
	        
	        //delete
	        var exitItems = d3.selectAll("g.day-item").filter(function(d) { 
	            return !(d[dateKey] in itemMap); 
	        }).remove();
	    };
	    
	    var pathMonth = function(t0) {
	    	var cellWidth = self.layout().cellWidth();
	    	var cellHeight = self.layout().cellHeight();
	    	var year = t0.getFullYear();
	    	var firstDay = firstDaysMap[year];
	        var t1 = new Date(year, t0.getMonth() + 1, 0),
	            d0 = t0.getDay(), w0 = d3.timeWeek.count(firstDay, t0),
	            d1 = t1.getDay(), w1 = d3.timeWeek.count(firstDay, t1);
	        return "M" + (w0 + 1) * cellWidth + "," + d0 * cellHeight
	            + "H" + w0 * cellWidth + "V" + 7 * cellHeight
	            + "H" + w1 * cellWidth + "V" + (d1 + 1) * cellHeight
	            + "H" + (w1 + 1) * cellWidth + "V" + 0
	            + "H" + (w0 + 1) * cellWidth + "Z";
	    };
	    
	    /**
	     * 根据labelFormat获取最终label的方法
	     * @param label labelFormat
	     * @param value 替换内容，支持{#script#},其中script为js脚本内容；支持{v},相当于{#d[key]#}
	     * @param defaultResult 默认最终label
	     * @param data 所有项数据
	     * @param d 当前项数据
	     */
	    var getResultLabel = function(label, value, defaultResult, data, d) {
	        if(!label) {
	            return defaultResult;
	        }
	        var result = label.replace(/{v}/ig, value);
	        return result.replace(RegexUtil.jsRegex, function() {
	            return arguments.length > 1 ? eval(arguments[1]) : "";
	        });
	    };
	    
	    Calendar.clazzName = "Calendar";
	    
	    // 初始化
	    self.init();
	};
	
	Calendar.struct = function(ghca_charts) {
	    var BaseChart = ghca_charts.view.component.charts.baseChart;
	    BaseChart.struct(ghca_charts);
	    Calendar.prototype = Object.create(BaseChart.prototype);
	    Calendar.prototype.constructor = Calendar;
	};
	
	module.exports = Calendar;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {/**
	 * 图表组件类，包括多个series实例，一个图表组件组成结构为
	 *          |---继承自baseChart类的series元素(所有的位置变换都是对该元素进行操作)
	 * chart--- |---legend
	 *          |---axis
	 */
		
	/**
	 * 构造方法 
	 * @param _data 图表配置数据
	 * @param _layout 图表布局对象，不传就为默认布局
	 */
	var Chart = function(_data, _layout) {
		
		// --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const BaseComponent = ghca_charts.view.component.baseComponent;
	    const SvgUtil = ghca_charts.view.util.svgUtil;
	    const Legend = ghca_charts.view.component.charts.legend;
	    const Heading = ghca_charts.view.component.charts.heading;
	    const Axis = ghca_charts.view.component.charts.axis;
	    const BaseChart = ghca_charts.view.component.charts.baseChart;
	    const ClassFactory = ghca_charts.view.util.classFactory;
	    const BaseEvent = ghca_charts.events.BaseEvent;
	    const ObjectUtil = ghca_charts.view.util.objectUtil;
	    const EventUtil = ghca_charts.view.util.eventUtil;
	    const RegexUtil = ghca_charts.view.util.regexUtil;
	    const ElementUtil = ghca_charts.view.util.elementUtil;
	    const MouseUtil = ghca_charts.view.util.mouseUtil;
	    const Label = ghca_charts.view.elements.plugins.label.label;
	    const CommonUtil = ghca_charts.view.util.commonUtil;
	    const Global = ghca_charts.global;
	    
	    BaseComponent.apply(this, arguments);
	    
	    var firstHorAxis, firstVerAxis, ticksPos, ticksText, axisHotBox,
	        self = this,
	        superResize = self.resize,
	        superUpdate = self.update,
	        superRenderChildren = self.renderChildren,
	        superAddListeners = self.addListeners,
	        superRenderDefsElements = self.renderDefsElements,
	        formatTime = d3.timeFormat('%Y-%m-%d'),
	        formatDateTime = d3.timeFormat('%Y-%m-%d %H:%M:%S'),
	        visibleItems = [],
	        visibleItemsChanged = true,
	        isHorAxisTime = false,
	        isHorAxisEnum = false,
	        scaleQuantize = d3.scaleQuantize();
	        
	    self.className("chart");
	    
	    // --------------------------------------------------------------------------
	    //
	    // Attributes
	    //
	    // --------------------------------------------------------------------------
	    
	    //------------------------------
	    //  headings
	    //------------------------------
	    
	    /**
	     * 图表标题对象数组
	     */
	    var headings = [];
	    this.headings = function(value){
	        if (!arguments.length) return headings;
	        headings = value;
	        return this;
	    };
	        
	    //------------------------------
	    //  legend
	    //------------------------------
	    
	    /**
	     * 图例对象
	     */
	    var legend = null;
	    this.legend = function(value){
	        if (!arguments.length) return legend;
	        legend = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  axis
	    //------------------------------
	    
	    /**
	     * 坐标轴对象
	     */
	    var axis = null;
	    this.axis = function(value){
	        if (!arguments.length) return axis;
	        axis = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  toolTip
	    //------------------------------
	    
	    /**
	     * 悬浮提示框对象
	     */
	    var toolTip = null;
	    this.toolTip = function(value){
	        if (!arguments.length) return toolTip;
	        toolTip = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  isDispatchSliderChange
	    //------------------------------
	    
	    /**
	     * 当slider选择范围改变时是否抛出事件
	     */
	    var isDispatchSliderChange = false;
	    this.isDispatchSliderChange = function(value){
	        if (!arguments.length) return isDispatchSliderChange;
	        isDispatchSliderChange = value;
	        return this;
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // public Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    /**
	     * 渲染图表系列内容
	     * @param series 数据系列，一个图表可能包含多个系列，每一个系列可能包含多个数据，即config.series
	     */
	    this.renderSeries = function(parent, series) {
	        if(Global.isDebug) {
	            console.log("Graph.renderSeries()");
	        }
	        for(var i = 0, len = series.length; i < len; i++) {
	            self.renderSeriesChart(parent, series, i);
	        }
	    };
	
	    /**
	     * 渲染series中单个图表内容，一个图表组件至少有一个series元素
	     * @param series 多个个图表数据，即chart.series
	     * @param index 当前图表在series中的索引值
	     */
	    this.renderSeriesChart = function(parent, series, index) {
	        var chartData = series[index];
	        if(Global.isDebug) {
	            console.log("Graph.renderSeriesChart(), type is " + chartData.type);
	        }
	        var chart = ClassFactory.newChartInstance(chartData.type, [chartData, null]);
	        if(!chart) {
	            throw new Error('当前传入的图表类型' + chart.type + "尚未支持。");
	        }
	        //设置当前图表在series中的索引值，以及series数据
	        chart.seriesIndex(index);
	        chart.seriesData(series);
	        //根据配置信息设置图表关联的坐标轴
	        self.setAxisForSeriesCharts(chart, chartData);
	        
	        parent.addChild(chart);
	        
	        return chart;
	    };
	    
	    /**
	     * 渲染子组件级别的plugin数组数据中的所有元素
	     * @param parent 父容器
	     * @param config 整体渲染配置数据
	     */
	    this.renderPlugins = function(parent, config) {
	        var plugins = config.plugins;
	        if(!plugins || plugins.length === 0) {
	            return;
	        }
	        if(Global.isDebug) {
	            console.log("Graph.renderPlugins()");
	        }
	        plugins.forEach(function(plugin, i) {
	            //这里延时实例化是要等待节点动画播放完毕才能准确定位布局plugin，可以在配置里关闭plugin动画
	            var timer = setTimeout(function(){
	                clearTimeout(timer);
	                self.renderPlugin(self, plugin);
	            }, 0);
	        });
	    };
	    
	    /**
	     * 渲染单个plugin元素
	     * @param parent 父容器
	     * @param d 整体渲染配置数据
	     */
	    this.renderPlugin = function(parent, d) {
	    	self.mainContainer().each(function(data) {
	            if(d.render === undefined || RegexUtil.replace(RegexUtil.dataRegex, d.render, data) == "true") {
	                if(Global.isDebug) {
	                    console.log("Graph.renderPlugin() class is " + d.clazz);
	                }
	                var plugin = ClassFactory.newPluginInstance(d.clazz, [parent.mainContainer(), data]);
	                plugin.config(d.config);
	                plugin.render();
	                pluginLayout(plugin, d, parent);
	            }
	        });
	    };
	    
	    /**
		 * 渲染所有图表标题
		 * 
		 * @param parent 父容器
		 * @param config 整体渲染配置数据
		 */
	    this.renderHeadings = function(parent, config) {
	        if(!config.headings) {
	            self.headings().length = 0;
	            return;
	        }
	        if(Global.isDebug) {
	            console.log("Graph.renderHeadings()");
	        }
	        var headings = config.headings;
	        for(var i = 0, len = headings.length; i < len; i++) {
	        	self.renderHeading(parent, config, headings[i]);
	        }
	    };
	    
	    /**
	     * 渲染单个图表标题
	     * @param config 单个标题渲染配置数据
	     */
	    this.renderHeading = function(parent, config, headingConfig) {
	        if(!config || !headingConfig) {
	            return;
	        }
	        if(Global.isDebug) {
	            console.log("Graph.renderHeading()");
	        }
	        //heading是非可视化组件，只是控制textItem的渲染，故不能用parent.addChild(heading)显示
	        var heading = new Heading(parent, config, headingConfig);
	        heading.render();
	        self.headings().push(heading);
	    };
	    
	    /**
	     * 渲染图例
	     * @param config 整体渲染配置数据
	     */
	    this.renderLegend = function(parent, config) {
	        if(!config.legend) {
	        	self.legend(null);
	            return;
	        }
	        if(Global.isDebug) {
	            console.log("Graph.renderLegend()");
	        }
	        //legend是非可视化组件，只是控制legendItem的渲染，故不能用parent.addChild(legend)显示
	        var legend = new Legend(parent, config);
	        legend.render();
	        self.legend(legend);
	    };
	    
	    /**
	     * 渲染坐标轴
	     * @param config 整体渲染配置数据
	     */
	    this.renderAxis = function(parent, config) {
	        if(!config.axis || (!config.axis.xAxis && !config.axis.yAxis)) {
	            self.axis(null);
	            return;
	        }
	        if(Global.isDebug) {
	            console.log("Graph.renderAxis()");
	        }
	        //axis是非可视化组件，只是控制horAxis和verAxis的渲染，故不能用parent.addChild(axis)显示
	        var axis = new Axis(parent, config);
	        axis.render();
	        self.axis(axis);
	        
	        firstHorAxis = axis.horAxises().length > 0 ? axis.horAxises()[0] : null;
	        firstVerAxis = axis.verAxises().length > 0 ? axis.verAxises()[0] : null;
	    };
	    
	    /**
	     * 渲染悬浮提示框
	     * @param config 整体渲染配置数据
	     */
	    this.renderToolTip = function(parent, config) {
	        if(!config.toolTip) {
	            self.toolTip(null);
	            return;
	        }
	        if(Global.isDebug) {
	            console.log("Graph.renderToolTip()");
	        }
	        
	        //创建tooltip div并且根据配置设置样式
	        var toolTipDiv = self.ownerSVG().toolTipDiv();
	        
	        //根据配置设置样式
	    	CommonUtil.setGroupStyle(toolTipDiv, config.toolTip.style);
	    	CommonUtil.setGroupAttr(toolTipDiv, config.toolTip.attr);
	    	
	        self.toolTip(toolTipDiv);
	    };
	    
	    this.renderChildren = function() {
	    	superRenderChildren();
	    	
	    	parseConfig();
	    	
	    	var data = self.data();
	    	if(data && data.hasOwnProperty("series")) {
	    		//渲染图表标题
	    		self.renderHeadings(self, data);
	            //渲染图例
	            self.renderLegend(self, data);
	            //渲染坐标轴
	            self.renderAxis(self, data);
	            //渲染图表系列内容
	            self.renderSeries(self, data.series);
	            //渲染坐标轴内容热区容器
	            renderAxisHotAreaContainer();
	            //渲染分割线容器
	            renderSplitLineContainer();
	            //渲染坐标轴指针容器
	            renderFocusLineContainer();
	            //渲染水平坐标轴范围选择容器
	            renderHSliderContainer("render");
	            //渲染悬浮提示内容
	            self.renderToolTip(self, data);
	            //刷新全局数据
	            refreshGlobalVars();
	            //这里再刷新一次是因为layout.measure方法在child.update()中调用，调用之后才会有最新的total数据在bar图表中，根据该total数据值刷新坐标轴刻度才正确
	            updateAgainInBarChart();
	        }
	        if(data) {
	        	//渲染子组件基本的所有plugin
	    		self.renderPlugins(self, data);
	        }
	    };
	    
	    /**
	     * 根据配置信息设置图表关联的坐标轴
	     */
	    this.setAxisForSeriesCharts = function(chart, chartData) {
	        //根据配置信息设置图表关联的坐标轴
	        var xAxisIndex, yAxisIndex, 
	            axis = self.axis(), 
	            horAxises = axis ? axis.horAxises() : null, 
	            verAxises = axis ? axis.verAxises() : null
	            
	        //根据配置设置图表关联的水平坐标轴
	        if(horAxises && horAxises.length > 0) {
	            if(chartData.hasOwnProperty("xAxisIndex")) {
	                xAxisIndex = chartData.xAxisIndex;
	                if(xAxisIndex >= horAxises.length) {
	                    xAxisIndex = horAxises.length - 1;
	                }
	                if(xAxisIndex < 0) {
	                    xAxisIndex = 0;
	                }
	            } else {
	                xAxisIndex = 0;
	            }
	            chart.horAxis(horAxises[xAxisIndex]);
	        }
	        
	        //根据配置设置图表关联的垂直坐标轴
	        if(verAxises && verAxises.length > 0) {
	            if(chartData.hasOwnProperty("yAxisIndex")) {
	                yAxisIndex = chartData.yAxisIndex;
	                if(yAxisIndex >= verAxises.length) {
	                    yAxisIndex = verAxises.length - 1;
	                }
	                if(yAxisIndex < 0) {
	                    yAxisIndex = 0;
	                }
	            } else {
	                yAxisIndex = 0;
	            }
	            chart.verAxis(verAxises[yAxisIndex]);
	        }
	    };
	    
	    this.sortAllChildrenByZIndex = function() {
	        var zIndex, className, childNodes = self.node().childNodes, chartIndex = 0;
	        for (var element, i = 0, len = childNodes.length; i < len; i++) {
	            element = childNodes[i];
	            className = element.getAttribute("class");
	            if(className === "legend") {
	                element.setAttribute("z-index", Chart.LEGEND_Z_INDEX);
	            } else if(className === "heading") {
	                element.setAttribute("z-index", Chart.HEADING_Z_INDEX);
	            } else if(className === "axis") {
	                element.setAttribute("z-index", Chart.AXIS_Z_INDEX);
	            } else if(className === "axis-hotArea-container") {
	                element.setAttribute("z-index", Chart.AXIS_HOTAREA_CONTAINER_Z_INDEX);
	            } else if(className === "focus-container") {
	                element.setAttribute("z-index", Chart.FOCUS_CONTAINER_Z_INDEX);
	            } else if(className === "borderContainer") {
	            	element.setAttribute("z-index", Chart.BORDER_CONTAINER_Z_INDEX);
	            } else if(className === "bgContainer") {
	                element.setAttribute("z-index", Chart.BG_Z_INDEX);
	            } else if(className === "split-container") {
	                element.setAttribute("z-index", Chart.SPLIT_CONTAINER_Z_INDEX);
	            } else if(className === "hSlider-container") {
	                element.setAttribute("z-index", Chart.HSLIDER_CONTAINER_Z_INDEX);
	            } else {
	            	zIndex = parseInt(element.getAttribute("z-index"));
	                //若有z-index属性，并且超过图表层级定义范围，则直接设置z-index为图表最小层级
	                if(!isNaN(zIndex) && (zIndex < Chart.CHART_MIN_Z_INDEX + chartIndex || zIndex > Chart.CHART_MAX_Z_INDEX)) {
	                    element.setAttribute("z-index", Chart.CHART_MIN_Z_INDEX + chartIndex);
	                    chartIndex++;
	                }
	            }
	        }
	        SvgUtil.sortByZIndex(childNodes, false);
	    };
	    
	    this.update = function() {
	    	visibleItemsChanged = true;
	        //update axis content
	        var data = self.data();
	        if(data && data.hasOwnProperty("series")) {
	            if(self.axis()) {
	            	//bar类型提前刷新布局，计算出total值，供axis.update使用，针对动态改变barType来写的---start
	            	barLayoutUpdate();
	            	//bar类型提前刷新布局，计算出total值，供axis.update使用，针对动态改变barType来写的---end
	            	
	                self.axis().update();
	            }
	            //渲染坐标轴内容热区容器
	            renderAxisHotAreaContainer();
	            //渲染分割线容器
	            renderSplitLineContainer();
	            //渲染坐标轴指针容器
	            renderFocusLineContainer();
	            //渲染水平坐标轴范围选择容器
	            renderHSliderContainer("update");
	            //渲染悬浮提示内容
	            self.renderToolTip(self, data);
	            //刷新全局数据
	            refreshGlobalVars();
	        }
	        
	        //update legend
	        if(self.legend()) {
	            self.legend().update();
	        }
	        
	        //这里调用父类update方法，确保执行了坐标轴内容更新以后，所有component组件大小正确
	        superUpdate();
	        
	        //update all headings
	        var headings = self.headings();
	        if(headings && headings.length > 0) {
	            for(var i = 0, len = headings.length; i < len; i++) {
	                headings[i].update();
	            }
	        }
	    };
	    
	    this.resize = function() {
	    	superResize();
	    	
	    	//update axis content
	    	var data = self.data();
	        if(data && data.hasOwnProperty("series")) {
	            if(self.axis()) {
	                self.axis().update();
	            }
	            //渲染坐标轴内容热区容器
	            renderAxisHotAreaContainer();
	            //渲染分割线容器
	            renderSplitLineContainer();
	            //渲染坐标轴指针容器
	            renderFocusLineContainer();
	            //渲染水平坐标轴范围选择容器
	            renderHSliderContainer("resize");
	            //刷新全局数据
	            refreshGlobalVars();
	        }
	        
	        //这里再次调用父类resize方法，确保执行了坐标轴内容更新以后，所有component组件大小正确
	        superResize();
	        
	        //reset layout all headings
	        var headings = self.headings();
	        if(headings && headings.length > 0) {
	        	for(var i = 0, len = headings.length; i < len; i++) {
	        		headings[i].resetLayout(true);
	        	}
	        }
	        //reset layout legend
	    	if(self.legend()) {
	            self.legend().resetLayout();
	    	}
	    };
	    
	    this.renderDefsElements = function() {
	    	superRenderDefsElements();
	    	
	        var id = self.id(), svg = self.ownerSVG().mainContainer();
	        var maskId = "rectMask" + id;
	        if(self.clipContent() && self.width() > 0 && self.height() > 0 && !self.isRenderer()) {
	        	var rx = _data && _data.border ? _data.border.rx : undefined;
	        	var ry = _data && _data.border ? _data.border.ry : undefined;
	            var reckMask = SvgUtil.createRectMask(svg, maskId, 0, 0, self.width(), self.height(), rx, ry);
	            self.mainContainer().attr("mask", "url(#" + maskId + ")");
	        } else {
	            SvgUtil.deleteDefsElement(svg, maskId);
	            self.mainContainer().attr("mask", null);
	        }
	        
	    };
	    
	    this.addListeners = function() {
	    	superAddListeners();
	    	
	    	if(self.axis()) {
	    		self.mainContainer().on("mouseover", mouseOverHandler);
	            self.mainContainer().on("mousemove", mouseMoveHandler);
	            self.mainContainer().on("mouseout", mouseOutHandler);
	    	}
	    	self.addEventListener(BaseEvent.LEGEND_ITEM_CLICK, self.legendItemClickHandler);
	    	self.addEventListener(BaseEvent.SHOW_TOOL_TIP, self.showToolTipHandler);
	    	self.addEventListener(BaseEvent.UPDATE_TOOL_TIP, self.updateToolTipHandler);
	    	self.addEventListener(BaseEvent.HIDE_TOOL_TIP, self.hideToolTipHandler);
	    };
	    
	    this.getVisibleItems = function() {
	    	if(visibleItemsChanged) {
	    		visibleItemsChanged = false;
	    		var children = self.children();
	            if(children !== null && children.length > 0) {
	                visibleItems = [];
	                var instanceofChart = ClassFactory.instanceofChart;
	                for(var child, i = 0, len = children.length; i < len; i++) {
	                    child = children[i];
	                    if(instanceofChart(child)) {
	                        visibleItems = visibleItems.concat(child.visibleItems());
	                    }
	                }
	            }
	    	}
	        return visibleItems;
	    };
	    
	    /**
	     * 根据x坐标获取对应的最近的一个item的数据
	     * @x x坐标
	     */
	    this.getItemDataByX = function(x) {
	    	var items = self.getVisibleItems();
	        var item = getItemByX(x, items);
	        return item;
	    };
	    
	    /**
	     * 根据y坐标获取对应的最近的一个item的数据
	     * @y y坐标
	     */
	    this.getItemDataByY = function(y) {
	        var items = self.getVisibleItems();
	        var item = getItemByY(y, items);
	        return item;
	    };
	    
	    /**
	     * 根据配置和当前鼠标坐标获取本图表要显示的toolTip内容字符串
	     * @config toolTip配置数据
	     * @x 当前鼠标相对坐标轴内容的水平坐标
	     * @y 当前鼠标相对坐标轴内容的垂直坐标
	     * @tickIndex 当前距离鼠标最近的刻度值索引
	     * @d 鼠标经过图表节点项数据
	     */
	    this.getToolTipStr = function(config, x, y, tickIndex, d) {
	        var itemsData = self.getVisibleItems();
	        var item, items, lineStr, str = "", br = "<br>";
	        var labelFormat = config.labelFormat;
	        var trigger = config.trigger ? config.trigger :　"item";//xAxis|yAxis|item
	        var isHorAxisEnum = firstHorAxis && firstHorAxis.type() === "enum";
	        var isVerAxisEnum = firstVerAxis && firstVerAxis.type() === "enum";
	        var showIcon = config.hasOwnProperty("showIcon") ? config.showIcon === true : true;
	        if(labelFormat === null || labelFormat === undefined || labelFormat === "") {
	            
	        } else if(ObjectUtil.isString(labelFormat)) {
	            if(trigger === "xAxis") {
	            	if(isHorAxisEnum && tickIndex !== undefined && ticksText) {
	            		items = self.filterArrayByElementProperty(itemsData, firstHorAxis.key(), ticksText[tickIndex]);
	            	} else {
	            		items = getItemsByX(x, itemsData);
	            	}
	            } else if(trigger === "yAxis") {
	            	if(isVerAxisEnum && tickIndex !== undefined && ticksText) {
	            		items = self.filterArrayByElementProperty(itemsData, firstVerAxis.key(), ticksText[tickIndex]);
	            	} else {
	            		items = getItemsByY(y, itemsData);
	            	}
	            } else if(d !== undefined) {//default item
	                items = [d];
	            }
	        	for(var i = 0, len = items.length; i < len; i++) {
	        		item = items[i];
	        		lineStr = self.formatToolTip(labelFormat, item);
	                if(lineStr !== "") {
	                    str += (showIcon ? (getTooltipItemIconDomStr(item) + replaceTooltipBr(lineStr)) : lineStr) + br;
	                }
	        	}
	        } else if(ObjectUtil.isObject(labelFormat)) {
	            var len, xAxisFormat = labelFormat.xAxisFormat, 
	                yAxisFormat = labelFormat.yAxisFormat;
	            if(trigger === "xAxis") {
	                if(isHorAxisEnum && tickIndex !== undefined && ticksText) {
	                    items = self.filterArrayByElementProperty(itemsData, firstHorAxis.key(), ticksText[tickIndex]);
	                }
	                //当枚举类型坐标轴标签显示格式被修改而导致没有查询到匹配结果时(比如数据源是"2017-1-1"，坐标轴刻度标签显示的是"1-1")，再用x轴距离过滤法查询一次
	                if(!items || items.length === 0) {
	                    items = getItemsByX(x, itemsData);
	                }
	            } else if(trigger === "yAxis") {
	                if(isVerAxisEnum && tickIndex !== undefined && ticksText) {
	                    items = self.filterArrayByElementProperty(itemsData, firstVerAxis.key(), ticksText[tickIndex]);
	                    items.reverse();
	                }
	                //当枚举类型坐标轴标签显示格式被修改而导致没有查询到匹配结果时，再用y轴距离过滤法查询一次
	                if(!items || items.length === 0) {
	                    items = getItemsByY(y, itemsData);
	                }
	            } else if(d !== undefined) {//default item
	            	items = [d];
	            }
	            if(ObjectUtil.isString(xAxisFormat)) {
	                if(items.length > 0) {
	                	if(trigger === "xAxis") {
	                        len = 1;
	                    } else if(trigger === "yAxis") {
	                        len = items.length;
	                    } else {
	                    	len = 1;
	                    }
	                	for(var i = 0; i < len; i++) {
	                        item = items[i];
	                        lineStr = self.formatToolTip(xAxisFormat, item);
	                        if(lineStr !== "") {
	                        	//包括trigger为yAxis|item,item只添加一个图标，所以这里只添加一次，后面yAxisFormat里面不再添加
	                            str += (showIcon ? (getTooltipItemIconDomStr(trigger !== "xAxis" ? item : null) + replaceTooltipBr(lineStr)) : lineStr)  + br;
	                        }
	                    }
	                }
	            }
	            if(ObjectUtil.isString(yAxisFormat)) {
	            	if(items.length > 0) {
	                    if(trigger === "xAxis") {
	                        len = items.length;
	                        //这里reverse处理使tooltip的数据内容顺序与Y轴从上到下显示的枚举数据顺序一致
	                        if(isVerAxisEnum) {
	                        	items.reverse();
	                        }
	                    } else if(trigger === "yAxis") {
	                        len = 1;
	                    } else {
	                        len = 1;
	                    }
	                    for(var i = 0; i < len; i++) {
	                        item = items[i];
	                        lineStr = self.formatToolTip(yAxisFormat, item);
	                        if(lineStr !== "") {
	                            str += (showIcon ? (getTooltipItemIconDomStr(trigger === "xAxis" ? item : null) + replaceTooltipBr(lineStr)) : lineStr) + br;
	                        }
	                    }
	                }
	            }
	        }
	        return str;
	    };
	    
	    /**
	     * 根据配置中的toolTip相关的format得到对应ges的字符串结果，其中{##}里面的是可执行的js代码
	     * @format 配置中的format字符串
	     * @d 对应item的数据
	     */
	    this.formatToolTip = function(format, d) {
	        format = format.replace("\n", "<br>");
	        return format.replace(RegexUtil.jsRegex, function() {
	            return arguments.length > 1 ? eval(arguments[1]) : "";
	        });
	    };
	    
	    //override
	    this.toJSON = function() {
	        var str = "";
	        var d = self.data();
	        if(!d) {
	            return str;
	        }
	        var series = d.series;
	        if(d.series) {
	        	d.series = [];
	        }
	        var cloneData = ObjectUtil.cloneObj(d);
	        var children = self.children();
	        for (var child, i = 0, len = children.length; i < len; i++) {
	        	child = children[i];
	        	if(ClassFactory.instanceofChart(child)) {
	        		cloneData.series.push(JSON.parse(child.toJSON()));
	        	}
	        }
	        if(series) {
	        	d.series = series;
	        }
	        str = JSON.stringify(cloneData);
	        return str;
	    };
	    
	    // --------------------------------------------------------------------------
	    // notice event actions code
	    // --------------------------------------------------------------------------
	    
	    /**
	     * 返回当前鼠标所在位置是否触发显示悬浮提示
	     */
	    this.isShowToolTip = function() {
	        return isInsideHotArea();
	    };
	    
	    /**
	     * 获取鼠标当前所在x坐标位置对应的x轴值，若取不到则返回null
	     */
	    this.getXAxisValue = function() {
	        var axisHotArea = self.axisHotArea.node(), 
	            box = axisHotArea.getBBox(), 
	            mousePos = MouseUtil.mouse(axisHotArea, self.graph()), 
	            x = mousePos[0],
	            y = mousePos[1];
	        var isInside = !(x < 0 || x > box.width || y < 0 || y > box.height);
	        if(!isInside) {
	            return null;
	        }
	        var data = self.getItemDataByX(x);
	        return data ? data[firstHorAxis.key()] : null;
	    };
	    
	    /**
	     * 显示悬浮提示操作
	     * @param isShow 是否显示悬浮提示，若为否则执行隐藏悬浮提示操作
	     * @param value 悬浮提示对应的x轴的值，若为null则执行隐藏悬浮提示操作
	     */
	    this.actionShowToolTip = function(isShow, value) {
	        if(isShow) {
	            self.actionUpdateToolTip(value);
	        } else {
	            self.actionHideToolTip();
	        }
	    };
	    
	    /**
	     * 刷新悬浮提示操作
	     * @param value 悬浮提示对应的x轴的值，若为null则执行隐藏悬浮提示操作
	     */
	    this.actionUpdateToolTip = function(value) {
	        if(value === null) {
	            self.actionHideToolTip();
	        } else {
	            firstHorAxis = axis.horAxises().length > 0 ? axis.horAxises()[0] : null;
	            var x;
	            if(firstHorAxis) {
	                var type = firstHorAxis.type();
	                var xScale = firstHorAxis.scaleIns();
	                if(xScale) {
	                	var domain = xScale.domain();
	                    if(type === "time") {
	                        x = domain.length === 2 && (value < domain[0] || value > domain[1]) ? NaN : xScale(value);
	                    } else if(type === "enum") {
	                        x = xScale.align() * xScale.step() +　xScale(value);
	                    } else {
	                        //type is value
	                        x = domain.length === 2 && (value < domain[0] || value > domain[1]) ? NaN : xScale(value);
	                    }
	                }
	            }
	            if(isNaN(x)) {
	                self.actionHideToolTip();
	            } else {
	            	if(self.xFocusLine && self.xFocusLine.attr("visibility") === "hidden") {
	                    mouseOverHandler(x, 0, null, null);
	                }
	                mouseMoveHandler(x, 0, null, null);
	            }
	        }
	    };
	    
	    /**
	     * 隐藏悬浮提示操作
	     */
	    this.actionHideToolTip = function() {
	        mouseOutHandler();
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // listeners
	    //
	    // --------------------------------------------------------------------------
	    
	    var mouseOverHandler = function() {
	    	if(isThumbDrag) {
	            return;
	        }
	        axisHotBox = self.axisHotArea.node().getBBox();
	    	if(arguments.length > 3 ? !isInsideHotArea(arguments[0], arguments[1], axisHotBox) : !isInsideHotArea()) {
	    		return;
	    	}
	        if(self.xFocusLine) {
	            self.xFocusLine.attr("visibility", "visible");
	        }
	        if(self.yFocusLine) {
	            self.yFocusLine.attr("visibility", "visible");
	        }
	        if(toolTipTrigger === "xAxis" || toolTipTrigger === "yAxis") {
	            var evt = EventUtil.createCustomEvent(BaseEvent.SHOW_TOOL_TIP, true, true);
	            self.dispatchEvent(evt);
	        }
	        if(toolTipTrigger === "xAxis") {
	            var horAxis, horAxises = self.axis().horAxises();
	            if(horAxises && horAxises.length > 0) {
	                horAxis = horAxises[0];
	                ticksPos = horAxis.getTicksPos();
	                ticksText = horAxis.isReverse() ? horAxis.getTicksText().reverse() : horAxis.getTicksText();
	            }
	        } else if(toolTipTrigger === "yAxis") {
	            var verAxis, verAxises = self.axis().verAxises();
	            if(verAxises && verAxises.length > 0) {
	                verAxis = verAxises[0];
	                ticksPos = verAxis.getTicksPos();
	                ticksText = verAxis.isReverse() ? verAxis.getTicksText() : verAxis.getTicksText().reverse();
	            }
	        }
	    };
	    
	    var mouseMoveHandler = function() {
	    	var axisHotArea = self.axisHotArea.node(), 
	            box = axisHotBox;
	            mousePos = arguments.length > 3 ? [arguments[0], arguments[1]] : MouseUtil.mouse(axisHotArea, self.graph()), 
	            x = mousePos[0],
	            y = mousePos[1],
	            toolTipConfig = self.data().toolTip,
	            trigger = toolTipConfig ? toolTipConfig.trigger : null;
	            
	    	if(!isInsideHotArea(x, y, box)) {
	    		mouseOutHandler();
	            return;
	        }
	        if(isThumbDrag) {
	            return;
	        }
	        var transition = d3.transition().duration(self.animation() ? 100 : 0).ease(d3.easeLinear);
	        if(self.xFocusLine) {
	        	if(trigger === "item") {//位置为鼠标当前坐标
	        		self.xFocusLine.attr("x1", x).attr("x2", x).attr("y1", 0).attr("y2", box.height);
	        	} else if(firstHorAxis && firstHorAxis.type() === "enum" && ticksPos) {
	                var hIndex = getNearValueIndex(x, ticksPos);
	                if(hIndex !== -1) {
	                    var hx = ticksPos[hIndex];
	                    mousePos.push(hIndex);
	                    self.xFocusLine
	                        .attr("y1", 0).attr("y2", box.height)
	                        .transition(transition)
	                        .attr("x1", hx).attr("x2", hx);
	                    if(xFocusLineConfig.type === "bar") {
	                    	self.xFocusLine.style("stroke-width", parseInt(box.width/ticksPos.length) + "px");
	                    }
	                }
	            } else {
	                var item = self.getItemDataByX(x);
	                if(item) {
	                    self.xFocusLine
	                        .attr("y1", 0).attr("y2", box.height)
	                        .transition(transition)
	                        .attr("x1", item.x).attr("x2", item.x);
	                }
	            }
	        }
	        if(self.yFocusLine) {
	            if(trigger === "item") {//位置为鼠标当前坐标
	                self.yFocusLine.attr("x1", 0).attr("x2", box.width).attr("y1", y).attr("y2", y);
	            } else if(firstVerAxis && firstVerAxis.type() === "enum" && ticksPos) {
	                var vIndex = getNearValueIndex(y, ticksPos);
	                if(vIndex !== -1) {
	                    var vy = ticksPos[vIndex];
	                    mousePos.push(vIndex);
	                    self.yFocusLine
	                        .attr("x1", 0).attr("x2", box.width)
	                        .transition(transition)
	                        .attr("y1", vy).attr("y2", vy);
	                    if(yFocusLineConfig.type === "bar") {
	                    	self.yFocusLine.style("stroke-width", parseInt(box.height/ticksPos.length) + "px");
	                    }
	                }
	            } else {
	                var item = self.getItemDataByY(y);
	                if(item) {
	                    self.yFocusLine
	                        .attr("x1", 0).attr("x2", box.width)
	                        .transition(transition)
	                        .attr("y1", item.y).attr("y2", item.y);
	                }
	            }
	        }
	        if(toolTipTrigger === "xAxis" || toolTipTrigger === "yAxis") {
	            var evt = EventUtil.createCustomEvent(BaseEvent.UPDATE_TOOL_TIP, true, true, mousePos);
	            self.dispatchEvent(evt);
	        }
	    };
	    
	    var mouseOutHandler = function() {
	        if(isThumbDrag) {
	            return;
	        }
	        if(self.xFocusLine) {
	            self.xFocusLine.attr("visibility", "hidden");
	        }
	        if(self.yFocusLine) {
	            self.yFocusLine.attr("visibility", "hidden");
	        }
	        if(toolTipTrigger === "xAxis" || toolTipTrigger === "yAxis") {
	            var evt = EventUtil.createCustomEvent(BaseEvent.HIDE_TOOL_TIP, true, true);
	            self.dispatchEvent(evt);
	        }
	    };
	    
	    this.legendItemClickHandler = function(event) {
	    	event.stopImmediatePropagation();
	    	visibleItemsChanged = true;
	    	//update axis
	    	var data = self.data();
	        if(data && data.hasOwnProperty("series")) {
	            if(self.axis()) {
	            	//bar类型提前刷新布局，计算出total值，供axis.update使用，针对动态改变barType来写的---start
	                barLayoutUpdate();
	                //bar类型提前刷新布局，计算出total值，供axis.update使用，针对动态改变barType来写的---end
	                
	                self.axis().update();
	            }
	            //如果存在，刷新水平坐标轴范围选择容器
	            renderHSliderContainer("update");
	        }
	        //update child base chart
	        var children = self.children();
	        for(var child, i = 0, len = children.length; i < len; i++) {
	    	    child = children[i];
	            if(ClassFactory.instanceofChart(child)) {
	                child.update();
	            }
	        }
	    };
	    
	    this.showToolTipHandler = function(event) {
	    	event.stopImmediatePropagation();
	    	if(self.toolTip() && self.data().toolTip && self.data().toolTip.labelFormat) {
	    		self.toolTip().node().style.display = "block";
	    	}
	        //console.log("showToolTipHandler");
	    };
	    
	    this.updateToolTipHandler = function(event) {
	    	event.stopImmediatePropagation();
	    	if(!self.toolTip()) {
	            return;
	        }
	    	var toolTipConfig = self.data().toolTip;
	    	if(!toolTipConfig) {
	    		return;
	    	}
	    	if(!toolTipConfig.labelFormat) {
	    		return;
	    	}
	    	//根据当前鼠标位置和配置获取每个子chart对应的toolTip字符串内容
	    	var mousePos, 
	    	    str = "", 
	        	node = self.toolTip().node(),
	        	style = node.style;
	        	
	        if(event.detail && (!event.detail.data || !event.detail.target || !(event.detail.target instanceof Chart))) {//trigger is item
	        	var axisHotArea = (self.axisHotArea && self.axisHotArea.node()) ? 
	        	   self.axisHotArea.node() : 
	        	   self.isRenderer() ? self.node().ownerSVGElement : self.node(), 
	            box = axisHotArea.getBBox(), 
	            mousePos = MouseUtil.mouse(axisHotArea, self.graph());
	            str += self.getToolTipStr(toolTipConfig, mousePos[0], mousePos[1], 
	                undefined, event.detail);
	            if(str!=""){
	                str+= "\n";
	            }
	        } else {//trigger is axis
	        	mousePos = event.detail.data;
	        	str += self.getToolTipStr(toolTipConfig, mousePos[0], mousePos[1],
	        	    mousePos.length > 2 ? mousePos[2] : undefined);
	        	if (str != "") {
	        	    str += "\n";
	        	}
	        }
	        	
	        if(str === "" || str === null) {
	        	style.display = "none";
	        	SvgUtil.removeAllChildren(node);
	        } else {
	        	node.innerHTML = str;
	        	style.display = "block";
	        	
	        	var topW = self.ownerSVG().parentWidth(), 
	                topH = self.ownerSVG().parentHeight(),
	                padding = firstHorAxis ? firstHorAxis.padding() : null;
	            x = mousePos[0] + (padding ? padding.left : 0) + 10;
	            y = mousePos[1] + (padding ? padding.top : 0) + 20;
	            if(x + node.clientWidth > topW) {
	                x = topW - node.clientWidth;
	            }
	            if(y + node.clientHeight > topH) {
	                y = topH - node.clientHeight;
	            }
	            //计算全局坐标
	            x += self.x();
	            y += self.y();
	        	
	        	style.left = x + "px";
	            style.top = y + "px";
	        }
	        //console.log("updateToolTipHandler:" + str);
	    };
	    
	    this.hideToolTipHandler = function(event) {
	    	event.stopImmediatePropagation();
	    	if(self.toolTip()) {
	            self.toolTip().node().style.display = "none";
	        }
	        //console.log("hideToolTipHandler");
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // private Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    /**
	     * 解析配置数据
	     */
	    var parseConfig = function() {
	    	isShowHSlider = _data.hSlider && _data.hSlider.visible;
	        isShowXFocusLine = _data.xFocusLine && _data.xFocusLine.visible;
	        isShowYFocusLine = _data.yFocusLine && _data.yFocusLine.visible;
	        isShowXSplitLine = _data.xSplitLine && _data.xSplitLine.visible;
	        isShowYSplitLine = _data.ySplitLine && _data.ySplitLine.visible;
	        
	        xFocusLineConfig = isShowXFocusLine ? 
	            CommonUtil.createConfig({visible:true, type:"line", style:{stroke:"red", pointerEvents:"none"}}, _data.xFocusLine) : null;
	        yFocusLineConfig = isShowYFocusLine ? 
	            CommonUtil.createConfig({visible:true, type:"line", style:{stroke:"red", pointerEvents:"none"}}, _data.yFocusLine) : null;
	        xSplitLineConfig = isShowXSplitLine ? 
	            CommonUtil.createConfig({visible:true, style:{stroke:"#d13438", pointerEvents:"none"}}, _data.xSplitLine) : null;
	        ySplitLineConfig = isShowYSplitLine ? 
	            CommonUtil.createConfig({visible:true, style:{stroke:"#d13438", pointerEvents:"none"}}, _data.ySplitLine) : null;
	        
	        if(_data.toolTip && _data.toolTip.trigger) {
	            toolTipTrigger = _data.toolTip.trigger;
	        } else {
	            toolTipTrigger = null;
	        }
	    };
	    
	    var refreshGlobalVars = function() {
	    	if(self.axis()) {
	    		axisHotBox = self.axisHotArea.node().getBBox();
	    	}
	        if(d3.event && window.event instanceof CustomEvent) {
	        	if(self.xFocusLine) {
	                self.xFocusLine.attr("visibility", "visible");
	            }
	            if(self.yFocusLine) {
	                self.yFocusLine.attr("visibility", "visible");
	            }
	        }
	    };
	    
	    /**
	     * 图表组件中的plugin布局
	     */
	    var pluginLayout = function(plugin, d, parent) {
	        var xPos = d.xPos, 
	            yPos = d.yPos, 
	            x = 0, 
	            y = 0,
	            bBox = parent.node().getBBox(),
	            w = bBox.width, 
	            h = bBox.height, 
	            rh = plugin.actualHeight(), 
	            rw = plugin.actualWidth();
	
	        if (xPos == "left")
	            x = -w/2;
	        else if (xPos == "center")
	            x = 0;
	        else if (xPos == "right")
	            x = w/2;
	        else if(!isNaN(xPos))
	            x = parseFloat(xPos);
	
	        if (yPos == "top")
	            y = -h/2;
	        else if (yPos == "middle")
	            y = 0;
	        else if (yPos == "bottom")
	            y = h/2;
	        else if(!isNaN(yPos))
	            y = parseFloat(yPos);
	            
	        if(plugin instanceof Label) {
	        	if (xPos == "left")
	                x -= rw;
	            else if (xPos == "center")
	                x -= rw/2;
	                
	        	if (yPos == "top")
	                y -= rh;
	            else if (yPos == "middle")
	                y -= rh/2;
	        }
	
	        plugin.transform("translate(" + [x-parent.x(), y-parent.y()] + ")");
	    };
	    
	    /**
	     * 当前鼠标是否在坐标轴热区内
	     */
	    var isInsideHotArea = function(x, y, box) {
	        if(arguments.length === 0) {
	            var axisHotArea = self.axisHotArea.node(), 
	                box = axisHotArea.getBBox(), 
	                mousePos = MouseUtil.mouse(axisHotArea, self.graph()), 
	                x = mousePos[0],
	                y = mousePos[1];
	        }
	        return !(x < 0 || x > box.width || y < 0 || y > box.height);
	    }
	    
	    /**
	     * 根据x坐标获取对应的最近的一个item的数据
	     * @x x坐标
	     * @data item数据数组
	     */
	    var getItemByX = function(x, data) {
	        var d, leftItem, rightItem, item;
	        for(var i = 0, len = data.length; i < len; i++) {
	            d = data[i];
	            if(x >= d.x) {
	                if(!leftItem) {
	                    leftItem = d;
	                } else if(leftItem.x < d.x) {
	                    leftItem = d;
	                }
	            } else if(x <= d.x) {
	                if(!rightItem) {
	                    rightItem = d;
	                } else if(rightItem.x > d.x) {
	                    rightItem = d;
	                }
	            }
	        }
	        if(leftItem && rightItem) {
	            item = x < leftItem.x + (rightItem.x - leftItem.x) / 2 ? leftItem : rightItem;
	        } else if(leftItem && !rightItem) {
	            item = leftItem;
	        } else if(!leftItem && rightItem) {
	            item = rightItem;
	        } else {
	            item = null;
	        }
	        return item;
	    };
	    
	    /**
	     * 根据y坐标获取对应的最近的一个item的数据
	     * @y y坐标
	     * @data item数据数组
	     */
	    var getItemByY = function(y, data) {
	        var d, topItem, bottomItem, item;
	        for(var i = 0, len = data.length; i < len; i++) {
	            d = data[i];
	            if(y >= d.y) {
	                if(!topItem) {
	                    topItem = d;
	                } else if(topItem.y < d.y) {
	                    topItem = d;
	                }
	            } else if(y <= d.y) {
	                if(!bottomItem) {
	                    bottomItem = d;
	                } else if(bottomItem.y > d.y) {
	                    bottomItem = d;
	                }
	            }
	        }
	        if(topItem && bottomItem) {
	            item = y < topItem.y + (bottomItem.y - topItem.y) / 2 ? topItem : bottomItem;
	        } else if(topItem && !bottomItem) {
	            item = topItem;
	        } else if(!topItem && bottomItem) {
	            item = bottomItem;
	        } else {
	            item = null;
	        }
	        return item;
	    };
	    
	    /**
	     * 根据x坐标获取对应的最近的所有item的数据
	     * @x x坐标
	     * @data item数据数组
	     */
	    var getItemsByX = function(x, data) {
	    	var item = getItemByX(x, data),
	    	    items = [];
	        //取所有x坐标相同的item
	        if(item) {
	        	var resultX = item.x;
	        	for(var i = 0, len = data.length; i < len; i++) {
	        		d = data[i];
	        		if(resultX === d.x) {
	        			items.push(d);
	        		}
	        	}
	        }
	        return items;
	    };
	    
	    /**
	     * 根据y坐标获取对应的最近的所有item的数据
	     * @y y坐标
	     * @data item数据数组
	     */
	    var getItemsByY = function(y, data) {
	       var item = getItemByY(y, data),
	           items = [];
	        //取所有y坐标相同的item
	        if(item) {
	            var resultY = item.y;
	            for(var i = 0, len = data.length; i < len; i++) {
	                d = data[i];
	                if(resultY === d.y) {
	                    items.push(d);
	                }
	            }
	        }
	        return items;
	    };
	    
	     /**
	     * bar图表渲染完毕后，再刷新一次的方法。
	     * 是因为layout.measure方法在child.update()中调用，调用之后才会后最新的total数据在bar图表中，
	     * 根据该total数据值刷新坐标轴刻度才正确
	     */
	    var updateAgainInBarChart = function() {
	    	if(self.isUpdateAxisAgain && self.axis()) {
	            //重新计算子容器尺寸和位置
	            var children = self.children();
	            if(children !== null && children.length > 0) {
	                for(var i = 0, len = children.length; i < len; i++) {
	                    children[i].update();
	                }
	            }
	            self.isUpdateAxisAgain = false;
	        }
	    };
	    
	    //bar类型提前刷新布局，计算出相关值，供axis.update使用，针对动态改变barType来写的
	    var barLayoutUpdate = function() {
	        const BarLayout = ghca_charts.layout.barLayout;
	        var children = self.children();
	    	for(var seriesChart, layout, layoutData, i = 0, len = children.length; i < len; i++) {
	    		seriesChart = children[i];
	            layout = seriesChart.layout();
	            layoutData = seriesChart.data().layout;
	            //这里用layout data中的barType是因为变更后的数据还没有刷新到layout对象中
	            if(layout instanceof BarLayout && layoutData) {
	                layout.update();
	            }
	        }
	    };
	    
	    /**
	     * 获取tooltip颜色标签字符串
	     * @param d 数据项对象
	     */
	    var getTooltipItemIconDomStr = function(d) {
	    	var leftSpace = "<div style='width:8px;height:8px;display:inline-block;'></div> ";
	    	if(!d) {
	    		return leftSpace;
	    	}
	    	var color = d.legendColor || d.fill || d.stroke || (d.data && (d.data.legendColor || d.data.fill || d.data.stroke)) || "";
	    	return color === "" ? leftSpace : "<svg width='8' height='8'><circle cx='4' cy='4' r='4' fill='" + color + "'></svg> ";
	    };
	    
	    var replaceTooltipBr = function(str) {
	    	var leftSpace = "<div style='width:8px;height:8px;display:inline-block;'></div> ";
	    	if(ObjectUtil.isString(str)) {
	    		return str.replace(/<br>/ig, "<br>" + leftSpace);
	    	}
	    	return str;
	    };
	    
	    // --------------------------------------------------------------------------
	    // axis hot area code
	    // --------------------------------------------------------------------------
	    
	    /**
	     * 坐标轴内容热区容器
	     */
	    var renderAxisHotAreaContainer = function() {
	        if(!self.axis()) {
	            return;
	        }
	        
	        if(!self.axisHotAreaContainer) {
	        	self.axisHotAreaContainer = self.mainContainer().append("g")
	                .attr("class", "axis-hotArea-container");
	        }
	        
	        //render axisHotArea rect
	        if(!self.axisHotArea) {
	            self.axisHotArea = self.axisHotAreaContainer.append("rect")
	                .attr("class", "axis-hotArea")
	                .attr("fill", "white")
	                .attr("opacity", 0);
	        }
	        
	        //update axie hot area
	        var rect = self.axis().getAxisContentArea();
	        self.axisHotArea
	            .attr("width", rect.w)
	            .attr("height", rect.h);
	            
	        self.axisHotAreaContainer.attr("transform", "translate(" + rect.x + "," + rect.y + ")");
	    };
	    
	    // --------------------------------------------------------------------------
	    // spilt line code
	    // --------------------------------------------------------------------------
	    
	    var isShowXSplitLine = false,
	        isShowYSplitLine = false,
	        xSplitLineConfig = null,
	        ySplitLineConfig = null;
	    
	    /**
	     * 渲染分割线容器
	     */
	    var renderSplitLineContainer = function() {
	        if(!self.axis() || (!isShowXSplitLine && !isShowYSplitLine)) {
	            return;
	        }
	        
	        //render split container
	        if(!self.splitContainer) {
	            self.splitContainer = self.mainContainer().append("g")
	                .attr("class", "split-container");
	        }
	        
	        //render splitHotArea container
	        if(!self.splitHotArea) {
	            self.splitHotArea = self.splitContainer.append("rect")
	                .attr("class", "split-container-hotArea")
	                .attr("pointer-events", "none")
	                .attr("fill", "blue")
	                .attr("visibility", "hidden")
	        }
	        
	        var rect = self.axis().getAxisContentArea();
	        self.splitHotArea
	            .attr("width", rect.w)
	            .attr("height", rect.h);
	        
	        //render x split line
	        if(isShowXSplitLine) {
	        	var filter = _data.xSplitLine.filter;
	        	//根据配置信息设置图表关联的坐标轴
	            var axis = self.axis();
	            var horAxises = axis ? axis.horAxises() : null;
	            self.splitContainer.selectAll("line.x-split-line").remove();
	            if(filter && horAxises && horAxises.length > 0) {
	            	var horAxis = horAxises[0];
	            	var xScale = horAxis.scaleIns();
	            	var domain = horAxis.domain();
	            	var splitData = filter(domain);
	            	self.splitContainer.selectAll("line.x-split-line")
	                    .data(splitData).enter().append("line")
	                    .attr("class", "x-split-line")
	                    .attr("x1", function(d){
	                        return xScale(d) +　0.5;
	                    })
	                    .attr("x2", function(d){
	                        return xScale(d) +　0.5;
	                    })
	                    .attr("y1", 0)
	                    .attr("y2", rect.h);
	            }
	            //update style for x focus line
	        	self.splitContainer.selectAll("line.x-split-line").each(function(d){
	                CommonUtil.setGroupStyle(d3.select(this), xSplitLineConfig.style);
	                CommonUtil.setGroupAttr(d3.select(this), xSplitLineConfig.attr);
	        	});
	        }
	        
	        //render y split line
	        if(isShowYSplitLine) {
	            var filter = _data.ySplitLine.filter;
	            //根据配置信息设置图表关联的坐标轴
	            var axis = self.axis();
	            var verAxises = axis ? axis.verAxises() : null;
	            self.splitContainer.selectAll("line.y-split-line").remove();
	            if(filter && verAxises && verAxises.length > 0) {
	                var verAxis = verAxises[0];
	                var yScale = verAxis.scaleIns();
	                var domain = verAxis.domain();
	                var splitData = filter(domain);
	                self.splitContainer.selectAll("line.y-split-line")
	                    .data(splitData).enter().append("line")
	                    .attr("class", "y-split-line")
	                    .attr("y1", function(d){
	                        return yScale(d) +　0.5;
	                    })
	                    .attr("y2", function(d){
	                        return yScale(d) +　0.5;
	                    })
	                    .attr("x1", 0)
	                    .attr("x2", rect.w);
	            }
	            //update style for x focus line
	            self.splitContainer.selectAll("line.y-split-line").each(function(d){
	                CommonUtil.setGroupStyle(d3.select(this), ySplitLineConfig.style);
	                CommonUtil.setGroupAttr(d3.select(this), ySplitLineConfig.attr);
	            });
	        }
	        
	       self.splitContainer.attr("transform", "translate(" + rect.x + "," + rect.y + ")");
	    };
	    
	    // --------------------------------------------------------------------------
	    // focus line code
	    // --------------------------------------------------------------------------
	    
	    var toolTipTrigger = null, 
	        isShowHSlider = false, 
	        isShowXFocusLine = false, 
	        isShowYFocusLine = false,
	        xFocusLineConfig = null,
	        yFocusLineConfig = null;
	    
	    /**
	     * 渲染坐标轴指针容器
	     */
	    var renderFocusLineContainer = function() {
	        if(!self.axis() || (!isShowXFocusLine && !isShowYFocusLine && !toolTipTrigger)) {
	            return;
	        }
	        
	        //render focus container
	        if(!self.focusContainer) {
	            self.focusContainer = self.mainContainer().append("g")
	                .attr("class", "focus-container");
	        }
	        
	        //render x focus line
	        if(isShowXFocusLine && !self.xFocusLine) {
	            self.xFocusLine = self.focusContainer.append("line")
	                .attr("class", "x-focus-line")
	                .attr("visibility", "hidden");
	        }
	        //update style for x focus line
	        if(isShowXFocusLine && self.xFocusLine) {
	        	CommonUtil.setGroupStyle(self.xFocusLine, xFocusLineConfig.style);
	        	CommonUtil.setGroupAttr(self.xFocusLine, xFocusLineConfig.attr);
	        }
	        
	        //render y focus line
	        if(isShowYFocusLine && !self.yFocusLine) {
	            self.yFocusLine = self.focusContainer.append("line")
	                .attr("class", "y-focus-line")
	                .attr("visibility", "hidden");
	        }
	        //update style for y focus line
	        if(isShowYFocusLine && self.yFocusLine) {
	            CommonUtil.setGroupStyle(self.yFocusLine, yFocusLineConfig.style);
	            CommonUtil.setGroupAttr(self.yFocusLine, yFocusLineConfig.attr);
	        }
	       
	       var rect = self.axis().getAxisContentArea();
	       self.focusContainer.attr("transform", "translate(" + rect.x + "," + rect.y + ")");
	       
	       //update focus line
	       var box = self.axisHotArea.node().getBBox();
	       if(self.xFocusLine) {
	            self.xFocusLine.attr("y1", 0).attr("y2", box.height);
	       }
	       if(self.yFocusLine) {
	            self.yFocusLine.attr("x1", 0).attr("x2", box.width);
	       }
	       
	//       addFocusContainerListeners();
	    };
	    
	//    var addFocusContainerListeners = function() {
	//        if(!isShowXFocusLine && !isShowYFocusLine && !toolTipTrigger) {
	//            return;
	//        }
	//    };
	    
	    // --------------------------------------------------------------------------
	    // hSlider code
	    // --------------------------------------------------------------------------
	    
	    var minThumbsGap = 8;
	    var thumbsGap = minThumbsGap;
	    var thumbWidth = 6;
	    var thumbHeight = 34;
	    var thumbBoundRect = null;
	    var thumbX = -thumbWidth;
	    var thumbY = 0;
	    var tempThumbX = 0;
	    var thumbStartX = 0;
	    var thumbRadius = 4.5;
	    var symbolPadding = 1.5;
	    var errorWidth = 10;//误差宽度
	    
	    var leftThumbX = 0;
	    var leftTempThumbX = 0;
	    var leftThumbStartX = 0;
	    
	    var rightThumbX = 0;
	    var rightTempThumbX = 0;
	    var rightThumbStartX = 0;
	    
	    var isThumbDrag = false;
	    var isLeftThumbDrag = false;
	    var isRightThumbDrag = false;
	    var isLeftThumbOver = false;
	    var isRightThumbOver = false;
	    var xScale = null;
	    
	    /**
	     * 渲染水平坐标轴范围选择容器
	     * @param type "render"|"update"|"resize"
	     */
	    var renderHSliderContainer = function(type) {
	    	isShowHSlider = _data.hSlider && _data.hSlider.visible;
	        if(!isShowHSlider) {
	        	if(self.hSliderContainer) {
	        		self.hSliderContainer.attr("visibility", "hidden");
	        	}
	            return;
	        }
	        
	        var horAxis, horAxises = self.axis().horAxises();
	        if(horAxises && horAxises.length > 0) {
	            horAxis = horAxises[0];
	            xScale = horAxis.scaleIns();
	            isHorAxisTime = horAxis.type() === "time";
	        }
	        
	        var rect = self.axis().getAxisContentArea();
	        thumbY = (rect.h - thumbHeight) / 2;
	        
	        //render hSlider container
	        if(!self.hSliderContainer) {
	            self.hSliderContainer = self.mainContainer().append("g").attr("class", "hSlider-container");
	        }
	        self.hSliderContainer.attr("visibility", "visible");
	        
	        //render hSliderHotArea container
	        if(!self.hSliderHotArea) {
	            self.hSliderHotArea = self.hSliderContainer.append("rect")
	                .attr("class", "hSlider-container-hotArea")
	                .attr("fill", "blue")
	                .attr("visibility", "hidden")
	                .attr("pointer-events", "none");
	        }
	        
	        //render thumb container
	        if(!self.hSliderThumb) {
	            self.hSliderThumb = self.hSliderContainer.append("g").attr("class", "hSlider-thumb-container");
	        }
	        
	        //render hSlider thumb gap area background rect
	        if(!self.hSliderThumbGapBg) {
	            self.hSliderThumbGapBg = self.hSliderThumb.append("rect")
	                .attr("class", "hSlider-thumb-gap-bg")
	                .attr("pointer-events", "none");
	        }
	        
	        //render hSlider thumb background rect
	        if(!self.hSliderThumbBg) {
	            self.hSliderThumbBg = self.hSliderThumb.append("rect").attr("class", "hSlider-thumb-bg");
	        }
	        
	        //render left thumb container
	        if(!self.hSliderLeftThumb) {
	            self.hSliderLeftThumb = self.hSliderThumb.append("g").attr("class", "hSlider-left-thumb-container");
	        }
	        
	        //render hSlider left thumb background path
	        if(!self.hSliderLeftThumbBg) {
	            self.hSliderLeftThumbBg = self.hSliderLeftThumb.append("path").attr("class", "hSlider-left-thumb-bg");
	        }
	        
	        //render hSlider left thumb top background path
	        if(!self.hSliderLeftThumbTopBg) {
	            self.hSliderLeftThumbTopBg = self.hSliderLeftThumb.append("path").attr("class", "hSlider-left-thumb-top-bg");
	        }
	        
	        //render hSlider left thumb bottom background path
	        if(!self.hSliderLeftThumbBottomBg) {
	            self.hSliderLeftThumbBottomBg = self.hSliderLeftThumb.append("path").attr("class", "hSlider-left-thumb-bottom-bg");
	        }
	        
	        //render right thumb container
	        if(!self.hSliderRightThumb) {
	            self.hSliderRightThumb = self.hSliderThumb.append("g").attr("class", "hSlider-right-thumb-container");
	        }
	        
	        //render hSlider right thumb background path
	        if(!self.hSliderRightThumbBg) {
	            self.hSliderRightThumbBg = self.hSliderRightThumb.append("path").attr("class", "hSlider-right-thumb-bg");
	        }
	        
	        //render hSlider right thumb top background path
	        if(!self.hSliderRightThumbTopBg) {
	            self.hSliderRightThumbTopBg = self.hSliderRightThumb.append("path").attr("class", "hSlider-right-thumb-top-bg");
	        }
	        
	        //render hSlider right thumb bottom background path
	        if(!self.hSliderRightThumbBottomBg) {
	            self.hSliderRightThumbBottomBg = self.hSliderRightThumb.append("path").attr("class", "hSlider-right-thumb-bottom-bg");
	        }
	        
	        //render thumb toolTip container
	        if(!self.hSliderThumbToolTip) {
	            self.hSliderThumbToolTip = self.hSliderContainer.append("g").attr("class", "hSlider-thumb-toolTip-container");
	        }
	        
	        var thumbToolTipStyle = _data.hSlider.thumbToolTip ? _data.hSlider.thumbToolTip.style : {"font-size":"12"};
	        //render left thumb toolTip
	        if(!self.hSliderLeftThumbToolTip) {
	            self.hSliderLeftThumbToolTip = self.hSliderThumbToolTip.append("text")
	                .attr("class", "hSlider-left-thumb-toolTip");
	        }
	        ElementUtil.setElementStyles(self.hSliderLeftThumbToolTip, thumbToolTipStyle);
	        ElementUtil.setElementStyles(self.hSliderLeftThumb, {display:_data.changeThumbSize?"":"none"});
	        ElementUtil.setElementStyles(self.hSliderRightThumb, {display:_data.changeThumbSize?"":"none"});
	
	        if(_data.changeThumbSize){
	            thumbWidth=8;
	        }else{
	            thumbWidth=0;
	        }
	        
	        //render rigth thumb toolTip
	        if(!self.hSliderRightThumbToolTip) {
	            self.hSliderRightThumbToolTip = self.hSliderThumbToolTip.append("text")
	                .attr("class", "hSlider-right-thumb-toolTip");
	        }
	        ElementUtil.setElementStyles(self.hSliderRightThumbToolTip, thumbToolTipStyle);
	        
	        self.hSliderHotArea
	            .attr("width", rect.w)
	            .attr("height", rect.h);
	            
	        self.hSliderLeftThumbBg
	            .attr("d", "M" + thumbWidth + " " + 0 + 
	            " L" + thumbWidth + " " + thumbHeight +
	            " C" + (thumbWidth/2) + " " + thumbHeight + ", " + 0 + " " + (thumbHeight - thumbRadius) + ", "+ 0 + " " + (thumbHeight - thumbRadius*2) +
	            " L" + 0 + " " + thumbRadius*2 +
	            " C" + 0 + " " + thumbRadius + ", " + (thumbWidth/2) + " " + 0 + ", "+ thumbWidth + " " + 0)
	            .attr("fill", "#666");
	       
	        self.hSliderLeftThumbTopBg
	            .attr("d", "M" + (thumbWidth - symbolPadding) + " " + symbolPadding + 
	            " L" + (thumbWidth - symbolPadding) + " " + thumbRadius*2 +
	            " L" + symbolPadding + " " + thumbRadius*2 +
	            " C" + symbolPadding + " " + thumbRadius + ", " + (symbolPadding + thumbRadius) + " " + symbolPadding + ", " + (thumbWidth - symbolPadding) + " " + symbolPadding)
	            .attr("fill", "#eee");
	            
	        self.hSliderLeftThumbBottomBg
	            .attr("d", "M" + symbolPadding + " " + (thumbHeight - thumbRadius*2) + 
	            " L" + (thumbWidth - symbolPadding) + " " + (thumbHeight - thumbRadius*2) +
	            " L" + (thumbWidth - symbolPadding) + " " + (thumbHeight - symbolPadding) +
	            " C" + thumbRadius + " " + (thumbHeight - symbolPadding) + ", " + symbolPadding + " " + (thumbHeight - symbolPadding - thumbRadius) + ", " + symbolPadding + " " + (thumbHeight - thumbRadius*2))
	            .attr("fill", "#eee");
	            
	        self.hSliderRightThumbBg
	            .attr("d", "M" + 0 + " " + 0 + 
	            " L" + 0 + " " + thumbHeight +
	            " C" + (thumbWidth/2) + " " + thumbHeight + ", " + thumbWidth + " " + (thumbHeight - thumbRadius) + ", "+ thumbWidth + " " + (thumbHeight - thumbRadius*2) +
	            " L" + thumbWidth + " " + thumbRadius*2 +
	            " C" + thumbWidth + " " + thumbRadius + ", " + (thumbWidth/2) + " " + 0 + ", "+ 0 + " " + 0)
	            .attr("fill", "#666");
	            
	        self.hSliderRightThumbTopBg
	            .attr("d", "M" + symbolPadding + " " + symbolPadding + 
	            " L" + symbolPadding + " " + thumbRadius*2 +
	            " L" + (thumbWidth - symbolPadding) + " " + thumbRadius*2 +
	            " C" + (thumbWidth - symbolPadding) + " " + thumbRadius + ", " + symbolPadding + " " + symbolPadding + ", " + symbolPadding + " " + symbolPadding)
	            .attr("fill", "#eee");
	            
	        self.hSliderRightThumbBottomBg
	            .attr("d", "M" + (thumbWidth - symbolPadding) + " " + (thumbHeight - thumbRadius*2) + 
	            " L" + symbolPadding + " " + (thumbHeight - thumbRadius*2) +
	            " L" + symbolPadding + " " + (thumbHeight - symbolPadding) +
	            " C" + symbolPadding + " " + (thumbHeight - symbolPadding) + ", " + thumbRadius + " " + (thumbHeight - symbolPadding - thumbRadius) + ", " + (thumbWidth - symbolPadding) + " " + (thumbHeight - thumbRadius*2))
	            .attr("fill", "#eee");
	            
	        //水平坐标轴为枚举类型时，默认显示水平框选组件为一个枚举的宽度范围    
	        if (firstHorAxis) {
	            if (firstHorAxis.type() === "enum") {
	                var domain = xScale.domain();
	                var len = domain.length === 0 ? 1 : domain.length;
	                var box = self.hSliderHotArea.node().getBBox();
	                var w = box.width / len;
	                thumbsGap = w - thumbWidth * 2;
	                thumbsGap = thumbsGap < minThumbsGap ? minThumbsGap : thumbsGap;
	            }else if(firstHorAxis.type() === "time"){
	                var len = self.data().series[0].data.length;
	                var box = d3.select(".scatter-ItemsContainer").node().getBBox();
	                var w = box.width / len;
	                thumbsGap = w;
	            }
	        }
	        if(!thumbsGap){
	            thumbsGap=5;
	        }
	            
	        self.hSliderThumbGapBg
	            .attr("width", thumbsGap)
	            .attr("height", rect.h)
	            .attr("fill", "rgba(0, 0, 0, 0.1)"); 
	            
	        self.hSliderThumbBg
	            .attr("width", thumbWidth * 2 + thumbsGap)
	            .attr("height", rect.h)
	            .attr("fill", "#ff0000")
	            .attr("opacity", 0); 
	            
	        
	    	self.hSliderContainer.attr("transform", "translate(" + rect.x + "," + rect.y + ")");
	        self.hSliderLeftThumb.attr("transform", "translate(" + 0 + "," + thumbY + ")");
	        self.hSliderRightThumb.attr("transform", "translate(" + (thumbWidth + thumbsGap) + "," + thumbY + ")");
	        self.hSliderThumbGapBg.attr("transform", "translate(" + thumbWidth + "," + 0 + ")"); 
	        self.hSliderThumb.attr("transform", "translate(" + (-thumbWidth) + "," + 0 + ")");
	        
	        //重新设置水平选择框位置
	        var pos = _data.hSlider && _data.hSlider.pos ? _data.hSlider.pos : null;
	        var gapPercent = _data.hSlider && _data.hSlider.gapPercent ? _data.hSlider.gapPercent : NaN;
	        setHSliderPos(pos, gapPercent);
	        
	        if(type !== "resize") {
	        	refreshThumbsTooltip(thumbX);
	        	
	        	//这里稍后调用是因为isDispatchSliderChange在所有render方法执行完之后才设置
	        	if(type === "update" || (type === "render" && 
	        	_data.series && ObjectUtil.isArray(_data.series.data) && _data.series.data.length > 0)) {
	        		var timer = setTimeout(function() {
	                    clearTimeout(timer);
	                    dispatchChangeEvent(thumbX);
	                }, 100);
	        	}
	            
	            addHSliderListeners();
	        }
	    };
	    
	    /**
	     * 设置水平选择框位置(暂不支持enum类型坐标轴设置)
	     * @param pos left|right default right
	     * @param gapPercent 框选范围占总长度百分比 0-1 default 0.1
	     */
	    var setHSliderPos = function(pos, gapPercent) {
	    	if(!firstHorAxis || firstHorAxis.type() === "enum") {
	    		return;
	    	}
	    	pos = pos === "right" ? "right" : "left";
	    	gapPercent = isNaN(gapPercent) ? 0.1 : gapPercent;
	    	var box = self.hSliderHotArea.node().getBBox();
	        if (firstHorAxis) {
	            var len = self.data().series[0].data.length;
	            var box = d3.select(".scatter-ItemsContainer").node().getBBox();
	            var w = box.width / len;
	            thumbsGap = w;
	        }
	        if(!thumbsGap){
	            thumbsGap=5;
	        }
	        thumbX = pos === "left" ? -thumbWidth : box.width - thumbsGap;
	        thumbBoundRect = self.axis().getAxisContentArea();
	        var minX = -thumbWidth;
	        var maxX = thumbBoundRect.w - thumbsGap - thumbWidth;
	        if(thumbX < minX) {
	            thumbX = minX;
	        }
	        if(thumbX > maxX) {
	            thumbX = maxX;
	        }
	        
	        self.hSliderRightThumb
	            .attr("transform", "translate(" + (thumbWidth + thumbsGap) + "," + thumbY + ")");
	        self.hSliderThumbGapBg
	            .attr("width", thumbsGap)
	            .attr("transform", "translate(" + thumbWidth + "," + 0 + ")"); 
	        self.hSliderThumbBg.attr("width", thumbWidth * 2 + thumbsGap);
	        self.hSliderThumb.attr("transform", "translate(" + (thumbX) + "," + 0 + ")");
	        
	        refreshThumbsTooltip(thumbX);
	    };
	    
	    var dispatchChangeEvent = function(x) {
	    	if(!self.isDispatchSliderChange() || !xScale) {
	    		return;
	    	}
	    	var startX = x + thumbWidth;
	        var endX = startX + thumbsGap;
	        var startData = self.getItemDataByX(startX);
	        var endData = self.getItemDataByX(endX);
	        
	        self.dispatchEvent(EventUtil.createCustomEvent(BaseEvent.SLIDER_RANGE_CHANGE, false, true, [startData, endData]));
	    };
	    
	    var thumb_dragStartHandler = function() {
	        mouseOutHandler();
	        isThumbDrag = true;
	        
	        thumbBoundRect = self.axis().getAxisContentArea();
	        var mousePos = MouseUtil.mouse(self.hSliderHotArea.node(), self.graph());
	        thumbStartX = mousePos[0];
	    };
	    
	    var thumb_dragHandler = function() {
	        var mousePos = MouseUtil.mouse(self.hSliderHotArea.node(), self.graph());
	        var minX = -thumbWidth;
	        var maxX = thumbBoundRect.w - thumbsGap - thumbWidth;
	        tempThumbX = (mousePos[0] - thumbStartX) + thumbX;
	        if(tempThumbX < minX) {
	            tempThumbX = minX;
	        }
	        if(tempThumbX > maxX) {
	            tempThumbX = maxX;
	        }
	        self.hSliderThumb.attr("transform", "translate(" + tempThumbX + "," + 0 + ")");
	        
	        refreshThumbsTooltip(tempThumbX);
	    };
	    
	    var thumb_dragEndHandler = function() {
	        isThumbDrag = false;
	        
	        validateThumbPos(0);
	        
	        thumbX = tempThumbX;
	        
	        refreshThumbsTooltip(tempThumbX);
	        dispatchChangeEvent(thumbX);
	        changeThumbContainer();
	    };
	    
	    var leftThumb_dragStartHandler = function() {
	        mouseOutHandler();
	        leftThumb_mouseOverHandler();
	        isThumbDrag = true;
	        isLeftThumbDrag = true;
	        
	        var mousePos = MouseUtil.mouse(self.hSliderHotArea.node(), self.graph());
	        leftThumbStartX = mousePos[0];
	        leftThumbX = thumbX;
	        leftTempThumbX = leftThumbX;
	        self.hSliderLeftThumb.attr("transform", "translate(" + leftThumbX + "," + thumbY + ")");
	        
	        var lThumb = self.hSliderLeftThumb.node();
	        var hSlider = self.hSliderContainer.node();
	        hSlider.appendChild(lThumb);
	    };
	    
	    var leftThumb_dragHandler = function() {
	        var mousePos = MouseUtil.mouse(self.hSliderHotArea.node(), self.graph());
	        var box = self.hSliderThumb.node().getBBox();
	        var minX = -thumbWidth;
	        var maxX = thumbX + box.width - minThumbsGap - thumbWidth * 2;
	        leftTempThumbX = (mousePos[0] - leftThumbStartX) + leftThumbX;
	        if(leftTempThumbX < minX) {
	            leftTempThumbX = minX;
	        }
	        if(leftTempThumbX > maxX) {
	            leftTempThumbX = maxX;
	        }
	        self.hSliderLeftThumb.attr("transform", "translate(" + leftTempThumbX + "," + thumbY + ")");
	        
	        refreshLeftThumbTooltip(leftTempThumbX);
	        
	        //刷新thumb内容
	        var thumbBgWidth = thumbX - leftTempThumbX + box.width;
	        self.hSliderThumbGapBg.attr("width", thumbBgWidth - thumbWidth * 2);
	        self.hSliderThumbBg.attr("width", thumbBgWidth);
	        thumbX = leftTempThumbX;
	        self.hSliderThumb.attr("transform", "translate(" + thumbX + "," + 0 + ")");
	        rightThumbX = thumbBgWidth - thumbWidth; 
	        self.hSliderRightThumb.attr("transform", "translate(" + rightThumbX + "," + thumbY + ")");
	    };
	    
	    var leftThumb_dragEndHandler = function() {
	        isThumbDrag = false;
	        isLeftThumbDrag = false;
	        
	        validateThumbPos(1);
	        
	        var box = self.hSliderThumb.node().getBBox();
	        var thumbBgWidth = thumbX - leftTempThumbX + box.width;
	        self.hSliderThumbGapBg.attr("width", thumbBgWidth - thumbWidth * 2);
	        self.hSliderThumbBg.attr("width", thumbBgWidth);
	        
	        thumbX = leftTempThumbX;
	        self.hSliderThumb.attr("transform", "translate(" + thumbX + "," + 0 + ")");
	        leftThumbX = 0;    
	        self.hSliderLeftThumb.attr("transform", "translate(" + leftThumbX + "," + thumbY + ")");
	        rightThumbX = thumbBgWidth - thumbWidth; 
	        self.hSliderRightThumb.attr("transform", "translate(" + rightThumbX + "," + thumbY + ")");
	        thumbsGap = thumbBgWidth - thumbWidth * 2;
	        
	        var lThumb = self.hSliderLeftThumb.node();
	        var thumb = self.hSliderThumb.node();
	        thumb.appendChild(lThumb);
	        
	        refreshLeftThumbTooltip(leftTempThumbX);
	        dispatchChangeEvent(thumbX);
	        
	        leftThumb_mouseOutHandler();
	    };
	    
	    var rightThumb_dragStartHandler = function() {
	        mouseOutHandler();
	        rightThumb_mouseOverHandler();
	        isThumbDrag = true;
	        isRightThumbDrag = true;
	        
	        var mousePos = MouseUtil.mouse(self.hSliderHotArea.node(), self.graph());
	        rightThumbStartX = mousePos[0];
	        rightThumbX = thumbX + thumbWidth + thumbsGap;
	        rightTempThumbX = rightThumbX;
	        self.hSliderRightThumb.attr("transform", "translate(" + rightThumbX + "," + thumbY + ")");
	        
	        var rThumb = self.hSliderRightThumb.node();
	        var hSlider = self.hSliderContainer.node();
	        hSlider.appendChild(rThumb);
	    };
	    
	    var rightThumb_dragHandler = function() {
	        var mousePos = MouseUtil.mouse(self.hSliderHotArea.node(), self.graph());
	        var box = self.hSliderHotArea.node().getBBox();
	        var minX = thumbX + thumbWidth + minThumbsGap;
	        var maxX = box.width;
	        rightTempThumbX = (mousePos[0] - rightThumbStartX) + rightThumbX;
	        if(rightTempThumbX < minX) {
	            rightTempThumbX = minX;
	        }
	        if(rightTempThumbX > maxX) {
	            rightTempThumbX = maxX;
	        }
	        self.hSliderRightThumb.attr("transform", "translate(" + rightTempThumbX + "," + thumbY + ")");
	        
	        refreshRightThumbTooltip(rightTempThumbX);
	        
	        //刷新thumb内容
	        var thumbBgWidth = rightTempThumbX - thumbX + thumbWidth;
	        self.hSliderThumbGapBg.attr("width", thumbBgWidth - thumbWidth * 2);
	        self.hSliderThumbBg.attr("width", thumbBgWidth);
	    };
	    
	    var rightThumb_dragEndHandler = function() {
	        isThumbDrag = false;
	        isRightThumbDrag = false;
	        
	        validateThumbPos(2);
	        
	        var thumbBgWidth = rightTempThumbX - thumbX + thumbWidth;
	        self.hSliderThumbGapBg.attr("width", thumbBgWidth - thumbWidth * 2);
	        self.hSliderThumbBg.attr("width", thumbBgWidth);
	        
	        rightThumbX = thumbBgWidth - thumbWidth; 
	        self.hSliderRightThumb.attr("transform", "translate(" + rightThumbX + "," + thumbY + ")");
	        thumbsGap = thumbBgWidth - thumbWidth * 2;
	        
	        var rThumb = self.hSliderRightThumb.node();
	        var thumb = self.hSliderThumb.node();
	        thumb.appendChild(rThumb);
	        
	        refreshRightThumbTooltip(rightTempThumbX);
	        dispatchChangeEvent(thumbX);
	        
	        rightThumb_mouseOutHandler();
	    };
	    
	    var validateThumbPos = function(dragType) {
	        if(isHorAxisEnum) {
	            var domain = xScale.domain();
	            var len = domain.length === 0 ? 1 : domain.length;
	            var box = self.hSliderHotArea.node().getBBox();
	            var maxWidth = box.width;
	            var w = maxWidth / len;
	            var halfW = w * 0.5;
	            if(dragType === 0) {
	            	var x = (tempThumbX + thumbWidth) % w;
	                if(x < halfW) {
	                    tempThumbX -= x;
	                } else {
	                    tempThumbX += (w - x);
	                }
	                self.hSliderThumb.attr("transform", "translate(" + tempThumbX + "," + 0 + ")");
	            } else if(dragType === 1) {
	            	var lx = (leftTempThumbX + thumbWidth) % w;
	                if(lx < halfW) {
	                    leftTempThumbX -= lx;
	                } else {
	                    leftTempThumbX += (w - lx);
	                }
	                if(parseFloat(self.hSliderThumbBg.attr("width")) < w) {
	                    leftTempThumbX -= w;
	                }
	        	} else if(dragType === 2) {
	        		var rx = rightTempThumbX % w + 1;
	                if(rx < halfW) {
	                    rightTempThumbX -= rx;
	                } else {
	                    rightTempThumbX += (w - rx);
	                }
	                if(parseFloat(self.hSliderThumbBg.attr("width")) < w) {
	                    rightTempThumbX += w;
	                }
	        	}
	        }
	    };
	    
	    var leftThumb_mouseOverHandler = function() {
	        isLeftThumbOver = true;
	        if(!isLeftThumbDrag) {
	            self.hSliderLeftThumbBg.transition().attr("fill", "#43b4e1").attr("stroke", "#6cc8ee");
	        }
	    };
	    
	    var leftThumb_mouseOutHandler = function() {
	        isLeftThumbOver = false;
	        if(!isLeftThumbDrag && !isLeftThumbOver) {
	            self.hSliderLeftThumbBg.transition().attr("fill", "#666").attr("stroke", "#666");
	        }
	    };
	    
	    var rightThumb_mouseOverHandler = function() {
	        isRightThumbOver = true;
	        if(!isRightThumbDrag) {
	            self.hSliderRightThumbBg.transition().attr("fill", "#43b4e1").attr("stroke", "#6cc8ee");
	        }
	    };
	    
	    var rightThumb_mouseOutHandler = function() {
	        isRightThumbOver = false;
	        if(!isRightThumbDrag && !isRightThumbOver) {
	            self.hSliderRightThumbBg.transition().attr("fill", "#666").attr("stroke", "#666");
	        }
	    };
	    
	    var thumbBg_mouseOverHandler = function() {
	        thumbBoundRect = self.axis().getAxisContentArea();
	    };
	    
	    var thumbBg_mouseMoveHandler = function() {
	        //根据边界判断是否显示xFocusLine
	        var mousePos = MouseUtil.mouse(self.hSliderHotArea.node(), self.graph());
	        var x = mousePos[0];
	        if(x < 0 || x - thumbBoundRect.w > 0) {
	            mouseOutHandler();
	        } else {
	            mouseOverHandler();
	            mouseMoveHandler();
	        }
	    };
	    
	    var thumbBg_mouseOutHandler = function() {
	        mouseOutHandler();
	    };
	    
	    var addHSliderListeners = function() {
	        if(!isShowHSlider) {
	            return;
	        }
	        
	        self.hSliderThumbBg.on("mouseover.focus", thumbBg_mouseOverHandler);
	        self.hSliderThumbBg.on("mousemove.focus", thumbBg_mouseMoveHandler);
	        self.hSliderThumbBg.on("mouseout.focus", thumbBg_mouseOutHandler);
	        
	        self.hSliderThumb.call(d3.drag()
	            .on("start.thumb", thumb_dragStartHandler)
	            .on("drag.thumb", thumb_dragHandler)
	            .on("end.thumb", thumb_dragEndHandler)
	        );
	        
	        self.hSliderLeftThumb.call(d3.drag()
	            .on("start.leftThumb", leftThumb_dragStartHandler)
	            .on("drag.leftThumb", leftThumb_dragHandler)
	            .on("end.leftThumb", leftThumb_dragEndHandler)
	        );
	        
	        self.hSliderRightThumb.call(d3.drag()
	            .on("start.leftThumb", rightThumb_dragStartHandler)
	            .on("drag.leftThumb", rightThumb_dragHandler)
	            .on("end.leftThumb", rightThumb_dragEndHandler)
	        );
	        
	        self.hSliderLeftThumb.on("mouseover.leftThumb", leftThumb_mouseOverHandler);
	        self.hSliderLeftThumb.on("mouseout.leftThumb", leftThumb_mouseOutHandler);
	        
	        self.hSliderRightThumb.on("mouseover.rightThumb", rightThumb_mouseOverHandler);
	        self.hSliderRightThumb.on("mouseout.rightThumb", rightThumb_mouseOutHandler);
	
	        d3.select(".scatter-ItemsContainer").on("click",changeThumbContainer);
	    };
	    
	    var changeThumbContainer = function() {
	        var mousePos = MouseUtil.mouse(self.hSliderHotArea.node(), self.graph());
	        thumbX=mousePos[0];
	        var num=thumbX/thumbsGap;
	        var numceil=Math.floor(num);
	        thumbX=numceil*thumbsGap;
	        thumbBoundRect = self.axis().getAxisContentArea();
	        var minX = -thumbWidth;
	        var maxX = thumbBoundRect.w - thumbsGap - thumbWidth;
	        if(thumbX < minX) {
	            thumbX = minX;
	        }
	        if(thumbX > maxX) {
	            thumbX = maxX;
	        }
	        self.hSliderThumb.attr("transform", "translate(" +thumbX + "," + 0 + ")");
	        refreshThumbsTooltip(thumbX);
	        var startX = thumbX + thumbWidth;
	        var startData = self.getItemDataByX(startX);
	        self.dispatchEvent(EventUtil.createCustomEvent(BaseEvent.SLIDER_MOVE_END, false, true, startData));
	    }
	    
	    /**
	     * 刷新所有滑块提示内容能
	     * @param x 滑块容器水平坐标
	     */
	    var refreshThumbsTooltip = function(x) {
	        if(!xScale) {
	           return;
	        }
	        var horAxis, horAxises = self.axis().horAxises();
	        if(horAxises && horAxises.length > 0) {
	            horAxis = horAxises[0];
	            isHorAxisTime = horAxis.type() === "time";
	            isHorAxisEnum = horAxis.type() === "enum";
	        }
	        if(isHorAxisEnum && xScale.domain().length === 0) {
	            return;
	        }
	        var leftX = x + thumbWidth;
	        var rightX = leftX + thumbsGap;
	        var leftText, rightText;
	        if(isHorAxisEnum) {
	        	//d3.scaleQuantize()也属于连续性比例尺。定义域是连续的，而输出域是离散的
	        	//invert/invertExtend这两种方法只针对连续性比例尺有效，即domain()域为连续性数据集的比例尺。
	        	var scale = scaleQuantize.domain(xScale.range()).range(xScale.domain());
	        	leftText = scale(leftX + errorWidth);
	            rightText = scale(rightX - errorWidth);
	        } else {
	        	leftText = xScale.invert(leftX);
	            rightText = xScale.invert(rightX);
	        }
	        var lt = self.hSliderLeftThumbToolTip.text(isHorAxisTime ? formatDateTime(leftText) : leftText);
	        var rt = self.hSliderRightThumbToolTip.text(isHorAxisTime ? formatDateTime(rightText) : rightText);
	        var ltBox = lt.node().getBBox();
	        var ty = -5;
	        lt.attr("transform", "translate(" + (leftX - ltBox.width) + "," + ty + ")");
	        rt.attr("transform", "translate(" + (rightX) + "," + ty + ")");
	    };
	    
	    /**
	     * 刷新左滑块提示内容能
	     * @param x 左滑块容器水平坐标
	     */
	    var refreshLeftThumbTooltip = function(x) {
	        if(!xScale) {
	           return;
	        }
	        var leftX = x + thumbWidth;
	        var leftText;
	        if(isHorAxisEnum) {
	            //d3.scaleQuantize()也属于连续性比例尺。定义域是连续的，而输出域是离散的
	            //invert/invertExtend这两种方法只针对连续性比例尺有效，即domain()域为连续性数据集的比例尺。
	            var scale = scaleQuantize.domain(xScale.range()).range(xScale.domain());
	            leftText = scale(leftX + errorWidth);
	        } else {
	            leftText = xScale.invert(leftX);
	        }
	        var lt = self.hSliderLeftThumbToolTip.text(isHorAxisTime ? formatDateTime(leftText) : leftText);
	        var ltBox = lt.node().getBBox();
	        var ty = -5;
	        lt.attr("transform", "translate(" + (leftX - ltBox.width) + "," + ty + ")");
	    };
	    
	    /**
	     * 刷新右滑块提示内容能
	     * @param x 右滑块容器水平坐标
	     */
	    var refreshRightThumbTooltip = function(x) {
	        if(!xScale) {
	           return;
	        }
	        var rightX = x;
	        var rightText;
	        if(isHorAxisEnum) {
	            //d3.scaleQuantize()也属于连续性比例尺。定义域是连续的，而输出域是离散的
	            //invert/invertExtend这两种方法只针对连续性比例尺有效，即domain()域为连续性数据集的比例尺。
	            var scale = scaleQuantize.domain(xScale.range()).range(xScale.domain());
	            rightText = scale(rightX - errorWidth);
	        } else {
	            rightText = xScale.invert(rightX);
	        }
	        var rt = self.hSliderRightThumbToolTip.text(isHorAxisTime ? formatDateTime(rightText) : rightText);
	        var ty = -5;
	        rt.attr("transform", "translate(" + rightX + "," + ty + ")");
	    };
	    
	    /**
	     * 获取和给定值最相近的值的所在数组索引
	     * @param v 给定值
	     * @param ary 要对比的值数组，从小到大排列
	     */
	    var getNearValueIndex = function(v, ary) {
	        var len = ary.length;
	        if(len === 0) {
	            return -1;
	        }
	        if(len === 1) {
	            return 0;
	        }
	        var min = ary[0], max = ary[len-1];
	        if(v <= min) {
	            return 0;
	        }
	        if(v >= max) {
	            return len-1;
	        }
	        len--;
	        for(var n, next, i = 0; i < len; i++) {
	            n = ary[i];
	            next = ary[i+1];
	            if(v === n) {
	                return i;
	            } else if(v > n && v < next) {
	                return (v - n) < (next - v) ? i : i+1;
	            }
	        }
	        return -1;
	    };
	    
	    Chart.clazzName = "Chart";
	};
	
	Chart.struct = function(ghca_charts) {
		var BaseComponent = ghca_charts.view.component.baseComponent;
		BaseComponent.struct(ghca_charts);
	    Chart.prototype = Object.create(BaseComponent.prototype);
	    Chart.prototype.constructor = Chart;
	};
	
	// --------------------------------------------------------------------------
	//
	// Const
	//
	// --------------------------------------------------------------------------
	
	//背景层级，固定为0
	Chart.BG_Z_INDEX = 0;
	
	//坐标轴层级，固定为1
	Chart.AXIS_Z_INDEX = 1;
	
	//坐标轴热区容器层级，固定为2
	Chart.AXIS_HOTAREA_CONTAINER_Z_INDEX = 2;
	
	//图表层级，范围为10-1000
	Chart.CHART_MIN_Z_INDEX = 10;
	Chart.CHART_MAX_Z_INDEX = 1000;
	
	//坐标轴聚焦辅助线容器层级，固定为1100
	Chart.FOCUS_CONTAINER_Z_INDEX = 1100;
	
	//坐标轴分割线容器层级，固定为1110
	Chart.SPLIT_CONTAINER_Z_INDEX = 1110;
	
	//水平框选组件容器层级，固定为1120
	Chart.HSLIDER_CONTAINER_Z_INDEX = 1120;
	
	//图例层级，固定为1200
	Chart.LEGEND_Z_INDEX = 1200;
	
	//标题层级，固定为1900
	Chart.HEADING_Z_INDEX = 1900;
	
	//边框容器层级，固定为2000
	Chart.BORDER_CONTAINER_Z_INDEX = 2000;
	
	module.exports = Chart;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {// 业务拓扑图类
	    
	/**
	 * 构造方法 
	 * @param _data 拓扑图配置数据
	 * @param _layout 拓扑图布局对象，不传就为默认布局
	 */
	var EditorTopology = function(_data, _layout) {
	    
	    // --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const BaseComponent = ghca_charts.view.component.baseComponent;
	    const Plugin = ghca_charts.view.elements.plugins.plugin;
	    const BaseChart = ghca_charts.view.component.charts.baseChart;
	    const TopoLayout = ghca_charts.layout.topoLayout;
	    const ClassFactory = ghca_charts.view.util.classFactory;
	    const DataParser = ghca_charts.view.util.dataParser;
	    const Const = ghca_charts.view.util.constant;
	    const ObjectUtil = ghca_charts.view.util.objectUtil;
	    const BaseEvent = ghca_charts.events.BaseEvent;
	    const Node = ghca_charts.view.elements.plugins.nodes.node;
	    const GroupNode = ghca_charts.view.elements.plugins.nodes.groupNode;
	    const math = ghca_charts.view.util.math;
	    const EventUtil = ghca_charts.view.util.eventUtil;
	    const MouseUtil = ghca_charts.view.util.mouseUtil;
	    const RegexUtil = ghca_charts.view.util.regexUtil;
	    const UUIDUtil = ghca_charts.view.util.UUIDUtil;
	    const Global = ghca_charts.global;
	
	    BaseChart.apply(this, arguments);
	
	    var self = this,
	        superInit = self.init,
	        superInitAllContainers = self.initAllContainers,
	        superAddListeners = self.addListeners,
	        superRenderPosition = self.renderPosition,
	        superRefreshData = self.refreshData,
	        superSetData = self.setData,
	        nodesInsMap = {},
	        linksInsMap = {},
	        groupsInsMap = {},
	        isValidateMode = false,
	        isInFocus = false,
	        changeData = {
	            nodes:{enter:{}, update:{}}, 
	            links:{enter:{}, update:{}}, 
	            groups:{enter:{}, update:{}}
	        };//数据变更集
	    var dragMoveX,dragMoveY;
	
	    self.className("seriesTopo");
	    //添加可从配置文件读取的属性名称
	    self.addAttributes("showLevel", "mode", "focusEffect");
	    
	    // --------------------------------------------------------------------------
	    //
	    // Attributes
	    //
	    // --------------------------------------------------------------------------
	
	    // ------------------------------
	    // showLevel
	    // ------------------------------
	    
	    /**
	     * 设置节点显示层级，默认全部节点都显示
	     * (暂时没有实现)
	     */
	    var showLevel = EditorTopology.SHOW_ALL_LEVEL_NODES;
	    this.showLevel = function(value) {
	        if (!arguments.length)
	            return showLevel;
	        showLevel = value;
	        if(_data) {
	            _data.showLevel = value;
	        }
	        return this;
	    };
	    
	    // ------------------------------
	    // mode
	    // ------------------------------
	    
	    /**
	     * 组件模式，normal|edit，默认为普通模式
	     */
	    var mode = "normal";
	    this.mode = function(value) {
	        if (!arguments.length)
	            return mode;
	        if(mode !== value) {
	            isValidateMode = true;
	        }
	        mode = value;
	        if(_data) {
	            _data.mode = value;
	        }
	        return this;
	    };
	    
	    // ------------------------------
	    // focusEffect
	    // ------------------------------
	        
	    /**
	     * 鼠标单击节点时，是否显示凸显效果(默认值true)
	     */
	    var focusEffect = true;
	    this.focusEffect = function(value) {
	        if (!arguments.length) return focusEffect;
	        focusEffect = value;
	        if(_data) {
	            _data.focusEffect = value;
	        }
	        return this;
	    };
	    
	    // ------------------------------
	    // isEditMode
	    // ------------------------------
	    
	    /**
	     * 组件是否处于编辑模式，默认为否
	     */
	    this.isEditMode = function() {
	        return mode === "edit";
	    };
	    
	    // ------------------------------
	    // selectedItems
	    // ------------------------------
	    
	    /**
	     * 当前选中的项数据对象数组
	     */
	    var selectedNodeItems = [];
	    this.selectedNodeItems = function(value) {
	        if (!arguments.length){
	            selectedNodeItems.length=0;
	            for(var i=0;i<self.nodes.length;i++){
	                if(self.nodes[i].ins&&self.nodes[i].ins.selected()){
	                    selectedNodeItems.push(self.nodes[i]);
	                }
	            }
	            return selectedNodeItems;
	        }
	            
	        selectedNodeItems = value;
	        return this;
	    };
	
	
	    this.calCurrentSelected
	
	    /**
	     * 当前选中的项数据对象数组
	     */
	    var selectedLinkItems = [];
	    this.selectedLinkItems = function(value) {
	        if (!arguments.length)
	            return selectedLinkItems;
	        selectedLinkItems = value;
	        return this;
	    };
	    /**
	     * 当前选中的项数据对象数组
	     */
	    var selectedGroupItems = [];
	    this.selectedGroupItems = function(value) {
	        if (!arguments.length)
	            return selectedGroupItems;
	        selectedGroupItems = value;
	        return this;
	    };
	
	
	    // --------------------------------------------------------------------------
	    //
	    // override Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    var autoGroupKeys;
	
	    /**
	     * 初始化方法
	     */
	    this.init = function() {
	        superInit();
	        self.layout().init();
	        self.nodes = self.layout().nodes();
	        self.links = self.layout().links();
	
	        self.groups = [];
	        self.nodesIns = [];
	        self.linksIns = [];
	        self.groupsIns = [];
	        autoGroupKeys=self.data().renderers.groupNode&&self.data().renderers.groupNode.autoGroupKeys&&self.data().renderers.groupNode.autoGroupKeys.split(",");//以逗号为分割的属性名，属性值相同的就是一个组     
	        autoGroupKeys=autoGroupKeys?autoGroupKeys:"";
	        //添加初始化数据中的所有节点和连线和节点分组内容
	        self.addNodes(self.data().nodes);
	        self.addLinks(self.data().links);
	        self.addGroups(self.data().groups);
	        self.addAutoGroupNodes(self.data().nodes);
	        
	        self.visibleItems(self.nodes);
	    };
	    
	    /**
	     * 初始化图表包含的各个层级
	     */
	    this.initAllContainers = function() {
	        superInitAllContainers();
	        
	        
	        //放置所有背景的g元素
	        var bgNodeContainer = new BaseComponent();
	        bgNodeContainer.className("topo-bgContainer");
	        self.addChild(bgNodeContainer);
	        self.bgNodeContainer = bgNodeContainer;
	
	        //放置所有连线节点组背景的g元素
	        var groupsContainer = new BaseComponent();
	        groupsContainer.className("topo-groupsContainer");
	        self.addChild(groupsContainer);
	        groupsContainer.mainContainer().attr("pointer-events", "none");
	        self.groupsContainer = groupsContainer;
	        
	        //放置所有连线的g元素
	        var linksContainer = new BaseComponent();
	        linksContainer.className("topo-linksContainer");
	        self.addChild(linksContainer);
	        self.linksContainer = linksContainer;
	        
	        //放置所有节点的g元素
	        var nodesContainer = new BaseComponent();
	        nodesContainer.className("topo-nodesContainer");
	        self.addChild(nodesContainer);
	        self.nodesContainer = nodesContainer;
	    };
	    
	    /**
	     * 初始化添加所有监听的方法
	     */
	    this.addListeners = function() {
	        superAddListeners();
	        //若点不固定，则添加实时刷新数据监听
	
	        // self.model.on("tick", self.tickHandler);
	        self.model.on("end", self.tickEndHandler);
	
	        self.addEventListener(BaseEvent.MODE_CHANGE, modeChangeHandler);
	        //self.addEventListener(BaseEvent.EV_EVENT_OPEN_EDIT, openEditHandler);
	        self.addEventListener(BaseEvent.SEARCH_TEXT, searchTextHandler);
	        self.addEventListener(BaseEvent.TOPO_NODE_FOCUS_IN, topoNodeFocusInHandler);
	        
	        self.mainContainer().node().addEventListener(BaseEvent.EAGLE_EYE_DRAG, function(e) {
	            event.stopImmediatePropagation();
	            var detail = e.detail;
	            self.x(detail.x);
	            self.y(detail.y);
	            self.renderTransform();
	        });
	
	        self.parent().mainContainer().on("mousedown.edit", edit_mouseDownHandler);
	         self.parent().mainContainer().on("mousemove.edit", edit_mouseMoveHandler);
	        self.parent().mainContainer().on("mouseup.edit", edit_mouseUpHandler);
	    };
	    
	    /**
	     * 刷新数据内容，生成需要的属性和相关值
	     */
	   this.refreshData = function() {
	        superRefreshData();
	        var  nodes = self.nodes,
	             links = self.links,
	             groups = self.groups,
	             level = self.showLevel();
	        
	        //根据showLevel设置每一个节点是否可见，以及是否展开
	        for(var node, nodeLevel, nodeEnabledExpand, i = 0, len = nodes.length; i < len; i++) {
	            node = nodes[i];
	            node.bindKey = i;
	            if(node.hasOwnProperty("visible")) {
	                continue;
	            }
	            nodeLevel = node.level === undefined ? 0 : node.level;  
	            nodeEnabledExpand = node.enabledExpand === undefined ? false : node.enabledExpand;  
	            if(nodeLevel < level) {
	                node.visible = true;
	                if(nodeEnabledExpand) {
	                    node.isExpanded = true;
	                }
	            } else if(nodeLevel == level) {
	                node.visible = true;
	                if(nodeEnabledExpand) {
	                    node.isExpanded = false;
	                }
	            } else {
	                node.visible = false;
	                if(nodeEnabledExpand) {
	                    node.isExpanded = false;
	                }
	            }
	        }
	
	        for(var link, i = 0, len = links.length; i < len; i++) {
	            link = links[i];
	            link.bindKey = i;
	            if(link.hasOwnProperty("visible")) {
	                continue;
	            }
	            link.visible = true;
	        }
	        
	        for(var group, i = 0, len = groups.length; i < len; i++) {
	            group = groups[i];
	            group.bindKey = i;
	            if(group.hasOwnProperty("visible")) {
	                continue;
	            }
	            group.visible = true;
	        }
	    };
	    
	    /**
	     * 渲染图表内容相关位置 
	     * @param isRenderByChange 是否根据当前变更集渲染
	     */
	    this.renderPosition = function(isRenderByChange) {
	        superRenderPosition();
	        
	        var nodesIns = self.nodesIns;
	        for(var nodeIns, i = 0, len = nodesIns.length; i < len; i++) {
	            nodeIns = nodesIns[i];
	            nodeIns.mainContainer().each(function(d) {
	                //在按照变更集刷新模式下检测当前数据对象是否在变更集中
	                if(isRenderByChange && !isItemInChangeData(d, changeData.nodes.enter)) {
	                    return;
	                }
	               
	                if(d.ins.selected()){
	                    d.x+=dragMoveX;
	                    d.y+=dragMoveY;
	                }
	               nodeIns.x(Math.round(d.x));
	               nodeIns.y(Math.round(d.y));
	               nodeIns.renderTransform();
	            });
	        }
	        dragMoveX=dragMoveY=0;
	        
	        var linksIns = self.linksIns;
	        for(var linkIns, i = 0, len = linksIns.length; i < len; i++) {
	            linkIns = linksIns[i];
	            //在按照变更集刷新模式下检测当前数据对象是否在变更集中
	            if(isRenderByChange && !isItemInChangeData(linkIns.mainContainer().node().__data__, changeData.links.enter)) {
	                continue;
	            }
	            if(linkIns.normalChild()){
	                linkIns.normalChild().update();
	            } else {
	                linkIns.render();
	            }
	        }
	        
	        //刷新所有节点组path数据
	        refreshGroupsData();
	        var groupsIns = self.groupsIns;
	        for(var groupIns, i = 0, len = groupsIns.length; i < len; i++) {
	            groupIns = groupsIns[i];
	            //在按照变更集刷新模式下检测当前数据对象是否在变更集中
	            if(isRenderByChange && !isItemInChangeData(groupIns.mainContainer().node().__data__, changeData.groups.enter)) {
	                continue;
	            }
	            if(groupIns.normalChild()){
	                groupIns.normalChild().update();
	            } else {
	                groupIns.render();
	            }
	        }
	
	        //触发鹰眼变更
	        self.sendMsgToEye(fireContentChange, 1000);
	    };
	    
	
	    // function getLinksBydata(nodes,linksData){//和节点匹配的连线
	    //     var list=[];       
	    //     var newLinks=[];
	    //     for(var i=0,d,len=linksData.length;i<len;i++){
	    //         d=linksData[i];
	    //         if(nodes.indexOf(d.source)!=-1&&nodes.indexOf(d.target)!=-1){//连线的source和target都在节点里面
	    //             list.push(d);
	    //         }else{
	    //             newLinks.push(d);
	    //         }
	    //     }
	    //     return [list,newLinks];
	    // }
	
	    /**
	     * 根据当前数据重新渲染内容，并重新计算布局内容
	     */
	    this.update = function(isUpdateByChange,isResize) {
	        // if(updateTimer!=0){
	        //     clearInterval(updateTimer);
	        //     updateTimer=0;
	        // }
	        // self.newUpdate();
	        // return;
	
	        if(Global.isDebug) {
	    		var otAll = new Date().getTime();
	    	}
	
	        //刷新当前数据
	        self.refreshData();
	
	        //只用当前可见的项作为渲染数据源
	        self.visibleItems(self.filterArrayByElementProperty(self.nodes, "visible", true));
	
	        //计算布局
	        self.layout().update(isResize);
	        if(Global.isDebug) {
	        	var nt = new Date().getTime();
	            console.log("update refreshData and layout cost time " + (nt-ot1) + " ms.");
	        }
	
	        //更新节点
	        updateNodes(isUpdateByChange);
	        //更新连线
	        updateLinks(isUpdateByChange);
	        //更新节点组
	        updateGroups(isUpdateByChange);
	        
	        if(Global.isDebug) {
	        	var nt = new Date().getTime();
	        }
	        //若是固定节点模式，移动所有对象正确位置
	        if(self.layout().fixed()) {
	            self.renderPosition(isUpdateByChange);
	        }
	        if(Global.isDebug) {
	        	var nt = new Date().getTime();
	            console.log("renderPosition cost time " + (nt-ot) + " ms.");
	        }
	
	        //清空变更集
	        clearChangeData();
	        
	        //等待初始化完成再验证mode是否改变，否则会出现各种问题
	        var timer = setTimeout(function() {
	            clearTimeout(timer);
	            validateMode();
	        }, 0);
	        
	        if(Global.isDebug) {
	        	var ntAll = new Date().getTime();
	            console.log("update cost time " + (ntAll-otAll) + " ms.");
	        }
	
	        
	        // /*这里先清除所有的连线和节点元素，然后再创建新的数据，否则动态添加的数据显示会有重复的问题。
	        //                             但是这样做在ie和edge中会造成闪烁，且效率极低，有待优化。*/
	        
	        // var linksContainer = self.linksContainer;
	        // linksContainer.removeAllChildren();
	        // self.linksIns.length = 0;
	        // var bgNodeContainer = self.bgNodeContainer;
	        // bgNodeContainer.removeAllChildren();
	        // var nodesContainer = self.nodesContainer;
	        // nodesContainer.removeAllChildren();
	        // self.nodesIns.length = 0;
	        // var groupsContainer = self.groupsContainer;
	        // groupsContainer.removeAllChildren();
	        // self.groupsIns.length = 0;
	
	        
	        // //只用当前可见的节点作为渲染数据源
	        // var nodesData = self.visibleItems();
	        // //若节点渲染器是一个组件，则重新设置一些配置数据
	        // for(var i = 0, len = nodesData.length; i < len; i++) {
	        //     var nodeData = nodesData[i];
	        //     var rendererConfig = self.getRendererConfig(nodeData, "fill");
	        //     if(rendererConfig && rendererConfig.type === "chart" && rendererConfig.series) {
	        //         var chartData, series = rendererConfig.series;
	        //         for(var j = 0, len1 = series.length; j < len1; j++) {
	        //             chartData = series[j];
	        //             //这里config设置的width和height值无效，渲染器组件宽高为线的高度值
	        //             chartData.width = rendererConfig.width ? rendererConfig.width : 0;
	        //             chartData.height = rendererConfig.height ? rendererConfig.height : 0;
	        //             //pie的位置特殊处理
	        //             if(chartData.type === "pie") {
	        //                 rendererConfig.x = -chartData.width / 2;
	        //                 rendererConfig.y = -chartData.height / 2;
	        //             }
	        //             //组装图表数据
	        //             DataParser.createChartData(chartData, nodeData);
	        //         }
	        //     }
	        // }
	        // // console.log("DataParser 耗时:"+(new Date().getTime()-ot));
	        // // ot=new Date().getTime();
	        // //渲染节点内容
	        // var bgNodes=[];
	        // var normalNodes=[];
	        // for(var i=0;i<nodesData.length;i++){
	        //     if(nodesData[i].isBg){
	        //         bgNodes.push(nodesData[i]);
	        //     }else{
	        //         normalNodes.push(nodesData[i]);
	        //     }
	        // }
	        // // console.log("nodeIns 数据组装耗时:"+(new Date().getTime()-ot));
	        // // ot=new Date().getTime();
	        // var nodesBgIns = ClassFactory.newRenderersInstanceByData(bgNodeContainer, self, "bgNodeContainer", bgNodes);
	        // // console.log("nodesBgIns 创建耗时:"+(new Date().getTime()-ot));
	        // // ot=new Date().getTime();
	        // var nodesNormalIns = ClassFactory.newRenderersInstanceByData(nodesContainer, self, "nodeContainer", normalNodes);//耗时严重
	        // // console.log("nodesNormalIns 创建耗时:"+(new Date().getTime()-ot));
	        // // ot=new Date().getTime();
	        // var nodesIns=nodesBgIns.concat(nodesNormalIns);
	        // // console.log("nodeIns 创建耗时:"+(new Date().getTime()-ot));
	        // // ot=new Date().getTime();
	
	        // if(nodesIns) {
	        //     for(var nodeIns, i = 0, len = nodesIns.length; i < len; i++) {
	        //         nodeIns = nodesIns[i];
	        //         //添加子节点收放按钮点击监听，可控制节点的展开,合拢
	        //         nodeIns.addEventListener("expandTool_collapsed", expandToolClickHandler);
	        //         //添加节点单击监听，点击节点自动居中，显示子级节点，淡化其他节点
	        //         nodeIns.addEventListener("click", nodeClickHandler);              
	        //         self.nodesIns.push(nodeIns);
	        //         //添加节点拖拽监听
	        //     }
	        //     if (self.isEditMode() == false) {
	        //         setListenersInNormal();
	        //     } else {
	        //         setListenersInEditLink();
	        //     }
	        // }
	        // // console.log("nodeIns 监听耗时:"+(new Date().getTime()-ot));
	        // // ot=new Date().getTime();
	
	        // //只用当前可见的连线作为渲染数据源
	        // var linksData = self.getVisibleLinks(self.links);
	        // //渲染连线内容   
	        // var linksIns = ClassFactory.newRenderersInstanceByData(linksContainer, self, "linkContainer", linksData, false, "stroke");
	        // if(linksIns) {
	        //     for(var linkIns, i = 0, len = linksIns.length; i < len; i++) {
	        //         linkIns = linksIns[i];
	        //         self.linksIns.push(linkIns);
	        //     }
	        // }
	        // // console.log("linksIns 耗时:"+(new Date().getTime()-ot));
	        // // ot=new Date().getTime();
	        
	        // //用当前可见的点渲染节点组
	        // resetAutoGroups();
	        // var groupsData = self.groups;
	        // //刷新所有节点组path数据
	        // refreshGroupsData();
	        // var groupsIns = ClassFactory.newRenderersInstanceByData(groupsContainer, self, "groupContainer", groupsData);
	        // if(groupsIns) {
	        //     for(var groupIns, i = 0, len = groupsIns.length; i < len; i++) {
	        //         groupIns = groupsIns[i];
	        //         self.groupsIns.push(groupIns);
	        //     }
	        // }
	        // // console.log("groupsIns 耗时:"+(new Date().getTime()-ot));
	        // // ot=new Date().getTime();
	        // if(self.layout().fixed()) {
	        //     self.renderPosition();
	        // }
	        // // console.log("renderPosition耗时:"+(new Date().getTime()-ot));
	        // // console.log("渲染topo耗时:"+(new Date().getTime()-st));
	
	        
	        // //等待初始化完成再验证mode是否改变，否则会出现各种问题
	        // var timer = setTimeout(function() {
	        //     clearTimeout(timer);
	        //     validateMode();
	        // }, 0);
	    };
	    
	    /**
	     * 设置数据内容
	     * @param value 数据内容，格式为：{data:[]}或者{nodes:[],links:[]}等
	     * @return 返回是否设置成功
	     */
	    this.setData = function(value) {
	        var result = superSetData(value);
	        
	        self.layout().nodes().length = 0;
	        self.layout().links().length = 0;
	        self.nodes.length = 0;
	        self.links.length = 0;
	        self.groups.length = 0;
	        // self.nodesIns.length = 0;
	        // self.linksIns.length = 0;
	        // self.groupsIns.length = 0;
	
	        autoGroupKeys=self.data().renderers.groupNode&&self.data().renderers.groupNode.autoGroupKeys&&self.data().renderers.groupNode.autoGroupKeys.split(",");
	        autoGroupKeys=autoGroupKeys?autoGroupKeys:"";
	
	        //添加初始化数据中的所有节点和连线
	        self.addNodes(self.data().nodes);
	        self.addLinks(self.data().links);
	        self.addGroups(self.data().groups);
	        self.addAutoGroupNodes(self.data().nodes);
	        return result;
	    };
	    
	     /**
	     * 更新节点内容
	     * @param isUpdateByChange 是否按照变更集刷新
	     */
	    var updateNodes = function(isUpdateByChange) {
	        //只用当前可见的节点作为渲染数据源
	        var nodesData = self.visibleItems();
	
	        //编辑器这边区分了背景节点和普通节点
	        var bgNodes=[];
	        var normalNodes=[];
	        for(var i=0;i<nodesData.length;i++){
	            if(nodesData[i].isBg){
	                bgNodes.push(nodesData[i]);
	            }else{
	                normalNodes.push(nodesData[i]);
	            }
	        }
	
	
	        //渲染节点内容
	        var bgUpdate = self.bgNodeContainer.mainContainer().selectAll("g.bgNodeContainer")
	            .data(bgNodes, self.bindKeyFn);
	        var normalUpdate = self.nodesContainer.mainContainer().selectAll("g.nodeContainer")
	            .data(normalNodes, self.bindKeyFn);
	        if(Global.isDebug) {
	            var ot = new Date().getTime();
	        }
	        //update
	        bgUpdate.each(function(d) {
	            //在按照变更集刷新模式下检测当前数据对象是否在变更集中
	            if(isUpdateByChange && !isItemInChangeData(d, changeData.nodes.update)) {
	                return;
	            }
	             //根据配置刷新数据内容
	            self.getRendererConfig(d, "fill");
	            var key = self.bindKeyFn(d);
	            var ins = nodesInsMap[key];
	            if(ins) {
	                var child = ins.normalChild();
	                if(child instanceof Plugin) {
	                    child.data(d);
	                    child.config(d.data.config);
	                    child.update();
	                    d.ins = child;
	                    d.legendIns = child;
	                    d.dragIns = ins;
	                    return;
	                }
	                var children = ins.children();
	                children.forEach(function(child) {
	                    if(child instanceof BaseComponent) {
	                        child.setDataAndUpdate(d);
	                        d.ins = child;
	                        d.legendIns = child;
	                        d.dragIns = ins;
	                    }
	                })
	            }
	        });
	        normalUpdate.each(function(d) {
	            //在按照变更集刷新模式下检测当前数据对象是否在变更集中
	            if(isUpdateByChange && !isItemInChangeData(d, changeData.nodes.update)) {
	                return;
	            }
	            self.getRendererConfig(d, "fill");
	            var key = self.bindKeyFn(d);
	            var ins = nodesInsMap[key];
	            if(ins) {
	                var child = ins.normalChild();
	                if(child instanceof Plugin) {
	                    child.data(d);
	                    child.config(d.data.config);
	                    child.update();
	                    d.ins = child;
	                    d.legendIns = child;
	                    d.dragIns = ins;
	                    return;
	                }
	                var children = ins.children();
	                children.forEach(function(child) {
	                    if(child instanceof BaseComponent) {
	                        child.setDataAndUpdate(d);
	                        d.ins = child;
	                        d.legendIns = child;
	                        d.dragIns = ins;
	                    }
	                })
	            }
	        });
	
	
	        if(Global.isDebug) {
	            var nt = new Date().getTime();
	            console.log("nodes update cost time " + (nt-ot) + " ms.");
	        }
	        
	        if(Global.isDebug) {
	            var ot = new Date().getTime();
	        }
	        //enter
	        var nodesEnter = [];
	        bgUpdate.enter().each(function(d) {
	            nodesEnter.push(d);
	            //若节点渲染器是一个组件，则重新设置一些配置数据
	            var nodeData = d;
	            var rendererConfig = self.getRendererConfig(nodeData, "fill");
	            if(rendererConfig && rendererConfig.type === "chart" && rendererConfig.series) {
	                var chartData, series = rendererConfig.series;
	                for(var j = 0, len1 = series.length; j < len1; j++) {
	                    chartData = series[j];
	                    //这里config设置的width和height值无效，渲染器组件宽高为线的高度值
	                    chartData.width = rendererConfig.width ? rendererConfig.width : 0;
	                    chartData.height = rendererConfig.height ? rendererConfig.height : 0;
	                    //pie的位置特殊处理
	                    if(chartData.type === "pie") {
	                        rendererConfig.x = -chartData.width / 2;
	                        rendererConfig.y = -chartData.height / 2;
	                    }
	                    //组装图表数据
	                    
	                    DataParser.createChartData(chartData, nodeData);
	                }
	            }
	            var nodesIns = ClassFactory.newRenderersInstanceByData(self.bgNodeContainer, self, "bgNodeContainer", [d]);
	            if(nodesIns) {
	                for(var nodeIns, i = 0, len = nodesIns.length; i < len; i++) {
	                    nodeIns = nodesIns[i];
	                    //添加子节点收放按钮点击监听，可控制节点的展开,合拢
	                    nodeIns.addEventListener("expandTool_collapsed", expandToolClickHandler);
	                    //添加节点单击监听，点击节点自动居中，显示子级节点，淡化其他节点
	                    nodeIns.addEventListener("click", nodeClickHandler);
	                    // nodeIns.addEventListener("mouseover", nodeMouseOverHandler);
	                    // nodeIns.addEventListener("mouseout", nodeMouseOutHandler);
	                    //添加节点拖拽监听
	                    if(self.isEditMode()===false&&self.dragNodeAble()===true){
	                        nodeIns.mainContainer().call(d3.drag()
	                        .on("start", self.node_dragStartHandler)
	                        .on("drag", self.node_dragHandler)
	                        .on("end", self.node_dragEndHandler));
	                    }
	                    self.nodesIns.push(nodeIns);
	                    var key = self.bindKeyFn(d);
	                    nodesInsMap[key] = nodeIns;
	                }
	            }
	        });
	
	        normalUpdate.enter().each(function(d) {
	            nodesEnter.push(d);
	            //若节点渲染器是一个组件，则重新设置一些配置数据
	            var nodeData = d;
	            var rendererConfig = self.getRendererConfig(nodeData, "fill");
	            if(rendererConfig && rendererConfig.type === "chart" && rendererConfig.series) {
	                var chartData, series = rendererConfig.series;
	                for(var j = 0, len1 = series.length; j < len1; j++) {
	                    chartData = series[j];
	                    //这里config设置的width和height值无效，渲染器组件宽高为线的高度值
	                    chartData.width = rendererConfig.width ? rendererConfig.width : 0;
	                    chartData.height = rendererConfig.height ? rendererConfig.height : 0;
	                    //pie的位置特殊处理
	                    if(chartData.type === "pie") {
	                        rendererConfig.x = -chartData.width / 2;
	                        rendererConfig.y = -chartData.height / 2;
	                    }
	                    //组装图表数据
	                    DataParser.createChartData(chartData, nodeData);
	                }
	            }
	            var nodesIns = ClassFactory.newRenderersInstanceByData(self.nodesContainer, self, "nodeContainer", [d]);
	            if(nodesIns) {
	                for(var nodeIns, i = 0, len = nodesIns.length; i < len; i++) {
	                    nodeIns = nodesIns[i];
	                    //添加子节点收放按钮点击监听，可控制节点的展开,合拢
	                    nodeIns.addEventListener("expandTool_collapsed", expandToolClickHandler);
	                    //添加节点单击监听，点击节点自动居中，显示子级节点，淡化其他节点
	                    nodeIns.addEventListener("click", nodeClickHandler);
	                    // nodeIns.addEventListener("mouseover", nodeMouseOverHandler);
	                    // nodeIns.addEventListener("mouseout", nodeMouseOutHandler);
	                    //添加节点拖拽监听
	                    if(self.isEditMode()===false&&self.dragNodeAble()===true){
	                        nodeIns.mainContainer().call(d3.drag()
	                        .on("start", self.node_dragStartHandler)
	                        .on("drag", self.node_dragHandler)
	                        .on("end", self.node_dragEndHandler));
	                    }
	                    self.nodesIns.push(nodeIns);
	                    var key = self.bindKeyFn(d);
	                    nodesInsMap[key] = nodeIns;
	                }
	            }
	        });
	
	        //添加新建节点数据到变更集
	        addItemsToChangeData(nodesEnter, changeData.nodes.enter);
	        if(Global.isDebug) {
	            var nt = new Date().getTime();
	            console.log("nodes enter cost time " + (nt-ot) + " ms.");
	        }
	        
	        if(Global.isDebug) {
	            var ot = new Date().getTime();
	        }
	        
	        //delete
	        var nodesExit = bgUpdate.exit();
	        nodesExit.each(function(d) {
	            var key = self.bindKeyFn(d);
	            if(nodesInsMap.hasOwnProperty(key)) {
	                delete nodesInsMap[key];
	            }
	            var index = self.nodesIns.indexOf(d.dragIns);
	            if(index !== -1) {
	                self.nodesIns.splice(index, 1);
	            }
	        }).remove();
	        nodesExit = normalUpdate.exit();
	        nodesExit.each(function(d) {
	            var key = self.bindKeyFn(d);
	            if(nodesInsMap.hasOwnProperty(key)) {
	                delete nodesInsMap[key];
	            }
	            var index = self.nodesIns.indexOf(d.dragIns);
	            if(index !== -1) {
	                self.nodesIns.splice(index, 1);
	            }
	        }).remove();
	        if(Global.isDebug) {
	            var nt = new Date().getTime();
	            console.log("nodes remove cost time " + (nt-ot) + " ms.");
	        }
	    };
	
	    /**
	     * 更新连线内容
	     * @param isUpdateByChange 是否按照变更集刷新
	     */
	    var updateLinks = function(isUpdateByChange) {
	        //只用当前可见的连线作为渲染数据源
	        var linksData = self.getVisibleLinks(self.links);
	        //渲染连线内容   
	        var linksUpdate = self.linksContainer.mainContainer().selectAll("g.linkContainer")
	            .data(linksData, self.bindKeyFn);
	        if(Global.isDebug) {
	            var ot = new Date().getTime();
	        }
	        //update
	        linksUpdate.each(function(d){
	            //在按照变更集刷新模式下检测当前数据对象是否在变更集中
	            if(isUpdateByChange && !isItemInChangeData(d, changeData.links.update)) {
	                return;
	            }
	             //根据配置刷新数据内容
	             self.getRendererConfig(d, "stroke");
	            var key = self.bindKeyFn(d);
	            var ins = linksInsMap[key];
	            if(ins) {
	                var child = ins.normalChild();
	                if(child instanceof Plugin) {
	                    child.data(d);
	                    child.config(d.data.config);
	                    child.update();
	                    d.ins = child;
	                    d.legendIns = child;
	                    d.dragIns = ins;
	                    return;
	                }
	                var children = ins.children();
	                children.forEach(function(child) {
	                    if(child instanceof BaseComponent) {
	                        child.setDataAndUpdate(d);
	                        d.ins = child;
	                        d.legendIns = child;
	                        d.dragIns = ins;
	                    }
	                })
	            }
	        });
	        if(Global.isDebug) {
	            var nt = new Date().getTime();
	            console.log("link update cost time " + (nt-ot) + " ms.");
	        }
	        if(Global.isDebug) {
	            var ot = new Date().getTime();
	        }
	        //enter
	        var linksEnter = [];
	        linksUpdate.enter().each(function(d) {
	            linksEnter.push(d);
	            var linksIns = ClassFactory.newRenderersInstanceByData(self.linksContainer, self, "linkContainer", [d], false, "stroke");
	            if(linksIns) {
	                for(var linkIns, i = 0, len = linksIns.length; i < len; i++) {
	                    linkIns = linksIns[i];
	                    self.linksIns.push(linkIns);
	                    var key = self.bindKeyFn(d);
	                    linksInsMap[key] = linkIns;
	                }
	            }
	        });
	        //添加新建连线数据到变更集
	        addItemsToChangeData(linksEnter, changeData.links.enter);
	        if(Global.isDebug) {
	            var nt = new Date().getTime();
	            console.log("link enter cost time " + (nt-ot) + " ms.");
	        }
	        if(Global.isDebug) {
	            var ot = new Date().getTime();
	        }
	        //delete
	        var linksExit = linksUpdate.exit();
	        linksExit.each(function(d) {
	            var key = self.bindKeyFn(d);
	            if(linksInsMap.hasOwnProperty(key)) {
	                delete linksInsMap[key];
	            }
	            var index = self.linksIns.indexOf(d.dragIns);
	            if(index !== -1) {
	                self.linksIns.splice(index, 1);
	            }
	        }).remove();
	        if(Global.isDebug) {
	            var nt = new Date().getTime();
	            console.log("link remove cost time " + (nt-ot) + " ms.");
	        }
	    };
	    
	     /**
	     * 更新节点组内容
	     * @param isUpdateByChange 是否按照变更集刷新
	     */
	    var updateGroups = function(isUpdateByChange) {
	        /*
	        var groupsContainer = self.groupsContainer;
	        groupsContainer.removeAllChildren();
	        self.groupsIns.length = 0;
	         //用当前可见的点渲染节点组
	         var groupsData = self.groups;
	         //刷新所有节点组path数据
	         refreshGroupsData();
	         var groupsIns = ClassFactory.newRenderersInstanceByData(groupsContainer, self, "groupContainer", groupsData);
	         if(groupsIns) {
	             for(var groupIns, i = 0, len = groupsIns.length; i < len; i++) {
	                 groupIns = groupsIns[i];
	                 self.groupsIns.push(groupIns);
	                }
	            }
	        return*/
	        
	        
	        //用当前可见的点渲染节点组
	        var groupsData = self.groups;
	        //刷新所有节点组path数据
	        if(Global.isDebug) {
	            var ot = new Date().getTime();
	        }
	        resetAutoGroups();
	        refreshGroupsData();
	        if(Global.isDebug) {
	            var nt = new Date().getTime();
	            console.log("refreshGroupsData cost time " + (nt-ot) + " ms.");
	        }
	        var groupsUpdate = self.groupsContainer.mainContainer().selectAll("g.groupContainer")
	            .data(groupsData, self.bindKeyFn);
	        if(Global.isDebug) {
	            var ot = new Date().getTime();
	        }
	        //update
	        groupsUpdate.each(function(d){
	            //在按照变更集刷新模式下检测当前数据对象是否在变更集中
	            if(isUpdateByChange && !isItemInChangeData(d, changeData.groups.update)) {
	                return;
	            }
	            //根据配置刷新数据内容
	            self.getRendererConfig(d, "fill");
	            var key = self.bindKeyFn(d);
	            var ins = groupsInsMap[key];
	            if(ins) {
	                var child = ins.normalChild();
	                if(child instanceof Plugin) {
	                    child.data(d);
	                    child.update();
	                    d.ins = child;
	                    d.legendIns = child;
	                    d.dragIns = ins;
	                    return;
	                }
	                var children = ins.children();
	                children.forEach(function(child) {
	                    if(child instanceof BaseComponent) {
	                        child.setDataAndUpdate(d);
	                        d.ins = child;
	                        d.legendIns = child;
	                        d.dragIns = ins;
	                    }
	                })
	            }
	        });
	        if(Global.isDebug) {
	            var nt = new Date().getTime();
	            console.log("group update cost time " + (nt-ot) + " ms.");
	        }
	        if(Global.isDebug) {
	            var ot = new Date().getTime();
	        }
	        //enter
	        var groupsEnter = [];
	        groupsUpdate.enter().each(function(d) {
	            groupsEnter.push(d);
	            var groupsIns = ClassFactory.newRenderersInstanceByData(self.groupsContainer, self, "groupContainer", [d]);
	            if(groupsIns) {
	                for(var groupIns, i = 0, len = groupsIns.length; i < len; i++) {
	                    groupIns = groupsIns[i];
	                    self.groupsIns.push(groupIns);
	                    var key = self.bindKeyFn(d);
	                    groupsInsMap[key] = groupIns;
	                }
	            }
	        });
	        //添加新建节点组数据到变更集
	        addItemsToChangeData(groupsEnter, changeData.groups.enter);
	        if(Global.isDebug) {
	            var nt = new Date().getTime();
	            console.log("group enter cost time " + (nt-ot) + " ms.");
	        }
	        if(Global.isDebug) {
	            var ot = new Date().getTime();
	        }
	        //delete
	        var groupsExit = groupsUpdate.exit();
	        groupsExit.each(function(d) {
	            var key = self.bindKeyFn(d);
	            if(groupsInsMap.hasOwnProperty(key)) {
	                delete groupsInsMap[key];
	            }
	            var index = self.groupsIns.indexOf(d.dragIns);
	            if(index !== -1) {
	                self.groupsIns.splice(index, 1);
	            }
	        }).remove();
	        if(Global.isDebug) {
	            var nt = new Date().getTime();
	            console.log("group remove cost time " + (nt-ot) + " ms.");
	        }
	    };
	
	
	    /**
	     * 刷新节点分组路径数据
	     */
	    var refreshGroupsData = function() {
	        var groupsData = self.groups;
	        for(var groupData, i = 0, len = groupsData.length; i < len; i++) {
	            groupData = groupsData[i];
	            setGroupPath(groupData);
	        }
	    };
	    
	    /**
	     * 设置节点分组路径字符串数据到节点分组数据对象中
	     * @param groupData 节点分组数据对象
	     */
	    var setGroupPath = function(groupData) {
	        //判断整个节点分组是否可见
	        if(groupData.visible === false) {
	            groupData.path = "";
	            groupData.pathPoints = [];
	            return;
	        }
	        var nodesData = groupData.nodes, points = [], 
	        radius = (groupData.data &&　groupData.data.hasOwnProperty("radius")) ?RegexUtil.replace(RegexUtil.dataRegex,groupData.data.radius,groupData): 20, 
	        extendedSize = (groupData.data &&　groupData.data.hasOwnProperty("extendedSize")) ? groupData.data.extendedSize : 10;
	        if(ObjectUtil.isString(radius)&&radius.indexOf("{")!=-1){
	            radius=20;
	        }
	        for(var ins, node, box, halfW, halfH, i = 0, len = nodesData.length; i < len; i++) {
	            node = nodesData[i];
	            if(!node.visible || !node.ins) {
	                continue;
	            }
	            ins = node.ins;
	//            box = ins instanceof BaseComponent ? ins.node().getBBox() : ins.mainPlugin.el.node().getBBox();
	            // box = ins instanceof BaseComponent ? ins.node().getBBox() : ins.mainPlugin.getBBox();
	            box = ins instanceof BaseComponent ? ins.getBBox() : ins.mainPlugin.getBBox();
	            halfW = box.width/2 + extendedSize;
	            halfH = box.height/2 + extendedSize;
	            points.push([node.x - halfW, node.y - halfH]);
	            points.push([node.x + halfW, node.y - halfH]);
	            points.push([node.x + halfW, node.y + halfH]);
	            points.push([node.x - halfW, node.y + halfH]);
	        }
	        var path = math.pointsToPolygonHullRoundPath(points, radius, false);
	        groupData.path = path;
	        groupData.pathPoints = points;
	    };
	    
	    var addNodeDragListeners = function() {
	        for(var nodeIns, nodesIns = self.nodesIns, i = 0, len = nodesIns.length; i < len; i++) {
	            nodeIns = nodesIns[i];
	            //添加节点拖拽监听
	            nodeIns.mainContainer().call(d3.drag()
	                .on("start", self.node_dragStartHandler)
	                .on("drag", self.node_dragHandler)
	                .on("end", self.node_dragEndHandler));
	        }
	    };
	    
	    var removeNodeDragListeners = function() {
	        for(var nodeIns, nodesIns = self.nodesIns, i = 0, len = nodesIns.length; i < len; i++) {
	            nodeIns = nodesIns[i];
	            //移除节点拖拽监听
	            nodeIns.mainContainer().on("mousedown.drag", null);
	        }
	    };
	
	
	    var dragNodeAble=true;
	    this.dragNodeAble=function(value){//能否拖拽节点
	        if(arguments.length===0){
	            return dragNodeAble;
	        }
	        dragNodeAble=value;
	        return this;
	    }
	    
	    var setListenersInNormal = function() {
	        self.addDragListeners();
	        if(self.dragNodeAble()){
	            addNodeDragListeners();
	        }
	    };
	    
	    var setListenersInEditLink = function() {
	        self.removeDragListeners();
	        removeNodeDragListeners();
	    };
	    
	    //override
	    this.toJSON = function(isData) {
	        var str = "";
	        var d = self.data();
	        if(!d) {
	            return str;
	        }
	        //清除数据属性节点的内容，然后克隆除数据内容外的配置内容，这样做是因为循环引用在toJson的时候会报错
	        var nodes = d.nodes;
	        var links = d.links;
	        var groups = d.groups;
	        if(nodes) {
	            d.nodes = [];
	        }
	        if(links) {
	            d.links = [];
	        }
	        if(groups) {
	            d.groups = [];
	        }
	        //根据需要的属性复制数据内容，下面是要排除的属性名称数组
	        var nodeKeys = ["collapsed", "data", "ins", "legendIns", "vx", "vy","index","links","cx","cy"];
	        var linkKeys = ["data", "ins","legendIns","lineIndex", "__proto__"];
	        var groupKeys = ["data", "ins","legendIns", "path","pathPoints"];
	        var getData = function(keys, data, isLink) {
	            var result = [];
	            if(isLink) {
	                for(var d, obj, i = 0, len = data.length; i < len; i++) {
	                    d = data[i];
	                    obj = {};
	                    result.push(obj);
	                    for(var k in d) {  
	                        if(keys.indexOf(k)==-1){
	                            obj[k]=d[k];
	                            if(k==="source"||k==="target"){
	                                obj[k]=d[k].id;
	                            }
	                        }
	                    }  
	                }
	            } else{
	                for(var d, obj, i = 0, len = data.length; i < len; i++) {
	                    d = data[i];
	                    obj = {};
	                    result.push(obj);
	                    for(var k in d) {  
	                        if(keys.indexOf(k)==-1){
	                            if(k==="nodes"&&keys===groupKeys){
	                                var nodes=d[k];
	                                obj[k]=[];
	                                for(var j=0;j<nodes.length;j++){
	                                    obj[k].push(nodes[j].id);
	                                }
	                            }else{
	                                obj[k]=d[k];
	                            }                           
	
	                        }
	                    }  
	                }
	            }
	            return result;
	        };
	        var cloneData = isData === true ? {} : ObjectUtil.cloneObj(d);
	        cloneData.nodes = getData(nodeKeys, self.nodes);
	        cloneData.links = getData(linkKeys, self.links, true);
	        cloneData.groups = getData(groupKeys, self.groups);
	        //还原数据
	        if(nodes) {
	            d.nodes = nodes;
	        }
	        if(links) {
	            d.links = links;
	        }
	        if(groups) {
	            d.groups = groups;
	        }
	        //把该baseChart的数据转换成json字符串
	        str = JSON.stringify(cloneData);
	        return str;
	    };
	    
	    /**
	     * override toString方法，用于打印本对象的一些基本信息
	     */
	    this.toString = function() {
	        return ("EditorTopo info: " +
	                "\n   width:"     + self.width()      + 
	                "\n   height:"    + self.height()     + 
	                "\n   layout:"    + self.layout()     + 
	                "\n   showLevel:" + self.showLevel()  +
	                "\n   data:"      + JSON.stringify(self.data(), null, 4));
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // listeners
	    //
	    // --------------------------------------------------------------------------
	    
	    var searchTextHandler = function(event) {
	        var str = event.detail;
	        var nodes = self.searchNodesByName(str);
	        self.centerNodesAndSelected(nodes, true);
	    };
	    
	    /**
	     * 外部抛事件代码如下:
	     * <code><pre>
	     * const BaseEvent = ghca_charts.events.BaseEvent;
	     * const EventUtil = ghca_charts.view.util.eventUtil;
	     * const evt = EventUtil.createCustomEvent(BaseEvent.TOPO_NODE_FOCUS_IN, true, true, "10.4.42.1");
	     * d3.selectAll("g.seriesTopo").node().dispatchEvent(evt);
	     * </pre></code>
	     */
	    var topoNodeFocusInHandler = function(event) {
	        var id = event.detail;
	        //移动该节点到中心位置并选中，然后突出显示节点
	        self.centerAndFocusInNode(id)
	    };
	    
	    /**
	     * 节点单击事件的监听相关处理方法
	     */
	    var nodeClickHandler = function(event) {
	        if(self.isEditMode() || !self.focusEffect()) {
	            if(_nodeClickHandler){
	                _nodeClickHandler(event);
	            }
	            return;
	        }
	        //获取当前双击的节点数据对象
	        var data = d3.select(event.currentTarget).data();
	        if(data.length === 0) {
	            return;
	        }
	        var node = data[0];
	        var nodeIns = node.ins;
	        var items = self.selectedNodeItems();
	        for (var i = 0; i < items.length; i++) {
	            var item = items[i];
	            if (item.ins.selected()&&nodeIns!==item.ins) {
	                item.ins.selected(false);
	            }
	        }
	        if(nodeIns && nodeIns.selected()) {
	            //若该节点已经处于选中状态，则取消选选中和聚焦状态
	            self.focusOutAllNodes();
	            item.ins.selected(false);
	        } else {
	            //移动该节点到中心位置并选中，然后突出显示节点
	            self.centerAndFocusInNode(node);
	        }
	    };
	    
	    /**
	     * 子节点收放按钮点击事件的监听相关处理方法
	     */
	    var expandToolClickHandler = function(event) {
	        event.stopImmediatePropagation();
	        var node = event.detail;
	        if(!node) {
	            return;
	        }
	        self.expandOrCollapseNodeInUI(node);
	    };
	    
	    /**
	     * 实时更新渲染数据的监听相关处理方法
	     */
	    this.tickHandler = function() {        
	        if(!self.layout().fixed()) {
	            self.renderPosition();
	            self.mainContainer().node().dispatchEvent(EventUtil.createCustomEvent(BaseEvent.EAGLE_EYE_DRAG_CHANGE,true,true,{enable:false}));
	        }       
	    };
	    this.tickEndHandler = function() {
	        if(!self.layout().fixed()) {
	            self.renderPosition();
	            self.mainContainer().node().dispatchEvent(EventUtil.createCustomEvent(BaseEvent.EAGLE_EYE_DRAG_CHANGE,true,true,{enable:true}));
	        }
	    };
	    
	    var multSelectMode=false;
	    this.multSelectMode=function(value){
	        if(arguments.length===0){
	            return multSelectMode;
	        }
	        multSelectMode=value;
	        return this;
	    }
	
	
	    /**
	     * 节点开始拖动
	     */
	    this.node_dragStartHandler = function(d) {
	        var items=self.selectedNodeItems();
	        if(!self.multSelectMode()){
	            items.forEach(function(node){
	                node.ins.selected(false);
	            });
	        }else{
	            if(items.indexOf(d)==-1){//不在多选列表
	                items.forEach(function(node){
	                    node.ins.selected(false);
	                });
	            }
	        }
	        d.ins.selected(true);
	        dragMoveX=d3.event.x-d.x;
	        dragMoveY=d3.event.y-d.y;
	        if(self.layout().fixed()) {
	            // d.x = d3.event.x;
	            // d.y = d3.event.y;
	            d.fx = d.x;
	            d.fy = d.y;
	            self.updateDragedObjectPos(d);
	        } else {
	             if (!d3.event.active) {
	                self.model.alphaTarget(0.3).restart();
	            }
	            d.fx = d.x;
	            d.fy = d.y;
	        }
	    };
	    
	    /**
	     * 节点拖动中
	     */
	    this.node_dragHandler = function(d) {
	        dragMoveX=d3.event.x-d.x;
	        dragMoveY=d3.event.y-d.y;
	        if(self.layout().fixed()) {
	            // d.x = d3.event.x;
	            // d.y = d3.event.y;
	            d.fx = d.x;
	            d.fy = d.y;
	            self.updateDragedObjectPos(d);
	        } else {
	            d.fx = d3.event.x;
	            d.fy = d3.event.y;
	        }
	    };
	    
	    /**
	     * 节点结束拖动
	     */
	    this.node_dragEndHandler = function(d) {
	        dragMoveX=d3.event.x-d.x;
	        dragMoveY=d3.event.y-d.y;
	        var evt = EventUtil.createCustomEvent("node_drag_end", true, true); //通知节点拖动事件
	        d3.selectAll("g.seriesTopo").node().dispatchEvent(evt);
	        if(self.layout().fixed()) {
	            // d.x = d3.event.x;
	            // d.y = d3.event.y;
	            d.fx = d.x;
	            d.fy = d.y;
	            self.updateDragedObjectPos(d);
	        } else {
	            if (!d3.event.active) {
	                self.model.alphaTarget(0);
	            }
	            d.fx = null;
	            d.fy = null;
	        }
	    };
	
	    /**
	     * 渲染鼠标拖动对象以及其相关联的对象的位置 
	     */
	    this.updateDragedObjectPos = function(d) {
	    	if(!d) {
	    		return;
	        }
	        
	        var nodesIns = self.nodesIns;
	        var nodes = [];
	        for(var nodeIns, i = 0, len = nodesIns.length; i < len; i++) {
	            nodeIns = nodesIns[i];
	            nodeIns.mainContainer().each(function(d) {
	                if(d.ins.selected()){
	                    d.x+=dragMoveX;
	                    d.y+=dragMoveY;
	                    nodes.push(d);
	                }
	               nodeIns.x(Math.round(d.x));
	               nodeIns.y(Math.round(d.y));
	               nodeIns.renderTransform();
	            });
	        }
	        dragMoveX=dragMoveY=0;
	
	
	    	// var nodeIns = d.dragIns;
	    	// if(nodeIns) {
	    	// 	nodeIns.x(Math.round(d.x));
	        //     nodeIns.y(Math.round(d.y));
	        //     nodeIns.renderTransform();
	    	// }
	        
	        for(var n=0;n<nodes.length;n++){
	            d=nodes[n];
	            var links = d.links;
	            if(ObjectUtil.isArray(links)) {
	                for(var link, linkIns, i = 0, len = links.length; i < len; i++) {
	                    link = links[i];
	                    // link.source && nodes.indexOf(link.source) === -1 && nodes.push(link.source);
	                    // link.target && nodes.indexOf(link.target) === -1 && nodes.push(link.target);
	                    linkIns = link.dragIns;
	                    if(!linkIns) {
	                        continue;
	                    }
	                    if(linkIns.normalChild()){
	                        linkIns.normalChild().update();
	                    } else {
	                        linkIns.render();
	                    }
	                }
	            }
	        }
	        
	//        //刷新所有节点组path数据
	//        refreshGroupsData();
	//        var groupsIns = self.groupsIns;
	//        for(var groupIns, i = 0, len = groupsIns.length; i < len; i++) {
	//            groupIns = groupsIns[i];
	//            if(groupIns.normalChild()) {
	//                groupIns.normalChild().update();
	//            } else {
	//                groupIns.render();
	//            }
	//        }
	        
	        //刷新相关节点组path数据
	        var groups = self.findGroupsByNodes(nodes);
	        for(var groupData, groupIns, i = 0, len = groups.length; i < len; i++) {
	            groupData = groups[i];
	            setGroupPath(groupData);
	            
	            groupIns = groupData.dragIns;
	            if(groupIns.normalChild()) {
	                groupIns.normalChild().update();
	            } else {
	                groupIns.render();
	            }
	        }
	
	        //延时触发鹰眼变更
	        self.sendMsgToEye(fireContentChange, 1000);
	    };
	
	    /*
	    * 找到多个节点所在的节点组列表
	    * @param arguments[0] 一个或者多个节点，一个节点直接传入，多个节点用数组包装再传入
	    * @return 返回节点组列表数组，若没有则返回空数组
	    */
	   this.findGroupsByNodes = function() {
	       if(ObjectUtil.isObject(arguments[0])) {
	           return self.findGroupsByNode(arguments[0]);
	       } 
	       if(ObjectUtil.isArray(arguments[0])) {
	           var nodes = arguments[0];
	           var result = [];
	           for(var groups, i = 0, len = nodes.length; i < len; i++) {
	               groups = self.findGroupsByNode(nodes[i]);
	               for(var group, j = 0, len1 = groups.length; j < len1; j++) {
	                   group = groups[j];
	                   if(result.indexOf(group) === -1) {
	                       result.push(group);
	                   }
	               }
	           }
	           return result;
	       }
	       return [];
	   };
	   
	   /**
	    * 找到节点所在的节点组列表
	    * @param node 节点数据对象
	    * @return 返回节点组列表数组，若没有则返回空数组
	    */
	   this.findGroupsByNode = function(node) {
	       var result = [];
	       if(!node) {
	           return result;
	       }
	       var groups = self.groups;
	       for(var group, nodes, i = 0, len = groups.length; i < len; i++) {
	           group = groups[i];
	           nodes = group.nodes;
	           if(nodes.indexOf(node) !== -1) {
	               result.push(group);
	           }
	       }
	       return result;
	   };
	   
	   /**
	    
	    
	    /**
	     * 点击保存按钮事件处理方法
	     */
	    var saveBtnClickHandler = function() {
	        //向外部抛出保存数据
	        self.node().dispatchEvent(EventUtil.createCustomEvent(
	           BaseEvent.EV_EVENT_DATA_STORAGE, true, true, {data:self.toJSON(true)}));
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // public Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    /**
	     * 设置传入的对象是否显示选中状态
	     * @param selected 对象是否显示选中状态
	     * @param insArray 要设置的对象数组，若不传则为图表中的所有对象(节点+连线)
	     */
	    this.setSelected = function(selected, insArray) {
	        if(insArray) {
	            for (var i = 0, len = insArray.length; i < len; i++) {
	                insArray[i].selected(selected);
	            }
	        } else {
	            var nodes = self.nodes;
	            for (var i = 0, len = nodes.length; i < len; i++) {
	                nodes[i].ins.selected(selected);
	            }
	            var links = self.links;
	            for (var i = 0, len = links.length; i < len; i++) {
	                links[i].ins.selected(selected);
	            }
	        }
	    };
	    
	    /**
	     * 将当前框选项显示选中效果
	     */
	    this.setSelectedItemsInSelectArea = function() {
	        var con = self.parent().parent().mainContainer();
	        var rect = con.select("rect.select");
	        // var rect = self.editCon.mainContainer().select("rect.select");
	        var rectNode = rect.node();
	        if(rectNode) {
	            selectedNodeItems.length = 0;
	            selectedLinkItems.length = 0;
	            selectedGroupItems.length = 0;
	            //选中区域内的所有节点
	            var node, link, ins, insRect, source, target, intersections, isCollision, 
	                nodes = self.nodes, 
	                links = self.links,
	                groups = self.groups,
	                rect = {},
	                selectRect = {
	                    x:parseInt(rectNode.getAttribute("x")),
	                    y:parseInt(rectNode.getAttribute("y")),
	                    width:parseInt(rectNode.getAttribute("width")),
	                    height:parseInt(rectNode.getAttribute("height"))
	                };
	                if(isNaN(selectRect.height)){
	                    selectRect.height=0;
	                }
	                if(isNaN(selectRect.width)){
	                    selectRect.width=0;
	                }
	                // selectRect = rectNode.getBBox();
	                // var nodeBox=self.nodesContainer.node().getBBox();
	                selectRect.x=(selectRect.x-self.x())/self.scaleX();
	                selectRect.y=(selectRect.y-self.y())/self.scaleY();
	                selectRect.width=selectRect.width/self.scaleX();
	                selectRect.height=selectRect.height/self.scaleY();
	
	                // var re=self.mainContainer().select("rect.select1");
	                // if(re.node()===null){
	                //     re=self.mainContainer().append("rect")                   
	                // }
	                // re.attr("class","select1")
	                // .attr("x",selectRect.x)
	                // .attr("y",selectRect.y)
	                // .attr("width",selectRect.width)
	                // .attr("height",selectRect.height)
	            for (var i = 0, len = nodes.length; i < len; i++) {
	                node = nodes[i];
	                ins = node.ins;
	                if(!ins){
	                    continue;
	                }
	//                insRect = ins instanceof BaseComponent ? ins.node().getBBox() : ins.mainPlugin.el.node().getBBox();
	                // insRect = ins instanceof BaseComponent ? ins.node().getBBox() : ins.mainPlugin.getBBox();
	                insRect = ins instanceof BaseComponent ? ins.getBBox() : ins.mainPlugin.getBBox();
	                //这样重新创建一个对象是因为ie中getBBox()返回的对象属性是只读的
	                rect.x = node.x + insRect.x;
	                rect.y = node.y + insRect.y;
	                rect.width = insRect.width;
	                rect.height = insRect.height;
	                if(math.isCollisionInTwoRects(selectRect, rect)) {
	                    ins.selected(true);
	                    selectedNodeItems.push(node);
	                } else {
	                    ins.selected(false);
	                }
	            }
	            selectedNodeItems.forEach(function(node){
	                groups.forEach(function(g){
	                    
	                    if(ObjectUtil.contains(g.nodes,node)&&!ObjectUtil.contains(selectedGroupItems,g)){
	                        selectedGroupItems.push(g);
	                    }
	                });
	            });
	
	
	            //选中区域内的所有连线
	            // var rectPath =  "M"+selectRect.x+","+selectRect.y +
	            //                 " L"+(selectRect.x+selectRect.width)+","+selectRect.y+
	            //                 " L"+(selectRect.x+selectRect.width)+","+(selectRect.y+selectRect.height)+
	            //                 " L"+(selectRect.x)+","+(selectRect.y+selectRect.height) + "Z";
	            // for (var i = 0, len = links.length; i < len; i++) {
	            //     link = links[i];
	            //     ins = link.ins;
	            //     source = link.source;
	            //     target = link.target;
	            //     //矩形框选区域是否包含该连线
	            //     if(math.isPointInsideBBox(source.x, source.y, selectRect) && 
	            //        math.isPointInsideBBox(target.x, target.y, selectRect)) {
	            //         isCollision = true;
	            //     } else {
	            //         //若不包含则判断是否有交点
	            //         intersections = Raphael.pathIntersection(ins.el.select("path").attr("d"), rectPath);
	            //         if(intersections.length > 0) {
	            //             isCollision = true;
	            //         } else {
	            //             isCollision = false;
	            //         }
	            //     }
	            //     if(isCollision) {
	            //         ins.selected(true);
	            //         selectedLinkItems.push(link);
	            //     } else {
	            //         ins.selected(false);
	            //     }
	            // }
	        }
	
	        return selectedNodeItems;
	    };
	    
	    /**
	     * 移动该节点到中心位置并选中，然后突出显示节点
	     * @param arguments[0] 节点id或者节点数据对象
	     */
	    this.centerAndFocusInNode = function() {
	        if(arguments.length === 0) {
	            return;
	        }
	        var node;
	        if(ObjectUtil.isString(arguments[0])) {
	            node = self.findNode(arguments[0]);
	        } else if(ObjectUtil.isObject(arguments[0])) {
	            node = arguments[0];
	        }
	        if(!node) {
	            return;
	        }
	        //移动该节点到中心位置并选中
	        self.centerNodesAndSelected(node,true);
	        //突出显示节点
	        self.focusInNode(node);
	    };
	    
	    var _isFocusNode=false;
	    this.isFocusNode=function(){
	        return _isFocusNode;
	    }
	
	
	    /**
	     * 突出显示节点
	     * @param node 要突出显示的节点数据对象
	     */
	    this.focusInNode = function(node) {
	        if(!node || !node.id) {
	            return;
	        }
	        var i, len, ins, nodeIns, linkIns, groupIns, nodeData, linkData, links, id = node.id, opacity = 0.1, 
	            nodesIns = self.nodesIns, linksIns = self.linksIns, groupsIns = self.groupsIns, insAry = [];
	        var duration = self.animation() ? 300 : 0;
	        //找到目标对象，并淡化所有节点、连线、分组的显示效果
	        for(i = 0, len = nodesIns.length; i < len; i++) {
	            nodeIns = nodesIns[i];
	            nodeIns.mainContainer().attr("opacity", opacity);
	            if(nodeIns.mainContainer().data()[0].id === id) {
	                ins = nodesIns[i];
	            }
	        }
	        for(i = 0, len = linksIns.length; i < len; i++) {
	            linkIns = linksIns[i];
	            linkIns.mainContainer().attr("opacity", opacity);
	        }
	        for(i = 0, len = groupsIns.length; i < len; i++) {
	            groupIns = groupsIns[i];
	            groupIns.mainContainer().attr("opacity", opacity);
	        }
	        //添加要突出显示的对象到数组中
	        nodeData = ins.mainContainer().data()[0];
	        insAry.push(nodeData.ins);
	        links = nodeData.links;
	        if(links) {
	            for(i = 0, len = links.length; i < len; i++) {
	                linkData = links[i];
	                insAry.push(linkData.ins);
	                if(linkData.target && linkData.target.ins) {
	                    insAry.push(linkData.target.ins);
	                }
	                if(linkData.source && linkData.source.ins) {
	                    insAry.push(linkData.source.ins);
	                }
	            }
	        }
	        //突出显示
	        for(i = 0, len = insAry.length; i < len; i++) {
	            ins = insAry[i];
	            if(ins instanceof BaseComponent) {
	                ins = ins.mainContainer();
	            } else {
	                ins = d3.select(ins.el.node().parentNode);
	            }
	            ins && ins.attr("opacity", 1);
	        }
	
	        _isFocusNode=true;
	    };
	    
	    /**
	     * 取消所有节点的突出显示效果
	     */
	    this.focusOutAllNodes = function() {
	        if(!self.nodesIns || !self.linksIns) {
	            return;
	        }
	        var i, len, ins, opacity = 1, nodesIns = self.nodesIns, 
	            linksIns = self.linksIns, groupsIns = self.groupsIns;
	        for(i = 0, len = nodesIns.length; i < len; i++) {
	            ins = nodesIns[i];
	            ins.mainContainer().attr("opacity", opacity);
	        }
	        for(i = 0, len = linksIns.length; i < len; i++) {
	            ins = linksIns[i];
	            ins.mainContainer().attr("opacity", opacity);
	        }
	        for(i = 0, len = groupsIns.length; i < len; i++) {
	            ins = groupsIns[i];
	            ins.mainContainer().attr("opacity", opacity);
	        }
	
	        _isFocusNode=false;
	    };
	    
	    /**
	     * 对传入的节点居中并设置显示选中状态(选中状态根据传入参数设置)
	     * @param arguments[0] 节点数据对象数组或者单个节点数据对象
	     * @param arguments[1] 是否选中传入的节点，默认为否
	     */
	    this.centerNodesAndSelected = function() {
	        var nodes = self.nodes;
	        var isSelect = arguments.length > 1 ? arguments[1] === true : false;
	        //取消所有节点选中状态
	        var nodesIns = [];
	        for (var i = 0, len = nodes.length; i < len; i++) {
	            nodesIns.push(nodes[i].ins);
	        }
	        self.setSelected(false, nodesIns);
	        
	        var ratio = 1, currentX = NaN, currentY = NaN;
	        if (ObjectUtil.isArray(arguments[0])) {//传入参数为数组
	            nodes = arguments[0];
	            if(nodes.length === 0) {
	                return;
	            }
	            //计算搜索结果点外接矩形中心
	            var minX = NaN, minY = NaN, maxX = NaN, maxY = NaN,
	                leftNodeW = NaN, rightNodeW = NaN, topNodeH = NaN, bottomNodeH = NaN;
	            for (var node, nodeIns, i = 0, len = nodes.length; i < len; i++) {
	                node = nodes[i];
	                nodeIns = node.ins;
	                if(isSelect) {
	                    nodeIns.selected(true);
	                }
	                if(isNaN(minX) || node.x < minX) {
	                    minX = node.x;
	                    leftNodeW = nodeIns.actualWidth();
	                }
	                if(isNaN(minY) || node.y < minY) {
	                    minY = node.y;
	                    topNodeH = nodeIns.actualHeight();
	                }
	                if(isNaN(maxX) || node.x > maxX) {
	                    maxX = node.x;
	                    rightNodeW = nodeIns.actualWidth();
	                }
	                if(isNaN(maxY) || node.y > maxY) {
	                    maxY = node.y;
	                    bottomNodeH = nodeIns.actualHeight();
	                }
	            }
	            currentX = (maxX + minX)/2, currentY = (maxY + minY)/2;
	            //搜索结果点外接矩形是否大于图表显示范围，若是则缩小内容
	            var ratioX = 1, ratioY = 1, 
	                areaW = maxX - minX + (leftNodeW + rightNodeW) / 2, 
	                areaH = maxY - minY + (topNodeH + bottomNodeH) / 2;
	            if(areaW > self.width()) {
	                ratioX = self.width() / areaW;
	            }
	            if(areaH > self.height()) {
	                ratioY = self.height() / areaH;
	            }
	            ratio = ratioX > ratioY ? ratioY : ratioX;
	            self.scaleX(ratio);
	            self.scaleY(ratio);
	        } else if(ObjectUtil.isObject(arguments[0])) {//传入参数为单个点
	            var node = arguments[0];
	            var nodeIns = node.ins;
	            if(isSelect) {
	                nodeIns.selected(true);
	            }
	            currentX = node.x;
	            currentY = node.y;
	        }
	        if(isNaN(currentX) || isNaN(currentY)) {
	            return;
	        }
	        
	        //把搜索结果点外接矩形中心点移动到图 表中心位置
	        var x = self.x(), y = self.y(), 
	            moveX = self.width()/2, moveY = self.height()/2;
	        x = (moveX - currentX * self.scaleX()) * self.graph().scaleX();
	        y = (moveY - currentY * self.scaleY()) * self.graph().scaleY();
	        self.x(Math.round(x));
	        self.y(Math.round(y));
	        self.layout().model().stop();
	        var transition = d3.transition().duration(self.animation() ? 500 : 0).ease(d3.easeExpOut);
	        self.renderTransform(transition);
	    };
	    
	    // --------------------------------------------------------------------------
	    // data control
	    // --------------------------------------------------------------------------
	    
	    /**
	     * 增加一个节点 
	     * @param node 节点数据对象
	     */
	    this.addNode = function(node) {
	        self.nodes.push(node);        
	    };
	
	    /**
	     * 批量增加节点 
	     * @param nodes 节点数据对象数组
	     */
	    this.addNodes = function(nodes) {
	        if (ObjectUtil.isArray(nodes)) {
	            for(var i = 0, len = nodes.length; i < len; i++) {
	                self.addNode(nodes[i]);
	            }
	        }
	    };
	
	    this.addAutoGroupNodes = function(nodes) {
	        if (ObjectUtil.isArray(nodes)) {
	            for(var i = 0, len = nodes.length; i < len; i++) {
	                self.addNodeToAutoGroup(nodes[i]);
	            }
	        }
	    };
	
	    /**
	     * 增加一条连线 
	     * @param link 连线数据对象 
	     */
	    this.addLink = function(link) {
	        //寻找该连线起点和终点
	        link.source = self.findNode(link.source);
	        link.target = self.findNode(link.target);
	        var source = link.source, 
	            target = link.target;
	        //寻找具有相同起点和终点的连线，生成lineIndex，并把该连线添加到起点和终点对应的连线数据数组里面
	        if(!source.hasOwnProperty("links")) {
	            source.links = [];
	        }
	        //刷新lineIndex
	        var lineIndex = self.refreshLineIndex(link);
	        link.lineIndex = lineIndex > 0 ? lineIndex : 0;
	        source.links.push(link);
	        if(!target.hasOwnProperty("links")) {
	            target.links = [];
	        }
	        target.links.push(link);
	        self.links.push(link);
	    };
	
	    /**
	     * 批量增加连线 
	     * @param links 连线数据对象数组
	     */
	    this.addLinks = function(links) {
	        if (ObjectUtil.isArray(links)) {
	            for(var i = 0, len = links.length; i < len; i++) {
	                self.addLink(links[i]);
	            }
	        }
	    };
	    
	    /**
	     * 删除节点 
	     * @param node 要删除的节点data
	     */
	    this.removeNode = function(node) {
	        var i = 0,id=node.id, n = self.findNode(id), links = self.links;
	        //删除该节点相关的连线
	        while (i < links.length) {
	            links[i]['source'] === n || links[i]['target'] === n ? links.splice(i, 1) : ++i;
	        }
	        //删除该节点
	        self.nodes.splice(self.findNodeIndex(id), 1);
	        //在所有分组中删除该节点
	        self.removeNodeFromAllGroup(n);
	    };
	    
	    /**
	     * 批量删除节点 
	     * @param ids 要删除的节点id数组
	     */
	    this.removeNodes = function(nodes) {
	        if (ObjectUtil.isArray(nodes)) {
	            for(var i = 0, len = nodes.length; i < len; i++) {
	                self.removeNode(nodes[i]);
	            }
	        }
	    };
	    
	    /**
	     * 删除连线 
	     * @param link 要删除的连线数据对象
	     */
	    this.removeLink = function(link) {
	        //删除连线自身
	        var links = self.links;
	        var index = links.indexOf(link);
	        if(index !== -1) {
	            links.splice(index, 1);
	        }
	        var source = link.source, 
	            target = link.target;
	        //删除连线起点中对应的该连线
	        self.removeLinkFromNode(source, link);
	        //删除连线终点中对应的该连线
	        self.removeLinkFromNode(target, link);
	        //刷新lineIndex
	        self.refreshLineIndex(link);
	    };
	    
	    /**
	     * 批量删除连线 
	     * @param links 要删除的连线数据对象数组
	     */
	    this.removeLinks = function(links) {
	        if (ObjectUtil.isArray(links)) {
	            for(var i = 0, len = links.length; i < len; i++) {
	                self.removeLink(links[i]);
	            }
	        }
	    };
	    
	    /**
	     * 删除节点中对应的连线引用
	     * @param node 包含该连线引用的节点数据对象
	     * @param link 要删除的连线数据对象
	     */
	    this.removeLinkFromNode = function(node, link) {
	        if(node && node.links) {
	            links = node.links;
	            for(var l, i = 0, len = links.length; i < len; i++) {
	                l = links[i];
	                if(l === link) {
	                    links.splice(i, 1);
	                    break;
	                }
	            }
	        }
	    };
	    
	    /**
	     * 删除节点下的子节点，同时清除link信息 
	     * @param id 要删除的节点id
	     */
	    this.removeChildNodes = function(id) {
	        var   node = self.findNode(id), //要删除的节点
	              nodes = self.nodes,       //所有节点
	              link = null,
	              links = self.links,       //所有连线 
	              delateLinks = [],         //要删除的连线索引数组
	              childNodes = [];          //当前节点的所有子节点数组
	
	        //找到所有要删除的连线索引，以及当前节点的所有子节点
	        links.forEach(function(link, index) {
	            //若节点是此条连线的起点
	            if(link['source'] === node) {
	                delateLinks.push(index);
	                childNodes.push(link['target']);
	            }
	        });
	
	        //删除上面找到的所有需要删除的连线
	        delateLinks.reverse().forEach(function(index) {
	            links.splice(index, 1);
	        });
	
	        //迭代删除节点
	        var remove = function(node) {
	            var length = links.length;
	            for (var i = length - 1; i >= 0; i--) {
	                if (links[i]['source'] === node) {
	                    var target = links[i]['target'];
	                    links.splice(i, 1);
	                    nodes.splice(self.findNodeIndex(node.id), 1);
	                    remove(target);
	                }
	            }
	        };
	
	        //删除上面找到当前节点的所有子节点
	        childNodes.forEach(function(node) {
	            remove(node);
	        });
	
	        //清除没有连线的节点
	        for (var i = nodes.length - 1, len = links.length; i >= 0; i--) {
	            var isFoundNode = false;
	            node = nodes[i];
	            for (var j = 0; j < len; j++) {
	                link = links[j];
	                if(link['source'] === node || link['target'] === node) {
	                    isFoundNode = true;
	                }
	            }
	            if(!isFoundNode) {
	                nodes.splice(i, 1);
	            }
	        }
	    };
	
	    /**
	     * 查找节点
	     * @param id 要查找的节点id
	     * @return 返回查找到的节点数据对象，若没有查找到则返回null
	     */
	    this.findNode = function(id) {
	        var nodes = self.nodes;
	        for (var i = 0, len = nodes.length; i < len; i++) {
	            if (nodes[i]['id'] === id)
	                return nodes[i];
	        }
	        return null;
	    };
	
	    /**
	     * 获取LINk
	     * @param id
	     * @returns {*}
	     */
	    this.findLink = function(id) {
	        var links = self.links;
	        for (var i = 0, len = links.length; i < len; i++) {
	            if (links[i]['id'] === id)
	                return links[i];
	        }
	        return null;
	    };
	    
	    /**
	     * 查找节点数据对象所在数组的索引值
	     * @param id 要查找的节点id
	     * @return 返回查找到的节点数据对象所在数组的索引值，若没有查找到则返回-1
	     */
	    this.findNodeIndex = function(id) {
	        var nodes = self.nodes;
	        for (var i = 0, len = nodes.length; i < len; i++) {
	            if (nodes[i]['id'] === id)
	                return i;
	        }
	        return -1;
	    };
	    
	    /**
	     * 刷新变更(添加、删除)目标连线所在的两端点之间的连线的索引值
	     * @param link 变更(添加、删除)目标连线数据对象
	     * @return 返回下一个要添加的连线索引值
	     */
	    this.refreshLineIndex = function(link) {
	        var sourceLink, 
	            lineIndex = 0, 
	            source = link.source, 
	            target = link.target,
	            sourceLinks = source.links;
	        for(var i = 0, len = sourceLinks.length; i < len; i++) {
	            sourceLink = sourceLinks[i];
	            //寻找具有相同节点的连线
	            if((sourceLink.target === source || sourceLink.source === source) && 
	               (sourceLink.target === target || sourceLink.source === target)) {
	                sourceLink.lineIndex = lineIndex;
	                lineIndex++;
	                //记录变更集
	                addItemsToChangeData(sourceLink, changeData.links.update);
	            }
	        }
	        return lineIndex;
	    };
	    
	    /**
	     * 增加一个节点组
	     * @param group 节点数据对象
	     */
	    this.addGroup = function(group) {
	        var nodes = group.nodes;
	        //替换group中的节点id为对应的节点数据对象
	        for (var node, i = 0, len = nodes.length; i < len; i++) {
	            node = self.findNode(nodes[i]);
	            nodes[i] = node;
	        }
	        self.groups.push(group);
	    };
	    
	    /**
	     * 批量增加节点组
	     * @param groups 节点组数据对象数组
	     */
	    this.addGroups = function(groups) {
	        if (ObjectUtil.isArray(groups)) {
	            for(var i = 0, len = groups.length; i < len; i++) {
	                self.addGroup(groups[i]);
	            }
	        }
	    };
	    
	    /**
	     * 删除一个节点组
	     * @param group 节点数据对象
	     */
	    this.removeGroup = function(group) {
	        var groups = self.groups;
	        var index = groups.indexOf(group);
	        if(index !== -1) {
	            //删除该节点组
	            groups.splice(index, 1);
	        }
	    };
	
	    var resetAutoGroups=function(){
	        autoGroupKeys=self.data().renderers.groupNode&&self.data().renderers.groupNode.autoGroupKeys&&self.data().renderers.groupNode.autoGroupKeys.split(",");
	        autoGroupKeys=autoGroupKeys?autoGroupKeys:"";
	        var groups=self.groups;
	        groups.forEach(function(group){
	            if(group.groupKey&&autoGroupKeys.indexOf(group.groupKey)==-1){
	                 self.removeGroup(group);
	            }
	//            //by lizheng 此处分组存在与否，不应与业务逻辑挂钩
	//            else if(group.nodes.length<2){
	//                self.removeGroup(group);
	//            }
	        })
	
	        self.addAutoGroupNodes(self.nodes);
	    }
	
	    var autoGroupsInfos=null;
	    this.setAutoGroupInfo=function(infos){
	        autoGroupsInfos=infos;
	    }
	
	
	      /**
	     * 添加节点到自动组
	     */
	    this.addNodeToAutoGroup=function(nodeData){
	        var allgroup=self.groups;
	        var num=allgroup.length;
	        var putGkeys=[];
	        var nodes = self.nodes;
	        for(var i=0;i<num;i++){
	            var group=allgroup[i];
	            var index=autoGroupKeys.indexOf(group.groupKey);
	            var copyNodes=[];
	            group.nodes.forEach(function(n){
	                copyNodes.push(n);
	            });
	
	            copyNodes.forEach(function(n){
	               if(nodes.indexOf(n)===-1){//不存在的节点要移除
	                    self.removeNodeFromGroup(n,group);
	               }
	            });
	            var node = self.findNode(nodeData.id);
	            if(index!=-1&&group.nodes.length>0&&group.nodes[0][group.groupKey]===nodeData[group.groupKey]){
	                var nameN="自动组_"+getAutoName(group.groupKey);
	                if(group.name!=nameN){
	                    group.name=nameN;
	                    addItemsToChangeData(group, changeData.groups.update);
	                }
	                self.addNodeToGroup(node,group);
	                putGkeys.push(group.groupKey);               
	            }
	        }
	
	       
	        for(var k=0;k<autoGroupKeys.length;k++){
	            var key=autoGroupKeys[k];
	            var groupIDs=[];
	            if(putGkeys.indexOf(key)===-1){
	                for(var j=0;j<nodes.length;j++){
	                    var gNode=nodes[j];
	                    if(gNode.id!=nodeData.id&&gNode[key]&&nodeData[key]&&gNode[key]===nodeData[key]){
	                        groupIDs.push(gNode.id);
	                    }
	                }
	            }
	            
	            if(groupIDs.length!=0){
	                groupIDs.push(nodeData.id);
	                var data = [{
	                    id: UUIDUtil.generateUUID(),
	                     renderer: "groupNode", 
	                     name: "自动组_"+getAutoName(key), 
	                     nodes: groupIDs, 
	                     visible: true,
	                     groupKey:key,
	                     radius:20,
	                     fill:"#e3dec8",
	                     fillOp: 0.3,
	                     lbBgFill:"#f8f8f8",
	                     lbFill:"#2c2c2c",                     
	                     lbOp:1
	                    }];
	                self.addGroups(data);    
	            }
	        }  
	    }
	
	    function getAutoName(key){
	        // console.log(key,autoGroupsInfos);
	        if(!autoGroupsInfos){
	            return key;
	        }
	
	        for(var i=0;i<autoGroupsInfos.length;i++){
	            if(autoGroupsInfos[i].props===key){
	                return autoGroupsInfos[i].name;
	            }
	        }
	        return key;
	    }
	    
	    /**
	     * 为指定的节点组中添加一个节点
	     * @param node 要删除的节点
	     * @param group 节点组
	     */
	    this.addNodeToGroup = function(node, group) {
	        if(!group.nodes) {
	            group.nodes = [];
	        }
	        var groupNodes = group.nodes;
	        var index = groupNodes.indexOf(node);
	        if(index === -1) {
	            groupNodes.push(node);
	        }
	    };
	    
	    /**
	     * 从指定的节点组中删除一个节点
	     * @param node 要删除的节点
	     * @param group 节点组
	     */
	    this.removeNodeFromGroup = function(node, group) {
	        var groupNodes = group.nodes;
	        var index = groupNodes.indexOf(node);
	        if(index !== -1) {
	            groupNodes.splice(index, 1);
	             //记录变更集
	             addItemsToChangeData(group, changeData.groups.update);
	        }
	    };
	    
	    /**
	     * 从所有的节点组中删除一个节点
	     * @param node 要删除的节点
	     */
	    this.removeNodeFromAllGroup = function(node) {
	        var groups = self.groups;
	        for(var group, i = 0, len = groups.length; i < len; i++) {
	            group = groups[i];
	            self.removeNodeFromGroup(node, group);
	        }
	    };
	    
	    /**
	     * 根据指定节点的id找到该节点的所有子孙节点
	     * @param id 指定节点的id
	     * @param isAll 是否返回所有子孙节点(无论是否展开)，默认为是，若为false，则只返回展开的子孙节点
	     * @return 返回指定节点的所有子孙节点数据对象数组，若没有找到则返回空数组
	     */
	    this.findAllChildNodes = function(id, isAll) {
	        var nodes = [];
	        var node = self.findNode(id);
	        if(!node) return nodes;
	        if(isAll === undefined) {
	            isAll = true;
	        }
	        
	        //有待优化--start
	        var getNode;
	        if(isAll) {
	            getNode = function(nodeId) {
	                self.nodes.forEach(function(node) {
	                    if(node.parentId === nodeId) {
	                        nodes.push(node);
	                        getNode(node.id);
	                    }
	                });
	            };
	            getNode(id);
	        } else {
	            getNode = function(parentNode, isFirst) {
	                var isExpanded = isFirst 
	                    || parentNode.isExpanded === undefined 
	                    || parentNode.isExpanded === true;
	                self.nodes.forEach(function(node) {
	                    if(isExpanded && node.parentId === parentNode.id) {
	                        nodes.push(node);
	                        getNode(node, false);
	                    }
	                });
	            };
	            getNode(node, true);
	        }
	        //有待优化--end
	        
	        return nodes;
	    }
	    
	    /**
	     * 设置指定节点是否可见
	     * @param nodes 要设置的指定节点对象数组
	     * @param visible 设置指定节点是否可见
	     */
	    this.setNodesVisible = function(nodes, visible) {
	        if(!nodes || nodes.length === 0) return;
	        if(visible === undefined)  {
	            visible = true;
	        }
	        for(var i = 0, len = nodes.length; i < len; i++) {
	            nodes[i].visible = visible;
	        }
	    };
	    
	    /**
	     * 展开节点
	     * @param id 要展开的节点id
	     * @param isExpandAll 是否强制展开所有子孙节点，默认为false,
	     * 若为false则原先合拢的子孙节点在父节点展开后保持原有状态；若为true则强制展开所有子孙节点
	     */
	    this.expandNode = function(id, isExpandAll) {
	        var nodes = self.findAllChildNodes(id, isExpandAll === undefined ? false : isExpandAll);
	        self.setNodesVisible(nodes, true);
	    };
	    
	    /**
	     * 合拢节点
	     * @param id 要合拢的节点id
	     */
	    this.collapseNode = function(id) {
	        var nodes = self.findAllChildNodes(id, true);
	        self.setNodesVisible(nodes, false);
	    };
	    
	    /**
	     * 展开或者合拢节点
	     * @param node 当前要展开或者合拢的节点数据对象
	     */
	    this.expandOrCollapseNode = function(node) {
	        if(!node.enabledExpand) {
	            return;
	        }
	        if(node.isExpanded) {
	            self.collapseNode(node.id);
	            node.isExpanded = false;
	        } else {
	            self.expandNode(node.id, false);
	            node.isExpanded = true;
	        }
	    };
	    
	    /**
	     * 从指定的连线数据数组中获取可见的所有连线
	     * @param links 指定的连线数据数组
	     * @return 返回可见的所有连线数组，若没有满足条件的数组，则返回空数组
	     */
	    this.getVisibleLinks = function(links) {
	        var result = [];
	        if(!links || links.length === 0){
	            return result;
	        }
	        var link;
	        for (var i = 0, len = links.length; i < len; i++) {
	            link = links[i];
	            if (link.source.visible && link.target.visible) {
	                if(link.hasOwnProperty("visible")) {
	                    if(link.visible) {
	                        result.push(link);
	                    }
	                } else {
	                    result.push(link);
	                }
	            }
	        }
	        return result;
	    };
	    
	    /**
	     * 根据搜索字符串内容从节点的name属性中搜索匹配的节点，并把所有满足搜索条件的节点数据放入一个数组中
	     * @param str 搜索条件字符串
	     * @return 所有满足搜索条件的节点数据数组，若没有搜索到则返回空数组
	     */
	    this.searchNodesByName = function(str) {
	        var result = [];
	        if(str === undefined || str === null || str.replace(/ /g,'') === "") {
	            return result;
	        }
	        var nodes = self.nodes;
	        for (var node, i = 0, len = nodes.length; i < len; i++) {
	            node = nodes[i];
	            if(node.name.indexOf(str) > -1) {
	                result.push(node);
	            }
	        }
	        return result;
	    }
	    
	    // --------------------------------------------------------------------------
	    //
	    // edit code
	    //
	    // --------------------------------------------------------------------------
	    
	    var drawlinkIns,
	        drawLinkSource,
	        oldDragable = false,
	        selectRectX = 0, 
	        selectRectY = 0;
	        
	    var modeChangeHandler = function(evt) {
	        self.mode((evt || window.event).detail ? "edit" : "normal");
	        validateMode();
	    };
	    
	    /**
	     * 监听外部抛出开启和关闭编辑模式的事件
	     */
	    var openEditHandler = function(evt) {
	        self.mode((evt || window.event).detail.data === true ? "edit" : "normal");
	        validateMode();
	    };
	    
	    var validateMode = function() {
	        if(!isValidateMode) {
	            return;
	        }
	        isValidateMode = false;
	        if(self.isEditMode()) {
	            self.focusOutAllNodes();
	            addEditContainer();
	            setListenersInEditLink();
	            // self.addEventListener(BaseEvent.OPERATION_TYPE, operationChangeHandler);
	            self.addEventListener(BaseEvent.OPEN_FLUX_TYPE, openFluxChangeHandler);
	            self.addEventListener(BaseEvent.OPEN_ALARM_TYPE, openAlarmChangeHandler);
	            // self.addEventListener(BaseEvent.OPERATION_CLEAR, operationClearHandler);
	            self.addEventListener(BaseEvent.ADD_ITEMS, addItemsHandler);
	            self.addEventListener(BaseEvent.REMOVE_ITEMS, removeItemsHandler);
	            // self.addEventListener(BaseEvent.REOMVE_ALL_SELECTED_ITEMS, removeAllSelectedItemsHandler);
	            // self.parent().mainContainer().on("mousedown.edit", edit_mouseDownHandler);
	            // self.parent().mainContainer().on("mousemove.edit", edit_mouseMoveHandler);
	            // self.parent().mainContainer().on("mouseup.edit", edit_mouseUpHandler);
	        } else {
	            removeEditContainer();
	            // self.removeEventListener(BaseEvent.OPERATION_TYPE, operationChangeHandler);
	            // self.removeEventListener(BaseEvent.OPERATION_CLEAR, operationClearHandler);
	            self.removeEventListener(BaseEvent.ADD_ITEMS, addItemsHandler);
	            self.removeEventListener(BaseEvent.REMOVE_ITEMS, removeItemsHandler);
	            // self.removeEventListener(BaseEvent.REOMVE_ALL_SELECTED_ITEMS, removeAllSelectedItemsHandler);
	            // self.parent().mainContainer().on("mousedown.edit", null);
	            // self.parent().mainContainer().on("mousemove.edit", null);
	            // self.parent().mainContainer().on("mouseup.edit", null);
	            setListenersInNormal();
	        }
	    };
	 
	
	    /**
	     * 开启流量
	     * @param event
	     */
	    var openFluxChangeHandler = function(event){
	        if(event.detail){
	            var detail = event.detail;
	            //[{id:1,flux:{}}]
	            var link = self.findLink(detail.id);
	            if(link){
	                link.flux = detail.flux;
	                if(link.ins)
	                    link.ins.render();
	            }
	        }else{
	            self.links.forEach(function(link){
	                delete link.flux;
	                if(link.ins)
	                    link.ins.render();
	            });
	        }
	    }
	
	    /**
	     * 开启告警
	     * @param event
	     */
	    var openAlarmChangeHandler = function(event){
	        if(event.detail){
	            //[{id:1,type:"link/node",value:{}}]
	            var detail = event.detail;
	            switch(detail.type){
	                case "link":{
	                    var link = self.findLink(detail.id);
	                    if(link){
	                        link.value = detail.value;
	                        if(link.ins)
	                            link.ins.render();
	                    }
	                    break;
	                }
	                case "node":{
	                    var node = self.findNode(detail.id);
	                    if(Global.isDebug) {
	                        console.log(node);
	                    }
	                    if(node){
	                        node.value = detail.value;
	                        if(Global.isDebug) {
	                            console.log(node);
	                        }
	                        if(node.ins)
	                            node.ins.render();
	                    }
	                    break;
	                }
	            }
	        }else{
	            self.links.forEach(function(link){
	                if(Global.isDebug) {
	                    console.log(link);
	                }
	                
	                delete link.value;
	                if(link.ins)
	                    link.ins.render();
	            });
	            self.nodes.forEach(function(node){
	                if(Global.isDebug) {
	                    console.log(node);
	                }
	                delete node.value;
	                if(node.ins)
	                    node.ins.render();
	            });
	        }
	    }
	
	    var addItemsHandler = function(event) {
	        var data = event.detail;
	        switch (data.type){
	            case "link":{
	                self.addLinksInUI(data.data)
	                break;
	            }
	            case "group":{
	                self.addGroupsInUI(data.data)
	                break;
	            }
	
	            default:{
	                self.addNodesInUI(data.data);
	                break;
	            }
	
	        }
	    };
	
	
	    var _mouseDownHandler=undefined;
	    this.addMouseDownHandler=function(handler){
	        _mouseDownHandler=handler;
	    }
	    var _nodeClickHandler=undefined;
	    this.addNodeClickHandler=function(handler){
	        _nodeClickHandler=handler;
	    }
	    var _mouseMoveHandler=undefined;
	    this.addMouseMoveHandler=function(handler){
	        _mouseMoveHandler=handler;
	    }
	    var _mouseUpHandler=undefined;
	    this.addMouseUpHandler=function(handler){
	        _mouseUpHandler=handler;
	    }
	
	    //缓存 mouse down 响应对象
	    var downTargetD = undefined;
	    var edit_mouseDownHandler = function() {    
	        if(_mouseDownHandler){
	            _mouseDownHandler(self);
	        }    
	
	        /* if(!operationData)return;
	        var target = d3.event.target;
	        var d = target.__data__;
	        if(d && d.ins) {
	            downTargetD = d;
	        }
	        switch(operationData.type){
	            case "node":{
	                break;
	            }
	            case "delete":{
	                var coordinates  = MouseUtil.mouse(self.mainContainer().node(), self.graph());
	                createSelectRect(coordinates[0], coordinates[1]);
	                break;
	            }
	            case "group":{
	                var coordinates  = MouseUtil.mouse(self.mainContainer().node(), self.graph());
	                createSelectRect(coordinates[0], coordinates[1]);
	                break;
	            }
	            case "link":{
	                endDrawLink();
	                drawLinkSource = undefined;
	                if(downTargetD) {
	                    var ins = downTargetD.ins;
	                    var linkData = {renderer:operationData.renderer, name:"", lineIndex:0, visible:true};
	                    if(ins instanceof Node) {
	                        drawLinkSource = d;
	                        startDrawLink(d.x, d.y, linkData);
	                    }
	                }
	                break;
	            }
	        } */
	    };
	    
	    var edit_mouseMoveHandler = function() {
	        if(_mouseMoveHandler){
	            _mouseMoveHandler(self);
	        }
	        /* if(self.isEditMode()&&drawLinkSource){
	            var coordinates  = MouseUtil.mouse(self.mainContainer().node(), self.graph());
	            drawLink(drawLinkSource.x, drawLinkSource.y, coordinates[0], coordinates[1]);
	        } */
	    };
	    
	    var edit_mouseUpHandler = function() {
	        if(_mouseUpHandler){
	            _mouseUpHandler(self);
	        }
	        
	
	        /* if(self.isEditMode()){
	            var target = d3.event.target;
	            var coordinates  = MouseUtil.mouse(self.mainContainer().node(), self.graph());
	            var d = target.__data__;
	            var data = {};
	            data.type="mouse_up";
	            data.x = coordinates[0];
	            data.y = coordinates[1];
	            self.node().dispatchEvent(EventUtil.createCustomEvent(BaseEvent.TOPO_EDIT_POSITON,true,true,data));
	        } */
	        
	        /* switch(operationData.type){
	            case "node":{
	                var data = ObjectUtil.cloneObj(operationData);
	                data.x = coordinates[0];
	                data.y = coordinates[1];
	                self.node().dispatchEvent(EventUtil.createCustomEvent(BaseEvent.OPERATION_END,true,true,data));
	                break;
	            }
	            case "group":{
	                self.setSelectedItemsInSelectArea();
	                removeSelectRect();
	                var data = ObjectUtil.cloneObj(operationData);
	                data.items = selectedNodeItems;
	                self.node().dispatchEvent(EventUtil.createCustomEvent(BaseEvent.OPERATION_END,true,true,data));
	                break;
	            }
	            case "link":{
	                var d = target.__data__;
	                if(d && d.ins) {
	                    var ins = d.ins;
	                    if(drawLinkSource && ins instanceof Node && drawLinkSource!==d) {
	                        var data = ObjectUtil.cloneObj(operationData);
	                        data.source = drawLinkSource;
	                        data.target = d;
	                        self.node().dispatchEvent(EventUtil.createCustomEvent(BaseEvent.OPERATION_END,true,true,data));
	                    }
	                }
	                drawLinkSource = null;
	                endDrawLink();
	                break;
	            }
	            case "delete":{
	                var d = target.__data__;
	                if(d && d.ins) {
	                    var ins = d.ins;
	                    if(ins instanceof GroupNode)
	                        selectedGroupItems.push(d);
	                    if(ins instanceof Node)
	                        selectedNodeItems.push(d);
	                }
	                self.setSelectedItemsInSelectArea();
	                removeSelectRect();
	                var data = ObjectUtil.cloneObj(operationData);
	                data.nodeItems = selectedNodeItems;
	                data.linkItems = selectedLinkItems;
	                data.groupItems = selectedGroupItems;
	                self.node().dispatchEvent(EventUtil.createCustomEvent(BaseEvent.OPERATION_END,true,true,data));
	                break;
	            }
	        } */
	    };
	    
	    var removeItemsHandler = function(event) {
	        self.removeAllSelectedInUI();
	    };
	
	    
	    /**
	     * 当处于编辑状态时添加编辑容器
	     */
	    var addEditContainer = function() {
	        var editCon = new BaseComponent();
	        editCon.className("edit-container");
	        editCon.percentWidth(100);
	        editCon.percentHeight(100);
	        self.addChild(editCon);
	        editCon.mainContainer().attr("pointer-events", "none");
	        self.editCon = editCon;
	    };
	    
	    /**
	     * 移除编辑容器
	     */
	    var removeEditContainer = function() {
	        if(self.editCon) {
	            self.removeChild(self.editCon);
	            delete self.editCon;
	        }
	    };
	    
	    /**
	     * 创建框选矩形
	     */
	    this.createSelectRect = function() {
	        if(self.editCon) {
	            var con = self.parent().parent().mainContainer();
	            var coordinates  = MouseUtil.mouse(con.node(), self.graph());
	            var rect = con.select("rect.select");
	            if(rect.node() === null) {
	                selectRectX = coordinates[0];
	                selectRectY = coordinates[1];
	                con.append("rect")
	                    .attr("class", "select")
	                    .attr("x", selectRectX)
	                    .attr("y", selectRectY)
	                    .attr("stroke", "#0078d7")
	                    .attr("stroke-width", 1)
	                    .attr("fill", "#0078d7")
	                    .attr("fill-opacity", 0.1)
	                    .attr("pointer-events","none")
	            }
	        }
	    };
	    
	    /**
	     * 绘制框选矩形
	     */
	    this.drawSelectRect = function() {
	        if(self.editCon) {
	            var con = self.parent().parent().mainContainer();
	            var rect = con.select("rect.select");
	            if(rect.node()) {
	                var sx, sy, mp = MouseUtil.mouse(con.node(), self.graph());//d3.mouse(con.node());
	                mp[0]=mp[0];
	                mp[1]=mp[1];
	
	                if(mp[0] < selectRectX) {
	                    w = selectRectX - mp[0];
	                    sx = mp[0];
	                } else {
	                    w = mp[0] - selectRectX;
	                    sx = selectRectX;
	                }
	                if(mp[1] < selectRectY) {
	                    h = selectRectY - mp[1];
	                    sy = mp[1];
	                } else {
	                    h = mp[1] - selectRectY;
	                    sy = selectRectY;
	                }
	                rect.attr("x", sx).attr("y", sy)
	                    .attr("width", w).attr("height", h);
	            }
	        }
	    };
	    
	     /**
	     * 移除框选矩形
	     */
	    this.removeSelectRect = function() {
	        if(self.editCon) {
	            self.parent().parent().mainContainer().select("rect.select").remove();
	        }
	    };
	    
	    /**
	     * 准备开始画连线
	     * @param x1, y1 起点坐标
	     * @param d 连线数据对象
	     */
	    this.startDrawLink = function(x1, y1, d) {
	        // if(!isDrawLink) {
	        //     return;
	        // }
	        d.source = {x:x1, y:y1};
	        d.target = {x:x1+1, y:y1+1};
	        var rendererConfig;
	        //获取节点渲染器配置
	        if(d.renderer) {
	            rendererConfig = self.data().renderers[d.renderer];
	        }
	        drawlinkIns = ClassFactory.newLinkInstance(rendererConfig.clazz, [self.linksContainer.mainContainer(), d]);
	        drawlinkIns.config(rendererConfig.config)
	        drawlinkIns.render();
	    };
	    
	    /**
	     * 画连线
	     * @param x1, y1 起点坐标
	     * @param x2, y2 终点坐标
	     */
	    this.drawLink = function(x1, y1, x2, y2) {
	        if(drawlinkIns) {
	            var d = drawlinkIns.itemData();
	            d.source.x = x1;
	            d.source.y = y1;
	            d.target.x = x2;
	            d.target.y = y2;
	            drawlinkIns.update();
	        }
	    };
	    
	    /**
	     * 结束画连线
	     */
	    this.endDrawLink = function() {
	        // if(!isDrawLink) {
	        //     return;
	        // }
	        if(drawlinkIns) {
	            drawlinkIns.el.remove();
	            drawlinkIns = null;
	        }
	    };
	
	    /**
	     * 增加一个节点界面操作
	     * @param node 节点数据对象
	     */
	    this.addNodeInUI = function(node) {
	        self.addNode(node);
	        self.update(true);
	    };
	
	    /**
	     * 批量增加节点界面操作 
	     * @param nodes 节点数据对象数组
	     */
	    this.addNodesInUI = function(nodes) {
	        self.addNodes(nodes);
	        self.addAutoGroupNodes(nodes);
	        self.update(true);
	    };
	
	    /**
	     * 增加一条连线界面操作
	     * @param link 连线数据对象 
	     */
	    this.addLinkInUI = function(link) {
	        self.addLink(link);
	        self.update(true);
	    };
	
	    /**
	     * 批量增加连线界面操作
	     * @param links 连线数据对象数组
	     */
	    this.addLinksInUI = function(links) {
	        self.addLinks(links);
	        self.update(true);
	    };
	
	    /**
	     * 批量增加组操作
	     * @param groups 组对象数组
	     */
	    this.addGroupsInUI = function(groups) {
	        self.addGroups(groups);
	        self.update(true);
	    };
	
	    /**
	     * 批量增加组操作
	     * @param groups 组对象数组
	     */
	    this.removeGroupsInUI = function(groups) {
	        if(!groups.length)return;
	        groups.forEach(function(group){
	            self.removeGroup(group);
	        })
	        self.update(true);
	    }
	    
	
	    /**
	     * 删除节点界面操作 
	     * @param id 要删除的节点id
	     */
	    this.removeNodeInUI = function(node) {
	        self.removeNode(node);
	        self.update(true);
	    };
	    
	    /**
	     * 批量删除节点界面操作 
	     * @param ids 要删除的节点id数组
	     */
	    this.removeNodesInUI = function(nodes) {
	        if(!nodes.length)return;
	        self.removeNodes(nodes);
	        self.update(true);
	    };
	    
	    /**
	     * 删除连线界面操作 
	     * @param link 要删除的连线数据对象
	     */
	    this.removeLinkInUI = function(link) {
	        self.removeLink(link);
	        self.update(true);
	    };
	    
	    /**
	     * 批量删除连线界面操作 
	     * @param links 要删除的连线数据对象数组
	     */
	    this.removeLinksInUI = function(links) {
	        if(!links ||!links.length)return;
	        self.removeLinks(links);
	        self.update(true);
	    };
	    
	    /**
	     * 批量删除选中节点和连线界面操作 
	     */
	    this.removeAllSelectedInUI = function() {
	        // var plugin, links = [], nodeIds = [];
	        // self.nodesIns.forEach(function(ins) {
	        //     plugin = ins.normalChild();
	        //     if(plugin && plugin.selected()){
	        //         nodeIds.push(plugin.el.data()[0].id);
	        //     }
	        // });
	        // self.linksIns.forEach(function(ins) {
	            // plugin = ins.normalChild();
	        //     if(plugin && plugin.selected()){
	        //      links.push(plugin.el.data()[0]);
	        //     }
	        // });
	        // self.removeNodes(nodeIds);
	        self.removeGroupsInUI(selectedGroupItems);
	        self.removeLinksInUI(selectedLinkItems)
	        self.removeNodesInUI(selectedNodeItems);
	    };
	    
	    /**
	     * 删除节点下的子节点，同时清除link信息界面操作 
	     * @param id 要删除的节点id
	     */
	    this.removeChildNodesInUI = function(id) {
	        self.removeChildNodes(id);
	        self.update(true);
	    };
	    
	    /**
	     * 展开节点界面操作
	     * @param id 要展开的节点id
	     * @param isExpandAll 是否强制展开所有子孙节点，默认为false,
	     *                    若为false则原先合拢的子孙节点在父节点展开后保持原有状态；若为true则强制展开所有子孙节点
	     */
	    this.expandNodeInUI = function(id, isExpandAll) {
	        self.expandNode(id, isExpandAll);
	        self.update(true);
	    };
	    
	    /**
	     * 合拢节点界面操作
	     * @param id 要合拢的节点id
	     */
	    this.collapseNodeInUI = function(id) {
	        self.collapseNode(id);
	        self.update(true);
	    };
	    
	    /**
	     * 展开或者合拢节点界面操作
	     * @param node 当前要展开或者合拢的节点数据对象
	     */
	    this.expandOrCollapseNodeInUI = function(node) {
	        if(!node.enabledExpand) {
	            return;
	        }
	        self.expandOrCollapseNode(node);
	        self.update(true);
	    };
	
	    // --------------------------------------------------------------------------
	    // change data control
	    // --------------------------------------------------------------------------
	    
	    /**
	     * 清空变更集数据
	     */
	    var clearChangeData = function() {
	        changeData.nodes.enter = {};
	        changeData.nodes.update = {};
	        changeData.links.enter = {};
	        changeData.links.update = {};
	        changeData.groups.enter = {};
	        changeData.groups.update = {};
	    };
	    
	    /**
	     * 添加数据到变更集
	     * @param arguments[0] 变更数据
	     * @param arguments[1] 目标源对象
	     */
	    var addItemsToChangeData = function() {
	        var source = arguments[1];
	        if(!ObjectUtil.isObject(source)) {
	            return;
	        }
	        if(ObjectUtil.isArray(arguments[0])) {
	            var items = arguments[0];
	            for(var item, i = 0, len = items.length; i < len; i++) {
	                item = items[i];
	                source[self.bindKeyFn(item)] = item;
	            }
	        } else {
	            var item = arguments[0];
	            source[self.bindKeyFn(item)] = item;
	        }
	    };
	    
	    /**
	     * 数据是否在变更集中
	     * @param arguments[0] 带检测项数据对象
	     * @param arguments[1] 目标源对象
	     * @return 返回检测结果
	     */
	    var isItemInChangeData = function() {
	        var source = arguments[1];
	        if(!ObjectUtil.isObject(source)) {
	            return false;
	        }
	        return source.hasOwnProperty(self.bindKeyFn(arguments[0]));
	    };
	    
	    /**
	     * 触发鹰眼变更
	     */
	    function fireContentChange(){
	        self.mainContainer().node().dispatchEvent(EventUtil.createEvent(BaseEvent.CONTENT_CHANGE,true,true));
	    }
	    
	    EditorTopology.clazzName = "EditorTopology";
	    
	    // 初始化
	    this.init();
	};
	
	EditorTopology.struct = function(ghca_charts) {
	    var BaseChart = ghca_charts.view.component.charts.baseChart;
	    BaseChart.struct(ghca_charts);
	    EditorTopology.prototype = Object.create(BaseChart.prototype);
	    EditorTopology.prototype.constructor = EditorTopology;
	};
	
	// --------------------------------------------------------------------------
	//
	// Const
	//
	// --------------------------------------------------------------------------
	
	//显示所有节点
	EditorTopology.SHOW_ALL_LEVEL_NODES = 99999;
	
	//显示第一层级所有节点
	EditorTopology.SHOW_FIRST_LEVEL_NODES = 0;
	
	module.exports = EditorTopology;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {//图表底部标题类
		
	/**
	 * 构造方法
	 * @param _parent 标题所在组件实例
	 * @param _config 整体配置数据
	 * @param _headingConfig 标题配置数据
	 */
	var Heading = function (_parent, _config, _headingConfig) {
		
		// --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const ColorUtil = ghca_charts.view.util.colorUtil;
	    const ObjectUtil = ghca_charts.view.util.objectUtil;
	    const StringUtil = ghca_charts.view.util.stringUtil;
	    const RegexUtil = ghca_charts.view.util.regexUtil;
	    const Global = ghca_charts.global;
	
	    if(arguments.length < 1) {
	        throw new Error('传入参数个数错误,当前个数' + arguments.length + ",应至少传入1个参数");
	    }
	    
	    //判断是否传入有效配置信息
	    if(!_config || !_headingConfig) {
	        return;
	    }
	    
	    var self = this, mainTextIns, subTextIns;
	    
	    //--------------------------------------------------------------------------
	    //
	    //  Attributes
	    //
	    //--------------------------------------------------------------------------
	    
	    //------------------------------
	    //  xPos
	    //------------------------------
	    
	    /**
	     * 水平位置 left|center|right|具体数值(默认值left)
	     */
	    var xPos = "left";
	    this.xPos = function(value) {
	        if (!arguments.length) return xPos;
	        xPos = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  yPos
	    //------------------------------
	    
	    /**
	     * 垂直位置 top|middle|bottom|具体数值(默认值top)
	     */
	    var yPos = "top";
	    this.yPos = function(value) {
	        if (!arguments.length) return yPos;
	        yPos = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  text
	    //------------------------------
	    
	    /**
	     * 主标题数据对象
	     */
	    var mainText = {text:"", "font-size":16, "font-family":"Microsoft YaHei", "fill":"black", "pointer-events":"none"};
	    this.mainText = function(value) {
	        if (!arguments.length) return mainText;
	        mainText = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  subText
	    //------------------------------
	    
	    /**
	     * 子标题数据对象
	     */
	    var subText = {text:"", "font-size":12, "font-family":"Microsoft YaHei", "fill":"black", "pointer-events":"none"};
	    this.subText = function(value) {
	        if (!arguments.length) return subText;
	        subText = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  padding
	    //------------------------------
	    
	    /**
	     * 标题Padding(默认10px)
	     * 格式为{left:left,right:right,top:top,bottom:bottom}或者一个数值，
	     * 配置中padding:10等同于padding:{left:10,right:10,top:10,bottom:10}
	     */
	    var padding = {left:10,right:10,top:10,bottom:10};
	    this.padding = function(value) {
	        if (!arguments.length) return padding;
	        padding = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  itemGap
	    //------------------------------
	    
	    /**
	     * 标题项之间间距(默认10px)
	     */
	    var itemGap = 10;
	    this.itemGap = function(value) {
	        if (!arguments.length) return itemGap;
	        itemGap = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  visible
	    //------------------------------
	    
	    /**
	     * 标题是否可见，(默认值true)
	     */
	    var visible = true;
	    this.visible = function(value) {
	        if (!arguments.length) return visible;
	        visible = value;
	        return this;
	    };
	    
	    // ------------------------------
	    // config
	    // ------------------------------
	
	    /**
	     * 整体配置数据
	     */
	    var config = _config;
	    this.config = function(value) {
	        if (!arguments.length)
	            return config;
	        config = value;
	        return this;
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // private Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    /**
	     * 初始化方法
	     */
	    var init = function() {
	        if (!_parent) {
	            throw new Error('Heading构造方法中传入的容器_ele:' + _ele + "无法找到。");
	        }
	        self.parent = _parent;
	        self.itemsList = [];
	    };
	    
	    /**
	     * 初始化标题包含的各个层级
	     */
	    var initAllContainers = function() {
	        //放置所有内容的最外层g元素
	    	if(self.visible() && !self.headingContainer) {
	    		self.headingContainer = self.parent.mainContainer().append("g").attr("class", "heading");
	    	} else if(!self.visible() && self.headingContainer) {
	    		self.headingContainer.remove();
	    		self.headingContainer = null;
	    		mainTextIns = null;
	    		subTextIns = null;
	    		self.itemsList.length = 0;
	    	}
	    };
	    
	    //--------------------------------------------------------------------------
	    //
	    //  public Methods
	    //
	    //--------------------------------------------------------------------------
	    
	    /**
	     * 刷新传入配置数据到相应标题参数的方法
	     */
	    this.refreshData = function() {
	        var heading = _headingConfig;
	        self.xPos(heading.hasOwnProperty("xPos") ? heading.xPos : xPos);
	        self.yPos(heading.hasOwnProperty("yPos") ? heading.yPos : yPos);
	        self.visible(heading.hasOwnProperty("visible") ? heading.visible : visible);
	        if(heading.hasOwnProperty("padding")) {
	        	var configPadding = heading.padding;
	        	var defaultPadding = self.padding();
	        	if(!isNaN(configPadding)) {
	        		defaultPadding.left = configPadding;
	        		defaultPadding.right = configPadding;
	        		defaultPadding.top = configPadding;
	        		defaultPadding.bottom = configPadding;
	        	} else {
	        		for(var key in configPadding) {
	                    defaultPadding[key] = configPadding[key];
	                }
	        	}
	        } else {
	        	self.padding(padding);
	        }
	        self.itemGap(heading.hasOwnProperty("itemGap") ? heading.itemGap : itemGap);
	        if(heading.hasOwnProperty("mainText")) {
	        	var defaultMainText = self.mainText();
	        	var configText = heading.mainText;
	        	for(var key in configText) {
	        		defaultMainText[key] = configText[key];
	        	}
	        }
	        if(heading.hasOwnProperty("subText")) {
	            var defaultSubText = self.subText();
	            var configSubText = heading.subText;
	            for(var key in configSubText) {
	                defaultSubText[key] = configSubText[key];
	            }
	        }
	    };
	    
	    /**
	     * 渲染主标题方法
	     */
	    this.mainTextRender = function() {
	    	var p = self.mainText();
	        if(!self.visible() || p.visible === false) {
	            return;
	        }
	        if(!mainTextIns) {
	        	var itemCon = self.headingContainer.append("g").attr("class", "mainText-container");
	            mainTextIns = itemCon.append("text").attr("class", "mainText");
	            self.itemsList.push(itemCon);
	        }
	        var content = self.getResultLabel(p.text);
	        mainTextIns.text(content);
	        //保留svg text元素中文本的空格显示
	        StringUtil.fixTextSpace(mainTextIns.node());
	        for(var key in p) {
	        	if(key !== "visible") {
	        		mainTextIns.attr(key, p[key]);
	        	}
	        }
	    };
	    
	    /**
	     * 渲染子标题方法
	     */
	    this.subTextRender = function() {
	    	var p = self.subText();
	    	if(!self.visible() || p.visible === false) {
	    		return;
	    	}
	    	if(!subTextIns) {
	    		var itemCon = self.headingContainer.append("g").attr("class", "subText-container");
	            subTextIns = itemCon.append("text").attr("class", "subText");
	            self.itemsList.push(itemCon);
	    	}
	        var content = self.getResultLabel(p.text);
	        subTextIns.text(content);
	        //保留svg text元素中文本的空格显示
	        StringUtil.fixTextSpace(subTextIns.node());
	        for(var key in p) {
	        	if(key !== "visible") {
	        		subTextIns.attr(key, p[key]);
	        	}
	        }
	    };
	    
	    /**
	     * 重新计算布局
	     */
	    this.resetLayout = function(isUpdate) {
	        if(!self.headingContainer || (!mainTextIns && !subTextIns)) {
	            return;
	        }
	        
	        var padding = self.padding(),
	            itemX = 0, 
	            itemY = 0, 
	            itemGap = self.itemGap(),
	            maxItemW = 0,
	            maxItemH = 0,
	            xPos = self.xPos(),
	            yPos = self.yPos(),
	            parentBox = self.parent.bgNode().getBBox();
	            parentW = parentBox.width,
	            parentH = parentBox.height,
	            layoutW = parentW - padding.left - padding.right;//可用于布局标题区域的宽度，不包括padding
	            layoutH = parentH - padding.top - padding.bottom;//可用于布局标题区域的高度，不包括padding
	            itemIns = null, 
	            itemBox = null;
	        
	        var itemsY = [];
	        for(var i = 0, len = self.itemsList.length; i < len; i++) {
	            itemIns = self.itemsList[i];
	            itemBox = itemIns.node().getBBox();
	            itemY += itemBox.height;
	            maxItemW = itemBox.width > maxItemW ? itemBox.width : maxItemW;
	            if(itemY + itemGap <= layoutH) {
	                itemIns.attr("transform", "translate(" + itemX + "," + itemY + ")");
	            } else {
	                itemX += (maxItemW + itemGap);
	                itemY = 0;
	                maxItemW = 0;
	                itemIns.attr("transform", "translate(" + itemX + "," + itemY + ")");
	            }
	            itemsY.push(itemY);
	            itemY += itemGap;
	        }
	            
	        //计算heading容器位置
	        var x = 0,
	            y = 0,
	            headingBox = self.headingContainer.node().getBBox(),
	            headingW = headingBox.width,
	            headingH = headingBox.height;
	        //计算水平定位
	        if(!isNaN(xPos)) {
	            x = xPos;
	        } else if(xPos === "left") {
	            x = padding.left;
	        } else if(xPos === "right")  {
	            x = parentW - headingW - padding.right;
	        } else {//default center
	            x = (parentW - headingW) / 2;
	            for(var i = 0, len = self.itemsList.length; i < len; i++) {
	                itemIns = self.itemsList[i];
	                itemBox = itemIns.node().getBBox();
	                itemX = (headingW - itemBox.width) / 2;
	                itemIns.attr("transform", "translate(" + itemX + "," + itemsY[i] + ")");
	            }
	        }
	        
	        //计算垂直定位
	        if(!isNaN(yPos)) {
	            y = yPos;
	        } else if(yPos === "middle") {
	            y = (parentH - headingH) / 2;
	        } else if(yPos === "bottom")  {
	            y = parentH - headingH - padding.bottom;
	        } else {//defult top
	            y = padding.top;
	        }
	        
	        if(isUpdate) {
	        	self.headingContainer
	                .attr("transform", "translate(" + x + "," + y + ")scale(1)");
	        } else {
	        	self.headingContainer
	                .attr("transform-origin", "center center")
	                .attr("transform", "translate(" + x + "," + y + ")scale(1)")
	                .attr("opacity", 0)
	                .transition().duration(500).ease(d3.easeExpIn)
	                .attr("opacity", 1)
	                .attr("transform", "translate(" + x + "," + y + ")scale(1)");
	        }
	    };
	    
	    /**
	     * 渲染方法
	     */
	    this.render = function() {
	        self.refreshData();
	        //初始化图列包含的各个层级
	        initAllContainers();
	        self.mainTextRender();
	        self.subTextRender();
	        self.resetLayout();
	        Global.isDebug && console.log("Heading.render()");
	    };
	    
	    /**
	     * 更新方法
	     */
	    this.update = function() {
	        self.refreshData();
	        initAllContainers();
	        self.mainTextRender();
	        self.subTextRender();
	        self.resetLayout(true);
	        Global.isDebug && console.log("Heading.update()");
	    };
	    
	    /**
	     * 根据labelFormat获取最终label的方法
	     * @param label labelFormat
	     */
	    this.getResultLabel = function(label) {
	    	if(label === null || label === undefined) {
	    		return "";
	    	}
	    	if(ObjectUtil.isNumber(label)) {
	    		label = label.toString();
	    	}
	    	var config = self.config();
	        var isSeriesConfig = config.hasOwnProperty("seriesConfig");
	        var series = config.series;
	        var data = isSeriesConfig ? series : series[0].data;//供传入方法调用
	        return label.replace(RegexUtil.jsRegex, function() {
	            return arguments.length > 1 && data.length > 0 ? eval(arguments[1]) : "";
	        });
	    };
	    
	    /**
	     * override toString方法，用于打印本对象的一些基本信息
	     */
	    this.toString = function () {
	        return ("Heading info: "    +
	                "\n   xPos:"        + self.xPos()       + 
	                "\n   yPos:"        + self.yPos());
	    };
	    
	    // 初始化
	    init();
	};
	
	Heading.struct = function(ghca_charts) {
	    Heading.prototype.constructor = Heading;
	};
	
	// --------------------------------------------------------------------------
	//
	// Const
	//
	// --------------------------------------------------------------------------
	
	module.exports = Heading;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {//水平坐标轴
	    
	/**
	 * 构造方法 
	 * @param _parent 坐标轴项所在容器对象
	 * @param _data 坐标轴项数据
	 */
	var HorAxis = function(_parent, _data) {
	    
	    // --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const BaseAxis = ghca_charts.view.component.charts.baseAxis;
	    
	    BaseAxis.apply(this, arguments);
	
	    var self = this,
	        superRenderAxis = self.renderAxis;
	    
	    //设置坐标轴默认位置
	    self.position("bottom");
	    
	    // --------------------------------------------------------------------------
	    //
	    // Attributes
	    //
	    // --------------------------------------------------------------------------
	        
	    //------------------------------
	    //  attribute
	    //------------------------------
	    
	    // --------------------------------------------------------------------------
	    //
	    // public Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    this.toString = function() {
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // private Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    /**
	     * 渲染坐标轴
	     */
	    this.renderAxis = function() {
	    	superRenderAxis();
	    	
	        var xScale, xAxis, boundBox, boundW, boundH, axisX, axisY,
	            domain = self.domain(), type = self.type(), padding = self.padding(), isReverse = self.isReverse();
	        if(type === "time") {
	            xScale = d3.scaleTime().clamp(true);
	        } else if(type === "enum") {
	            xScale = d3.scaleBand();
	        } else {
	            //type is value
	            xScale = d3.scaleLinear().clamp(true);
	        }
	        boundBox = self.parentChart().bgNode().getBBox();
	        boundW = boundBox.width;
	        boundH = boundBox.height;
	        axisW = boundW - padding.left - padding.right;
	        axisX = padding.left;
	        xScale.domain(domain).range(isReverse ? [axisW, 0] : [0, axisW]);
	            
	        if(self.position() === "top") {
	            xAxis = d3.axisTop(xScale);
	            axisY = padding.top;
	        } else {
	            xAxis = d3.axisBottom(xScale);
	            axisY = boundH - padding.bottom;
	        }
	        self.x(axisX);
	        self.y(axisY);
	        self.width(axisW);
	        //set tick opt
	        var tick = self.tick();
	        for(var key in tick) {
	            if(xAxis.hasOwnProperty(key)) {
	                xAxis[key](tick[key]);
	            }
	        }
	        //render x axis
	        if(!self.axisContainer) {
	            self.axisContainer = self.parent.append("g").attr("class", "xAxis");
	        }
	        self.axisContainer
	            .style("visibility", self.visible() === false ? "hidden" : "visible")
	            .call(xAxis)
	            .attr("transform", "translate(" + axisX + "," + axisY + ")");
	            
	        self.scaleIns(xScale);
	        self.axisIns(xAxis);
	    };
	    
	    /**
	     * 渲染坐标轴说明标签
	     */
	    this.renderAxisLabel = function() {
	        var x, y, label,
	            config = self.axisLabel(), 
	            text = config.text;
	            pos = config.pos, 
	            padding = config.padding;
	        if(text === "" || text === null || text === undefined) {
	        	return;
	        }
	        
	        label = self.axisContainer.selectAll("text.axisLabel");
	        if(label.node() === null) {
	        	label = self.axisContainer.append("text").attr("class", "axisLabel");
	        }
	        label.text(text);
	        
	        //设置坐标轴说明标签样式
	        self.setAxisLabelStyle();
	        
	        //计算布局
	        var labelBox = label.node().getBBox();
	        var maxTickWidth = 0;
	        var maxTickHeight = 0;
	        self.axisContainer.selectAll("g.tick").each(function(d){
	            var tickBox = d3.select(this).node().getBBox();
	            if(tickBox.width > maxTickWidth) {
	            	maxTickWidth = tickBox.width;
	            }
	            if(tickBox.height > maxTickHeight) {
	                maxTickHeight = tickBox.height;
	            }
	        });
	        if(pos === "left") {
	            x = labelBox.width / 2;
	        } else if(pos === "center") {
	            x = self.width() / 2;    
	        } else {
	            x = self.width() - labelBox.width / 2;         
	        }
	        if(self.position() === "bottom") {
	        	y = labelBox.height + maxTickHeight + padding;
	        } else {
	            y = -labelBox.height - maxTickHeight - padding;
	        }
	        label.attr("transform", "translate(" + x + "," + y + ")");
	    };
	    
	    /**
	     * 渲染刻度对应网格
	     * @rect 网格区域矩形
	     */
	    this.renderTickLine = function(rect) {
	    	var x, y1, y2;
	    	if(self.position() === "bottom") {
	    		y1 = 0;
	    		y2 = -rect.h;
	    	} else {
	    		y1 = 0;
	            y2 = rect.h;
	    	}
	    	
	    	var ticks = self.axisContainer.selectAll("g.tick");
	    	var pathNode = self.axisContainer.select("path.domain").node();
	        var axisPathWidth = pathNode ? pathNode.getBBox().width : NaN;
	    	ticks.each(function() {
	    		var transform = d3.select(this).attr("transform");
	            var tx = parseFloat(transform.replace(/[^0-9.\-, ]/g,'').split(/[, ]/g)[0]) + 0.5;
	            //与y轴重叠的网格线不渲染，否会遮挡y轴线
	            if(!isNaN(axisPathWidth) && (Math.abs(tx - axisPathWidth) < 1 || tx < 1)) {
	                return;
	            }
	            x = tx;
	    		var line = self.gridLineContainer.append("line").attr("class", "tickLine")
	                .attr("x1", x).attr("y1", y1).attr("x2", x).attr("y2", y2);
	    	});
	    };
	    
	    /**
	     * 渲染刻度间对应网格
	     * @rect 网格区域矩形
	     */
	    this.renderInnerLine = function(rect) {
	        var x, y1, y2, 
	        gapNum = self.gridLine().innerLine.gapNum;
	        if(gapNum < 1) {
	        	return;
	        }
	        if(self.position() === "bottom") {
	            y1 = 0;
	            y2 = -rect.h;
	        } else {
	            y1 = 0;
	            y2 = rect.h;
	        }
	        
	        var ticks = self.axisContainer.selectAll("g.tick");
	        var dx, minX = NaN, maxX = NaN, n = gapNum + 1;
	        ticks.each(function() {
	            var transform = d3.select(this).attr("transform");
	            var tx = parseFloat(transform.replace(/[^0-9.\-, ]/g,'').split(/[, ]/g)[0]) + 0.5;
	            if(isNaN(tx)) {
	            	tx = 0;
	            }
	            if(isNaN(minX)) {
	            	minX = tx;
	            }
	            if(isNaN(maxX)) {
	                maxX = tx;
	            }
	            if(tx < minX) {
	            	minX = tx;
	            }
	            if(tx > maxX) {
	                maxX = tx;
	            }
	        });
	        dx = (maxX - minX) / (ticks.nodes().length - 1) / n;
	        //tick left part
	        for(x = minX - dx; x > 0; x -= dx) {
	            self.gridLineContainer.append("line").attr("class", "innerLine")
	                .attr("x1", x).attr("y1", y1).attr("x2", x).attr("y2", y2);
	        }
	        //tick part and right part
	        var i = 0, axisW = self.width();
	        for(x = minX; x < axisW; x += dx, i++) {
	        	//若有tickLine,则跳过
	        	if(i % n !== 0) {
	        		self.gridLineContainer.append("line").attr("class", "innerLine")
	                    .attr("x1", x).attr("y1", y1).attr("x2", x).attr("y2", y2);
	        	}
	        }
	    };
	    
	    /**
	     * 获取刻度坐标数据数组，该数组按升序排序。
	     * 若为水平坐标轴，则格式为[x1,...,xn]；若为垂直坐标轴，则格式为[y1,...,yn]
	     */
	    this.getTicksPos = function() {
	    	var result = [];
	        var ticks = self.axisContainer.selectAll("g.tick");
	        ticks.each(function() {
	            var transform = d3.select(this).attr("transform");
	            var tx = parseFloat(transform.replace(/[^0-9.\-, ]/g,'').split(/[, ]/g)[0]) + 0.5;
	            result.push(tx);
	        });
	        result.sort(function(a, b){return a - b;});
	        return result;
	    };
	    
	};
	
	HorAxis.struct = function(ghca_charts) {
		var BaseAxis = ghca_charts.view.component.charts.baseAxis;
	    BaseAxis.struct(ghca_charts);
	    HorAxis.prototype = Object.create(BaseAxis.prototype);
	    HorAxis.prototype.constructor = HorAxis;
	};
	
	// --------------------------------------------------------------------------
	//
	// Const
	//
	// --------------------------------------------------------------------------
	
	module.exports = HorAxis;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {//图例类
		
	/**
	 * 构造方法
	 * @param _parent 图例所在组件实例
	 * @param _config 整体配置数据
	 */
	var Legend = function (_parent, _config) {
		
		// --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const LegendItem = ghca_charts.view.component.charts.legendItem;
	    const ColorUtil = ghca_charts.view.util.colorUtil;
	    const ObjectUtil = ghca_charts.view.util.objectUtil;
	    const RegexUtil = ghca_charts.view.util.regexUtil;
	    const StringUtil = ghca_charts.view.util.stringUtil;
	    const Global = ghca_charts.global;
	    
	    if(arguments.length < 1) {
	        throw new Error('传入参数个数错误,当前个数' + arguments.length + ",应至少传入1个参数");
	    }
	    
	    //判断是否传入有效配置信息
	    if(!_config || !_config.legend) {
	        return;
	    }
	    
	    var self = this,
	    	defaultPadding = 10;
	    
	    //--------------------------------------------------------------------------
	    //
	    //  Attributes
	    //
	    //--------------------------------------------------------------------------
	    
	    //------------------------------
	    //  xPos
	    //------------------------------
	    
	    /**
	     * 水平位置 left|center|right|具体数值(默认值center)
	     */
	    var xPos = "center";
	    this.xPos = function(value) {
	        if (!arguments.length) return xPos;
	        xPos = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  yPos
	    //------------------------------
	    
	    /**
	     * 垂直位置 top|middle|bottom|具体数值(默认值top)
	     */
	    var yPos = "top";
	    this.yPos = function(value) {
	        if (!arguments.length) return yPos;
	        yPos = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  onlyOneColumn
	    //------------------------------
	    
	    /**
	     * 是否只有一列内容(默认值false)
	     */
	    var onlyOneColumn = false;
	    this.onlyOneColumn = function(value) {
	        if (!arguments.length) return onlyOneColumn;
	        onlyOneColumn = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  onlyOneRow
	    //------------------------------
	    
	    /**
	     * 是否只有一行内容(默认值false)
	     */
	    var onlyOneRow = false;
	    this.onlyOneRow = function(value) {
	        if (!arguments.length) return onlyOneRow;
	        onlyOneRow = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  visible
	    //------------------------------
	    
	    /**
	     * 图例是否可见(默认值true)
	     */
	    var visible = true;
	    this.visible = function(value) {
	        if (!arguments.length) return visible;
	        visible = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  keyPath
	    //------------------------------
	    
	    /**
	     * 针对下面key属性，设置该key所在对象路径，从图表数据本身开始，图表本身数据所在路径为xxx..series[n]，
	     * 要取topo的节点为图例，则这里传"nodes",相当于xxx..series[n].nodes， 
	     * 要取topo的连线为图例，则这里传"links",,相当于xxx..series[n].links，
	     * 若不传，则下面的key就是var array = xxx..series[n];array[n].key(默认值"")
	     */
	    var keyPath = "";
	    this.keyPath = function(value) {
	        if (!arguments.length) return keyPath;
	        keyPath = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  key
	    //------------------------------
	    
	    /**
	     * 用来进行图例项分组的键名称，比如"level"，(默认值name)
	     */
	    var key = "name";
	    this.key = function(value) {
	        if (!arguments.length) return key;
	        key = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  items
	    //------------------------------
	    
	    /**
	     * 图例项说明文字数组，若不传则默认为key对应的值组成的数组，若传入值，比如[0, 1]，
	     * 则只对key对应值为0或者1的数据对象分组标注图例，其他值的数据对象渲染成第三种颜色，图例项文本为“其他”
	     */
	    var items = [];
	    this.items = function(value) {
	        if (!arguments.length) return items;
	        items = StringUtil.parseArray(value);
	        return this;
	    };
	    
	    //------------------------------
	    //  labelFormat
	    //------------------------------
	    
	    /**
	     * 图例项说明文字组成规则，比如"等级{v}",{v}表示items对应的值，
	     * 若items为[0, 1]，则最终显示为"等级0"或者"等级1"，若不传，默认显示为items的值
	     */
	    var labelFormat = null;
	    this.labelFormat = function(value) {
	        if (!arguments.length) return labelFormat;
	        labelFormat = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  colors
	    //------------------------------
	    
	    /**
	     * 用户自定义图例颜色数组
	     */
	    var colors = null;
	    this.colors = function(value) {
	        if (!arguments.length) return colors;
	        colors = StringUtil.parseArray(value);
	        return this;
	    };
	    
	    //------------------------------
	    //  icon
	    //------------------------------
	    
	    /**
	     * 用户自定义图例图形相关配置，统一形式。定义了icons以后该属性无效
	     */
	    var icon = null;
	    this.icon = function(value) {
	        if (!arguments.length) return icon;
	        icon = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  icons
	    //------------------------------
	    
	    /**
	     * 用户自定义图例图形相关配置，枚举形式
	     */
	    var icons = null;
	    this.icons = function(value) {
	        if (!arguments.length) return icons;
	        icons = StringUtil.parseArray(value);
	        return this;
	    };
	    
	    //------------------------------
	    //  label
	    //------------------------------
	    
	    /**
	     * 用户自定义图例文本相关配置，统一形式。定义了labels以后该属性无效
	     */
	    var label = null;
	    this.label = function(value) {
	        if (!arguments.length) return label;
	        label = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  labels
	    //------------------------------
	    
	    /**
	     * 用户自定义图例文本相关配置，枚举形式
	     */
	    var labels = null;
	    this.labels = function(value) {
	        if (!arguments.length) return labels;
	        labels = StringUtil.parseArray(value);
	        return this;
	    };
	    
	    //------------------------------
	    //  domain
	    //------------------------------
	    
	    /**
	     * colors数组对应的范围值数组，默认null，比如用户要定义0-24,25-49,50-74,75-100这些范围，可以传入[25, 50, 75]
	     */
	    var domain = null;
	    this.domain = function(value) {
	        if (!arguments.length) return domain;
	        domain = StringUtil.parseArray(value);
	        return this;
	    };
	    
	    // ------------------------------
	    // showTotal
	    // ------------------------------
	
	    /**
	     * 在图例标签后是否显示该图列所对应的实例总个数，默认为否
	     */
	    var showTotal = false;
	    this.showTotal = function(value) {
	        if (!arguments.length)
	            return showTotal;
	        showTotal = value;
	        return this;
	    };
	    
	    // ------------------------------
	    // mouseOverEffect
	    // ------------------------------
	
	    /**
	     * 在鼠标经过图例项时，是否在图例对应的所有实例上播放效果动画，默认为否
	     */
	    var mouseOverEffect = false;
	    this.mouseOverEffect = function(value) {
	        if (!arguments.length)
	            return mouseOverEffect;
	        mouseOverEffect = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  itemGap
	    //------------------------------
	    
	    /**
	     * 图例间距
	     */
	    var itemGap = 10;
	    this.itemGap = function(value) {
	        if (!arguments.length) return itemGap;
	        itemGap = value;
	        return this;
	    };
	    
	    // ------------------------------
	    // config
	    // ------------------------------
	
	    /**
	     * 整体配置数据
	     */
	    var config = _config;
	    this.config = function(value) {
	        if (!arguments.length)
	            return config;
	        config = value;
	        return this;
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // private Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    /**
	     * 初始化方法
	     */
	    var init = function() {
	        if (!_parent) {
	            throw new Error('Legend构造方法中传入的容器_ele:' + _ele + "无法找到。");
	        }
	        self.parent = _parent;
	        self.itemsList = [];//图例项实例列表
	        self.itemsData = [];//生成的用来实例化图例项的数据
	    };
	    
	    /**
	     * 初始化图列包含的各个层级
	     */
	    var initAllContainers = function() {
	        //放置所有内容的最外层g元素
	    	if(self.visible() && !self.legendContainer) {
	    		self.legendContainer = self.parent.mainContainer().append("g").attr("class", "legend");
	    	} else if(!self.visible() && self.legendContainer) {
	    		self.legendContainer.remove();
	    	}
	    };
	    
	    //--------------------------------------------------------------------------
	    //
	    //  public Methods
	    //
	    //--------------------------------------------------------------------------
	    
	    /**
	     * 刷新传入配置数据到相应图例参数的方法
	     */
	    this.refreshData = function() {
	        var isSetItems = false,
	            parseDomain = false,
	            legend = self.config().legend;
	        self.xPos(legend.hasOwnProperty("xPos") ? legend.xPos : "center");
	        self.yPos(legend.hasOwnProperty("yPos") ? legend.yPos : "top");
	        self.visible(legend.hasOwnProperty("visible") ? legend.visible : true);
	        self.onlyOneColumn(legend.hasOwnProperty("onlyOneColumn") ? legend.onlyOneColumn : false);
	        self.onlyOneRow(legend.hasOwnProperty("onlyOneRow") ? legend.onlyOneRow : false);
	        self.showTotal(legend.hasOwnProperty("showTotal") ? legend.showTotal : false);
	        self.mouseOverEffect(legend.hasOwnProperty("mouseOverEffect") ? legend.mouseOverEffect : false);
	        self.itemGap(legend.hasOwnProperty("itemGap") ? legend.itemGap : 10);
	        self.keyPath(legend.hasOwnProperty("keyPath") ? legend.keyPath : "");
	        self.labelFormat(legend.hasOwnProperty("labelFormat") ? legend.labelFormat : null);
	        if(legend.hasOwnProperty("colors") && legend.colors) {
	            self.colors(legend.colors);
	            parseDomain = true;
	        }
	        if(legend.hasOwnProperty("icon") && legend.icon) {
	            self.icon(legend.icon);
	            parseDomain = true;
	        }
	        if(legend.hasOwnProperty("label") && legend.label) {
	            self.label(legend.label);
	            parseDomain = true;
	        }
	        if(legend.hasOwnProperty("icons") && legend.icons) {
	            self.icons(legend.icons);
	            parseDomain = true;
	        }
	        if(legend.hasOwnProperty("labels") && legend.labels) {
	            self.labels(legend.labels);
	            parseDomain = true;
	        }
	        if(parseDomain && legend.hasOwnProperty("domain") && legend.domain) {
	            self.domain(legend.domain);
	        }
	        if(legend.hasOwnProperty("key") && ObjectUtil.isString(legend.key)) {
	            self.key(legend.key);
	        } else {
	            self.key("name");
	        }
	        //若没有传入items，则根据key获取items，否则直接使用items
	        if(legend.hasOwnProperty("items") && ObjectUtil.isArray(legend.items) &&　legend.items.length > 0) {
	            isSetItems = true;
	            self.items(legend.items);
	        } else {
	            isSetItems = false;
	            self.items([]);
	        }
	        var index = 0, series = self.config().series;
	        if(series) {
	            var itemsData;
	            var outerPlugins = ghca_charts.global.outerPlugins;
	            series.forEach(function(chartData) {
	                if(outerPlugins && outerPlugins.chartMap && outerPlugins.chartMap[chartData.type]) {
	                	//检查外部注册的图表类
	                	itemsData = self.keyPath() === "" ? chartData.data : eval('chartData.'+self.keyPath());
	                } else {
	                	//检查内部注册的图表类
	                	switch(chartData.type.toLowerCase()) {
	                        case "topology":
	                        case "biztopology":
	                        case "sankey":
	                        case "tree":
	                        case "sunburst":
	                        case "pack":
	                        case "radialtree":
	                           itemsData = self.keyPath() === "" ? chartData.nodes : eval('chartData.'+self.keyPath());
	                           break;
	                        case "pie":
	                        case "scatter":
	                        case "area":
	                        case "line":
	                        case "bar":
	                        case "treemap":
	                        case "calendar":
	                        case "progressbar":
	                            itemsData = self.keyPath() === "" ? chartData.data : eval('chartData.'+self.keyPath());
	                           break;
	                        default:
	                           itemsData = null;
	                           break;
	                    }
	                }
	                if(itemsData) {
	                    self.concat(self.itemsData, self.getItemsData(itemsData, chartData, isSetItems, index));
	                }
	                index++;
	            });
	        }
	    };
	    
	    var getItemValue = function(d, key) {
	    	var value = null;
	    	try {
	    		if(RegexUtil.jsRegex.test(key)) {
	    			value = key.replace(RegexUtil.jsRegex, function() {
	                    return arguments.length > 1 ?  eval(arguments[1]) : "";
	                });
	    		} else {
	    			value = key.indexOf(".") !== -1 ? eval("d." + key) : d[key];
	    		}
	    	} catch(e) {
	    		value = null;
	    	}
	    	return value;
	    }
	    
	    /**
	     * 获取图例项数据
	     * @param data 图例项控制需要的数据数组
	     * @param chartData 图表数据
	     * @param isSetItems 是否在初始化配置中定义items内容
	     * @param index 本图表数据在series中的索引值
	     * @return 返回生成的图例项数据
	     */
	    this.getItemsData = function(data, chartData, isSetItems, index) {
	        var result = [];
	        if(!data || data.length == 0){
	            return result;
	        }
	        var itemColor, itemData, itemValue, 
	            chartType = chartData.type;
	            keyMap = {}, 
	            key = self.key(),
	            colors = self.colors(),
	            colorIndex = 0;
	            labelFormat = self.labelFormat();
	        //是否在初始化配置中定义items内容
	        if(isSetItems) {
	            /*若items传入值，比如[0, 1]，则生成的图例项渲染数据itemsData中，只对由key指定属性对应的值为0或者1的数据对象分组标注图例，
	                   图列项文本由labelFormat属性确定，其他值的数据对象渲染成第三种颜色，图例项文本为“其他”*/
	            var otherData = [], items = self.items();
	            for(var i = 0, len = data.length; i < len; i++) {
	                itemData = data[i];
	                itemValue = getItemValue(itemData, key);
	                //根据items中的某个值,查找对应的data中的所有指定key属性对应的值为该值的节点，生成需要的数据
	                if(!keyMap[itemValue] && items.indexOf(itemValue) !== -1) {
	                    itemColor = ColorUtil.getColor(colorIndex === 0 ? index : colorIndex, colors);
	                    result.push({
	                        iconShape:Legend.ITEM_ICON_MAP[chartType],
	                        color:itemColor,
	                        showTotal:showTotal,
	                        mouseOverEffect:mouseOverEffect,
	                        label:self.getResultLabel(labelFormat, itemValue, itemValue, data, itemData), 
	                        chartData:chartData,
	                        data:data.filter(function(item) {
	                            if(getItemValue(item, key) === itemValue) {
	                                item.legendColor = itemColor;
	                                return true;
	                            }
	                            return false;
	                        })
	                    });
	                    keyMap[itemValue] = 1;
	                    colorIndex++;
	                } else if(items.indexOf(itemValue) === -1) {
	                    //记录其他
	                    otherData.push(itemData);
	                }
	            }
	            //若有其他项数据，则添加图例其他项
	            if(otherData.length > 0) {
	            	var otherColorIndex = colorIndex === 1 ? (index + 1) : colorIndex;
	            	var otherTypeColor = ColorUtil.getColor(otherColorIndex, colors);
	            	for(var i = 0, len = otherData.length; i < len; i++) {
	            		itemData = otherData[i];
	            		itemData.legendColor = otherTypeColor;
	            	}
	                result.push({
	                    iconShape:Legend.ITEM_ICON_MAP[chartType],
	                    color:otherTypeColor,
	                    showTotal:showTotal,
	                    mouseOverEffect:mouseOverEffect,
	                    label:"其他", 
	                    chartData:chartData,
	                    data:otherData
	                });
	            }
	        } else {
	            //若items不传值，则生成的图例项渲染数据itemsData默认为由key指定属性对应的值组成的数组，且数组内容不能重复
	            var useDomainColor = self.colors() != null && self.domain() != undefined;
	            //判断是否使用用户自定义图例颜色
	            var colorFn = useDomainColor ? 
	                d3.scaleThreshold().domain(self.domain()).range(self.colors()) : 
	                ColorUtil.getColor;
	            var iconConfig = self.icons() === null ? 
	                self.icon() === null ? null : [self.icon] : 
	                self.icons();
	            var iconFn = iconConfig !== null ? 
	                d3.scaleThreshold().domain(self.domain() && self.icons() ? self.domain() : []).range(iconConfig) : 
	                null;
	            var labelConfig = self.labels() === null ? 
	                self.label() === null ? null : [self.label()] : 
	                self.labels();
	            var labelFn = labelConfig !== null ? 
	                d3.scaleThreshold().domain(self.domain() && self.labels() ? self.domain() : []).range(labelConfig) : 
	                null;
	            //定义使用用户自定义颜色时，获取labelFormat属性中{v}代表的范围说明字符串的方法
	            var getValueLabel = function(itemValue) {
	                if(useDomainColor) {
	                    var scoreAry = colorFn.invertExtent(itemValue);
	                    var valueLabel;
	                    if(scoreAry[0] === undefined) {
	                        valueLabel = scoreAry[1] + "(不含)以下";
	                    } else if(scoreAry[1] === undefined) {
	                        valueLabel = scoreAry[0] + "(含)以上";
	                    } else {
	                        valueLabel = scoreAry.join("(含)-") + "(不含)";
	                    }
	                    return valueLabel;
	                }
	                return itemValue;
	            };
	            //拼装图例项渲染数据
	            for(var i = 0, len = data.length; i < len; i++) {
	                itemData = data[i];
	                itemValue = useDomainColor ? colorFn(getItemValue(itemData, key)) : getItemValue(itemData, key);
	                if(itemValue !== undefined && itemValue !== null && !keyMap[itemValue]) {
	                    itemColor = useDomainColor ? itemValue : colorFn(colorIndex === 0 ? index : colorIndex, colors);
	                    result.push({
	                        iconShape:Legend.ITEM_ICON_MAP[chartType],
	                        customIcon:iconFn ? iconFn(getItemValue(itemData, key)) : null,
	                        customLabel:labelFn ? labelFn(getItemValue(itemData, key)) : null,
	                        color:itemColor,
	                        showTotal:showTotal,
	                        mouseOverEffect:mouseOverEffect,
	                        label:self.getResultLabel(labelFormat, getValueLabel(itemValue), itemValue, data, itemData), 
	                        chartData:chartData,
	                        data:data.filter(function(item) {
	                            if((useDomainColor ? colorFn(getItemValue(item, key)) : getItemValue(item, key)) === itemValue) {
	                                item.legendColor = itemColor;
	                                return true;
	                            }
	                            return false;
	                        })
	                    });
	                    keyMap[itemValue] = 1;
	                    colorIndex++;
	                }
	            }
	            //若使用自定义颜色，则按自定义颜色数组顺序对图例项排序
	            if(useDomainColor) {
	                var colors = self.colors();
	                result.forEach(function(obj) {
	                    return obj.index = colors.indexOf(obj.color);
	                });
	                result.sort(function(a, b){
	                    return a.index > b.index;
	                });
	            }
	        }
	        return result;
	    };
	    
	    /**
	     * 把目标数组中的元素添加到源数组中的方法
	     * @param ary1 源数组
	     * @param ary2 目标数组
	     * @return 返回添加元素后的源数组
	     */
	    this.concat = function(ary1, ary2) {
	        if(!ary2 || !ObjectUtil.isArray(ary2)) {
	            return ary1;
	        }
	        for(var i = 0, len = ary2.length; i < len; i++) {
	            ary1.push(ary2[i]);
	        }
	        return ary1;
	    };
	    
	    /**
	     * 渲染所有图例项方法
	     */
	    this.ItemsRender = function() {
	        var itemsData = self.itemsData;
	        if(!itemsData || !self.visible()) {
	            return;
	        }
	        for(var i = 0, len = itemsData.length; i < len; i++) {
	            self.ItemRender(itemsData[i]);
	        }
	    };
	    
	    /**
	     * 渲染单个图例项方法
	     * @param itemData 图例项数据
	     */
	    this.ItemRender = function(itemData) {
	        var itemCon = self.legendContainer.append("g").attr("class", "legendItem");
	        var item = new LegendItem(itemCon, itemData);
	        item.render();
	        self.itemsList.push(item);
	    };
	    
	    /**
	     * 更新内容
	     */
	    this.update = function() {
	    	//clear
	    	self.xPos("center");
	        self.yPos("top");
	        self.visible(true);
	        self.onlyOneColumn(false);
	        self.onlyOneRow(false);
	        self.showTotal(false);
	        self.mouseOverEffect(false);
	        self.keyPath("");
	        self.labelFormat(null);
	        self.colors(null);
	        self.icons(null);
	        self.labels(null);
	        self.icon(null);
	        self.label(null);
	        self.domain(null);
	        self.key("name");
	        self.items([]);
	    	self.itemsList = [];
	        self.itemsData = [];
	    	if(self.legendContainer) {
	    		self.legendContainer.remove();
	    		self.legendContainer = null;
	    	}
	    	
	    	self.render();
	    };
	    
	    /**
	     * 重新计算布局
	     */
	    this.resetLayout = function() {
	        if(!self.legendContainer || self.itemsList.length === 0) {
	            return;
	        }
	        //计算legendItem容器位置
	        var padding = ObjectUtil.isObject(self.config().legend.padding) ? self.config().legend.padding : defaultPadding,
	        	paddingLeft = ObjectUtil.isObject(padding) && ObjectUtil.isNumber(padding.left) ? padding.left : defaultPadding;
		        paddingRight = ObjectUtil.isObject(padding) && ObjectUtil.isNumber(padding.right) ? padding.right : defaultPadding;
		        paddingTop = ObjectUtil.isObject(padding) && ObjectUtil.isNumber(padding.top) ? padding.top : defaultPadding;
		        paddingBottom = ObjectUtil.isObject(padding) && ObjectUtil.isNumber(padding.bottom) ? padding.bottom : defaultPadding;
	            itemX = 0, 
	            itemY = 0, 
	            itemGap = self.itemGap(),
	            maxItemW = 0,
	            maxItemH = 0,
	            xPos = self.xPos(),
	            yPos = self.yPos(),
	            parentBox = self.parent.bgNode().getBBox();
	            parentW = parentBox.width,
	            parentH = parentBox.height,
	            layoutW = parentW - paddingLeft - paddingRight;//可用于布局图列项区域的宽度，不包括padding
	            layoutH = parentH - paddingTop - paddingBottom;//可用于布局图列项区域的高度，不包括padding
	            itemIns = null, 
	            itemBox = null;
	        
	        //若水平位置设置为居中模式，则使用行布局；否则使用列布局
	        if(onlyOneRow || (xPos === "center" && !onlyOneColumn)) {
	            for(var i = 0, len = self.itemsList.length; i < len; i++) {
	                itemIns = self.itemsList[i].ele;
	                itemBox = itemIns.node().getBBox();
	                maxItemH = itemBox.height > maxItemH ? itemBox.height : maxItemH;
	                if(itemX + itemBox.width + itemGap <= layoutW) {
	                    itemIns.attr("transform", "translate(" + itemX + "," + itemY + ")");
	                } else {
	                    itemX = 0;
	                    itemY += (maxItemH + itemGap);
	                    maxItemH = 0;
	                    itemIns.attr("transform", "translate(" + itemX + "," + itemY + ")");
	                }
	                itemX += (itemBox.width + itemGap);
	            }
	        } else {
	            for(var i = 0, len = self.itemsList.length; i < len; i++) {
	                itemIns = self.itemsList[i].ele;
	                itemBox = itemIns.node().getBBox();
	                maxItemW = itemBox.width > maxItemW ? itemBox.width : maxItemW;
	                if(itemY + itemBox.height + itemGap <= layoutH) {
	                    itemIns.attr("transform", "translate(" + itemX + "," + itemY + ")");
	                } else {
	                    itemX += (maxItemW + itemGap);
	                    itemY = 0;
	                    maxItemW = 0;
	                    itemIns.attr("transform", "translate(" + itemX + "," + itemY + ")");
	                }
	                itemY += (itemBox.height + itemGap);
	            }
	        }
	            
	        //计算legend容器位置
	        var x = 0,
	            y = 0,
	            legendBox = self.legendContainer.node().getBBox(),
	            legendW = legendBox.width,
	            legendH = legendBox.height;
	        //计算水平定位
	        if(!isNaN(xPos)) {
	            x = xPos;
	        } else if(xPos === "left") {
	            x = paddingLeft;
	        } else if(xPos === "right")  {
	            x = parentW - legendW - paddingRight;
	        } else {//default center
	            x = (parentW - legendW) / 2;
	        }
	        
	        //计算垂直定位
	        if(!isNaN(yPos)) {
	            y = yPos;
	        } else if(yPos === "middle") {
	            y = (parentH - legendH) / 2;
	        } else if(yPos === "bottom")  {
	            y = parentH - legendH - paddingBottom;
	        } else {//defult top
	            y = paddingTop;
	        }
	        
	        self.legendContainer.attr("transform", "translate(" + x + "," + y + ")");
	    };
	    
	    /**
	     * 渲染方法
	     */
	    this.render = function() {
	        self.refreshData();
	        //初始化图列包含的各个层级
	        initAllContainers();
	        self.ItemsRender();
	        self.resetLayout();
	        if(Global.isDebug) {
	            console.log("Legend.render()");
	        }
	    };
	    
	    /**
	     * 根据labelFormat获取最终label的方法
	     * @param label labelFormat
	     * @param value 替换内容，支持{#script#},其中script为js脚本内容；支持{v},相当于{#d[key]#}
	     * @param defaultResult 默认最终label
	     * @param data 所有项数据
	     * @param d 当前项数据
	     */
	    this.getResultLabel = function(label, value, defaultResult, data, d) {
	    	if(!label) {
	    		return defaultResult;
	    	}
	    	var result = label.replace(/{v}/ig, value);
	        return result.replace(RegexUtil.jsRegex, function() {
	            return arguments.length > 1 ? eval(arguments[1]) : "";
	        });
	    };
	    
	    /**
	     * override toString方法，用于打印本对象的一些基本信息
	     */
	    this.toString = function () {
	        return ("Legend info: "     +
	                "\n   xPos:"        + self.xPos()       + 
	                "\n   yPos:"        + self.yPos()       + 
	                "\n   key:"         + self.key()        + 
	                "\n   items:"       + self.items()      + 
	                "\n   labelFormat:" + self.labelFormat());
	    };
	    
	    // 初始化
	    init();
	};
	
	Legend.struct = function(ghca_charts) {
	    Legend.prototype.constructor = Legend;
	};
	
	// --------------------------------------------------------------------------
	//
	// Const
	//
	// --------------------------------------------------------------------------
	
	/**
	 * 根据图表类型提供相应的图例项图标的映射对象
	 */
	Legend.ITEM_ICON_MAP = {
	    line:   	"line",
	    area:   	"line",
	    pie:    	"pie",
	    sunburst:	"pie"
	};
	
	module.exports = Legend;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {//图例项类
		
	/**
	 * 构造方法
	 * @param _ele 图例项所在容器对象
	 * @param _data 图例项数据
	 */
	var LegendItem = function (_ele, _data) {
		
		// --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const BaseEvent = ghca_charts.events.BaseEvent;
	    const StringUtil = ghca_charts.view.util.stringUtil;
	    const EventUtil = ghca_charts.view.util.eventUtil;
	    const ElementUtil = ghca_charts.view.util.elementUtil;
	    const Global = ghca_charts.global;
	
	    if(arguments.length < 2) {
	        throw new Error('传入参数个数错误,当前个数' + arguments.length + ",应至少传入2个参数");
	    }
	    
	    var self = this,
	        lengedTimer = NaN;
	    
	    //--------------------------------------------------------------------------
	    //
	    //  Attributes
	    //
	    //--------------------------------------------------------------------------
	    
	    // ------------------------------
	    // data
	    // ------------------------------
	
	    /**
	     * 图例项数据
	     */
	    var data = _data;
	    this.data = function(value) {
	        if (!arguments.length)
	            return data;
	        data = value;
	        return this;
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // private Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    /**
	     * 初始化方法
	     */
	    var init = function() {
	        //获取渲染容器实例
	        if (typeof(_ele) == 'string') {
	            _ele = document.getElementById(_ele);
	        }
	        if (!_ele) {
	            throw new Error('LegendItem构造方法中传入的容器_ele:' + _ele + "无法找到。");
	        }
	        self.ele = _ele;
	        self.isShow = true;
	        
	        //添加监听
	        addListeners();
	    };
	    
	    /**
	     * 初始化添加所有监听的方法
	     */
	    var addListeners = function() {
	        self.ele.on("click.legendItem", clickHandler);
	        self.ele.on("mouseover.legendItem", mouseOverHandler);
	        self.ele.on("mouseout.legendItem", mouseOutHandler);
	    };
	    
	        
	    /**
	     * 获取该图列所对应的实例总个数标签内容
	     */
	    var getTotalLabel = function(itemData) {
	        return (itemData.showTotal && itemData && itemData.data)  ? "("+itemData.data.length+")" : "";
	    };
	    
	    /**
	     * 设置图例对应所有实例的属性
	     * @param key 样式名称
	     * @param value 样式值
	     */
	    var setLegendInsAttr = function(key, value) {
	        var data = self.data().data;
	        for (var i = 0, len = data.length; i < len; i++) {
	            var ins = data[i].legendIns;
	            ins = ins && ins.mainContainer ? ins.mainContainer() : ins;
	            ins && ins.attr(key, value);
	        };
	    };
	    
	    /**
	     * 在图例对应所有实例上播放闪烁效果
	     */
	    var playLegendAnimate = function() {
	    	if(!self.data().mouseOverEffect) {
	    		return;
	    	}
	    	var i = 0, minOpacity = 0.25;
	        setLegendInsAttr("opacity", minOpacity);
	        lengedTimer = setInterval(function() {
	            if(i === 2 && !isNaN(lengedTimer)) {
	                clearInterval(lengedTimer);
	                lengedTimer = NaN;
	            }
	            setLegendInsAttr("opacity", i % 2 === 0 ? 1 : minOpacity);
	            i++;
	        }, 400);
	    };
	    
	    /**
	     * 在图例对应所有实例上停止播放闪烁效果
	     */
	    var stopLegendAnimate = function() {
	    	if(!self.data().mouseOverEffect) {
	            return;
	        }
	    	if(!isNaN(lengedTimer)) {
	            clearInterval(lengedTimer);
	            lengedTimer = NaN;
	        }
	        setLegendInsAttr("opacity", 1);
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // listeners
	    //
	    // --------------------------------------------------------------------------
	    
	    /**
	     * 点击事件
	     */
	    var clickHandler = function() {
	    	var e = (arguments.length > 0 && arguments[0]) || window.event || d3.event;
	    	e.stopImmediatePropagation();
	    	stopLegendAnimate();
	    	
	    	var itemData = self.data();
	        if(!itemData) {
	            return;
	        }
	    	self.isShow = !self.isShow;
	    	//是否自定义图标或者
	    	if(itemData.customIcon || itemData.customLabel) {
	    		if(self.isShow) {
	    			self.shape.style("opacity", 1);
	    		} else {
	    			self.shape.style("opacity", 0.65);
	    		}
	    	} else {
	    		var hideColor = "#ccc", 
	                showColor = "#000", 
	                itemData = self.data(),
	                shape = itemData.iconShape ? itemData.iconShape : "rect";
	            if(self.isShow) {
	                self.shape.selectAll(".icon").attr(shape === "line" ? "stroke" : "fill", itemData.color);
	                self.label.attr("fill", showColor);
	            } else {
	                self.shape.selectAll(".icon").attr(shape === "line" ? "stroke" : "fill", hideColor);
	                self.label.attr("fill", hideColor);
	            }
	    	}
	    	var data = self.data().data;
	    	data.forEach(function(itemData) {
	    		itemData.visible = self.isShow;
	    	});
	    	//抛出图例项鼠标点击事件
	    	var evt = EventUtil.createEvent(BaseEvent.LEGEND_ITEM_CLICK, {bubbles:true, cancelable:true});
	    	self.ele.node().dispatchEvent(evt);
	    };
	    
	    /**
	     * 鼠标经过事件
	     */
	    var mouseOverHandler = function() {
	    	if(self.isShow) {
	    		self.ele.style("cursor", "pointer");
	            self.shape.selectAll("*").style("opacity", 0.65);
	            self.label.style("opacity", 0.5);
	            //闪烁效果
	            playLegendAnimate();
	    	}
	    };
	    
	    /**
	     * 鼠标移出事件
	     */
	    var mouseOutHandler = function() {
	    	if(self.isShow) {
	    		self.shape.selectAll("*").style("opacity", 1);
	    		self.label.style("opacity", 1);
	    		stopLegendAnimate();
	    	}
	    };
	    
	    //--------------------------------------------------------------------------
	    //
	    //  public Methods
	    //
	    //--------------------------------------------------------------------------
	    
	    /**
	     * 创建内容
	     */
	    this.createContent = function() {
	        var itemData = self.data();
	        if(!itemData) {
	            return;
	        }
	        
	        var customIcon = itemData.customIcon;
	        var customLabel = itemData.customLabel;
	        var gap = (customIcon && customIcon.hasOwnProperty("gap")) ? customIcon.gap : 2;
	        var iconWidth = (customIcon && customIcon.hasOwnProperty("iconWidth")) ? customIcon.iconWidth : 24;
	        var iconHeight = (customIcon && customIcon.hasOwnProperty("iconHeight")) ? customIcon.iconHeight : 12;
	         
	        //text
	        var content = itemData.label + getTotalLabel(itemData);
	        var maxLength = customLabel && customLabel.hasOwnProperty("maxLength") ? customLabel.maxLength : 0;
	        if(maxLength > 0 && content.length > maxLength) {
	        	self.ele.append("title").text(content);
	        	content = content.substring(0, maxLength) + "...";
	        }
	        self.label = self.ele
	          .append("text")
	          .attr("class", "legendItemText")
	          .attr("font-size", "12px")
	          .attr("pointer-events", "none")
	          .attr("x", iconWidth + gap)
	          .text(content);
	        
	        //设置自定义文本样式
	        if(customLabel) {
	        	ElementUtil.setElementProperties(self.label, customLabel);
	        }
	        //保留svg text元素中文本的空格显示
	        StringUtil.fixTextSpace(self.label.node());
	        
	        var labelBox = self.label.node().getBBox();
	        var labelWidth = labelBox.width;
	        var labelHeight = labelBox.height;
	        var bgWidth = iconWidth + gap + labelWidth;
	        var bgHeight = iconHeight < labelHeight ? labelHeight : iconHeight;
	        
	        self.label.attr("y", customIcon ? (labelHeight + iconHeight)/2 : iconHeight);
	        
	        //icon
	        self.shape = self.ele.append("g").attr("pointer-events", "none");
	        if(customIcon) {
	        	//custom icon
	        	self.shape = self.shape
	                .append(customIcon.shape)
	                .attr("class", "icon");
	            if(customIcon.shape === "circle") {
	            	self.shape.attr("cx", iconWidth/2).attr("cy", bgHeight/2);
	            } else {
	            	self.shape.attr("x", 0)
	                    .attr("y", (bgHeight - iconHeight)/2)
	                    .attr("width", iconWidth)
	                    .attr("height", iconHeight);
	            }
	            var iconStyle = customIcon.style;
	            if(iconStyle) {
	                ElementUtil.setElementProperties(self.shape, iconStyle);
	            }    
	        } else {
	        	//icon, default is rect
	            var shape = itemData.iconShape ? itemData.iconShape : "rect";
	            if(shape === "rect") {
	                self.shape
	                    .append("rect")
	                    .attr("class", "icon")
	                    .attr("x", 0)
	                    .attr("y", (bgHeight - iconHeight)/2)
	                    .attr("width", iconWidth)
	                    .attr("height", iconHeight)
	                    .attr("rx", 3)
	                    .attr("ry", 3)
	                    .attr("fill", itemData.color);
	            } else if(shape === "line") {
	                self.shape
	                    .append("line")
	                    .attr("class", "icon")
	                    .attr("x1", 0)
	                    .attr("x2", iconWidth)
	                    .attr("y1", bgHeight/2)
	                    .attr("y2", bgHeight/2)
	                    .attr("stroke-width", 1.5)
	                    .attr("stroke", itemData.color);
	                    
	                if(itemData.chartData.nodeShow) {
	                    self.shape
	                        .append("circle")
	                        .attr("class", "icon")
	                        .attr("cx", iconWidth/2)
	                        .attr("cy", bgHeight/2)
	                        .attr("r", 3)
	                        .attr("stroke-width", 1.5)
	                        .attr("fill", itemData.color)
	                        .attr("stroke", itemData.color);
	                }
	            } else if(shape === "pie") {
	                var arc = d3.arc()
	                    .outerRadius(iconHeight)
	                    .innerRadius(iconHeight/2);
	                    
	                self.shape
	                    .append("path")
	                    .attr("class", "icon")
	                    .attr("d", arc({startAngle:-Math.PI/3.5, endAngle:Math.PI/3.5}))
	                    .attr("fill", itemData.color)
	                    .attr("transform", "translate(" + [iconHeight, 
	                        iconHeight + (bgHeight - self.shape.node().getBBox().height)/2] + ")");
	            }
	        }
	        
	        if(self.shape) {
	        	self.shape.attr("pointer-events", "none");
	        }
	        
	        //background rect
	        self.bgRect = self.ele
	            .insert("rect", ":first-child")
	            .attr("x", 0)
	            .attr("y", 0)
	            .attr("width", bgWidth)
	            .attr("height", bgHeight)
	            .attr("fill", "red")
	            .attr("opacity", 0);
	    };
	    
	    /**
	     * 渲染方法
	     */
	    this.render = function() {
	        self.createContent();
	        Global.isDebug && console.log("LegendItem.render()");
	    };
	    
	    /**
	     * override toString方法，用于打印本对象的一些基本信息
	     */
	    this.toString = function () {
	    };
	    
	    // 初始化
	    init();
	};
	
	LegendItem.struct = function(ghca_charts) {
	    LegendItem.prototype.constructor = LegendItem;
	};
	
	module.exports = LegendItem;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {// 线图类
	    
	/**
	 * 构造方法 
	 * @param _data 线图配置数据
	 * @param _layout 线图布局对象，不传就为默认布局
	 */
	var Line = function(_data, _layout) {
	    
	    // --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const BaseComponent = ghca_charts.view.component.baseComponent;
	    const BaseChart = ghca_charts.view.component.charts.baseChart;
	    const ClassFactory = ghca_charts.view.util.classFactory;
	    const ColorUtil = ghca_charts.view.util.colorUtil;
	    const SvgUtil = ghca_charts.view.util.svgUtil;
	
	    BaseChart.apply(this, arguments);
	    
	    var self = this,
	        nodesInsMap = {},
	        superInit = self.init,
	        superInitAllContainers = self.initAllContainers,
	        superAddListeners = self.addListeners,
	        superRenderPosition = self.renderPosition,
	        superRefreshData = self.refreshData,
	        nodeInsMap = {};
	    
	    self.className("seriesLine");
	    //添加可从配置文件读取的属性名称
	    self.addAttributes("tension", "nodeShow");
	
	    // --------------------------------------------------------------------------
	    //
	    // Attributes
	    //
	    // --------------------------------------------------------------------------
	
	    // ------------------------------
	    // tension
	    // ------------------------------
	    
	    /**
	     * 连线弯曲率[0, 1],1时为折线，0和1之间(包括0)值为曲线(默认值为0)
	     */
	    var tension = 0;
	    this.tension = function(value){
	        if (!arguments.length) return tension;
	        tension = value;
	        return this;
	    };
	    
	    // ------------------------------
	    // nodeShow
	    // ------------------------------
	    
	    /**
	     * 是否显示节点(默认值为false)
	     */
	    var nodeShow = false;
	    this.nodeShow = function(value){
	        if (!arguments.length) return nodeShow;
	        nodeShow = value;
	        return this;
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // override Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    /**
	     * 初始化方法
	     */
	    this.init = function() {
	        superInit();
	        
	        var items = self.data().data;
	        self.visibleItems(items);
	        self.itemsIns = [];
	    };
	    
	    /**
	     * 初始化添加所有监听的方法
	     */
	    this.addListeners = function() {
	        superAddListeners();
	    };
	    
	    /**
	     * 刷新数据内容，生成需要的属性和相关值
	     */
	   this.refreshData = function() {
	   	    superRefreshData();
	        //生成visible属性，默认值为true
	        var items = self.data().data;
	        for(var item, i = 0, len = items.length; i < len; i++) {
	            item = items[i];
	            item.bindKey = i;
	            if(!item.hasOwnProperty("visible")) {
	                item.visible = true;
	            }
	        }
	    };
	    
	    /**
	     * 渲染图表内容相关位置 
	     */
	    this.renderPosition = function() {
	        superRenderPosition();
	        
	        if(self.lineContainer) {
	            self.lineContainer.renderTransform();
	        }
	    };
	    
	    this.initAllContainers = function() {
	        superInitAllContainers();
	        
	        //放置所有项的g元素
	        if(!self.lineContainer) {
	            var lineContainer = new BaseComponent();
	            lineContainer.className("line-Container");
	            self.addChild(lineContainer);
	            self.lineContainer = lineContainer;
	        }
	    };
	    
	    /**
	     * 根据当前数据重新渲染内容，并重新计算布局内容
	     */
	    this.update = function() {
	    	self.refreshData();
	        var items = self.data().data;
	        self.visibleItems(self.filterArrayByElementProperty(items, "visible", true));
	        //计算布局，获取项数据数组
	        self.layout().update();
	        
	        /*这里先清除所有的项元素，然后再创建新的数据，否则动态添加的数据显示会有重复的问题。
	                                    但是这样做在ie和edge中会造成闪烁，且效率极低，有待优化。*/
	        var lineContainer = self.lineContainer;
	//        SvgUtil.removeAllChildren(lineContainer.node());
	//        self.itemsIns.length = 0;
	        
	//        //获取节点渲染器配置，并根据legend组件分配的颜色设置节点填充颜色,若没有legend相关配置，则pie组件始终强制使用自动生成的颜色填充
	//        for(var d, i = 0, len = itemsData.length; i < len; i++) {
	//            d = itemsData[i];
	//            if(d.legendColor === null || d.legendColor === undefined || d.legendColor === "") {
	//                d.legendColor = ColorUtil.getColor(i);
	//            }
	//            var config = self.getRendererConfig(d, "fill");
	//            //判断饼图外半径是否为auto,若为auto,则自动填满图表范围;若没有outerRadius属性，则等同于auto
	//            if(!config.hasOwnProperty("clazzProperties")) {
	//                
	//            } else if(config.clazzProperties.hasOwnProperty("outerRadius") && config.clazzProperties.outerRadius === "auto") {
	//                config.clazzProperties.outerRadius = Math.min(self.width(), self.height()) / 2;
	//            }
	//        }
	//        //渲染节点内容
	//        var itemsIns = ClassFactory.newRenderersInstanceByData(lineContainer, self, "itemContainer", itemsData);
	//        if(itemsIns) {
	//            for(var i = 0, len = itemsIns.length; i < len; i++) {
	//                self.itemsIns.push(itemsIns[i]);
	//            }
	//        }
	        
	        //渲染节点
	        var horAxis, verAxis, xScale, yScale, xPadding = 0, yPadding = 0, vAixsHeight = 0;
	        if(self.horAxis()) {
	            horAxis = self.horAxis();
	            xPadding = horAxis.padding();
	            xScale = horAxis.scaleIns();
	        }
	        if(self.verAxis()) {
	            verAxis = self.verAxis();
	            yPadding = verAxis.padding();
	            yScale = verAxis.scaleIns();
	            vAixsHeight = verAxis.height();
	        }
	        
	        var line = d3.line()
	            .x(function(d) { return d.x; })
	            .curve(d3.curveCardinal.tension(self.tension()));
	        
	        var defaultColor = ColorUtil.getColor(self.seriesIndex());
	        lineContainer = self.lineContainer.mainContainer();
	        self.lineContainer.x(xPadding.left);
	        self.lineContainer.y(yPadding.top);
	        
	        //根据字典中指定的渲染器数据生成节点渲染器数据
	        var visibleItems = self.visibleItems();
	        for(var d, i = 0, len = visibleItems.length; i < len; i++) {
	            d = visibleItems[i];
	            if(d.legendColor === null || d.legendColor === undefined || d.legendColor === "") {
	                d.legendColor = defaultColor;
	            }
	            self.getRendererConfig(d, "fill");
	        }
	        
	        //render path
	        var diffKey = self.diffKey();
	        var pathUpdate = lineContainer.selectAll("path.line-path")
	            .data(visibleItems.length > 0 ? [visibleItems] : []);
	        
	        var pathExit = pathUpdate.exit();
	        pathExit.remove();
	        
	        pathUpdate
	            .transition().duration(self.animation() ? 500 : 0)
	            .attr("stroke-linejoin", "round")
	            .attr("stroke-linecap", "round")
	            .attr("stroke-width", 1.5)
	            .attr("stroke", function(d) {
	                var color = defaultColor;
	                if(d.hasOwnProperty("legendColor")) {
	                    color = d.legendColor;
	                } else if(d.length > 0 && d[0].hasOwnProperty("legendColor")) {
	                    color = d[0].legendColor;
	                }
	                return color;
	            })
	            .attr("d", line.y(vAixsHeight))
	            .attr("d", line.y(function(d) { return d.y; }));
	        
	        pathUpdate.enter().append("path")
	            .attr("class", "line-path")
	            .attr("fill", "none")
	            .attr("stroke-linejoin", "round")
	            .attr("stroke-linecap", "round")
	            .attr("stroke-width", 1.5)
	            .attr("stroke", function(d) {
	            	var color = defaultColor;
	                if(d.hasOwnProperty("legendColor")) {
	                    color = d.legendColor;
	                } else if(d.length > 0 && d[0].hasOwnProperty("legendColor")) {
	                    color = d[0].legendColor;
	                }
	                return color;
	            })
	            .each(function(d) {
	                if(d.length > 0) {
	                    d[0].legendIns = self.lineContainer;
	                }
	            })
	            .attr("d", line.y(vAixsHeight))
	            .transition().duration(self.animation() ? 1000 : 0)
	            .attr("d", line.y(function(d) { return d.y; }));
	         
	        //render items
	        if(self.nodeShow()) {
	        	var pointUpdate = lineContainer.selectAll("g.point-item")
	        	   .data(visibleItems, self.bindKeyFn);
	            var pointExit = pointUpdate.exit();
	            pointExit.each(function(d) {
	                var key = self.bindKeyFn(d);
	                if(nodesInsMap.hasOwnProperty(key)) {
	                    delete nodesInsMap[key];
	                }
	            }).remove();
	            
	            //update
	            pointUpdate.each(function(d) {
	                var key = self.bindKeyFn(d);
	                var ins = nodesInsMap[key];
	                if(ins) {
	                    ins.data(d);
	                    ins.update();
	                    d.ins = ins;
	                    d.legendIns = ins;
	                }
	            });
	                
	            //add
	            var pointsEnter = pointUpdate.enter().append("g").attr("class", "point-item");
	            pointsEnter.each(function(d){
	                if(!d.hasOwnProperty("legendColor")) {
	                    d.legendColor = defaultColor;
	                }
	                var rendererConfig = self.getRendererConfig(d, "stroke");
	                var clazz = d.hasOwnProperty("renderer") ? rendererConfig.clazz : "lineNode";
	                var nodeIns = ClassFactory.newNodeInstance(clazz, [d3.select(this), d]);
	                nodeIns.render();
	                d.ins = nodeIns;
	                d.legendIns = self.lineContainer;
	                var key = self.bindKeyFn(d);
	                nodesInsMap[key] = nodeIns;
	            });
	        } else {
	        	lineContainer.selectAll("g.point-item").remove();
	        }
	            
	        self.renderPosition();
	    };
	    
	    /**
	     * override toString方法，用于打印本对象的一些基本信息
	     */
	    this.toString = function() {
	        return ("Line info: "     +
	                "\n   width:"     + self.width()      + 
	                "\n   height:"    + self.height()     + 
	                "\n   layout:"    + self.layout()     + 
	                "\n   data:"      + JSON.stringify(self.data(), null, 4));
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // listeners
	    //
	    // --------------------------------------------------------------------------
	    
	    // --------------------------------------------------------------------------
	    //
	    // public Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    Line.clazzName = "Line";
	    
	    // 初始化
	    self.init();
	};
	
	Line.struct = function(ghca_charts) {
	    var BaseChart = ghca_charts.view.component.charts.baseChart;
	    BaseChart.struct(ghca_charts);
	    Line.prototype = Object.create(BaseChart.prototype);
	    Line.prototype.constructor = Line;
	};
	
	// --------------------------------------------------------------------------
	//
	// Const
	//
	// --------------------------------------------------------------------------
	
	module.exports = Line;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {// pack图类
		
	/**
	 * 构造方法
	 * @param _data pack图配置数据
	 * @param _layout pack图布局对象，不传就为默认布局
	 */
	var Pack = function(_data, _layout) {
		
		// --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const BaseChart = ghca_charts.view.component.charts.baseChart;
	    const ObjectUtil =  ghca_charts.view.util.objectUtil;
	    const ClassFactory = ghca_charts.view.util.classFactory;
	
	    BaseChart.apply(this, arguments);
	
	    var self = this,
	        superInit = self.init,
	        superInitAllContainers = self.initAllContainers,
	        superAddListeners = self.addListeners,
	        superRefreshData = self.refreshData,
	        superRenderPosition = self.renderPosition;
	
	    self.className("pack");
	
	    var isInit = true,
	        node;
	    
	    // --------------------------------------------------------------------------
	    //
	    // Attributes
	    //
	    // --------------------------------------------------------------------------
	    
	    // ------------------------------
	    // nodeInsMap
	    // ------------------------------
	    
	    /**
	     * 节点实例map
	     */
	    var nodeInsMap = d3.map();
	    this.nodeInsMap = function(){
	        return nodeInsMap;
	    };
	    
	    // ------------------------------
	    // xScale
	    // ------------------------------
	    
	    /**
	     * 水平方向比例尺
	     */
	    var xScale = d3.scaleLinear();
	    this.xScale = function(){
	        return xScale;
	    }
	    
	    // ------------------------------
	    // yScale
	    // ------------------------------
	    
	    /**
	     * 垂直方向比例尺
	     */
	    var yScale = d3.scaleLinear();
	    this.yScale = function(){
	        return yScale;
	    }
	    
	    
	    // ------------------------------
	    // scaleK
	    // ------------------------------
	    
	    /**
	     * 当前缩放系数
	     */
	    var scaleK = 1;
	    this.scaleK = function(){
	        return scaleK;
	    }
	
	    // --------------------------------------------------------------------------
	    //
	    // override Methods
	    //
	    // --------------------------------------------------------------------------
	        
	    /**
	     * 初始化方法
	     */
	    this.init = function() {
	        superInit();
	    };
	
	    /**
	     * 初始化图表包含的各个层级
	     */
	    this.initAllContainers = function() {
	        superInitAllContainers();
	        self.packContainer =  self.mainContainer().append("g").attr("class", "pack-Container");
	        //放置所有节点的g元素
	        self.nodesContainer =  self.packContainer.append("g").attr("class", "nodes-Container");
	    };
	
	    /**
	     * 初始化添加所有监听的方法
	     */
	    this.addListeners = function() {
	        superAddListeners();
	        d3.select(window).on("click", function() {
	            zoomNode(self.layout().root());
	        });
	    };
	    
	    var setNodeScale = function(d) {
	    	var radius = self.layout().radius();
	        var r = radius * 2;
	        scaleK = r / d.outerRadius / 2;
	        xScale.range([0, r]);
	        yScale.range([0, r]);
	        xScale.domain([d.data.x - d.outerRadius, d.data.x + d.outerRadius]);
	        yScale.domain([d.data.y - d.outerRadius, d.data.y + d.outerRadius]);
	    };
	    
	    var zoomNode = function(d, i) {
	    	d3.event && d3.event.stopPropagation();
	    	
	    	setNodeScale(d);
	    	
	    	//update all nodes
	        self.packContainer.selectAll("g.packNode").each(function(d) {
	            var ins = self.nodeInsMap().get(d.data.id);
	            if(ins) {
	                self.getRendererConfig(d.data, "fill");
	                ins.update(d);
	            }
	        });
	    	
	//		var t =  self.packContainer.selectAll("g.pack-item")
	//            .transition().duration(self.animation() ? 500 : 0);
	//
	//        t.selectAll("g.packNode").attr("transform", function(d){
	//            return "translate(" + xScale(d.data.x) + "," + yScale(d.data.y) + ")";
	//        })
	//        .selectAll("path")
	//            .attr("d", function(d){
	//            	var arc = d3.arc()
	//                    .innerRadius(scaleK * d.innerRadius)
	//                    .outerRadius(scaleK * d.outerRadius);
	//                return arc(d);
	//            });
	
	//		t.selectAll("text")
	//            .attr("x", function(d) {
	//				return xScale(d.x);
	//			}).attr("y", function(d) {
	//				return yScale(d.y);
	//			}).style("opacity", function(d) {
	//				return scaleK * d.r > 20 ? 1 : 0;
	//			});
	
			node = d;
		};
	
	    /**
		 * 刷新数据内容，生成需要的属性和相关值
		 */
	    this.refreshData = function() {
	        superRefreshData();
	    };
	
	    /**
	     * 渲染图表内容相关位置
	     */
	    this.renderPosition = function() {
	        superRenderPosition();
	        //内容居中
	        self.packContainer.attr("transform", function() {
	        	var r = self.layout().radius();
	            return "translate(" + (self.width()/2-r) + "," + (self.height()/2-r) + ")";
	        });
	    };
	    
	    /**
	     * 根据当前数据重新渲染内容，并重新计算布局内容
	     */
	    this.update = function() {
	    	self.refreshData();
	    	
	        if(!self.data() ||　!ObjectUtil.isArray(self.data().nodes) || self.data().nodes.length === 0) {
	            return;
	        }
	
	        self.layout().visibleData(self.filterArrayByElementProperty(self.data().nodes,"visible",true));
	        self.layout().radius(Math.min(self.width(), self.height()) / 2 - 35);
	        self.layout().update();
	        
	        node = self.layout().root();
	        
	        if(isInit) {
	            setNodeScale(node);
	        }
	        
	        //render items
	        var diffKey = self.diffKey();
	        var packItemsUpdate = self.nodesContainer.selectAll("g.pack-item")
	            .data(self.layout().nodes(), self.bindKeyFn);
	        //delete
	        packItemsUpdate.exit().each(function(d) {
	            var key = self.bindKeyFn(d);
	            var main = self.mainContainer();
	            var ins = self.nodeInsMap().get(key);
	            self.nodeInsMap().remove(key);
	            d3.select(this).remove();
	        });
	        //update
	        packItemsUpdate.each(function(d) {
	        	var key = self.bindKeyFn(d);
	            var ins = self.nodeInsMap().get(key);
	            if(ins) {
	            	self.getRendererConfig(d.data, "fill");//把渲染器配置信息刷新到渲染器实例数据里面
	                ins.update(d);
	            }
	        });
	        //add
	        var packItemsUpdate = packItemsUpdate.enter().append("g")
	            .attr("class", "pack-item")
	            .each(function(d){
	                if(!d.data) {
	                    return;
	                }
	                var rendererConfig = self.getRendererConfig(d.data, "fill");
	                var clazz = (rendererConfig && rendererConfig.clazz) ? rendererConfig.clazz : "packNode";
	                var nodeIns = ClassFactory.newNodeInstance(clazz, [d3.select(this), d, self]);
	                nodeIns.isChartFirstInit(isInit);
	                nodeIns.graph(self.graph());
	                nodeIns.render();
	                var key = self.bindKeyFn(d);
	                self.nodeInsMap().set(key, nodeIns);
	                d.data.legendIns = d3.select(this);
	            })
	            .on("click", function(d) { 
	                return zoomNode(node == d ? self.layout().root() : d); 
	            });
	
	        isInit = false;
	        self.renderPosition();
	    };
	    
	    //override
	    this.filterArrayByElementProperty = function(nodes, name, value) {
	        var visibleNodes = [],unvisibleNodeKeys = [];
	        function contains(d){
	            var i = unvisibleNodeKeys.length;
	            while (i--) {
	                if (unvisibleNodeKeys[i] === d) {
	                    return true;
	                }
	            }
	            return false;
	        };
	        var idField = self.data()["idField"],
	            parentField = self.data()["parentField"];
	        nodes.forEach(function(node){
	            if((node[name]==undefined || node[name]==true) && !contains(node[parentField])){
	                visibleNodes.push(node);
	            }else{
	                unvisibleNodeKeys.push(node[idField]);
	            }
	        });
	        return visibleNodes;
	    };
	    
	    /**
	     * override 用于绑定数据区别是否变更的属性内容获取方式回调，用于selectAll("").data(data, bindKeyFn);
	     */
	    this.bindKeyFn = function(d) {
	        var diffKey = self.diffKey();
	        return (diffKey && d[diffKey]) ? d[diffKey] : d.data.id;
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // listeners
	    //
	    // --------------------------------------------------------------------------
	    
	    
	    // --------------------------------------------------------------------------
	    //
	    // private Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    Pack.clazzName = "pack";
	    
	    // 初始化
	    this.init();
	};
	
	Pack.struct = function(ghca_charts) {
		var BaseChart = ghca_charts.view.component.charts.baseChart;
		BaseChart.struct(ghca_charts);
	    Pack.prototype = Object.create(BaseChart.prototype);
	    Pack.prototype.constructor = Pack;
	};
	
	module.exports = Pack;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {// 饼图类
	    
	/**
	 * 构造方法 
	 * @param _data 饼图配置数据
	 * @param _layout 饼图布局对象，不传就为默认布局
	 */
	var Pie = function(_data, _layout) {
		
	    // --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const BaseComponent = ghca_charts.view.component.baseComponent;
	    const BaseChart = ghca_charts.view.component.charts.baseChart;
	    const ClassFactory = ghca_charts.view.util.classFactory;
	    const ColorUtil = ghca_charts.view.util.colorUtil;
	    const StringUtil = ghca_charts.view.util.stringUtil;
	    const ObjectUtil = ghca_charts.view.util.objectUtil;
	    const RegexUtil = ghca_charts.view.util.regexUtil;
	
	    BaseChart.apply(this, arguments);
	    
	    var self = this,
	        nodesInsMap = {},
	        isInit = true,
	        superInit = self.init,
	        superInitAllContainers = self.initAllContainers,
	        superAddListeners = self.addListeners,
	        superRenderPosition = self.renderPosition,
	        superRefreshData = self.refreshData;
	    
	    self.className("seriesPie");
	    //添加可从配置文件读取的属性名称
	//    self.addAttributes("attribute");
	
	    // --------------------------------------------------------------------------
	    //
	    // Attributes
	    //
	    // --------------------------------------------------------------------------
	
	    // ------------------------------
	    // attribute
	    // ------------------------------
	    
	    // --------------------------------------------------------------------------
	    //
	    // override Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    /**
	     * 初始化方法
	     */
	    this.init = function() {
	        superInit();
	        
	        var items = self.data().data;
	        self.visibleItems(items);
	        self.itemsIns = [];
	    };
	    
	    /**
	     * 初始化图表包含的各个层级
	     */
	    this.initAllContainers = function() {
	        superInitAllContainers();
	        //放置所有项的g元素
	        var itemsContainer = new BaseComponent();
	        itemsContainer.className("pie-ItemsContainer");
	        self.addChild(itemsContainer);
	        self.itemsContainer = itemsContainer;
	    };
	    
	    /**
	     * 初始化添加所有监听的方法
	     */
	    this.addListeners = function() {
	        superAddListeners();
	    };
	    
	    /**
	     * 刷新数据内容，生成需要的属性和相关值
	     */
	   this.refreshData = function() {
	   	    superRefreshData();
	   	    
	        var items = self.data().data;
	        for(var item, i = 0, len = items.length; i < len; i++) {
	            item = items[i];
	            item.bindKey = i;
	            //生成visible属性，默认值为true
	            if(!item.hasOwnProperty("visible")) {
	                item.visible = true;
	            }
	        };
	    };
	    
	    /**
	     * 渲染图表内容相关位置 
	     */
	    this.renderPosition = function() {
	    	superRenderPosition();
	    	
	    	//饼图内容居中
	        self.itemsContainer.x(self.width() / 2);
	        self.itemsContainer.y(self.height() / 2);
	        self.itemsContainer.renderTransform();
	    };
	    
	    /**
	     * 根据当前数据重新渲染内容，并重新计算布局内容
	     */
	    this.update = function() {
	    	self.refreshData();
	    	//只用当前可见的项作为渲染数据源
	        var items = self.data().data;
	        self.visibleItems(self.filterArrayByElementProperty(items, "visible", true));
	        
	        //计算布局，获取项数据数组
	        self.layout().update();
	        var visibleItems = self.visibleItems();
	        
	        /*这里先清除所有的项元素，然后再创建新的数据，否则动态添加的数据显示会有重复的问题。
	                                    但是这样做在ie和edge中会造成闪烁，且效率极低，有待优化。*/
	    	var itemsContainer = self.itemsContainer;
	//      itemsContainer.mainContainer().selectAll("g.pie-item").remove();
	//        self.itemsIns.length = 0;
	        
	        //获取节点渲染器配置，并根据legend组件分配的颜色设置节点填充颜色,若没有legend相关配置，则pie组件始终强制使用自动生成的颜色填充
	        for(var d, i = 0, len = visibleItems.length; i < len; i++) {
	        	d = visibleItems[i];
	            if(d.legendColor === null || d.legendColor === undefined || d.legendColor === "") {
	                d.legendColor = ColorUtil.getColor(i);
	            }
	            var config = self.getRendererConfig(d, "fill");
	            validateRadius(config, d);
	        }
	//        //渲染节点内容
	//        var itemsIns = ClassFactory.newRenderersInstanceByData(itemsContainer, self, "itemContainer", visibleItems);
	//        if(itemsIns) {
	//        	for(var i = 0, len = itemsIns.length; i < len; i++) {
	//        		self.itemsIns.push(itemsIns[i]);
	//        	}
	//        }
	        
	        //render items
	        var pieItemsUpdate = itemsContainer.mainContainer().selectAll("g.pie-item")
	            .data(visibleItems, self.bindKeyFn);
	        //update
	        pieItemsUpdate.each(function(d){
	            var key = self.bindKeyFn(d);
	            var ins = nodesInsMap[key];
	            if(ins) {
	                ins.data(d);
	                ins.update();
	                d.ins = ins;
	                d.legendIns = ins;
	            }
	        });
	        //add
	        var pieItemsEnter = pieItemsUpdate.enter().append("g").attr("class", "pie-item");
	        pieItemsEnter.each(function(d){
	            var clazz = d.hasOwnProperty("data") && d.data ? d.data.clazz : "arcClass";
	            var nodeIns = ClassFactory.newNodeInstance(clazz, [d3.select(this), d]);
	            nodeIns.isChartFirstInit(isInit);
	            nodeIns.graph(self.graph());
	            nodeIns.render();
	            d.ins = nodeIns;
	            d.legendIns = d3.select(this);
	            var key = self.bindKeyFn(d);
	            nodesInsMap[key] = nodeIns;
	        });
	        //delete
	        var pieItemsExit = pieItemsUpdate.exit();
	        pieItemsExit.each(function(d) {
	            var key = self.bindKeyFn(d);
	            if(nodesInsMap.hasOwnProperty(key)) {
	                delete nodesInsMap[key];
	            }
	        }).remove();
	        
	        self.renderPosition();
	        
	        isInit = false;
	    };
	    
	    /**
	     * override toString方法，用于打印本对象的一些基本信息
	     */
	    this.toString = function() {
	        return ("Pie info: "   +
	                "\n   width:"     + self.width()      + 
	                "\n   height:"    + self.height()     + 
	                "\n   layout:"    + self.layout()     + 
	                "\n   data:"      + JSON.stringify(self.data(), null, 4));
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // listeners
	    //
	    // --------------------------------------------------------------------------
	    
	    // --------------------------------------------------------------------------
	    //
	    // private Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    /**
	     * 校验内外半径方法
	     */
	    var validateRadius = function(config, d) {
	    	if(!config) {
	    		return;
	    	}
	        var maxSize = Math.min(self.width(), self.height());
	        if(!config.hasOwnProperty("clazzProperties")) {
	            config.clazzProperties = {outerRadius:"auto"};
	        }
	        //outerRadius
	        if(!config.clazzProperties.hasOwnProperty("outerRadius")) {
	            config.clazzProperties.outerRadius = "auto";
	        }
	        var outerRadius = config.clazzProperties.outerRadius;
	        if(ObjectUtil.isString(outerRadius)) {
	        	if(outerRadius === "auto") {
	                outerRadius = maxSize / 2;
	            } else if(outerRadius.indexOf("{") !== -1) {
	            	outerRadius = parseFloat(RegexUtil.replace(RegexUtil.dataRegex, outerRadius, d));
	            } else {
	            	var parseOR = StringUtil.parsePercent(outerRadius);
	                if(!isNaN(parseOR)) {
	                    outerRadius = parseInt(parseOR / 100 * maxSize);
	                }
	            }
	            config.clazzProperties.outerRadius = outerRadius;
	        }
	        
	        //innerRadius
	        if(!config.clazzProperties.hasOwnProperty("innerRadius")) {
	            config.clazzProperties.innerRadius = "auto";
	        }
	        var innerRadius = config.clazzProperties.innerRadius;
	        if(ObjectUtil.isString(innerRadius)) {
	        	if(innerRadius === "auto") {
	                innerRadius = 0;
	            } else if(innerRadius.indexOf("{") !== -1) {
	                innerRadius = parseFloat(RegexUtil.replace(RegexUtil.dataRegex, innerRadius, d));
	            } else {
	                var parseIR = StringUtil.parsePercent(innerRadius);
	                if(!isNaN(parseIR)) {
	                    innerRadius = parseInt(parseIR / 100 * maxSize);
	                }
	            }
	            config.clazzProperties.innerRadius = innerRadius;
	        }
	    };
	    
	    Pie.clazzName = "Pie";
	    
	    // 初始化
	    self.init();
	};
	
	Pie.struct = function(ghca_charts) {
		var BaseChart = ghca_charts.view.component.charts.baseChart;
		BaseChart.struct(ghca_charts);
	    Pie.prototype = Object.create(BaseChart.prototype);
	    Pie.prototype.constructor = Pie;
	};
	
	// --------------------------------------------------------------------------
	//
	// Const
	//
	// --------------------------------------------------------------------------
	
	module.exports = Pie;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {// 进度条图类
	    
	/**
	 * 构造方法 
	 * @param _data 进度条图配置数据
	 * @param _layout 进度条图布局对象，不传就为默认布局
	 */
	var ProgressBar = function(_data, _layout) {
	    
	    // --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const BaseComponent = ghca_charts.view.component.baseComponent;
	    const BaseChart = ghca_charts.view.component.charts.baseChart;
	    const ClassFactory = ghca_charts.view.util.classFactory;
	    const ColorUtil = ghca_charts.view.util.colorUtil;
	
	    BaseChart.apply(this, arguments);
	    
	    var self = this,
	        nodesInsMap = {},
	        superInit = self.init,
	        superInitAllContainers = self.initAllContainers,
	        superAddListeners = self.addListeners,
	        superRenderPosition = self.renderPosition,
	        superRefreshData = self.refreshData;
	    
	    self.className("seriesProgressBar");
	    
	    // --------------------------------------------------------------------------
	    //
	    // Attributes
	    //
	    // --------------------------------------------------------------------------
	
	    // ------------------------------
	    // attribute
	    // ------------------------------
	    
	    // --------------------------------------------------------------------------
	    //
	    // override Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    /**
	     * 初始化方法
	     */
	    this.init = function() {
	        superInit();
	        
	        var items = self.data().data;
	        self.visibleItems(items);
	        self.itemsIns = [];
	    };
	    
	    /**
	     * 初始化添加所有监听的方法
	     */
	    this.addListeners = function() {
	        superAddListeners();
	    };
	    
	    /**
	     * 刷新数据内容，生成需要的属性和相关值
	     */
	   this.refreshData = function() {
	        superRefreshData();
	        //生成visible属性，默认值为true
	        var items = self.data().data;
	        for(var item, i = 0, len = items.length; i < len; i++) {
	            item = items[i];
	            item.bindKey = i;
	            if(!item.hasOwnProperty("visible")) {
	                item.visible = true;
	            }
	        }
	    };
	    
	    /**
	     * 渲染图表内容相关位置 
	     */
	    this.renderPosition = function() {
	        superRenderPosition();
	    };
	    
	    this.initAllContainers = function() {
	        superInitAllContainers();
	        
	        //放置所有项的g元素
	        if(!self.barContainer) {
	            var barContainer = new BaseComponent();
	            barContainer.className("progressBar-Container");
	            self.addChild(barContainer);
	            self.barContainer = barContainer;
	        }
	    };
	    
	    /**
	     * 根据当前数据重新渲染内容，并重新计算布局内容
	     */
	    this.update = function() {
	        self.refreshData();
	        var items = self.data().data;
	        self.visibleItems(self.filterArrayByElementProperty(items, "visible", true));
	        //计算布局，获取项数据数组
	        self.layout().update();
	        
	        var visibleItems = self.visibleItems();
	        var barContainer = self.barContainer;
	        
	        //渲染节点
	        //获取节点渲染器配置，并根据legend组件分配的颜色设置节点填充颜色,若没有legend相关配置，则始终强制使用自动生成的颜色填充
	        for(var d, i = 0, len = visibleItems.length; i < len; i++) {
	            d = visibleItems[i];
	//            if(d.legendColor === null || d.legendColor === undefined || d.legendColor === "") {
	//                d.legendColor = ColorUtil.getColor(i);
	//            }
	            var config = self.getRendererConfig(d, "fill");
	        }
	        
	        //render items
	        var diffKey = self.diffKey();
	        var barItemsUpdate = barContainer.mainContainer().selectAll("g.bar-item")
	            .data(visibleItems, self.bindKeyFn);
	        //delete
	        var barItemsExit = barItemsUpdate.exit();
	        barItemsExit.each(function(d) {
	            var key = self.bindKeyFn(d);
	            if(nodesInsMap.hasOwnProperty(key)) {
	                delete nodesInsMap[key];
	            }
	        }).remove();
	        //update
	        barItemsUpdate.each(function(d) {
	            var key = self.bindKeyFn(d);
	            var ins = nodesInsMap[key];
	            if(ins) {
	                ins.data(d);
	                ins.update();
	                d.ins = ins;
	                d.legendIns = ins;
	            }
	        });
	        //add
	        var barItemsEnter = barItemsUpdate.enter().append("g").attr("class", "bar-item");
	        barItemsEnter.each(function(d){
	            var clazz = d.hasOwnProperty("data") && d.data ? d.data.clazz : "node";
	            var nodeIns = ClassFactory.newNodeInstance(clazz, [d3.select(this), d]);
	            nodeIns.render();
	            d.ins = nodeIns;
	            d.legendIns = nodeIns;
	            var key = self.bindKeyFn(d);
	            nodesInsMap[key] = nodeIns;
	        });
	            
	        self.renderPosition();
	    };
	    
	    /**
	     * override toString方法，用于打印本对象的一些基本信息
	     */
	    this.toString = function() {
	        return ("ProgressBar info: "      +
	                "\n   width:"     + self.width()      + 
	                "\n   height:"    + self.height()     + 
	                "\n   layout:"    + self.layout()     + 
	                "\n   data:"      + JSON.stringify(self.data(), null, 4));
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // listeners
	    //
	    // --------------------------------------------------------------------------
	    
	    // --------------------------------------------------------------------------
	    //
	    // public Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    ProgressBar.clazzName = "ProgressBar";
	    
	    // 初始化
	    self.init();
	};
	
	ProgressBar.struct = function(ghca_charts) {
	    var BaseChart = ghca_charts.view.component.charts.baseChart;
	    BaseChart.struct(ghca_charts);
	    ProgressBar.prototype = Object.create(BaseChart.prototype);
	    ProgressBar.prototype.constructor = ProgressBar;
	};
	
	// --------------------------------------------------------------------------
	//
	// Const
	//
	// --------------------------------------------------------------------------
	
	module.exports = ProgressBar;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {// sankey图类
		
	/**
	 * 构造方法 
	 * @param _data sankey图配置数据
	 * @param _layout sankey图布局对象，不传就为默认布局
	 */
	var Sankey = function(_data, _layout) {
		
		// --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const BaseComponent = ghca_charts.view.component.baseComponent;
	    const Chart = ghca_charts.view.component.charts.chart;
	    const BaseChart = ghca_charts.view.component.charts.baseChart;
	    const SankeyLayout = ghca_charts.layout.sankeyLayout;
	    const ClassFactory = ghca_charts.view.util.classFactory;
	    const DataParser = ghca_charts.view.util.dataParser;
	    const Const = ghca_charts.view.util.constant;
	    const ObjectUtil = ghca_charts.view.util.objectUtil;
	    const BaseEvent = ghca_charts.events.BaseEvent;
	    const EventUtil = ghca_charts.view.util.eventUtil;
	    const ElementUtil = ghca_charts.view.util.elementUtil;
	
	    BaseChart.apply(this, arguments);
	    
	    var self = this,
	        superInit = self.init,
	        superInitAllContainers = self.initAllContainers,
	        superAddListeners = self.addListeners,
	        superRenderPosition = self.renderPosition,
	        superRefreshData = self.refreshData,
	        superSetData = self.setData;
	    	defaultNodeTextStyle = {
				"font-family":"微软雅黑", 
				"font-size":"13px", 
				"fill":"#000000", 
				"pointer-events":"none"
			};
	    
	    self.className("seriesSankey");
	    //添加可从配置文件读取的属性名称
	    self.addAttributes("nodeDragDir", "focusEffect", "nodeTextStyle");
	    
	    // --------------------------------------------------------------------------
	    //
	    // Attributes
	    //
	    // --------------------------------------------------------------------------
	
	    // ------------------------------
	    // nodeDragDir
	    // ------------------------------
	        
	    /**
	     * 节点拖动类型 hor|ver|free|fix(默认值free)
	     * @see Const
	     */
	    var nodeDragDir = Const.FREE_DRAG_TYPE;
	    this.nodeDragDir = function(value) {
	        if (!arguments.length) return nodeDragDir;
	        nodeDragDir = value;
	        return this;
	    };
	    
	    // ------------------------------
	    // focusEffect
	    // ------------------------------
	        
	    /**
	     * 鼠标移动到节点上时，是否显示凸显效果(默认值true)
	     */
	    var focusEffect = true;
	    this.focusEffect = function(value) {
	        if (!arguments.length) return focusEffect;
	        focusEffect = value;
	        return this;
	    };
	    
	    // ------------------------------
	    // nodeTextStyle
	    // ------------------------------
	        
	    /**
	     * 节点文本样式对象
	     */
	    var nodeTextStyle = {};
	    this.nodeTextStyle = function(value) {
	        if (!arguments.length) return nodeTextStyle;
	        nodeTextStyle = value;
	        return this;
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // override Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    /**
	     * 初始化方法
	     */
	    this.init = function() {
	        superInit();
	        
	        self.nodes = self.layout().nodes();
	        self.links = self.layout().links();
	        self.nodesIns = [];
	        self.linksIns = [];
	        
	        //添加初始化数据中的所有节点和连线
	        self.addNodes(self.data().nodes);
	        self.addLinks(self.data().links);
	    };
	    
	    /**
	     * 初始化图表包含的各个层级
	     */
	    this.initAllContainers = function() {
	        superInitAllContainers();
	        
	        //放置所有连线的g元素
	        var linksContainer = new BaseComponent();
	        linksContainer.className("sankey-linksContainer");
	        self.addChild(linksContainer);
	        self.linksContainer = linksContainer;
	        
	        //放置所有节点的g元素
	        var nodesContainer = new BaseComponent();
	        nodesContainer.className("sankey-nodesContainer");
	        self.addChild(nodesContainer);
	        self.nodesContainer = nodesContainer;
	    };
	    
	    /**
	     * 初始化添加所有监听的方法
	     */
	    this.addListeners = function() {
	        superAddListeners();
	        
	        self.addEventListener(BaseEvent.NODE_MOUSE_OVER, self.node_nodeMouseMoveHandler);
	        self.addEventListener(BaseEvent.NODE_MOUSE_OUT, self.node_nodeMouseOutHandler);
	    };
	    
	    /**
	     * 刷新数据内容，生成需要的属性和相关值
	     */
	   this.refreshData = function() {
	   	   superRefreshData();
	       var data = self.data(),
	           nodes = data.nodes;
	        
	        //生成visible属性，默认值为true
	        nodes.forEach(function(node) {
	        	if(!node.hasOwnProperty("visible")) {
	        		node.visible = true;
	        	}
	        });
	        
	        for(var key in defaultNodeTextStyle) {
	        	if(!nodeTextStyle.hasOwnProperty(key)) {
	        		nodeTextStyle[key] = defaultNodeTextStyle[key];
	        	}
	        }
	    };
	    
	    /**
	     * 渲染图表内容相关位置 
	     */
	    this.renderPosition = function() {
	    	superRenderPosition();
	    	
	        var nodesIns = self.nodesIns;
	        for(var nodeIns, i = 0, len = nodesIns.length; i < len; i++) {
	        	nodeIns = nodesIns[i];
	        	nodeIns.mainContainer().each(function(d) {
	        	   nodeIns.x(d.x);
	        	   nodeIns.y(d.y);
	        	   nodeIns.renderTransform();
	        	});
	        }
	            
	        self.linksContainer.mainContainer().selectAll("g.linkContainer path")
	            .attr("d", self.layout().model().linkPath());
	    };
	    
	    /**
	     * 根据当前数据重新渲染内容，并重新计算布局内容
	     */
	    this.update = function() {
	    	self.refreshData();
	        //计算布局
	        self.layout().update();
	        //重新计算节点level属性
	        refreshLevel();
	        
	        /*这里先清除所有的连线和节点元素，然后再创建新的数据，否则动态添加的数据显示会有重复的问题。
	                                    但是这样做在ie和edge中会造成闪烁，且效率极低，有待优化。*/
	        var linksContainer = self.linksContainer;
	        linksContainer.removeAllChildren();
	        self.linksIns.length = 0;
	        var nodesContainer = self.nodesContainer;
	        nodesContainer.removeAllChildren();
	        self.nodesIns.length = 0;
	        
	        //只用当前可见的连线作为渲染数据源
	        var linksData = self.getVisibleLinks(self.links);
	        var pluginCallBack = function(linkIns) {
	        	linkIns.pathFunction(self.layout().model().linkPath);
	            linkIns.sortFunction(function(a, b) { 
	                return b.dy - a.dy; 
	            });
	        };
	        //渲染连线内容   
	        var linksIns = ClassFactory.newRenderersInstanceByData(linksContainer, self, "linkContainer", 
	            linksData, false, "stroke", pluginCallBack);
	        if(linksIns) {
	            for(var linkIns, i = 0, len = linksIns.length; i < len; i++) {
	                linkIns = linksIns[i];
	                self.linksIns.push(linkIns);
	                linkIns.mainContainer().each(function(d) {
	                	d.ins = linkIns;
	                });
	            }
	        }
	        
	        //只用当前可见的节点作为渲染数据源
	        var nodesData = self.filterArrayByElementProperty(self.nodes, "visible", true);
	        //若节点渲染器是一个组件，则重新设置一些配置数据
	        for(var i = 0, len = nodesData.length; i < len; i++) {
	        	var nodeData = nodesData[i];
	        	var rendererConfig = self.getRendererConfig(nodeData, "fill");
	            if(rendererConfig && rendererConfig.type === "chart" && rendererConfig.series) {
	            	var chartData, series = rendererConfig.series;
	            	for(var j = 0, len1 = series.length; j < len1; j++) {
	            		chartData = series[j];
	            		//这里config设置的width和height值无效，渲染器组件宽高为线的高度值
	                    chartData.width = nodeData.dy;
	                    chartData.height = nodeData.dy;
	                    //pie的位置特殊处理
	                    if(chartData.type === "pie") {
	                    	chartData.x = -chartData.width / 2;
	                    }
	                    //组装图表数据
	                    DataParser.createChartData(chartData, nodeData);
	            	}
	            }
	        }
	        //渲染节点内容
	        var pluginCallBack = function(linkIns) {
	            linkIns.isDragable(self.nodeDragDir() !== Const.FIX_DRAG_TYPE);
	        };
	        var nodesIns = ClassFactory.newRenderersInstanceByData(nodesContainer, self, "nodeContainer", 
	            nodesData, true, "fill", pluginCallBack);
	        if(nodesIns) {
	            for(var nodeIns, i = 0, len = nodesIns.length; i < len; i++) {
	            	nodeIns = nodesIns[i];
	            	nodeIns.mainContainer().call(d3.drag()
	                    .on("start", self.node_dragStartHandler)
	                    .on("drag", self.node_dragHandler)
	                    .on("end", self.node_dragEndHandler));
	                //这里addEventListener内的this为nodeIns.node()对象，故这样写
	                (function(ins){
	                	ins.addEventListener("mouseover", function(event) {
	                		var evt = EventUtil.createCustomEvent(BaseEvent.NODE_MOUSE_OVER, true, true);
	                        ins.dispatchEvent(evt);
	                    });
	                    ins.addEventListener("mouseout", function(event) {
	                    	var evt = EventUtil.createCustomEvent(BaseEvent.NODE_MOUSE_OUT, true, true);
	                        ins.dispatchEvent(evt);
	                    });
	                })(nodeIns);
	                
	                self.nodesIns.push(nodeIns);
	                
	                //-----临时写法-----start
	                //添加节点标签
	                var labelGap = 4;
	                var isPlugin = nodeIns.normalChild() === null ? false : true;
	                var nodeWidth = self.layout().model().nodeWidth();
	                var text = nodeIns.mainContainer().append("text")
	                    .attr("class", "sankey-node-text")
	                    .attr("x", function(d) { return isPlugin ? -6 : -(d.dy/2 +　labelGap);})
	                    .attr("y", function(d) { return d.dy/2; })
	                    .attr("dy", ".35em")
	                    .attr("text-anchor", "end");
	                ElementUtil.setElementStyles(text, self.nodeTextStyle());
	                text.text(function(d) { return d.name; })
	                    .filter(function(d) { return d.x < self.width() / 2; })
	                    .attr("x", function(d) { return isPlugin ? 6 + nodeWidth : d.dy/2 + labelGap + nodeWidth;})
	                    .attr("text-anchor", "start");
	                var duration = self.animation() ? 300 : 0;
	                text.attr("opacity", 0)
	                    .transition().duration(duration).ease(d3.easeLinear)
	                    .delay(function(d){
	                        return d.level * (duration - 10);
	                    })
	                    .attr("opacity", 1);
	                //-----临时写法-----end
	                    
	                nodeIns.mainContainer().each(function(d) {
	                    d.ins = nodeIns;
	                    d.textIns = text;
	                });
	            }
	        }
	        
	        self.renderPosition();
	    };
	    
	    /**
	     * 设置数据内容
	     * @param value 数据内容，格式为：{data:[]}或者{nodes:[],links:[]}等
	     * @return 返回是否设置成功
	     */
	    this.setData = function(value) {
	    	var result = superSetData(value);
	    	
	    	self.layout().nodes().length = 0;
	    	self.layout().links().length = 0;
	    	self.nodes.length = 0;
	        self.links.length = 0;
	        self.nodesIns.length = 0;;
	        self.linksIns.length = 0;;
	        
	        //添加初始化数据中的所有节点和连线
	        self.addNodes(self.data().nodes);
	        self.addLinks(self.data().links);
	        
	        return result;
	    };
	    
	    /**
	     * override toString方法，用于打印本对象的一些基本信息
	     */
	    this.toString = function() {
	        return ("Sankey info: "   +
	                "\n   width:"     + self.width()      + 
	                "\n   height:"    + self.height()     + 
	                "\n   layout:"    + self.layout()     + 
	                "\n   data:"      + JSON.stringify(self.data(), null, 4));
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // listeners
	    //
	    // --------------------------------------------------------------------------
	    
	    /**
	     * 节点开始拖动
	     */
	    this.node_dragStartHandler = function(d) {
	    	//把拖动节点添加到父容器最外层
	        this.parentNode.appendChild(this);
	    };
	    
	    /**
	     * 节点拖动中
	     */
	    this.node_dragHandler = function(d) {
	        dragMoveNode(this, d);
	    };
	    
	    /**
	     * 节点结束拖动
	     */
	    this.node_dragEndHandler = function(d) {
	       dragMoveNode(this, d);
	    };
	    
	    /**
	     * 自定义鼠标移动到某个节点上
	     */
	    this.node_nodeMouseMoveHandler = function(event) {
	    	event.stopPropagation();
	    	if(self.focusEffect()) {
	    		focusInNode(event.detail.target);
	    	}
	    };
	    
	    /**
	     * 自定义鼠标移出某个节点
	     */
	    this.node_nodeMouseOutHandler = function(event) {
	    	event.stopPropagation();
	    	if(self.focusEffect()) {
	    		focusOutAllNodes();
	    	}
	    };
	
	    // --------------------------------------------------------------------------
	    //
	    // public Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    /**
	     * 增加一个节点 
	     * @param node 节点数据对象
	     */
	    this.addNode = function(node) {
	    	node.sourceLinks = [];
	        node.targetLinks = [];
	        self.nodes.push(node);
	    };
	
	    /**
	     * 批量增加节点 
	     * @param nodes 节点数据对象数组
	     */
	    this.addNodes = function(nodes) {
	        if (ObjectUtil.isArray(nodes)) {
	            nodes.forEach(function(node) {
	                self.addNode(node);
	            });
	        }
	    };
	
	    /**
	     * 增加一条连线 
	     * @param link 连线数据对象 
	     */
	    this.addLink = function(link) {
	        link.source = self.findNode(link.source);
	        link.target = self.findNode(link.target);
	        link.source.sourceLinks.push(link);
	        link.target.targetLinks.push(link);
	        self.links.push(link);
	    };
	
	    /**
	     * 批量增加连线 
	     * @param links 连线数据对象数组
	     */
	    this.addLinks = function(links) {
	        if (ObjectUtil.isArray(links)) {
	            links.forEach(function(link) {
	                self.addLink(link);
	            });
	        }
	    };
	
	    /**
	     * 删除节点 
	     * @param id 要删除的节点id
	     */
	    this.removeNode = function(id) {
	        var i = 0, n = self.findNode(id), links = self.links;
	        //删除该节点相关的连线
	        while (i < links.length) {
	            links[i]['source'] == n || links[i]['target'] == n ? links.splice(i, 1) : ++i;
	        }
	        //删除该节点
	        self.nodes.splice(self.findNodeIndex(id), 1);
	    };
	    
	    /**
	     * 删除节点下的子节点，同时清除link信息 
	     * @param id 要删除的节点id
	     */
	    this.removeChildNodes = function(id) {
	        var   node = self.findNode(id), //要删除的节点
	              nodes = self.nodes,       //所有节点
	              link = null,
	              links = self.links,       //所有连线 
	              delateLinks = [],         //要删除的连线索引数组
	              childNodes = [];          //当前节点的所有子节点数组
	
	        //找到所有要删除的连线索引，以及当前节点的所有子节点
	        links.forEach(function(link, index) {
	            //若节点是此条连线的起点
	            if(link['source'] == node) {
	                delateLinks.push(index);
	                childNodes.push(link['target']);
	            }
	        });
	
	        //删除上面找到的所有需要删除的连线
	        delateLinks.reverse().forEach(function(index) {
	            links.splice(index, 1);
	        });
	
	        //迭代删除节点
	        var remove = function(node) {
	            var length = links.length;
	            for (var i = length - 1; i >= 0; i--) {
	                if (links[i]['source'] == node) {
	                    var target = links[i]['target'];
	                    links.splice(i, 1);
	                    nodes.splice(self.findNodeIndex(node.id), 1);
	                    remove(target);
	                }
	            }
	        };
	
	        //删除上面找到当前节点的所有子节点
	        childNodes.forEach(function(node) {
	            remove(node);
	        });
	
	        //清除没有连线的节点
	        for (var i = nodes.length - 1; i >= 0; i--) {
	            var isFoundNode = false;
	            node = nodes[i];
	            for (var j = 0, len = links.length; j < len; j++) {
	                link = links[j];
	                if(link['source'] == node || link['target'] == node) {
	                    isFoundNode = true;
	                }
	            }
	            if(!isFoundNode){
	                nodes.splice(i, 1);
	            }
	        }
	    }
	
	    /**
	     * 查找节点
	     * @param id 要查找的节点id
	     * @return 返回查找到的节点数据对象，若没有查找到则返回null
	     */
	    this.findNode = function(id) {
	        var nodes = self.nodes;
	        for (var i = 0, len = nodes.length; i < len; i++) {
	            if (nodes[i]['id'] == id)
	                return nodes[i];
	        }
	        return null;
	    };
	    
	    /**
	     * 查找节点数据对象所在数组的索引值
	     * @param id 要查找的节点id
	     * @return 返回查找到的节点数据对象所在数组的索引值，若没有查找到则返回-1
	     */
	    this.findNodeIndex = function(id) {
	        var nodes = self.nodes;
	        for (var i = 0, len = nodes.length; i < len; i++) {
	            if (nodes[i]['id'] == id)
	                return i;
	        }
	        return -1;
	    };
	    
	    /**
	     * 设置指定节点的所有子孙级别的所有节点是否可见
	     * @param id 要设置的指定节点id
	     * @param visible 设置指定节点的所有子孙级别的所有节点是否可见,值为true、false
	     */
	    this.setAllChildLevelNodesVisible = function(id, visible) {
	        var node = self.findNode(id);
	        if(!node) return;
	        
	        if(arguments.length < 2)  {
	            visible = true;
	        }
	        
	        //有待优化--start
	        var visibleNode = function(nodeId){
	            self.nodes.forEach(function(node) {
	                if(node.parentId === nodeId) {
	                    node.visible = visible;
	                    visibleNode(node.id);
	                }
	            });
	        };
	        //有待优化--end
	        
	        visibleNode(id);
	    };
	    
	    /**
	     * 设置指定节点的下一级所有节点是否可见
	     * @param id 要设置的指定节点id
	     * @param visible 设置指定节点的下一级所有节点是否可见,值为true、false
	     */
	    this.setNextLevelNodesVisible = function(id, visible) {
	        var node = self.findNode(id);
	        if(!node) return;
	        
	        if(arguments.length < 2)  {
	            visible = true;
	        }
	            
	        self.nodes.forEach(function(node) {
	            if(node.parentId === id) {
	                node.visible = visible;
	            }
	        });
	    };
	
	    /**
	     * 展开节点
	     * @param id 要展开的节点id
	     * @param isExpandAll 是否展开所有子孙节点，默认为false,若为false则只展开该节点的下一级节点
	     */
	    this.expandNode = function(id, isExpandAll) {
	        if(isExpandAll) {
	            self.setAllChildLevelNodesVisible(id, true);
	        } else {
	            self.setNextLevelNodesVisible(id, true);
	        }
	        //根据当前数据重新渲染内容
	        self.update();
	    }
	    
	    /**
	     * 合拢节点
	     * @param id 要合拢的节点id
	     */
	    this.collapseNode = function(id) {
	        self.setAllChildLevelNodesVisible(id, false);
	        //根据当前数据重新渲染内容
	        self.update();
	    }
	    
	    /**
	     * 从指定的连线数据数组中获取可见的所有连线
	     * @param links 指定的连线数据数组
	     * @return 返回可见的所有连线数组，若没有满足条件的数组，则返回空数组
	     */
	    this.getVisibleLinks = function(links) {
	        var result = [];
	        if(!links || links.length === 0){
	            return result;
	        }
	        var link;
	        for (var i = 0, len = links.length; i < len; i++) {
	            link = links[i];
	            if (link.source.visible && link.target.visible) {
	                if(link.hasOwnProperty("visible")) {
	                    if(link.visible) {
	                        result.push(link);
	                    }
	                } else {
	                    result.push(link);
	                }
	            }
	        }
	        return result;
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // private Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    /**
	     * 拖动节点
	     * @param node 被拖动的节点显示对象
	     * @param d 被拖动的节点数据对象
	     */
	    var dragMoveNode = function(node, d) {
	        var drageType = self.nodeDragDir();
	        if(drageType === Const.FIX_DRAG_TYPE) {
	            return;
	        } else if(drageType === Const.HOR_DRAG_TYPE) {
	            d.x = Math.max(0, Math.min(self.width() - d.dx, d3.event.x))
	        } else if(drageType === Const.VER_DRAG_TYPE) {
	            d.y = Math.max(0, Math.min(self.height() - d.dy, d3.event.y))
	        } else {
	            d.x = d3.event.x;
	            d.y = d3.event.y;
	        }
	        //重绘节点位置变换
	        var nodesIns = self.nodesIns;
	        for(var nodeIns, i = 0, len = nodesIns.length; i < len; i++) {
	            nodeIns = nodesIns[i];
	            nodeIns.mainContainer().each(function(k) {
	               nodeIns.x(k.x);
	               nodeIns.y(k.y);
	               nodeIns.renderTransform();
	            });
	        }
	        //重绘连线
	        self.layout().model().relayoutLinkDepths();
	        self.linksContainer.mainContainer().selectAll("g.linkContainer path")
	            .attr("d", self.layout().model().linkPath());
	    };
	    
	    /**
	     * 突出显示节点
	     * @param nodeIns 要突出显示的节点对象
	     */
	    var focusInNode = function(target) {
	    	if(!target) {
	    		return;
	    	}
	    	var i, len, ins, nodeIns, linkIns, nodeData, linkData, sourceLinks, targetLinks, 
	    	    opacity = 0.2, nodesIns = self.nodesIns, linksIns = self.linksIns, insAry = [];
		    var duration = self.animation() ? 300 : 0;
	    	//找到目标对象，并淡化所有节点和连线的显示效果
		    for(i = 0, len = nodesIns.length; i < len; i++) {
	            nodeIns = nodesIns[i];
	            nodeIns.mainContainer().attr("opacity", opacity);
	            if(nodeIns === target) {
	                ins = nodesIns[i];
	            }
	        }
	        for(i = 0, len = linksIns.length; i < len; i++) {
	            linkIns = linksIns[i];
	            linkIns.mainContainer().attr("opacity", opacity);
	        }
	        //添加要突出显示的对象到数组中
	    	nodeData = ins.mainContainer().data()[0];
	    	insAry.push(nodeData.ins);
	    	insAry.push(nodeData.textIns);
	    	sourceLinks = nodeData.sourceLinks;
	    	for(i = 0, len = sourceLinks.length; i < len; i++) {
	    		linkData = sourceLinks[i];
	    		insAry.push(linkData.ins);
	    		if(linkData.target) {
	    			insAry.push(linkData.target.ins);
	    			insAry.push(linkData.target.textIns);
	    		}
	    	}
	    	targetLinks = nodeData.targetLinks;
	        for(i = 0, len = targetLinks.length; i < len; i++) {
	            linkData = targetLinks[i];
	            insAry.push(linkData.ins);
	            if(linkData.source) {
	                insAry.push(linkData.source.ins);
	                insAry.push(linkData.source.textIns);
	            }
	        }
	        //突出显示
	        for(i = 0, len = insAry.length; i < len; i++) {
	            ins = insAry[i];
	            if(ins instanceof BaseComponent) {
	            	ins = ins.mainContainer();
	            }
	            ins.attr("opacity", 1);
	        }
	    };
	    
	    /**
	     * 取消所有节点的突出显示效果
	     */
	    var focusOutAllNodes = function() {
	            var i, len, ins, opacity = 1, nodesIns = self.nodesIns, linksIns = self.linksIns;
	        for(i = 0, len = nodesIns.length; i < len; i++) {
	            ins = nodesIns[i];
	            ins.mainContainer().attr("opacity", opacity);
	        }
	        for(i = 0, len = linksIns.length; i < len; i++) {
	            ins = linksIns[i];
	            ins.mainContainer().attr("opacity", opacity);
	        }
	        self.mainContainer().selectAll("text.sankey-node-text").attr("opacity", opacity);
	    };
	    
	    /**
	     * 生成level属性，若visible为false，则删除该属性，且该节点的子节点level减少1
	     */
	    var refreshLevel = function() {
	    	var data = self.data(),
	            nodes = data.nodes,
	            rootNodes = [];
	        nodes.forEach(function(node) {
	            if(node.targetLinks.length === 0) {
	                rootNodes.push(node);
	            }
	        });
	        
	        function setLevel(node, level) {
	            if(node.visible) {
	                node.level = level;
	                level++;
	            } else if(node.hasOwnProperty("level")) {
	                delete node.level;
	            }
	            node.sourceLinks.forEach(function(link) {
	                setLevel(link.target, level);
	            });
	        }
	        rootNodes.forEach(function(node) {
	        	setLevel(node, 0);
	        });
	    };
	    
	    Sankey.clazzName = "Sankey";
	    
	    // 初始化
	    this.init();
	};
	
	Sankey.struct = function(ghca_charts) {
		var BaseChart = ghca_charts.view.component.charts.baseChart;
		BaseChart.struct(ghca_charts);
	    Sankey.prototype = Object.create(BaseChart.prototype);
	    Sankey.prototype.constructor = Sankey;
	};
	
	// --------------------------------------------------------------------------
	//
	// Const
	//
	// --------------------------------------------------------------------------
	
	module.exports = Sankey;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {// 散点图类
	    
	/**
	 * 构造方法 
	 * @param _data 散点图配置数据
	 * @param _layout 散点图布局对象，不传就为默认布局
	 */
	var Scatter = function(_data, _layout) {
	    
	    // --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const BaseComponent = ghca_charts.view.component.baseComponent;
	    const BaseChart = ghca_charts.view.component.charts.baseChart;
	    const ClassFactory = ghca_charts.view.util.classFactory;
	    const ColorUtil = ghca_charts.view.util.colorUtil;
	    const SvgUtil = ghca_charts.view.util.svgUtil;
	    const EventUtil = ghca_charts.view.util.eventUtil;
	    const DataParser = ghca_charts.view.util.dataParser;
	    const BaseEvent = ghca_charts.events.BaseEvent;
	
	    BaseChart.apply(this, arguments);
	    
	    var self = this,
	        nodesInsMap = {},
	        superInit = self.init,
	        superInitAllContainers = self.initAllContainers,
	        superAddListeners = self.addListeners,
	        superRenderPosition = self.renderPosition,
	        superRefreshData = self.refreshData;
	    
	    self.className("seriesScatter");
	
	    // --------------------------------------------------------------------------
	    //
	    // Attributes
	    //
	    // --------------------------------------------------------------------------
	
	    // ------------------------------
	    // attribute
	    // ------------------------------
	    
	    // --------------------------------------------------------------------------
	    //
	    // override Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    /**
	     * 初始化方法
	     */
	    this.init = function() {
	        superInit();
	        
	        var items = self.data().data;
	        self.visibleItems(items);
	        self.nodesIns = [];
	    };
	    
	    /**
	     * 初始化添加所有监听的方法
	     */
	    this.addListeners = function() {
	        superAddListeners();
	    };
	    
	    /**
	     * 刷新数据内容，生成需要的属性和相关值
	     */
	   this.refreshData = function() {
	        superRefreshData();
	        var items = self.data().data;
	        for(var item, i = 0, len = items.length; i < len; i++) {
	        	item = items[i];
	        	item.bindKey = i;
	            //生成visible属性，默认值为true
	            if(!item.hasOwnProperty("visible")) {
	                item.visible = true;
	            }
	        };
	    };
	    
	    /**
	     * 渲染图表内容相关位置 
	     */
	    this.renderPosition = function() {
	        superRenderPosition();
	        
	        if(self.itemsContainer) {
	            self.itemsContainer.renderTransform();
	        }
	        
	        if(!self.layout().isTimeLine()) {
	        	var nodesIns = self.nodesIns;
	            for(var nodeIns, i = 0, len = nodesIns.length; i < len; i++) {
	                nodeIns = nodesIns[i];
	                if(nodeIns instanceof BaseComponent) {
	                	 nodeIns.mainContainer().each(function(d) {
	                       nodeIns.x(d.x);
	                       nodeIns.y(d.y);
	                       nodeIns.renderTransform();
	                    });
	                }
	            }
	        }
	    };
	    
	    this.initAllContainers = function() {
	    	superInitAllContainers();
	    	
	    	//放置所有项的g元素
	    	if(!self.itemsContainer) {
	    		var itemsContainer = new BaseComponent();
	            itemsContainer.className("scatter-ItemsContainer");
	            self.addChild(itemsContainer);
	            self.itemsContainer = itemsContainer;
	    	}
	    };
	    
	    /**
	     * 根据当前数据重新渲染内容，并重新计算布局内容
	     */
	    this.update = function() {
	    	self.refreshData();
	        //只用当前可见的项作为渲染数据源
	        var items = self.data().data;
	        self.visibleItems(self.filterArrayByElementProperty(items, "visible", true));
	        
	        //计算布局，获取项数据数组
	        self.layout().update();
	        
	         /*这里先清除所有的项元素，然后再创建新的数据，否则动态添加的数据显示会有重复的问题。
	                                    但是这样做在ie和edge中会造成闪烁，且效率极低，有待优化。*/
	        var itemsContainer = self.itemsContainer;
	        if(self.layout().isTimeLine()) {
		        SvgUtil.removeAllChildren(itemsContainer.node());
	        }
	        self.nodesIns.length = 0;
	        
	        //渲染节点
	        var horAxis, verAxis, xPadding = 0, yPadding = 0;
	        if(self.horAxis()) {
	        	horAxis = self.horAxis();
	        	xPadding = horAxis.padding();
	        }
	        if(self.verAxis()) {
	        	verAxis = self.verAxis();
	            yPadding = verAxis.padding();
	        }
	        var itemsContainer = self.itemsContainer.mainContainer(), 
	            defaultColor = ColorUtil.getColor(self.seriesIndex());
	        self.itemsContainer.x(xPadding.left);
	        self.itemsContainer.y(yPadding.top);
	        //只用当前可见的节点作为渲染数据源
	        var nodesData = self.visibleItems();
	        var diffKey = self.diffKey();
	        if(self.layout().isTimeLine()) {
	        	itemsContainer.selectAll("rect.scatter-point").data(nodesData, self.bindKeyFn)
	        	    .enter().append("rect")
	                .attr("class", "scatter-point")
	                .attr("y", function(d) {
	                    return d.y;
	                })
	                .attr("x", function(d) {
	                    return d.x;
	                })
	                .attr("width", function(d) {
	                    return d.dx;
	                })
	                .attr("height", function(d) {
	                    return d.dy;
	                })
	                .attr("fill",  function(d) {
	                    return d.hasOwnProperty("legendColor") ? d.legendColor :　defaultColor;
	                })
	                .attr("stroke", function(d) {
	                    return d.hasOwnProperty("legendColor") ? d.legendColor :　defaultColor;
	                })
	                .each(function(d) {
	                    d.legendIns = d3.select(this);
	                })
	                .on('click', function(d) {
	                    var evt = EventUtil.createCustomEvent(BaseEvent.NODE_CLICK, true, true, d);
	                    d3.select(this).node().dispatchEvent(evt);
	                });
	        } else {
	            //若节点渲染器是一个组件，则重新设置一些配置数据
	        	var isChartRenderer = false;
	            for(var i = 0, len = nodesData.length; i < len; i++) {
	                var nodeData = nodesData[i];
	                var rendererConfig = self.getRendererConfig(nodeData, "fill");
	                if(rendererConfig && rendererConfig.type === "chart" && rendererConfig.series) {
	                	isChartRenderer = true;
	                    var chartData, series = rendererConfig.series;
	                    for(var j = 0, len1 = series.length; j < len1; j++) {
	                        chartData = series[j];
	                        //这里config设置的width和height值无效，渲染器组件宽高为线的高度值
	                        chartData.width = rendererConfig.width ? rendererConfig.width : 0;
	                        chartData.height = rendererConfig.height ? rendererConfig.height : 0;
	                        //pie的位置特殊处理
	                        if(chartData.type === "pie") {
	                            chartData.x = -chartData.width / 2;
	                            chartData.y = -chartData.height / 2;
	                        }
	                        //组装图表数据
	                        DataParser.createChartData(chartData, nodeData);
	                    }
	                }
	            }
	            //渲染节点内容
	            if(isChartRenderer) {
	            	SvgUtil.removeAllChildren(itemsContainer.node());
		            var nodesIns = ClassFactory.newRenderersInstanceByData(self.itemsContainer, self, "scatter-point", nodesData);
	                if(nodesIns) {
	                    for(var nodeIns, i = 0, len = nodesIns.length; i < len; i++) {
	                        nodeIns = nodesIns[i];
	                        self.nodesIns.push(nodeIns);
	                    }
	                }
	            } else {
	            	var pointUpdate = itemsContainer.selectAll(".scatter-point")
	                   .data(nodesData, self.bindKeyFn);
	                var pointExit = pointUpdate.exit();
	                pointExit.each(function(d) {
	                	var key = self.bindKeyFn(d);
	                	if(nodesInsMap.hasOwnProperty(key)) {
	                		delete nodesInsMap[key];
	                	}
	                }).remove();
	                
	                //update
	                pointUpdate.each(function(d) {
	                	var key = self.bindKeyFn(d);
	                    var ins = nodesInsMap[key];
	                    if(ins) {
	                    	ins.data(d);
	                        ins.update(true);
	                        d.ins = ins;
	                        d.legendIns = ins;
	                        self.nodesIns.push(ins);
	                    }
	                });
	                
	                //add
	                var pointsEnter = pointUpdate.enter();
	                pointsEnter.each(function(d){
	                    if(!d.hasOwnProperty("legendColor")) {
	                        d.legendColor = defaultColor;
	                    }
	                    var rendererConfig = self.getRendererConfig(d, "fill");
	                    var clazz = d.hasOwnProperty("renderer") ? rendererConfig.clazz : "circleShape";
	                    var nodeIns = ClassFactory.newNodeInstance(clazz, [d3.select(this), d]);
	                    nodeIns.className("scatter-point");
	                    nodeIns.render();
	                    d.ins = nodeIns;
	                    d.legendIns = nodeIns;
	                    self.nodesIns.push(nodeIns);
	                    var key = self.bindKeyFn(d);
	                    nodesInsMap[key] = nodeIns;
	                });
	            }
	        }
	        
	        self.renderPosition();
	    };
	    
	    /**
	     * override toString方法，用于打印本对象的一些基本信息
	     */
	    this.toString = function() {
	        return ("Scatter info: "  +
	                "\n   width:"     + self.width()      + 
	                "\n   height:"    + self.height()     + 
	                "\n   layout:"    + self.layout()     + 
	                "\n   data:"      + JSON.stringify(self.data(), null, 4));
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // listeners
	    //
	    // --------------------------------------------------------------------------
	    
	    // --------------------------------------------------------------------------
	    //
	    // public Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    Scatter.clazzName = "Scatter";
	    
	    // 初始化
	    self.init();
	};
	
	Scatter.struct = function(ghca_charts) {
	    var BaseChart = ghca_charts.view.component.charts.baseChart;
	    BaseChart.struct(ghca_charts);
	    Scatter.prototype = Object.create(BaseChart.prototype);
	    Scatter.prototype.constructor = Scatter;
	};
	
	// --------------------------------------------------------------------------
	//
	// Const
	//
	// --------------------------------------------------------------------------
	
	module.exports = Scatter;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {// 旭日图类
		
	/**
	 * 构造方法
	 * @param _data 旭日图配置数据
	 * @param _layout 旭日图布局对象，不传就为默认布局
	 */
	var Sunburst = function(_data, _layout) {
		
		// --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const BaseChart = ghca_charts.view.component.charts.baseChart;
	    const PercentageInfo = ghca_charts.view.elements.plugins.tool.percentageInfo;
	    const ToolTip = ghca_charts.view.elements.plugins.tool.toolTip;
	    const ObjectUtil =  ghca_charts.view.util.objectUtil;
	    const BaseEvent = ghca_charts.events.BaseEvent;
	    const EventUtil = ghca_charts.view.util.eventUtil;
	    const ElementUtil = ghca_charts.view.util.elementUtil;
	    const ColorUtil = ghca_charts.view.util.colorUtil;
	    const StringUtil = ghca_charts.view.util.stringUtil;
	    const ClassFactory = ghca_charts.view.util.classFactory;
	    const Label = ghca_charts.view.elements.plugins.label.label;
	
	    BaseChart.apply(this, arguments);
	
	    var self = this,
	        superInit = self.init,
	        superInitAllContainers = self.initAllContainers,
	        superAddListeners = self.addListeners,
	        superRefreshData = self.refreshData,
	        superRenderPosition = self.renderPosition;
	
	    self.className("sunburst");
	    //添加可从配置文件读取的属性名称
	    self.addAttributes("isFillMiddle", "isShowNavigation");
	
	    // Breadcrumb dimensions: width, height, spacing, width of tip/tail.
	    var b = {
	        w: 75, h: 30, s: 3, t: 10
	    };
	
	    var defaultWidth = 300;
	    var percentageDefaultFontSize= 30;
	    var percentageInfo;
	    var totalSize = 0;
	    var isInit = true;
	    var oldLabelPos = "innerRing";
	    
	    // --------------------------------------------------------------------------
	    //
	    // Attributes
	    //
	    // --------------------------------------------------------------------------
	    
	    // ------------------------------
	    // nodeInsMap
	    // ------------------------------
	    
	    /**
	     * 节点实例map
	     */
	    var nodeInsMap = d3.map();
	    this.nodeInsMap = function(){
	        return nodeInsMap;
	    }
	
	    // ------------------------------
	    // isFillMiddle
	    // ------------------------------
	    
	    /**
	     * 是否把中间部分填满
	     */
	    var isFillMiddle = false;
	    this.isFillMiddle = function(){
	        if(!arguments.length)return isFillMiddle;
	        isFillMiddle = arguments[0];
	        return this;
	    };
	    
	    // ------------------------------
	    // isShowNavigation
	    // ------------------------------
	    
	    /**
	     * 是否显示上方导航元素
	     */
	    var isShowNavigation = true;
	    this.isShowNavigation = function(){
	        if(!arguments.length)return isShowNavigation;
	        isShowNavigation = arguments[0];
	        return this;
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // override Methods
	    //
	    // --------------------------------------------------------------------------
	        
	    /**
	     * 初始化方法
	     */
	    this.init = function() {
	        superInit();
	    };
	
	    /**
	     * 初始化图表包含的各个层级
	     */
	    this.initAllContainers = function() {
	        superInitAllContainers();
	        //放置所有项的g元素
	        self.sunburstContainer =  self.mainContainer().append("g").attr("class", "sunburst-Container");
	        //所有扇形元素
	        self.arcsContainer = self.sunburstContainer.append("g").attr("class", "sunburst-arcsContainer");
	        //中间显示百分比元素
	        self.percentageContainer = self.sunburstContainer.append("g").attr("class", "percentage-labelsContainer");
	        //上方导航元素
	        self.navigationContainer =  self.mainContainer().append("g").attr("class", "navigation-Container");
	        //环信息元素
	        self.ringInfoContainer =  self.sunburstContainer.append("g").attr("class", "ringInfo-Container");
	
	        // percentageInfo = classFactory.newPluginInstance("percentageinfo",[self.percentageContainer,{name:"",value:"111"}]);
	        percentageInfo = new PercentageInfo(self.percentageContainer,{value:""});
	        percentageInfo.config(self.data().percentageInfo);
	    };
	
	    /**
	     * 初始化添加所有监听的方法
	     */
	    this.addListeners = function() {
	        superAddListeners();
	        
	        self.sunburstContainer.on("mouseleave", mouseleaveHandler);
	    };
	
	    /**
	     * 刷新数据内容，生成需要的属性和相关值
	     */
	    this.refreshData = function() {
	        superRefreshData();
	    };
	
	    /**
	     * 渲染图表内容相关位置
	     */
	    this.renderPosition = function() {
	        superRenderPosition();
	        //旭日图内容居中
	        self.sunburstContainer.attr("transform", function() {
	            return "translate(" + self.width()/2 + "," + self.height()/2 + ")";
	        });
	    };
	    
	    /**
	     * 根据当前数据重新渲染内容，并重新计算布局内容
	     */
	    this.update = function() {
	    	self.refreshData();
	    	
	    	//当渲染器标签位置变换时，删除所有节点实例重新渲染，仅通过外部setConfigPropertyAndUpdate设置的配置有效 - start
	    	var labelPos = "innerRing";
	    	try {
	    		labelPos = self.data().renderers.node.clazzProperties.labelPos;
	    	} catch(e) {
	    		labelPos = oldLabelPos;
	    	}
	    	if(labelPos !== oldLabelPos) {
	    		oldLabelPos = labelPos;
	    		self.arcsContainer.selectAll("*").remove();
	    	}
	    	//当渲染器标签位置变换时，删除所有节点实例重新渲染，仅通过外部setConfigPropertyAndUpdate设置的配置有效 - end
	    	
	        self.navigationContainer.selectAll("*").remove();
	        
	        if(!self.data() ||　!ObjectUtil.isArray(self.data().nodes) || self.data().nodes.length === 0) {
	            return;
	        }
	
	        self.layout().visibleData(self.filterArrayByElementProperty(self.data().nodes,"visible",true));
	        self.layout().radius(Math.min(self.width(), self.height()) / 2 - 35);
	        self.layout().update();
	        
	        // Bounding circle underneath the sunburst, to make it easier to detect
	        // when the mouse leaves the parent g.
	        if(!self.arcsCircle) {
	        	self.arcsCircle = self.arcsContainer.append("svg:circle").style("opacity", 0);
	        }
	        self.arcsCircle.attr("r", self.layout().radius());
	        
	        //render items
	        var diffKey = self.diffKey();
	        var sunburstItemsUpdate = self.arcsContainer.selectAll("g.sunburst-item")
	            .data(self.layout().nodes(), function(d, i) {
	                return (diffKey && d[diffKey]) ? d[diffKey] : d.data.id;
	            });
	        //delete
	        sunburstItemsUpdate.exit().each(function(d) {
	            var id = d.data.id;
	            var main = self.mainContainer();
	            main.select(self.graph().getCustomId("#labelCon_",id)).remove();
	            main.select(self.graph().getCustomId("#polyline_",id)).remove();
	            var ins = self.nodeInsMap().get(id);
	            if(ins) {
	            	ins.polyline = null;
	            }
	            self.nodeInsMap().remove(id);
	            d3.select(this).remove();
	        });
	        //update
	        sunburstItemsUpdate.each(function(d) {
	            var ins = self.nodeInsMap().get(d.data.id);
	            if(ins) {
	            	self.getRendererConfig(d.data, "fill");//把渲染器配置信息刷新到渲染器实例数据里面
	                ins.update(d);
	            }
	        });
	        //add
	        var sunburstItemsEnter = sunburstItemsUpdate.enter().append("g")
	            .attr("class", "sunburst-item")
	            .on("mouseover", mouseOverHandler)
	            .each(function(d){
	                if(!d.data || !d.parent) {
	                    return;
	                }
	                var rendererConfig = self.getRendererConfig(d.data, "fill");
	                var clazz = (rendererConfig && rendererConfig.clazz) ? rendererConfig.clazz : "sunburstNode";
	                var nodeIns = ClassFactory.newNodeInstance(clazz, [d3.select(this), d, self]);
	                nodeIns.isChartFirstInit(isInit);
	                nodeIns.graph(self.graph());
	                nodeIns.render();
	                self.nodeInsMap().set(d.data.id, nodeIns);
	                d.data.legendIns = d3.select(this);
	            });
	        
	        updateRingInfo(self.layout().nodes());
	
	        totalSize = sunburstItemsUpdate.merge(sunburstItemsEnter).datum().value;
	        isInit = false;
	    };
	    
	    //override
	    this.filterArrayByElementProperty = function(nodes, name, value) {
	        var visibleNodes = [],unvisibleNodeKeys = [];
	        function contains(d){
	            var i = unvisibleNodeKeys.length;
	            while (i--) {
	                if (unvisibleNodeKeys[i] === d) {
	                    return true;
	                }
	            }
	            return false;
	        };
	        var idField = self.data()["idField"],
	            parentField = self.data()["parentField"];
	        nodes.forEach(function(node){
	            if((node[name]==undefined || node[name]==true) && !contains(node[parentField])){
	                visibleNodes.push(node);
	            }else{
	                unvisibleNodeKeys.push(node[idField]);
	            }
	        });
	        return visibleNodes;
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // listeners
	    //
	    // --------------------------------------------------------------------------
	    
	    var mouseOverHandler = function(d) {
	        d3.event.stopPropagation();
	        
	        var sequenceArray = d.ancestors().reverse();
	        var root = sequenceArray.shift(); // remove root node from the array
	
	        updatePercentageInfo(d,root);
	        updateBreadcrumbs(sequenceArray,root);
	
	        var paths = self.arcsContainer.selectAll("g.sunburstNode path")
	            .style("fill-opacity", 0.1)//这里用fill-opacity是因为opacity在chrome里渲染有问题
	            .each(function(d) {
	                visibleLabel(d, 0.1);
	            });
	            
	        paths
	            .filter(function(node) {
	            	for(var i = 0, id = node.data.id, len = sequenceArray.length; i < len; i++) {
	            		if(sequenceArray[i].data.id === id) {
	            			return true;
	            		}
	            	}
	                return false;
	            })
	            .style("fill-opacity", 1)
	            .each(function(d) {
	                visibleLabel(d, 1);
	            });
	    };
	    
	    var mouseleaveHandler = function() {
	    	if(self.isShowNavigation()) {
	    		self.navigationContainer.style("visibility", "hidden");
	    	}
	
	        // Transition each segment to full opacity and then reactivate it.
	        self.arcsContainer.selectAll("g.sunburstNode path")
	            .style("fill-opacity", 1)
	            .each(function(d) {
	            	visibleLabel(d, 1);
	            });
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // private Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    var visibleLabel = function(d, opacity) {
	    	var id = d.data.id;
	        var main = self.mainContainer();
	        main.select(self.graph().getCustomId("#labelCon_",id)).style("fill-opacity", opacity);
	        main.select(self.graph().getCustomId("#polyline_",id)).style("opacity", opacity);
	    };
	    
	    var updateRingInfo = function(nodes) {
	    	//remove content
	        self.ringInfoContainer.selectAll("polyline").remove();
	        self.ringInfoContainer.selectAll("g.label").remove();
	        
	        var ringInfoData = self.data().ringInfo;
	        if(!ringInfoData) {
	        	return;
	        }
	        var ringInfoVisible = ringInfoData.visible !== false;
	        if(!ringInfoVisible) {
	            return;
	        }
	        var gap = isNaN(ringInfoData.gap) ? 5 : ringInfoData.gap ;
	        var labelData = ringInfoData.label;
	        var lineData = ringInfoData.line;
	        
	        //create ring info data
	        var infosObj = {};
	        for(var d, info, i = 0, len = nodes.length; i < len; i++) {
	        	d = nodes[i];
	        	if(d.visible === false) {
	        		continue;
	        	}
	        	info = infosObj[d.depth];
	        	if(!info) {
	        		info = {depth:d.depth};
	        		info.total = 1;
	        		info.name = d.data && d.data.groupName ? d.data.groupName : "";
	        		info.innerRadius = d.innerRadius;
	        		info.outerRadius = d.outerRadius;
	        		info.startAngle = 0;
	        		info.endAngle = Math.PI;
	        		info.data = d;
	        		infosObj[d.depth] = info;
	        	} else {
	        		info.total++;
	        	}
	        }
	        var infos = [];
	        for(var key in infosObj) {
	        	infos.push(infosObj[key]);
	        }
	        if(infos.length > 1) {
	        	infos.sort(function(a, b) {
	                return a.depth - b.depth;
	            });
	        }
	        
	        //render content
	        var transition = d3.transition().delay(self.animation() ? isInit ? 500 : 0 : 0)
	            .duration(self.animation() ? 1000 : 0).ease(d3.easeExpOut);
	        for(var i = 0, len = infos.length; i < len; i++) {
	        	var ud = infos[i];
	        	if(ud.depth === 0) {
	        		continue;
	        	}
	        	
	        	//render polyline
	            var ir = ud.innerRadius;
	            var or = ud.outerRadius;
	            var distance = or * 0.2;
	            distance = distance < 10 ? 10 : (distance > 20 ? 20 : distance);
	            var outerArc1 = d3.arc().innerRadius(ir).outerRadius(or);
	            var outerArcRadius = self.layout().radius() + 35 + distance;
	            var outerArc2 = d3.arc().innerRadius(outerArcRadius).outerRadius(outerArcRadius);
	            ud.outerArc1 = outerArc1;
	            ud.outerArc2 = outerArc2;
	            ud.lineSize = isNaN(lineData.lineSize) ? 20 : lineData.lineSize;
	            
	            var lineStyle = lineData.style;
	            var polyline = self.ringInfoContainer.append("polyline");
	            polyline.datum(ud)
	            ElementUtil.setElementStyles(polyline, lineStyle);
	            polyline.attr("fill", "none")
	                .transition(transition)
	                .attrTween("points", polylineRenderTween);
	                
	            //render label
	            var label = new Label(self.ringInfoContainer, ud);
	            label.config(labelData.config);
	            label.render();
	            var pos = polylineRenderTween(ud)(1)[2];
	            pos[0] += gap;
	            pos[1] -= label.mainContainer().node().getBBox().height / 2;
	            label.mainContainer()
	                .attr("opacity", 0)
	                .attr("cursor", "default")
	                .attr("transform", "translate(" + [pos[0] + 100, pos[1]] + ")")
	                .on("mousedown", function(d) {
	                    var evt = EventUtil.createCustomEvent(BaseEvent.RING_LABEL_CLICK, true, true, d);
	                    d3.select(this).node().dispatchEvent(evt);
	                })
	                .transition(transition)
	                .attr("opacity", 1)
	                .attr("transform", "translate(" + pos + ")");
	        }
	    };
	    
	    var midAngle = function (d){
	        return d.startAngle + (d.endAngle - d.startAngle) / 2;
	    };
	    
	    var polylineRenderTween = function(d) {
	        this._current = this._current || d;
	        var interpolate = d3.interpolate({startAngle:this._current.startAngle, endAngle:this._current.endAngle}, d);
	        this._current = interpolate(0);
	        var outerArc1 = d.outerArc1;
	        var outerArc2 = d.outerArc2;
	        var r = self.layout().radius() + 5;
	        return function(t) {
	            var d2 = interpolate(t);
	            var startP = outerArc1.centroid(d2);
	            var centerP = [r, -(r-startP[0])];
	            var endP = [centerP[0], centerP[1]];
	            centerP[1] = (centerP[1] - startP[1]) * t + startP[1];
	            endP[1] = (endP[1] - startP[1]) * t + startP[1];
	            endP[0] += d.lineSize * (midAngle(d2) < Math.PI ? 1 : -1);
	            return [startP, centerP, endP];
	        };          
	    };
	
	    var updatePercentageInfo = function(d, root) {
	    	if(!self.data().percentageInfo || !self.data().percentageInfo.visible === false) {
	    		return;
	    	}
	        var r = root.outerRadius;
	        var percentage = (100 * d.data.value / totalSize).toPrecision(3);
	        var percentageString = percentage + "%";
	        if (percentage < 0.1) {
	            percentageString = "< 0.1%";
	        }
	        var length = percentageString.length;
	        var fontSize = r*2/(length-1);
	        //更改字体大小，适应窗口大小
	        // percentageInfo.config().label.config.fontSize = defaultWidth/ Math.min(self.width(), self.height())*percentageDefaultFontSize;
	        percentageInfo.config().label.config.fontSize = fontSize;
	        percentageInfo.data({value:percentageString});
	        percentageInfo.render();
	    	self.percentageContainer.style("visibility", "");
	    };
	
	    // Update the breadcrumb trail to show the current sequence and percentage.
	    var updateBreadcrumbs = function(nodeArray) {
	        if(!self.isShowNavigation()) {
	        	return;
	        }
	        var count = Math.floor(self.width()/(b.w+b.s));
	        var secondArray = [];
	        if(nodeArray.length>count){
	            var i=0,n=nodeArray.length-count;
	            for(i=0;i<n;i++){
	                secondArray.push(nodeArray[count+i]);
	            }
	            nodeArray.splice(count-1,n);
	        }
	        initBreadcrumbs(nodeArray,0);
	        initBreadcrumbs(secondArray,1);
	    };
	    
	    var initBreadcrumbs = function(nodeArray, rows) {
	        // Data join; key function combines name and depth (= position in sequence).
	        var trail = self.navigationContainer.selectAll(rows==0?"g.first":"g.second")
	            .data(nodeArray, function(d) { return d.data.id; });
	
	        // Remove exiting nodes.
	        trail.exit().remove();
	
	        // Add breadcrumb and label for entering nodes.
	        var entering = trail.enter().append("svg:g").attr("class",rows==0?"first":"second");
	        entering.append("svg:polygon")
	            .attr("points", function breadcrumbPoints(d, i) {
	                var points = [];
	                points.push("0,"+rows*(b.h+b.s));
	                points.push(b.w + ","+rows*(b.h+b.s));
	                points.push(b.w + b.t + "," + (b.h / 2+rows*(b.h+b.s)));
	                points.push(b.w + "," + (b.h+rows*(b.h+b.s)));
	                points.push("0," + (b.h+rows*(b.h+b.s)));
	                if (i > 0) { // Leftmost breadcrumb; don't include 6th vertex.
	                    points.push(b.t + "," + (b.h / 2+rows*(b.h+b.s)));
	                }
	                return points.join(" ");
	            })
	            .style("fill", function(d) { return d.data.legendColor; });
	
	        entering.append("svg:text")
	            .attr("x", (b.w + b.t) / 2 + 3)
	            .attr("y", b.h*rows+b.h / 2)
	            .attr("dy", "0.35em")
	            .attr("text-anchor", "middle")
	            .style("font-size", "12px")
	            .style("font-family", "微软雅黑")
	            .each(function(d) {
	                var text = d3.select(this);
	                var content = d.data.name;
	                var texts = StringUtil.splitByLine(content, b.w - 12, 12, 1);
	                text.selectAll("tspan")
	                    .data(texts)
	                    .enter()
	                    .append("tspan")
	                    .text(function(d) {
	                        return d;
	                    });
	                text.attr("title", content.indexOf("...") !== -1 ? content : "");
	            })
	
	        // Merge enter and update selections; set position for all nodes.
	        entering.merge(trail).attr("transform", function(d, i) {
	            return "translate(" + i * (b.w + b.s) + ", 0)";
	        });
	
	        // Make the breadcrumb trail visible, if it's hidden.
	        self.navigationContainer.style("visibility", "");
	    };
	
	    Sunburst.clazzName = "sunburst";
	    
	    // 初始化
	    this.init();
	};
	
	Sunburst.struct = function(ghca_charts) {
		var BaseChart = ghca_charts.view.component.charts.baseChart;
		BaseChart.struct(ghca_charts);
	    Sunburst.prototype = Object.create(BaseChart.prototype);
	    Sunburst.prototype.constructor = Sunburst;
	};
	
	module.exports = Sunburst;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {// 拓扑图类
		
	/**
	 * 构造方法 
	 * @param _data 拓扑图配置数据
	 * @param _layout 拓扑图布局对象，不传就为默认布局
	 */
	var Topology = function(_data, _layout) {
		
		// --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const BaseComponent = ghca_charts.view.component.baseComponent;
	    const Plugin = ghca_charts.view.elements.plugins.plugin;
	    const BaseChart = ghca_charts.view.component.charts.baseChart;
	    const TopoLayout = ghca_charts.layout.topoLayout;
	    const ClassFactory = ghca_charts.view.util.classFactory;
	    const DataParser = ghca_charts.view.util.dataParser;
	    const Const = ghca_charts.view.util.constant;
	    const ObjectUtil = ghca_charts.view.util.objectUtil;
	    const BaseEvent = ghca_charts.events.BaseEvent;
	    const Node = ghca_charts.view.elements.plugins.nodes.node;
	    const math = ghca_charts.view.util.math;
	    const EventUtil = ghca_charts.view.util.eventUtil;
	    const RegexUtil = ghca_charts.view.util.regexUtil;
	    const MouseUtil = ghca_charts.view.util.mouseUtil;
	    const Global = ghca_charts.global;
	
		BaseChart.apply(this, arguments);
		
		var self = this,
			superInit = self.init,
	        superInitAllContainers = self.initAllContainers,
	        superAddListeners = self.addListeners,
	        superRenderPosition = self.renderPosition,
	        superRefreshData = self.refreshData,
	        superSetData = self.setData,
	        nodesInsMap = {},
	        linksInsMap = {},
	        groupsInsMap = {},
	        isInFocus = false,
	        isValidateMode = false,
	        changeData = {
	            nodes:{enter:{}, update:{}}, 
	            links:{enter:{}, update:{}}, 
	            groups:{enter:{}, update:{}}
	        };//数据变更集
	
	    self.className("seriesTopo");
	    //添加可从配置文件读取的属性名称
	    self.addAttributes("showLevel", "mode", "focusEffect", "mouseOverFocusEffect");
	    
		// --------------------------------------------------------------------------
		//
		// Attributes
		//
		// --------------------------------------------------------------------------
	
		// ------------------------------
	    // showLevel
	    // ------------------------------
		
		/**
	     * 设置节点显示层级，默认全部节点都显示
	     * (暂时没有实现)
	     */
		var showLevel = Topology.SHOW_ALL_LEVEL_NODES;
	    this.showLevel = function(value) {
	        if (!arguments.length)
	            return showLevel;
	        showLevel = value;
	        if(_data) {
	            _data.showLevel = value;
	        }
	        return this;
	    };
	    
	    // ------------------------------
	    // mode
	    // ------------------------------
	    
	    /**
	     * 组件模式，normal|edit，默认为普通模式
	     */
	    var mode = Topology.MODE_NORMAL;
	    this.mode = function(value) {
	        if (!arguments.length)
	            return mode;
	        if(mode !== value) {
	        	isValidateMode = true;
	        }
	        mode = value;
	        if(_data) {
	        	_data.mode = value;
	        }
	        return this;
	    };
	    
	    // ------------------------------
	    // focusEffect
	    // ------------------------------
	        
	    /**
	     * 鼠标单击节点时，是否显示凸显效果(默认值true)
	     */
	    var focusEffect = true;
	    this.focusEffect = function(value) {
	        if (!arguments.length) return focusEffect;
	        focusEffect = value;
	        if(_data) {
	            _data.focusEffect = value;
	        }
	        return this;
	    };
	    
	    // ------------------------------
	    // mouseOverFocusEffect
	    // ------------------------------
	        
	    /**
	     * 鼠标单击节点时，是否显示凸显效果(默认值false)
	     */
	    var mouseOverFocusEffect = false;
	    this.mouseOverFocusEffect = function(value) {
	        if (!arguments.length) return mouseOverFocusEffect;
	        mouseOverFocusEffect = value;
	        if(_data) {
	            _data.mouseOverFocusEffect = value;
	        }
	        return this;
	    };
	    
	    // ------------------------------
	    // isEditMode
	    // ------------------------------
	    
	    /**
	     * 组件是否处于编辑模式，默认为否
	     */
	    this.isEditMode = function() {
	        return mode === Topology.MODE_EDIT;
	    };
	    
	    // ------------------------------
	    // selectedItems
	    // ------------------------------
	    
	    /**
	     * 当前选中的项数据对象数组
	     */
	    var selectedItems = [];
	    this.selectedItems = function(value) {
	        if (!arguments.length)
	            return selectedItems;
	        selectedItems = value;
	        return this;
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // override Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    /**
	     * 初始化方法
	     */
	    this.init = function() {
	        superInit();
	        
	        self.nodes = self.layout().nodes();
	        self.links = self.layout().links();
	        self.groups = [];
	        self.nodesIns = [];
	        self.linksIns = [];
	        self.groupsIns = [];
	        
	        //添加初始化数据中的所有节点和连线和节点分组内容
	        self.addNodes(self.data().nodes);
	        self.addLinks(self.data().links);
	        self.addGroups(self.data().groups);
	        
	        self.visibleItems(self.nodes);
	    };
	    
	    /**
	     * 初始化图表包含的各个层级
	     */
	    this.initAllContainers = function() {
	        superInitAllContainers();
	        
	        //放置所有连线节点组背景的g元素
	        var groupsContainer = new BaseComponent();
	        groupsContainer.className("topo-groupsContainer");
	        self.addChild(groupsContainer);
	        groupsContainer.mainContainer().attr("pointer-events", "none");
	        self.groupsContainer = groupsContainer;
	        
	        //放置所有连线的g元素
	        var linksContainer = new BaseComponent();
	        linksContainer.className("topo-linksContainer");
	        self.addChild(linksContainer);
	        self.linksContainer = linksContainer;
	        
	        //放置所有节点的g元素
	        var nodesContainer = new BaseComponent();
	        nodesContainer.className("topo-nodesContainer");
	        self.addChild(nodesContainer);
	        self.nodesContainer = nodesContainer;
	    };
	    
	    /**
	     * 初始化添加所有监听的方法
	     */
	    this.addListeners = function() {
	        superAddListeners();
	        //若点不固定，则添加实时刷新数据监听
	
	        self.model.on("tick", self.tickHandler);
	        self.model.on("end", self.tickEndHandler);
	
	        self.addEventListener(BaseEvent.MODE_CHANGE, modeChangeHandler);
	        //self.addEventListener(BaseEvent.EV_EVENT_OPEN_EDIT, openEditHandler);
	        self.addEventListener(BaseEvent.SEARCH_TEXT, searchTextHandler);
	        self.addEventListener(BaseEvent.TOPO_NODE_FOCUS_IN, topoNodeFocusInHandler);
	        
	        self.mainContainer().node().addEventListener(BaseEvent.EAGLE_EYE_DRAG, function(e) {
	            event.stopImmediatePropagation();
	            var detail = e.detail;
	            self.x(detail.x);
	            self.y(detail.y);
	            self.renderTransform();
	        });
	    };
	    
	    /**
	     * 刷新数据内容，生成需要的属性和相关值
	     */
	   this.refreshData = function() {
	        superRefreshData();
	        var  nodes = self.nodes,
	             links = self.links,
	             groups = self.groups,
	             level = self.showLevel();
	        
	        //根据showLevel设置每一个节点是否可见，以及是否展开
	        for(var node, nodeLevel, nodeEnabledExpand, i = 0, len = nodes.length; i < len; i++) {
	            node = nodes[i];
	            node.bindKey = i;
	            if(node.hasOwnProperty("visible")) {
	                continue;
	            }
	            nodeLevel = node.level === undefined ? 0 : node.level;  
	            nodeEnabledExpand = node.enabledExpand === undefined ? false : node.enabledExpand;  
	            if(nodeLevel < level) {
	                node.visible = true;
	                if(nodeEnabledExpand) {
	                    node.isExpanded = true;
	                }
	            } else if(nodeLevel == level) {
	                node.visible = true;
	                if(nodeEnabledExpand) {
	                    node.isExpanded = false;
	                }
	            } else {
	                node.visible = false;
	                if(nodeEnabledExpand) {
	                    node.isExpanded = false;
	                }
	            }
	        }
	        
	        for(var link, i = 0, len = links.length; i < len; i++) {
	            link = links[i];
	            link.bindKey = i;
	            if(link.hasOwnProperty("visible")) {
	                continue;
	            }
	            link.visible = true;
	        }
	        
	        for(var group, i = 0, len = groups.length; i < len; i++) {
	            group = groups[i];
	            group.bindKey = i;
	            if(group.hasOwnProperty("visible")) {
	                continue;
	            }
	            group.visible = true;
	        }
	    };
	    
	    /**
	     * 渲染图表内容相关位置
	     * @param isRenderByChange 是否根据当前变更集渲染
	     */
	    this.renderPosition = function(isRenderByChange) {
	        superRenderPosition();
	        
	        var nodesIns = self.nodesIns;
	        for(var nodeIns, i = 0, len = nodesIns.length; i < len; i++) {
	            nodeIns = nodesIns[i];
	            nodeIns.mainContainer().each(function(d) {
	            	//在按照变更集刷新模式下检测当前数据对象是否在变更集中
	                if(isRenderByChange && !isItemInChangeData(d, changeData.nodes.enter)) {
	                    return;
	                }
	                nodeIns.x(Math.round(d.x));
	                nodeIns.y(Math.round(d.y));
	                nodeIns.renderTransform();
	            });
	        }
	        
	        var linksIns = self.linksIns;
	        for(var linkIns, i = 0, len = linksIns.length; i < len; i++) {
	            linkIns = linksIns[i];
	            //在按照变更集刷新模式下检测当前数据对象是否在变更集中
	            if(isRenderByChange && !isItemInChangeData(linkIns.mainContainer().node().__data__, changeData.links.enter)) {
	                continue;
	            }
	            if(linkIns.normalChild()){
	                linkIns.normalChild().update();
	            } else {
	                linkIns.render();
	            }
	        }
	        
	        //刷新所有节点组path数据
	        refreshGroupsData();
	        var groupsIns = self.groupsIns;
	        for(var groupIns, i = 0, len = groupsIns.length; i < len; i++) {
	            groupIns = groupsIns[i];
	            //在按照变更集刷新模式下检测当前数据对象是否在变更集中
	            if(isRenderByChange && !isItemInChangeData(groupIns.mainContainer().node().__data__, changeData.groups.enter)) {
	                continue;
	            }
	            if(groupIns.normalChild()){
	                groupIns.normalChild().update();
	            } else {
	                groupIns.render();
	            }
	        }
	
	        //延时触发鹰眼变更
	        self.useEagleEye() && self.sendMsgToEye(fireContentChange, 1000);
	    };
	    
	    /**
	     * 渲染鼠标拖动对象以及其相关联的对象的位置 
	     */
	    this.updateDragedObjectPos = function(d) {
	    	if(!d) {
	    		return;
	    	}
	    	var nodes = [d];
	    	var nodeIns = d.dragIns;
	    	if(nodeIns) {
	    		nodeIns.x(Math.round(d.x));
	            nodeIns.y(Math.round(d.y));
	            nodeIns.renderTransform();
	    	}
	        
	        var links = d.links;
	        if(ObjectUtil.isArray(links)) {
	        	for(var link, linkIns, i = 0, len = links.length; i < len; i++) {
	        		link = links[i];
	                linkIns = link.dragIns;
	                if(!linkIns) {
	                	continue;
	                }
	                if(linkIns.normalChild()){
	                    linkIns.normalChild().update();
	                } else {
	                    linkIns.render();
	                }
	            }
	        }
	        
	        //刷新相关节点组
	        var groups = self.findGroupsByNodes(nodes);
	        for(var groupData, groupIns, i = 0, len = groups.length; i < len; i++) {
	            groupData = groups[i];
	            setGroupPath(groupData);
	            
	            groupIns = groupData.dragIns;
	            if(groupIns.normalChild()) {
	                groupIns.normalChild().update();
	            } else {
	                groupIns.render();
	            }
	        }
	
	        //延时触发鹰眼变更
	        self.useEagleEye() && self.sendMsgToEye(fireContentChange, 1000);
	    };
	    
	    /**
	     * 根据当前数据重新渲染内容，并重新计算布局内容
	     * @param isUpdateByChange 是否按照变更集刷新
	     * @param isResize 是否通过resize调用本方法
	     */
	    this.update = function(isUpdateByChange, isResize) {
	    	if(Global.isDebug) {
	    		var otAll = new Date().getTime();
	    	}
	    	//刷新当前数据
	        self.refreshData();
	        //只用当前可见的项作为渲染数据源
	        self.visibleItems(self.filterArrayByElementProperty(self.nodes, "visible", true));
	        //计算布局
	        self.layout().update(isResize);
	        if(Global.isDebug) {
	        	var nt = new Date().getTime();
	            console.log("update refreshData and layout cost time " + (nt-ot1) + " ms.");
	        }
	        
	        //更新节点
	        updateNodes(isUpdateByChange);
	        //更新连线
	        updateLinks(isUpdateByChange);
	        //更新节点组
	        updateGroups(isUpdateByChange);
	        
	        if(Global.isDebug) {
	        	var nt = new Date().getTime();
	        }
	        //若是固定节点模式，移动所有对象正确位置
	        if(self.layout().fixed()) {
	            self.renderPosition(isUpdateByChange);
	        }
	        if(Global.isDebug) {
	        	var nt = new Date().getTime();
	            console.log("renderPosition cost time " + (nt-ot) + " ms.");
	        }
	        
	        //清空变更集
	        clearChangeData();
	        
	        //等待初始化完成再验证mode是否改变，否则会出现各种问题
	        var timer = setTimeout(function() {
	            clearTimeout(timer);
	            validateMode();
	        }, 0);
	        
	        if(Global.isDebug) {
	        	var ntAll = new Date().getTime();
	            console.log("update cost time " + (ntAll-otAll) + " ms.");
	        }
	    };
	    
	//    /**
	//     * 根据当前数据重新渲染内容，并重新计算布局内容
	//     */
	//    this.update = function() {
	//        self.refreshData();
	//        //只用当前可见的项作为渲染数据源
	//        self.visibleItems(self.filterArrayByElementProperty(self.nodes, "visible", true));
	//        
	//        //计算布局
	//        self.layout().update();
	//        
	//        /*这里先清除所有的连线和节点元素，然后再创建新的数据，否则动态添加的数据显示会有重复的问题。
	//                                    但是这样做在ie和edge中会造成闪烁，且效率极低，有待优化。*/
	//        var linksContainer = self.linksContainer;
	//        linksContainer.removeAllChildren();
	//        self.linksIns.length = 0;
	//        var nodesContainer = self.nodesContainer;
	//        nodesContainer.removeAllChildren();
	//        self.nodesIns.length = 0;
	//        var groupsContainer = self.groupsContainer;
	//        groupsContainer.removeAllChildren();
	//        self.groupsIns.length = 0;
	//        
	//        //只用当前可见的节点作为渲染数据源
	//        var nodesData = self.visibleItems();
	//        //若节点渲染器是一个组件，则重新设置一些配置数据
	//        for(var i = 0, len = nodesData.length; i < len; i++) {
	//            var nodeData = nodesData[i];
	//            var rendererConfig = self.getRendererConfig(nodeData, "fill");
	//            if(rendererConfig && rendererConfig.type === "chart" && rendererConfig.series) {
	//                var chartData, series = rendererConfig.series;
	//                for(var j = 0, len1 = series.length; j < len1; j++) {
	//                    chartData = series[j];
	//                    //这里config设置的width和height值无效，渲染器组件宽高为线的高度值
	//                    chartData.width = rendererConfig.width ? rendererConfig.width : 0;
	//                    chartData.height = rendererConfig.height ? rendererConfig.height : 0;
	//                    //pie的位置特殊处理
	//                    if(chartData.type === "pie") {
	//                        rendererConfig.x = -chartData.width / 2;
	//                        rendererConfig.y = -chartData.height / 2;
	//                    }
	//                    //组装图表数据
	//                    DataParser.createChartData(chartData, nodeData);
	//                }
	//            }
	//        }
	//        //渲染节点内容
	//        var nodesIns = ClassFactory.newRenderersInstanceByData(nodesContainer, self, "nodeContainer", nodesData);
	//        if(nodesIns) {
	//            for(var nodeIns, i = 0, len = nodesIns.length; i < len; i++) {
	//                nodeIns = nodesIns[i];
	//                //添加子节点收放按钮点击监听，可控制节点的展开,合拢
	//                nodeIns.addEventListener("expandTool_collapsed", expandToolClickHandler);
	//                //添加节点单击监听，点击节点自动居中，显示子级节点，淡化其他节点
	//                nodeIns.addEventListener("click", nodeClickHandler);
	//                nodeIns.addEventListener("mouseover", nodeMouseOverHandler);
	//                nodeIns.addEventListener("mouseout", nodeMouseOutHandler);
	//                //添加节点拖拽监听
	//                nodeIns.mainContainer().call(d3.drag()
	//                    .on("start", self.node_dragStartHandler)
	//                    .on("drag", self.node_dragHandler)
	//                    .on("end", self.node_dragEndHandler));
	//                self.nodesIns.push(nodeIns);
	//            }
	//        }
	//        //只用当前可见的连线作为渲染数据源
	//        var linksData = self.getVisibleLinks(self.links);
	//        //渲染连线内容   
	//        var linksIns = ClassFactory.newRenderersInstanceByData(linksContainer, self, "linkContainer", linksData, false, "stroke");
	//        if(linksIns) {
	//            for(var linkIns, i = 0, len = linksIns.length; i < len; i++) {
	//                linkIns = linksIns[i];
	//                self.linksIns.push(linkIns);
	//            }
	//        }
	//        
	//        //用当前可见的点渲染节点组
	//        var groupsData = self.groups;
	//        //刷新所有节点组path数据
	//        refreshGroupsData();
	//        var groupsIns = ClassFactory.newRenderersInstanceByData(groupsContainer, self, "groupContainer", groupsData);
	//        if(groupsIns) {
	//            for(var groupIns, i = 0, len = groupsIns.length; i < len; i++) {
	//                groupIns = groupsIns[i];
	//                self.groupsIns.push(groupIns);
	//            }
	//        }
	//        
	//        if(self.layout().fixed()) {
	//        	self.renderPosition();
	//        }
	//        
	//        //等待初始化完成再验证mode是否改变，否则会出现各种问题
	//        var timer = setTimeout(function() {
	//        	clearTimeout(timer);
	//        	validateMode();
	//        }, 0);
	//    };
	    
	    /**
	     * 设置数据内容
	     * @param value 数据内容，格式为：{data:[]}或者{nodes:[],links:[]}等
	     * @return 返回是否设置成功
	     */
	    this.setData = function(value) {
	        var result = superSetData(value);
	        
	        self.layout().nodes().length = 0;
	        self.layout().links().length = 0;
	        self.nodes.length = 0;
	        self.links.length = 0;
	        self.groups.length = 0;
	        // self.nodesIns.length = 0;
	        // self.linksIns.length = 0;
	        // self.groupsIns.length = 0;
	        
	        //添加初始化数据中的所有节点和连线
	        self.addNodes(self.data().nodes);
	        self.addLinks(self.data().links);
	        self.addGroups(self.data().groups);
	        
	        return result;
	    };
	    
	    /**
	     * 更新节点内容
	     * @param isUpdateByChange 是否按照变更集刷新
	     */
	    var updateNodes = function(isUpdateByChange) {
	        //只用当前可见的节点作为渲染数据源
	        var nodesData = self.visibleItems();
	        //渲染节点内容
	        var nodesUpdate = self.nodesContainer.mainContainer().selectAll("g.nodeContainer")
	            .data(nodesData, self.bindKeyFn);
	        if(Global.isDebug) {
	            var ot = new Date().getTime();
	        }
	        //update
	        nodesUpdate.each(function(d) {
	            //在按照变更集刷新模式下检测当前数据对象是否在变更集中
	            if(isUpdateByChange && !isItemInChangeData(d, changeData.nodes.update)) {
	                return;
	            }
	            //根据配置刷新数据内容
	            self.getRendererConfig(d, "fill");
	            var key = self.bindKeyFn(d);
	            var ins = nodesInsMap[key];
	            if(ins) {
	                var child = ins.normalChild();
	                if(child instanceof Plugin) {
	                    child.data(d);
	                    child.config(d.data.config);
	                    child.update();
	                    d.ins = child;
	                    d.legendIns = child;
	                    d.dragIns = ins;
	                    return;
	                }
	                var children = ins.children();
	                children.forEach(function(child) {
	                    if(child instanceof BaseComponent) {
	                        child.setDataAndUpdate(d);
	                        d.ins = child;
	                        d.legendIns = child;
	                        d.dragIns = ins;
	                    }
	                })
	            }
	        });
	        if(Global.isDebug) {
	            var nt = new Date().getTime();
	            console.log("nodes update cost time " + (nt-ot) + " ms.");
	        }
	        
	        if(Global.isDebug) {
	            var ot = new Date().getTime();
	        }
	        //enter
	        var nodesEnter = [];
	        nodesUpdate.enter().each(function(d) {
	            nodesEnter.push(d);
	            //若节点渲染器是一个组件，则重新设置一些配置数据
	            var nodeData = d;
	            var rendererConfig = self.getRendererConfig(nodeData, "fill");
	            if(rendererConfig && rendererConfig.type === "chart" && rendererConfig.series) {
	                var chartData, series = rendererConfig.series;
	                for(var j = 0, len1 = series.length; j < len1; j++) {
	                    chartData = series[j];
	                    //这里config设置的width和height值无效，渲染器组件宽高为线的高度值
	                    chartData.width = rendererConfig.width ? rendererConfig.width : 0;
	                    chartData.height = rendererConfig.height ? rendererConfig.height : 0;
	                    //pie的位置特殊处理
	                    if(chartData.type === "pie") {
	                        rendererConfig.x = -chartData.width / 2;
	                        rendererConfig.y = -chartData.height / 2;
	                    }
	                    //组装图表数据
	                    DataParser.createChartData(chartData, nodeData);
	                }
	            }
	            var nodesIns = ClassFactory.newRenderersInstanceByData(self.nodesContainer, self, "nodeContainer", [d]);
	            if(nodesIns) {
	                for(var nodeIns, i = 0, len = nodesIns.length; i < len; i++) {
	                    nodeIns = nodesIns[i];
	                    //添加子节点收放按钮点击监听，可控制节点的展开,合拢
	                    nodeIns.addEventListener("expandTool_collapsed", expandToolClickHandler);
	                    //添加节点单击监听，点击节点自动居中，显示子级节点，淡化其他节点
	                    nodeIns.addEventListener("click", nodeClickHandler);
	                    nodeIns.addEventListener("mouseover", nodeMouseOverHandler);
	                    nodeIns.addEventListener("mouseout", nodeMouseOutHandler);
	                    //添加节点拖拽监听
	                    nodeIns.mainContainer().call(d3.drag()
	                        .on("start", self.node_dragStartHandler)
	                        .on("drag", self.node_dragHandler)
	                        .on("end", self.node_dragEndHandler));
	                    self.nodesIns.push(nodeIns);
	                    var key = self.bindKeyFn(d);
	                    nodesInsMap[key] = nodeIns;
	                }
	            }
	        });
	        //添加新建节点数据到变更集
	        addItemsToChangeData(nodesEnter, changeData.nodes.enter);
	        if(Global.isDebug) {
	            var nt = new Date().getTime();
	            console.log("nodes enter cost time " + (nt-ot) + " ms.");
	        }
	        
	        if(Global.isDebug) {
	            var ot = new Date().getTime();
	        }
	        
	        //delete
	        var nodesExit = nodesUpdate.exit();
	        nodesExit.each(function(d) {
	            var key = self.bindKeyFn(d);
	            if(nodesInsMap.hasOwnProperty(key)) {
	                delete nodesInsMap[key];
	            }
	            var index = self.nodesIns.indexOf(d.dragIns);
	            if(index !== -1) {
	                self.nodesIns.splice(index, 1);
	            }
	        }).remove();
	        if(Global.isDebug) {
	            var nt = new Date().getTime();
	            console.log("nodes remove cost time " + (nt-ot) + " ms.");
	        }
	    };
	    
	    /**
	     * 更新连线内容
	     * @param isUpdateByChange 是否按照变更集刷新
	     */
	    var updateLinks = function(isUpdateByChange) {
	        //只用当前可见的连线作为渲染数据源
	        var linksData = self.getVisibleLinks(self.links);
	        //渲染连线内容   
	        var linksUpdate = self.linksContainer.mainContainer().selectAll("g.linkContainer")
	            .data(linksData, self.bindKeyFn);
	        if(Global.isDebug) {
	            var ot = new Date().getTime();
	        }
	        //update
	        linksUpdate.each(function(d){
	            //在按照变更集刷新模式下检测当前数据对象是否在变更集中
	            if(isUpdateByChange && !isItemInChangeData(d, changeData.links.update)) {
	                return;
	            }
	            //根据配置刷新数据内容
	            self.getRendererConfig(d, "stroke");
	            var key = self.bindKeyFn(d);
	            var ins = linksInsMap[key];
	            if(ins) {
	                var child = ins.normalChild();
	                if(child instanceof Plugin) {
	                    child.data(d);
	                    child.config(d.data.config);
	                    child.update();
	                    d.ins = child;
	                    d.legendIns = child;
	                    d.dragIns = ins;
	                    return;
	                }
	                var children = ins.children();
	                children.forEach(function(child) {
	                    if(child instanceof BaseComponent) {
	                        child.setDataAndUpdate(d);
	                        d.ins = child;
	                        d.legendIns = child;
	                        d.dragIns = ins;
	                    }
	                })
	            }
	        });
	        if(Global.isDebug) {
	            var nt = new Date().getTime();
	            console.log("link update cost time " + (nt-ot) + " ms.");
	        }
	        if(Global.isDebug) {
	            var ot = new Date().getTime();
	        }
	        //enter
	        var linksEnter = [];
	        linksUpdate.enter().each(function(d) {
	            linksEnter.push(d);
	            var linksIns = ClassFactory.newRenderersInstanceByData(self.linksContainer, self, "linkContainer", [d], false, "stroke");
	            if(linksIns) {
	                for(var linkIns, i = 0, len = linksIns.length; i < len; i++) {
	                    linkIns = linksIns[i];
	                    self.linksIns.push(linkIns);
	                    var key = self.bindKeyFn(d);
	                    linksInsMap[key] = linkIns;
	                }
	            }
	        });
	        //添加新建连线数据到变更集
	        addItemsToChangeData(linksEnter, changeData.links.enter);
	        if(Global.isDebug) {
	            var nt = new Date().getTime();
	            console.log("link enter cost time " + (nt-ot) + " ms.");
	        }
	        if(Global.isDebug) {
	            var ot = new Date().getTime();
	        }
	        //delete
	        var linksExit = linksUpdate.exit();
	        linksExit.each(function(d) {
	            var key = self.bindKeyFn(d);
	            if(linksInsMap.hasOwnProperty(key)) {
	                delete linksInsMap[key];
	            }
	            var index = self.linksIns.indexOf(d.dragIns);
	            if(index !== -1) {
	                self.linksIns.splice(index, 1);
	            }
	        }).remove();
	        if(Global.isDebug) {
	            var nt = new Date().getTime();
	            console.log("link remove cost time " + (nt-ot) + " ms.");
	        }
	    };
	    
	    /**
	     * 更新节点组内容
	     * @param isUpdateByChange 是否按照变更集刷新
	     */
	    var updateGroups = function(isUpdateByChange) {
	        //用当前可见的点渲染节点组
	        var groupsData = self.groups;
	        //刷新所有节点组path数据
	        if(Global.isDebug) {
	            var ot = new Date().getTime();
	        }
	        refreshGroupsData();
	        if(Global.isDebug) {
	            var nt = new Date().getTime();
	            console.log("refreshGroupsData cost time " + (nt-ot) + " ms.");
	        }
	        var groupsUpdate = self.groupsContainer.mainContainer().selectAll("g.groupContainer")
	            .data(groupsData, self.bindKeyFn);
	        if(Global.isDebug) {
	            var ot = new Date().getTime();
	        }
	        //update
	        groupsUpdate.each(function(d){
	            //在按照变更集刷新模式下检测当前数据对象是否在变更集中
	            if(isUpdateByChange && !isItemInChangeData(d, changeData.groups.update)) {
	                return;
	            }
	            //根据配置刷新数据内容
	            self.getRendererConfig(d, "fill");
	            var key = self.bindKeyFn(d);
	            var ins = groupsInsMap[key];
	            if(ins) {
	                var child = ins.normalChild();
	                if(child instanceof Plugin) {
	                    child.data(d);
	                    child.update();
	                    d.ins = child;
	                    d.legendIns = child;
	                    d.dragIns = ins;
	                    return;
	                }
	                var children = ins.children();
	                children.forEach(function(child) {
	                    if(child instanceof BaseComponent) {
	                        child.setDataAndUpdate(d);
	                        d.ins = child;
	                        d.legendIns = child;
	                        d.dragIns = ins;
	                    }
	                })
	            }
	        });
	        if(Global.isDebug) {
	            var nt = new Date().getTime();
	            console.log("group update cost time " + (nt-ot) + " ms.");
	        }
	        if(Global.isDebug) {
	            var ot = new Date().getTime();
	        }
	        //enter
	        var groupsEnter = [];
	        groupsUpdate.enter().each(function(d) {
	            groupsEnter.push(d);
	            var groupsIns = ClassFactory.newRenderersInstanceByData(self.groupsContainer, self, "groupContainer", [d]);
	            if(groupsIns) {
	                for(var groupIns, i = 0, len = groupsIns.length; i < len; i++) {
	                    groupIns = groupsIns[i];
	                    self.groupsIns.push(groupIns);
	                    var key = self.bindKeyFn(d);
	                    groupsInsMap[key] = groupIns;
	                }
	            }
	        });
	        //添加新建节点组数据到变更集
	        addItemsToChangeData(groupsEnter, changeData.groups.enter);
	        if(Global.isDebug) {
	            var nt = new Date().getTime();
	            console.log("group enter cost time " + (nt-ot) + " ms.");
	        }
	        if(Global.isDebug) {
	            var ot = new Date().getTime();
	        }
	        //delete
	        var groupsExit = groupsUpdate.exit();
	        groupsExit.each(function(d) {
	            var key = self.bindKeyFn(d);
	            if(groupsInsMap.hasOwnProperty(key)) {
	                delete groupsInsMap[key];
	            }
	            var index = self.groupsIns.indexOf(d.dragIns);
	            if(index !== -1) {
	                self.groupsIns.splice(index, 1);
	            }
	        }).remove();
	        if(Global.isDebug) {
	            var nt = new Date().getTime();
	            console.log("group remove cost time " + (nt-ot) + " ms.");
	        }
	    };
	    
	    /**
	     * 刷新节点分组路径数据
	     */
	    var refreshGroupsData = function() {
	        var groupsData = self.groups;
	        for(var groupData, i = 0, len = groupsData.length; i < len; i++) {
	            groupData = groupsData[i];
	            setGroupPath(groupData);
	        }
	    };
	    
	    /**
	     * 设置节点分组路径字符串数据到节点分组数据对象中
	     * @param groupData 节点分组数据对象
	     */
	    var setGroupPath = function(groupData) {
	        //判断整个节点分组是否可见
	        if(groupData.visible === false) {
	            groupData.path = "";
	            groupData.pathPoints = [];
	            return;
	        }
	        var nodesData = groupData.nodes, points = [], 
	        radius = (groupData.data &&　groupData.data.hasOwnProperty("radius")) ? RegexUtil.replace(RegexUtil.dataRegex,groupData.data.radius,groupData): 20, 
	        extendedSize = (groupData.data &&　groupData.data.hasOwnProperty("extendedSize")) ? groupData.data.extendedSize : 10;
	        if(ObjectUtil.isString(radius)&&radius.indexOf("{")!=-1){
	            radius=20;
	        }
	        for(var ins, node, box, halfW, halfH, i = 0, len = nodesData.length; i < len; i++) {
	            node = nodesData[i];
	            if(!node.visible || !node.ins) {
	                continue;
	            }
	            ins = node.ins;
	            box = ins instanceof BaseComponent ? ins.getBBox() : ins.mainPlugin.getBBox();
	            halfW = box.width/2 + extendedSize;
	            halfH = box.height/2 + extendedSize;
	            points.push([node.x - halfW, node.y - halfH]);
	            points.push([node.x + halfW, node.y - halfH]);
	            points.push([node.x + halfW, node.y + halfH]);
	            points.push([node.x - halfW, node.y + halfH]);
	        }
	        var path = math.pointsToPolygonHullRoundPath(points, radius, false);
	        groupData.path = path;
	        groupData.pathPoints = points;
	    };
	    
	    var addNodeDragListeners = function() {
	        for(var nodeIns, nodesIns = self.nodesIns, i = 0, len = nodesIns.length; i < len; i++) {
	            nodeIns = nodesIns[i];
	            //添加节点拖拽监听
	            nodeIns.mainContainer().call(d3.drag()
	                .on("start", self.node_dragStartHandler)
	                .on("drag", self.node_dragHandler)
	                .on("end", self.node_dragEndHandler));
	        }
	    };
	    
	    var removeNodeDragListeners = function() {
	        for(var nodeIns, nodesIns = self.nodesIns, i = 0, len = nodesIns.length; i < len; i++) {
	            nodeIns = nodesIns[i];
	            //移除节点拖拽监听
	            nodeIns.mainContainer().on("mousedown.drag", null);
	        }
	    };
	    
	    var setListenersInNormal = function() {
	        self.addDragListeners();
	        addNodeDragListeners();
	    };
	    
	    var setListenersInEditLink = function() {
	        self.removeDragListeners();
	        removeNodeDragListeners();
	    };
	    
	    //override
	    this.toJSON = function(isData) {
	        var str = "";
	        var d = self.data();
	        if(!d) {
	            return str;
	        }
	        //清除数据属性节点的内容，然后克隆除数据内容外的配置内容，这样做是因为循环引用在toJson的时候会报错
	        var nodes = d.nodes;
	        var links = d.links;
	        var groups = d.groups;
	        if(nodes) {
	            d.nodes = [];
	        }
	        if(links) {
	            d.links = [];
	        }
	        if(groups) {
	            d.groups = [];
	        }
	        //根据需要的属性复制数据内容
	        var nodeKeys = ["renderer", "id", "name", "parentId", "enabledExpand", "visible", "x", "y"];
	        var linkKeys = ["renderer", "name","source", "target", "visible"];
	        var groupKeys = ["renderer", "id", "name", "nodes", "visible"];
	        var getData = function(keys, data, isLink) {
	        	var result = [];
	        	if(isLink) {
	        		for(var d, obj, i = 0, len = data.length; i < len; i++) {
	                    d = data[i];
	                    obj = {};
	                    result.push(obj);
	                    for(var key, j = 0, len1 = keys.length; j < len1; j++) {
	                        key = keys[j];
	                        if(d.hasOwnProperty(key)) {
	                        	if(key === "source" || key === "target") {
	                        		obj[key] = d[key].id;
	                        	} else {
	                        		obj[key] = d[key];
	                        	}
	                        }
	                    }
	                }
	        	} else {
	        		for(var d, obj, i = 0, len = data.length; i < len; i++) {
	                    d = data[i];
	                    obj = {};
	                    result.push(obj);
	                    for(var key, j = 0, len1 = keys.length; j < len1; j++) {
	                        key = keys[j];
	                        if(d.hasOwnProperty(key)) {
	                        	//过滤group数据中的nodes元素，只记录节点id
	                        	if(keys === groupKeys && key === "nodes") {
	                        		var nodes = d[key];
	                        		var resultNodes = [];
	                        		for(var k = 0, len2 = nodes.length; k < len2; k++) {
	                        			resultNodes.push(nodes[k].id);
	                        		}
	                        		obj[key] = resultNodes;
	                        	} else {
	                        		obj[key] = d[key];
	                        	}
	                        }
	                    }
	                }
	        	}
	        	return result;
	        };
	        var cloneData = isData === true ? {} : ObjectUtil.cloneObj(d);
	        cloneData.nodes = getData(nodeKeys, self.nodes);
	        cloneData.links = getData(linkKeys, self.links, true);
	        cloneData.groups = getData(groupKeys, self.groups);
	        //还原数据
	        if(nodes) {
	            d.nodes = nodes;
	        }
	        if(links) {
	            d.links = links;
	        }
	        if(groups) {
	            d.groups = groups;
	        }
	        //把该baseChart的数据转换成json字符串
	        str = JSON.stringify(cloneData);
	        return str;
	    };
	    
	    /**
	     * override toString方法，用于打印本对象的一些基本信息
	     */
	    this.toString = function() {
	        return ("Topology info: " +
	                "\n   width:"     + self.width()      + 
	                "\n   height:"    + self.height()     + 
	                "\n   layout:"    + self.layout()     + 
	                "\n   showLevel:" + self.showLevel()  +
	                "\n   data:"      + JSON.stringify(self.data(), null, 4));
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // listeners
	    //
	    // --------------------------------------------------------------------------
	    
	    var searchTextHandler = function(event) {
	        var str = event.detail;
	        var nodes = self.searchNodesByName(str);
	        self.centerNodesAndSelected(nodes, true);
	    };
	    
	    /**
	     * 外部抛事件代码如下:
	     * <code><pre>
	     * const BaseEvent = ghca_charts.events.BaseEvent;
	     * const EventUtil = ghca_charts.view.util.eventUtil;
	     * const evt = EventUtil.createCustomEvent(BaseEvent.TOPO_NODE_FOCUS_IN, true, true, "10.4.42.1");
	     * d3.selectAll("g.seriesTopo").node().dispatchEvent(evt);
	     * </pre></code>
	     */
	    var topoNodeFocusInHandler = function(event) {
	        var id = event.detail;
	        //移动该节点到中心位置并选中，然后突出显示节点
	        self.centerAndFocusInNode(id)
	    };
	    
	    /**
	     * 节点单击事件的监听相关处理方法
	     */
	    var nodeClickHandler = function(event) {
	        if(self.isEditMode() || !self.focusEffect()) {
	            return;
	        }
	        event.stopImmediatePropagation();
	        //获取当前点击的节点数据对象
	        var data = d3.select(event.currentTarget).data();
	        if(data.length === 0) {
	            return;
	        }
	        var node = data[0];
	        var nodeIns = node.ins;
	        if(isInFocus) {
	            //若已经处于聚焦状态，则取消选选中和聚焦状态
	            self.focusOutAllNodes();
	        } else {
	            //移动该节点到中心位置并选中，然后突出显示节点
	            self.centerAndFocusInNode(node);
	        }
	    };
	    
	    /**
	     * 节点鼠标移入事件的监听相关处理方法
	     */
	    var nodeMouseOverHandler = function(event) {
	    	if(self.isEditMode() || !self.mouseOverFocusEffect()) {
	            return;
	        }
	        //获取当前鼠标移入的节点数据对象
	        var data = d3.select(event.currentTarget).data();
	        if(data.length === 0) {
	            return;
	        }
	        var node = data[0];
	        //突出显示节点
	        self.focusInNode(node);
	    };
	    
	    /**
	     * 节点鼠标移chu 事件的监听相关处理方法
	     */
	    var nodeMouseOutHandler = function(event) {
	        if(self.isEditMode() || !self.mouseOverFocusEffect()) {
	            return;
	        }
	        //若已经处于聚焦状态，则取消选选中和聚焦状态
	        isInFocus && self.focusOutAllNodes();
	    };
	    
	    /**
	     * 子节点收放按钮点击事件的监听相关处理方法
	     */
	    var expandToolClickHandler = function(event) {
	        event.stopImmediatePropagation();
	        var node = event.detail;
	        if(!node) {
	            return;
	        }
	        self.expandOrCollapseNodeInUI(node);
	    };
	    
	    /**
	     * 实时更新渲染数据的监听相关处理方法
	     */
	    this.tickHandler = function() {
	//    	var ot = new Date().getTime();
	        if(!self.layout().fixed()) {
	            self.renderPosition();
	            self.mainContainer().node().dispatchEvent(EventUtil.createCustomEvent(BaseEvent.EAGLE_EYE_DRAG_CHANGE,true,true,{enable:false}));
	        }   
	//        var nt = new Date().getTime();
	//        console.log("tick cost time: " + (nt-ot) + " ms.");
	    };
	    this.tickEndHandler = function() {
	        if(!self.layout().fixed()) {
	            self.mainContainer().node().dispatchEvent(EventUtil.createCustomEvent(BaseEvent.EAGLE_EYE_DRAG_CHANGE,true,true,{enable:true}));
	        }
	    };
	    
	    /**
	     * 节点开始拖动
	     */
	    this.node_dragStartHandler = function(d) {
	    	if(isDrawLink) {
	    		return;
	    	}
	    	if(self.layout().fixed()) {
	    		d.x = d3.event.x;
	            d.y = d3.event.y;
	            d.fx = d.x;
	            d.fy = d.y;
	            self.updateDragedObjectPos(d);
	        } else {
	             if (!d3.event.active) {
	                self.model.alphaTarget(0.3).restart();
	            }
	            d.fx = d.x;
	            d.fy = d.y;
	        }
	    };
	    
	    /**
	     * 节点拖动中
	     */
	    this.node_dragHandler = function(d) {
	    	if(isDrawLink) {
	            return;
	        }
	    	if(self.layout().fixed()) {
	            d.x = d3.event.x;
	            d.y = d3.event.y;
	            d.fx = d.x;
	            d.fy = d.y;
	            self.updateDragedObjectPos(d);
	        } else {
	            d.fx = d3.event.x;
	            d.fy = d3.event.y;
	        }
	    };
	    
	    /**
	     * 节点结束拖动
	     */
	    this.node_dragEndHandler = function(d) {
	    	if(isDrawLink) {
	            return;
	        }
	    	if(self.layout().fixed()) {
	            d.x = d3.event.x;
	            d.y = d3.event.y;
	            d.fx = d.x;
	            d.fy = d.y;
	            self.updateDragedObjectPos(d);
	        } else {
	            if (!d3.event.active) {
	                self.model.alphaTarget(0);
	            }
	            d.fx = null;
	            d.fy = null;
	        }
	    };
	    
	    /**
	     * 点击保存按钮事件处理方法
	     */
	    var saveBtnClickHandler = function() {
	        //向外部抛出保存数据
	        self.node().dispatchEvent(EventUtil.createCustomEvent(
	           BaseEvent.EV_EVENT_DATA_STORAGE, true, true, {data:self.toJSON(true)}));
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // public Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    /**
	     * 设置传入的对象是否显示选中状态
	     * @param selected 对象是否显示选中状态
	     * @param insArray 要设置的对象数组，若不传则为图表中的所有对象(节点+连线)
	     */
	    this.setSelected = function(selected, insArray) {
	        if(insArray) {
	            for (var i = 0, len = insArray.length; i < len; i++) {
	                insArray[i].selected(selected);
	            }
	        } else {
	            var nodes = self.nodes;
	            for (var i = 0, len = nodes.length; i < len; i++) {
	                nodes[i].ins.selected(selected);
	            }
	            var links = self.links;
	            for (var i = 0, len = links.length; i < len; i++) {
	                links[i].ins.selected(selected);
	            }
	        }
	    };
	    
	    /**
	     * 将当前框选项显示选中效果
	     */
	    this.setSelectedItemsInSelectArea = function() {
	        var rect = self.editCon.mainContainer().select("rect.select");
	        var rectNode = rect.node();
	        if(rectNode) {
	        	selectedItems.length = 0;
	        	//选中区域内的所有节点
	        	var node, link, ins, insRect, source, target, isCollision, 
	        	    nodes = self.nodes, 
	        	    links = self.links, 
	        	    rect = {},
	        	    selectRect = {
	                    x:parseInt(rectNode.getAttribute("x")),
	                    y:parseInt(rectNode.getAttribute("y")),
	                    width:parseInt(rectNode.getAttribute("width")),
	                    height:parseInt(rectNode.getAttribute("height"))
	        	    };
	            for (var i = 0, len = nodes.length; i < len; i++) {
	                node = nodes[i];
	                ins = node.ins;
	                insRect = ins instanceof BaseComponent ? ins.getBBox() : ins.mainPlugin.getBBox();
	                //这样重新创建一个对象是因为ie中getBBox()返回的对象属性是只读的
	                rect.x = Math.round(node.x + insRect.x);
	                rect.y = Math.round(node.y + insRect.y);
	                rect.width = Math.round(insRect.width);
	                rect.height = Math.round(insRect.height);
	                if(math.isCollisionInTwoRects(selectRect, rect)) {
	                    ins.selected(true);
	                    selectedItems.push(node);
	                } else {
	                    ins.selected(false);
	                }
	            }
	            
	            //选中区域内的所有连线
	            var rectPath =  "M"+selectRect.x+","+selectRect.y +
	                            " L"+(selectRect.x+selectRect.width)+","+selectRect.y+
	                            " L"+(selectRect.x+selectRect.width)+","+(selectRect.y+selectRect.height)+
	                            " L"+(selectRect.x)+","+(selectRect.y+selectRect.height) + "Z";
	            for (var i = 0, len = links.length; i < len; i++) {
	                link = links[i];
	                ins = link.ins;
	                source = link.source;
	                target = link.target;
	                //矩形框选区域是否包含该连线
	            	if(math.isPointInsideBBox(source.x, source.y, selectRect) && 
	            	   math.isPointInsideBBox(target.x, target.y, selectRect)) {
	            		isCollision = true;
	            	} else {
	            		//若不包含则判断是否有交点
	            		isCollision = Raphael.isPathIntersection(ins.el.select("path").attr("d"), rectPath);
	            	}
	            	if(isCollision) {
	            		ins.selected(true);
	                    selectedItems.push(node);
	            	} else {
	            		ins.selected(false);
	            	}
	            }
	        }
	    };
	    
	    /**
	     * 移动该节点到中心位置并选中，然后突出显示节点
	     * @param arguments[0] 节点id或者节点数据对象
	     */
	    this.centerAndFocusInNode = function() {
	        if(arguments.length === 0) {
	            return;
	        }
	        var node;
	        if(ObjectUtil.isString(arguments[0])) {
	            node = self.findNode(arguments[0]);
	        } else if(ObjectUtil.isObject(arguments[0])) {
	            node = arguments[0];
	        }
	        if(!node) {
	            return;
	        }
	        //移动该节点到中心位置并选中
	        self.centerNodesAndSelected(node, true);
	        //突出显示节点
	        self.focusInNode(node);
	    };
	    
	    /**
	     * 突出显示节点
	     * @param node 要突出显示的节点数据对象
	     */
	    this.focusInNode = function(node) {
	        if(!node || !node.id) {
	            return;
	        }
	        var i, len, ins, nodeIns, linkIns, groupIns, nodeData, linkData, links, id = node.id, opacity = 0.1, 
	            nodesIns = self.nodesIns, linksIns = self.linksIns, groupsIns = self.groupsIns, insAry = [];
	        var duration = self.animation() ? 300 : 0;
	        //找到目标对象，并淡化所有节点、连线、分组的显示效果
	        for(i = 0, len = nodesIns.length; i < len; i++) {
	            nodeIns = nodesIns[i];
	            nodeIns.mainContainer().attr("opacity", opacity);
	            if(nodeIns.mainContainer().data()[0].id === id) {
	                ins = nodesIns[i];
	            }
	        }
	        for(i = 0, len = linksIns.length; i < len; i++) {
	            linkIns = linksIns[i];
	            linkIns.mainContainer().attr("opacity", opacity);
	        }
	        for(i = 0, len = groupsIns.length; i < len; i++) {
	            groupIns = groupsIns[i];
	            groupIns.mainContainer().attr("opacity", opacity);
	        }
	        //添加要突出显示的对象到数组中
	        nodeData = ins.mainContainer().data()[0];
	        insAry.push(nodeData.ins);
	        links = nodeData.links;
	        if(links) {
	            for(i = 0, len = links.length; i < len; i++) {
	                linkData = links[i];
	                insAry.push(linkData.ins);
	                if(linkData.target && linkData.target.ins) {
	                    insAry.push(linkData.target.ins);
	                }
	                if(linkData.source && linkData.source.ins) {
	                    insAry.push(linkData.source.ins);
	                }
	            }
	        }
	        //突出显示
	        for(i = 0, len = insAry.length; i < len; i++) {
	            ins = insAry[i];
	            if(ins instanceof BaseComponent) {
	                ins = ins.parent().mainContainer();
	            } else {
	                ins = d3.select(ins.el.node().parentNode);
	            }
	            ins && ins.attr("opacity", 1);
	        }
	        isInFocus = true;
	    };
	    
	    /**
	     * 取消所有节点的突出显示效果
	     */
	    this.focusOutAllNodes = function() {
	        if(!self.nodesIns || !self.linksIns) {
	            return;
	        }
	        var i, len, ins, opacity = 1, nodesIns = self.nodesIns, 
	            linksIns = self.linksIns, groupsIns = self.groupsIns;
	        for(i = 0, len = nodesIns.length; i < len; i++) {
	            ins = nodesIns[i];
	            ins.mainContainer().attr("opacity", opacity);
	        }
	        for(i = 0, len = linksIns.length; i < len; i++) {
	            ins = linksIns[i];
	            ins.mainContainer().attr("opacity", opacity);
	        }
	        for(i = 0, len = groupsIns.length; i < len; i++) {
	            ins = groupsIns[i];
	            ins.mainContainer().attr("opacity", opacity);
	        }
	        isInFocus = false;
	    };
	    
	    /**
	     * 对传入的节点居中并设置显示选中状态(选中状态根据传入参数设置)
	     * @param arguments[0] 节点数据对象数组或者单个节点数据对象
	     * @param arguments[1] 是否选中传入的节点，默认为否
	     */
	    this.centerNodesAndSelected = function() {
	        var nodes = self.nodes;
	        var isSelect = arguments.length > 1 ? arguments[1] === true : false;
	        //取消所有节点选中状态
	        var nodesIns = [];
	        for (var i = 0, len = nodes.length; i < len; i++) {
	        	nodesIns.push(nodes[i].ins);
	        }
	        self.setSelected(false, nodesIns);
	        
	        var ratio = 1, currentX = NaN, currentY = NaN;
	        if (ObjectUtil.isArray(arguments[0])) {//传入参数为数组
	            nodes = arguments[0];
	            if(nodes.length === 0) {
	            	return;
	            }
	            //计算搜索结果点外接矩形中心
	            var minX = NaN, minY = NaN, maxX = NaN, maxY = NaN,
	                leftNodeW = NaN, rightNodeW = NaN, topNodeH = NaN, bottomNodeH = NaN;
	            for (var node, nodeIns, i = 0, len = nodes.length; i < len; i++) {
	                node = nodes[i];
	                nodeIns = node.ins;
	                if(isSelect) {
	                	nodeIns.selected(true);
	                }
	                if(isNaN(minX) || node.x < minX) {
	                    minX = node.x;
	                    leftNodeW = nodeIns.actualWidth();
	                }
	                if(isNaN(minY) || node.y < minY) {
	                    minY = node.y;
	                    topNodeH = nodeIns.actualHeight();
	                }
	                if(isNaN(maxX) || node.x > maxX) {
	                    maxX = node.x;
	                    rightNodeW = nodeIns.actualWidth();
	                }
	                if(isNaN(maxY) || node.y > maxY) {
	                    maxY = node.y;
	                    bottomNodeH = nodeIns.actualHeight();
	                }
	            }
	            currentX = (maxX + minX)/2, currentY = (maxY + minY)/2;
	            //搜索结果点外接矩形是否大于图表显示范围，若是则缩小内容
	            var ratioX = 1, ratioY = 1, 
	                areaW = maxX - minX + (leftNodeW + rightNodeW) / 2, 
	                areaH = maxY - minY + (topNodeH + bottomNodeH) / 2;
	            if(areaW > self.width()) {
	            	ratioX = self.width() / areaW;
	            }
	            if(areaH > self.height()) {
	                ratioY = self.height() / areaH;
	            }
	            ratio = ratioX > ratioY ? ratioY : ratioX;
	            self.scaleX(ratio);
	            self.scaleY(ratio);
	        } else if(ObjectUtil.isObject(arguments[0])) {//传入参数为单个点
	            var node = arguments[0];
	            var nodeIns = node.ins;
	            if(isSelect) {
	            	nodeIns.selected(true);
	            }
	            currentX = node.x;
	            currentY = node.y;
	        }
	        if(isNaN(currentX) || isNaN(currentY)) {
	            return;
	        }
	        
	        //把搜索结果点外接矩形中心点移动到图 表中心位置
	        var x = self.x(), y = self.y(), 
	            moveX = self.width()/2, moveY = self.height()/2;
	        x = (moveX - currentX * self.scaleX()) * self.graph().scaleX();
	        y = (moveY - currentY * self.scaleY()) * self.graph().scaleY();
	        self.x(Math.round(x));
	        self.y(Math.round(y));
	        self.layout().model().stop();
	        var transition = d3.transition().duration(self.animation() ? 500 : 0).ease(d3.easeExpOut);
	        self.renderTransform(transition);
	    };
	    
	    // --------------------------------------------------------------------------
	    // data control
	    // --------------------------------------------------------------------------
	    
	    /**
	     * 增加一个节点 
	     * @param node 节点数据对象
	     */
	    this.addNode = function(node) {
	        self.nodes.push(node);
	    };
	
	    /**
	     * 批量增加节点 
	     * @param nodes 节点数据对象数组
	     */
	    this.addNodes = function(nodes) {
	        if (ObjectUtil.isArray(nodes)) {
	        	for(var i = 0, len = nodes.length; i < len; i++) {
	        		self.addNode(nodes[i]);
	        	}
	        }
	    };
	
	    /**
	     * 增加一条连线 
	     * @param link 连线数据对象 
	     */
	    this.addLink = function(link) {
	    	//寻找该连线起点和终点
	        link.source = self.findNode(link.source);
	        link.target = self.findNode(link.target);
	        var source = link.source, 
	            target = link.target;
	        //寻找具有相同起点和终点的连线，生成lineIndex，并把该连线添加到起点和终点对应的连线数据数组里面
	        if(!source.hasOwnProperty("links")) {
	        	source.links = [];
	        }
	        //刷新lineIndex
	        var lineIndex = self.refreshLineIndex(link);
	    	link.lineIndex = lineIndex > 0 ? lineIndex : 0;
	        source.links.push(link);
	        if(!target.hasOwnProperty("links")) {
	            target.links = [];
	        }
	        target.links.push(link);
	        self.links.push(link);
	    };
	
	    /**
	     * 批量增加连线 
	     * @param links 连线数据对象数组
	     */
	    this.addLinks = function(links) {
	        if (ObjectUtil.isArray(links)) {
	        	for(var i = 0, len = links.length; i < len; i++) {
	                self.addLink(links[i]);
	            }
	        }
	    };
	    
	    /**
	     * 删除节点 
	     * @param id 要删除的节点id
	     */
	    this.removeNode = function(id) {
	        var i = 0, n = self.findNode(id), links = self.links;
	        //删除该节点相关的连线
	        while (i < links.length) {
	            links[i]['source'] === n || links[i]['target'] === n ? links.splice(i, 1) : ++i;
	        }
	        //删除该节点
	        self.nodes.splice(self.findNodeIndex(id), 1);
	        //在所有分组中删除该节点
	        self.removeNodeFromAllGroup(n);
	    };
	    
	    /**
	     * 批量删除节点 
	     * @param ids 要删除的节点id数组
	     */
	    this.removeNodes = function(ids) {
	        if (ObjectUtil.isArray(ids)) {
	        	for(var i = 0, len = ids.length; i < len; i++) {
	        		self.removeNode(ids[i]);
	        	}
	        }
	    };
	    
	    /**
	     * 删除连线 
	     * @param link 要删除的连线数据对象
	     */
	    this.removeLink = function(link) {
	    	//删除连线自身
	        var links = self.links;
	        var index = links.indexOf(link);
	        if(index !== -1) {
	            links.splice(index, 1);
	        }
	        var source = link.source, 
	            target = link.target;
	        //删除连线起点中对应的该连线
	        self.removeLinkFromNode(source, link);
	        //删除连线终点中对应的该连线
	        self.removeLinkFromNode(target, link);
	        //刷新lineIndex
	        self.refreshLineIndex(link);
	    };
	    
	    /**
	     * 批量删除连线 
	     * @param links 要删除的连线数据对象数组
	     */
	    this.removeLinks = function(links) {
	        if (ObjectUtil.isArray(links)) {
	        	for(var i = 0, len = links.length; i < len; i++) {
	                self.removeLink(links[i]);
	            }
	        }
	    };
	    
	    /**
	     * 删除节点中对应的连线引用
	     * @param node 包含该连线引用的节点数据对象
	     * @param link 要删除的连线数据对象
	     */
	    this.removeLinkFromNode = function(node, link) {
	        if(node && node.links) {
	            links = node.links;
	            for(var l, i = 0, len = links.length; i < len; i++) {
	                l = links[i];
	                if(l === link) {
	                    links.splice(i, 1);
	                    break;
	                }
	            }
	        }
	    };
	    
	    /**
	     * 删除节点下的子节点，同时清除link信息 
	     * @param id 要删除的节点id
	     */
	    this.removeChildNodes = function(id) {
	        var   node = self.findNode(id), //要删除的节点
	              nodes = self.nodes,       //所有节点
	              link = null,
	              links = self.links,       //所有连线 
	              delateLinks = [],         //要删除的连线索引数组
	              childNodes = [];          //当前节点的所有子节点数组
	
	        //找到所有要删除的连线索引，以及当前节点的所有子节点
	        links.forEach(function(link, index) {
	            //若节点是此条连线的起点
	            if(link['source'] === node) {
	                delateLinks.push(index);
	                childNodes.push(link['target']);
	            }
	        });
	
	        //删除上面找到的所有需要删除的连线
	        delateLinks.reverse().forEach(function(index) {
	            links.splice(index, 1);
	        });
	
	        //迭代删除节点
	        var remove = function(node) {
	            var length = links.length;
	            for (var i = length - 1; i >= 0; i--) {
	                if (links[i]['source'] === node) {
	                    var target = links[i]['target'];
	                    links.splice(i, 1);
	                    nodes.splice(self.findNodeIndex(node.id), 1);
	                    remove(target);
	                }
	            }
	        };
	
	        //删除上面找到当前节点的所有子节点
	        childNodes.forEach(function(node) {
	            remove(node);
	        });
	
	        //清除没有连线的节点
	        for (var i = nodes.length - 1, len = links.length; i >= 0; i--) {
	            var isFoundNode = false;
	            node = nodes[i];
	            for (var j = 0; j < len; j++) {
	                link = links[j];
	                if(link['source'] === node || link['target'] === node) {
	                    isFoundNode = true;
	                }
	            }
	            if(!isFoundNode) {
	                nodes.splice(i, 1);
	            }
	        }
	    };
	
	    /**
	     * 查找节点
	     * @param id 要查找的节点id
	     * @return 返回查找到的节点数据对象，若没有查找到则返回null
	     */
	    this.findNode = function(id) {
	        var nodes = self.nodes;
	        for (var i = 0, len = nodes.length; i < len; i++) {
	            if (nodes[i]['id'] === id)
	                return nodes[i];
	        }
	        return null;
	    };
	
	    /**
	     * 获取LINk
	     * @param id
	     * @returns {*}
	     */
	    this.findLink = function(id) {
	        var links = self.links;
	        for (var i = 0, len = links.length; i < len; i++) {
	            if (links[i]['id'] === id)
	                return links[i];
	        }
	        return null;
	    };
	    
	    /**
	     * 查找节点数据对象所在数组的索引值
	     * @param id 要查找的节点id
	     * @return 返回查找到的节点数据对象所在数组的索引值，若没有查找到则返回-1
	     */
	    this.findNodeIndex = function(id) {
	        var nodes = self.nodes;
	        for (var i = 0, len = nodes.length; i < len; i++) {
	            if (nodes[i]['id'] === id)
	                return i;
	        }
	        return -1;
	    };
	    
	    /**
	     * 刷新变更(添加、删除)目标连线所在的两端点之间的连线的索引值
	     * @param link 变更(添加、删除)目标连线数据对象
	     * @return 返回下一个要添加的连线索引值
	     */
	    this.refreshLineIndex = function(link) {
	        var sourceLink, 
	            lineIndex = 0, 
	            source = link.source, 
	            target = link.target,
	            sourceLinks = source.links;
	        for(var i = 0, len = sourceLinks.length; i < len; i++) {
	            sourceLink = sourceLinks[i];
	            //寻找具有相同节点的连线
	            if((sourceLink.target === source || sourceLink.source === source) && 
	               (sourceLink.target === target || sourceLink.source === target)) {
	                sourceLink.lineIndex = lineIndex;
	                lineIndex++;
	                //记录变更集
	                addItemsToChangeData(sourceLink, changeData.links.update);
	            }
	        }
	        return lineIndex;
	    };
	    
	    /**
	     * 增加一个节点组
	     * @param group 节点数据对象
	     */
	    this.addGroup = function(group) {
	    	var nodes = group.nodes;
	    	//替换group中的节点id为对应的节点数据对象
	    	for (var node, i = 0, len = nodes.length; i < len; i++) {
	            node = self.findNode(nodes[i]);
	            nodes[i] = node;
	        }
	        self.groups.push(group);
	    };
	    
	    /**
	     * 批量增加节点组
	     * @param groups 节点组数据对象数组
	     */
	    this.addGroups = function(groups) {
	        if (ObjectUtil.isArray(groups)) {
	        	for(var i = 0, len = groups.length; i < len; i++) {
	                self.addGroup(groups[i]);
	            }
	        }
	    };
	    
	    /**
	     * 删除一个节点组
	     * @param group 节点数据对象
	     */
	    this.removeGroup = function(group) {
	        var groups = self.groups;
	        var index = groups.indexOf(group);
	        if(index !== -1) {
	            //删除该节点组
	            groups.splice(index, 1);
	        }
	    };
	    
	    /**
	     * 为指定的节点组中添加一个节点
	     * @param node 要删除的节点
	     * @param group 节点组
	     */
	    this.addNodeToGroup = function(node, group) {
	    	if(!group.nodes) {
	    		group.nodes = [];
	    	}
	        var groupNodes = group.nodes;
	        var index = groupNodes.indexOf(node);
	        if(index === -1) {
	            groupNodes.push(node);
	        }
	    };
	    
	    /**
	     * 从指定的节点组中删除一个节点
	     * @param node 要删除的节点
	     * @param group 节点组
	     */
	    this.removeNodeFromGroup = function(node, group) {
	        var groupNodes = group.nodes;
	        var index = groupNodes.indexOf(node);
	        if(index !== -1) {
	            groupNodes.splice(index, 1);
	            //记录变更集
	            addItemsToChangeData(group, changeData.groups.update);
	        }
	    };
	    
	    /**
	     * 从所有的节点组中删除一个节点
	     * @param node 要删除的节点
	     */
	    this.removeNodeFromAllGroup = function(node) {
	        var groups = self.groups;
	        for(var group, i = 0, len = groups.length; i < len; i++) {
	        	group = groups[i];
	        	self.removeNodeFromGroup(node, group);
	        }
	    };
	    
	    /**
	     * 找到多个节点所在的节点组列表
	     * @param arguments[0] 一个或者多个节点，一个节点直接传入，多个节点用数组包装再传入
	     * @return 返回节点组列表数组，若没有则返回空数组
	     */
	    this.findGroupsByNodes = function() {
	        if(ObjectUtil.isObject(arguments[0])) {
	            return self.findGroupsByNode(arguments[0]);
	        } 
	        if(ObjectUtil.isArray(arguments[0])) {
	            var nodes = arguments[0];
	            var result = [];
	            for(var groups, i = 0, len = nodes.length; i < len; i++) {
	                groups = self.findGroupsByNode(nodes[i]);
	                for(var group, j = 0, len1 = groups.length; j < len1; j++) {
	                    group = groups[j];
	                    if(result.indexOf(group) === -1) {
	                        result.push(group);
	                    }
	                }
	            }
	            return result;
	        }
	        return [];
	    };
	    
	    /**
	     * 找到节点所在的节点组列表
	     * @param node 节点数据对象
	     * @return 返回节点组列表数组，若没有则返回空数组
	     */
	    this.findGroupsByNode = function(node) {
	        var result = [];
	        if(!node) {
	            return result;
	        }
	        var groups = self.groups;
	        for(var group, nodes, i = 0, len = groups.length; i < len; i++) {
	            group = groups[i];
	            nodes = group.nodes;
	            if(nodes.indexOf(node) !== -1) {
	                result.push(group);
	            }
	        }
	        return result;
	    };
	    
	    /**
	     * 根据指定节点的id找到该节点的所有子孙节点
	     * @param id 指定节点的id
	     * @param isAll 是否返回所有子孙节点(无论是否展开)，默认为是，若为false，则只返回展开的子孙节点
	     * @return 返回指定节点的所有子孙节点数据对象数组，若没有找到则返回空数组
	     */
	    this.findAllChildNodes = function(id, isAll) {
	    	var nodes = [];
	    	var node = self.findNode(id);
	        if(!node) return nodes;
	        if(isAll === undefined) {
	        	isAll = true;
	        }
	        
	        //有待优化--start
	        var getNode;
	        if(isAll) {
	        	getNode = function(nodeId) {
	                self.nodes.forEach(function(node) {
	                    if(node.parentId === nodeId) {
	                        nodes.push(node);
	                        getNode(node.id);
	                    }
	                });
	            };
	            getNode(id);
	        } else {
	        	getNode = function(parentNode, isFirst) {
	        		var isExpanded = isFirst 
	            		|| parentNode.isExpanded === undefined 
	            		|| parentNode.isExpanded === true;
	                self.nodes.forEach(function(node) {
	                    if(isExpanded && node.parentId === parentNode.id) {
	                		nodes.push(node);
	                		getNode(node, false);
	                    }
	                });
	            };
	            getNode(node, true);
	        }
	        //有待优化--end
	        
	        return nodes;
	    }
	    
	    /**
	     * 设置指定节点是否可见
	     * @param nodes 要设置的指定节点对象数组
	     * @param visible 设置指定节点是否可见
	     */
	    this.setNodesVisible = function(nodes, visible) {
	        if(!nodes || nodes.length === 0) return;
	        if(visible === undefined)  {
	            visible = true;
	        }
	        for(var i = 0, len = nodes.length; i < len; i++) {
	        	nodes[i].visible = visible;
	        }
	    };
	    
	    /**
	     * 展开节点
	     * @param id 要展开的节点id
	     * @param isExpandAll 是否强制展开所有子孙节点，默认为false,
	     *                    若为false则原先合拢的子孙节点在父节点展开后保持原有状态；若为true则强制展开所有子孙节点
	     */
	    this.expandNode = function(id, isExpandAll) {
	    	var nodes = self.findAllChildNodes(id, isExpandAll === undefined ? false : isExpandAll);
	        self.setNodesVisible(nodes, true);
	    };
	    
	    /**
	     * 合拢节点
	     * @param id 要合拢的节点id
	     */
	    this.collapseNode = function(id) {
	    	var nodes = self.findAllChildNodes(id, true);
	        self.setNodesVisible(nodes, false);
	    };
	    
	    /**
	     * 展开或者合拢节点
	     * @param node 当前要展开或者合拢的节点数据对象
	     */
	    this.expandOrCollapseNode = function(node) {
	    	if(!node.enabledExpand) {
	    		return;
	    	}
	        if(node.isExpanded) {
	            self.collapseNode(node.id);
	            node.isExpanded = false;
	        } else {
	            self.expandNode(node.id, false);
	            node.isExpanded = true;
	        }
	    };
	    
	    /**
	     * 从指定的连线数据数组中获取可见的所有连线
	     * @param links 指定的连线数据数组
	     * @return 返回可见的所有连线数组，若没有满足条件的数组，则返回空数组
	     */
	    this.getVisibleLinks = function(links) {
	        var result = [];
	        if(!links || links.length === 0){
	            return result;
	        }
	        var link;
	        for (var i = 0, len = links.length; i < len; i++) {
	        	link = links[i];
	            if (link.source.visible && link.target.visible) {
	            	if(link.hasOwnProperty("visible")) {
	            		if(link.visible) {
	            			result.push(link);
	            		}
	            	} else {
	            		result.push(link);
	            	}
	            }
	        }
	        return result;
	    };
	    
	    /**
	     * 根据搜索字符串内容从节点的name属性中搜索匹配的节点，并把所有满足搜索条件的节点数据放入一个数组中
	     * @param str 搜索条件字符串
	     * @return 所有满足搜索条件的节点数据数组，若没有搜索到则返回空数组
	     */
	    this.searchNodesByName = function(str) {
	    	var result = [];
	    	if(str === undefined || str === null || str.replace(/ /g,'') === "") {
	            return result;
	        }
	        var nodes = self.nodes;
	        for (var node, i = 0, len = nodes.length; i < len; i++) {
	            node = nodes[i];
	            if(node.name.indexOf(str) > -1) {
	                result.push(node);
	            }
	        }
	        return result;
	    }
	    
	    // --------------------------------------------------------------------------
	    //
	    // edit code
	    //
	    // --------------------------------------------------------------------------
	    
	    var drawlinkIns, drawLinkData, drawLinkSource,
	        isDrawLink = false,
	        oldDragable = false,
	        selectRectX = 0, 
	        selectRectY = 0;
	        
	    var modeChangeHandler = function(evt) {
	        self.mode((evt || window.event).detail ? Topology.MODE_EDIT : Topology.MODE_NORMAL);
	        validateMode();
	    };
	    
	    /**
	     * 监听外部抛出开启和关闭编辑模式的事件
	     */
	    var openEditHandler = function(evt) {
	        self.mode((evt || window.event).detail.data === true ? Topology.MODE_EDIT : Topology.MODE_NORMAL);
	        validateMode();
	    };
	    
	    var validateMode = function() {
	    	if(!isValidateMode) {
	    		return;
	    	}
	    	isValidateMode = false;
	    	if(self.isEditMode()) {
	            self.focusOutAllNodes();
	            oldDragable = self.dragable();
	            self.dragable(false);
	            addEditContainer();
	            self.removeDragListeners();
	            self.addEventListener(BaseEvent.ADD_ITEMS, addItemsHandler);
	            self.addEventListener(BaseEvent.REMOVE_ITEMS, removeItemsHandler);
	            self.addEventListener(BaseEvent.REOMVE_ALL_SELECTED_ITEMS, removeAllSelectedItemsHandler);
	            self.parent().mainContainer().on("mousedown.edit", edit_mouseDownHandler);
	        } else {
	            isDrawLink = false;
	            self.dragable(oldDragable);
	            removeEditContainer();
	            self.removeEventListener(BaseEvent.ADD_ITEMS, addItemsHandler);
	            self.removeEventListener(BaseEvent.REMOVE_ITEMS, removeItemsHandler);
	            self.removeEventListener(BaseEvent.REOMVE_ALL_SELECTED_ITEMS, removeAllSelectedItemsHandler);
	            self.parent().mainContainer().on("mousedown.edit", null);
	            setListenersInNormal();
	        }
	    };
	    
	    var addItemsHandler = function(event) {
	        var data = event.detail; 
	        if(data.type === "node") {
	            self.addNodesInUI(data.data);
	        } else if(data.type === "link") {
	            setListenersInEditLink();
	            self.getRendererConfig(data.data, "stroke");
	            drawLinkData = data.data;
	            isDrawLink = true;
	        }
	    };
	    
	    var edit_mouseDownHandler = function() {
	    	var isAddListeners = false, 
	            target = d3.event.target;
	    	if(isDrawLink) {
	    		drawLinkSource = null;
	            var d = target.__data__;
	            if(d && d.ins) {
	                var ins = d.ins;
	                if(ins instanceof Node) {
	                	isAddListeners = true;
	                    drawLinkSource = d;
	                    drawLinkData.ins = d.ins;
	                    startDrawLink(d.x, d.y, drawLinkData);
	                }
	            }
	    	} else if(self.parent().bgRect.node() === target) {
	    		isAddListeners = true;
	    		var sp = d3.mouse(self.editCon.bgNode());
	    		createSelectRect(sp[0], sp[1]);
	    	}
	    	if(isAddListeners) {
	    		//强制光标设置为箭头，否则会出现工字型光标
	    		self.parent().mainContainer().attr("cursor", "default");
	    		d3.select(window).on("mouseup.edit", edit_mouseUpHandler);
	            d3.select(window).on("mousemove.edit", edit_mouseMoveHandler);
	    	}
	    };
	    
	    var edit_mouseMoveHandler = function() {
	    	if(isDrawLink) {
	    		var m = d3.mouse(self.bgNode());
	            drawLink(drawLinkSource.x, drawLinkSource.y, m[0], m[1]);
	    	} else {
	    		drawSelectRect();
	    		//若实时框选效率低，可将该处屏蔽
	    		self.setSelectedItemsInSelectArea();
	    	}
	    };
	    
	    var edit_mouseUpHandler = function() {
	        d3.select(window).on("mousemove.edit", null);
	        d3.select(window).on("mouseup.edit", null);
	        
	        var target = d3.event.target;
	        if(isDrawLink) {
	        	endDrawLink();
	            var d = target.__data__;
	            if(d && d.ins) {
	                var ins = d.ins;
	                if(drawLinkSource && ins instanceof Node) {
	                    drawLinkData.source = drawLinkSource.id;
	                    drawLinkData.target = d.id;
	                    self.addLinkInUI(drawLinkData);
	                }
	            }
	            
	            addNodeDragListeners();
	        } else {
	        	self.setSelectedItemsInSelectArea();
	        	removeSelectRect();
	        }
	    };
	    
	    var removeItemsHandler = function(event) {
	        
	    };
	    
	    var removeAllSelectedItemsHandler = function(event) {
	        self.removeAllSelectedInUI();
	    };
	    
	    /**
	     * 当处于编辑状态时添加编辑容器
	     */
	    var addEditContainer = function() {
	    	var editCon = new BaseComponent();
	    	editCon.className("edit-container");
	    	editCon.percentWidth(100);
	    	editCon.percentHeight(100);
	    	self.addChild(editCon);
	    	editCon.mainContainer().attr("pointer-events", "none");
	    	self.editCon = editCon;
	    };
	    
	    /**
	     * 移除编辑容器
	     */
	    var removeEditContainer = function() {
	    	if(self.editCon) {
	    		self.removeChild(self.editCon);
	    		delete self.editCon;
	    	}
	    };
	    
	    /**
	     * 创建框选矩形
	     */
	    var createSelectRect = function(x, y) {
	        if(self.editCon) {
	            var con = self.editCon.mainContainer();
	            var rect = con.select("rect.select");
	            if(rect.node() === null) {
	            	selectRectX = x;
	            	selectRectY = y;
	                con.append("rect")
	                    .attr("class", "select")
	                    .attr("x", selectRectX)
	                    .attr("y", selectRectY)
	                    .attr("stroke", "#0078d7")
	                    .attr("stroke-width", 1)
	                    .attr("fill", "#0078d7")
	                    .attr("fill-opacity", 0.1);
	            }
	        }
	    };
	    
	    /**
	     * 绘制框选矩形
	     */
	    var drawSelectRect = function() {
	        if(self.editCon) {
	            var con = self.editCon.mainContainer();
	            var rect = con.select("rect.select");
	            if(rect.node()) {
	                var sx, sy, mp = MouseUtil.mouse(self.mainContainer().node(), self.graph());//d3.mouse(con.node());
	                if(mp[0] < selectRectX) {
	                    w = selectRectX - mp[0];
	                    sx = mp[0];
	                } else {
	                    w = mp[0] - selectRectX;
	                    sx = selectRectX;
	                }
	                if(mp[1] < selectRectY) {
	                    h = selectRectY - mp[1];
	                    sy = mp[1];
	                } else {
	                    h = mp[1] - selectRectY;
	                    sy = selectRectY;
	                }
	                rect.attr("x", Math.round(sx)).attr("y", Math.round(sy))
	                    .attr("width", Math.round(w)).attr("height", Math.round(h));
	            }
	        }
	    };
	    
	     /**
	     * 移除框选矩形
	     */
	    var removeSelectRect = function() {
	        if(self.editCon) {
	        	self.editCon.mainContainer().select("rect.select").remove();
	        }
	    };
	    
	    /**
	     * 准备开始画连线
	     * @param x1, y1 起点坐标
	     * @param d 连线数据对象
	     */
	    var startDrawLink = function(x1, y1, d) {
	        if(!isDrawLink) {
	            return;
	        }
	        d.source = {x:x1, y:y1, ins:d.ins};
	        d.target = {x:x1+1, y:y1+1, ins:d.ins};
	        var rendererConfig;
	        //获取节点渲染器配置
	        if(d.renderer) {
	            rendererConfig = self.data().renderers[d.renderer];
	        }
	        drawlinkIns = ClassFactory.newLinkInstance(rendererConfig.clazz, [self.linksContainer.mainContainer(), d]);
	        drawlinkIns.config(rendererConfig.config)
	        drawlinkIns.render();
	    };
	    
	    /**
	     * 画连线
	     * @param x1, y1 起点坐标
	     * @param x2, y2 终点坐标
	     */
	    var drawLink = function(x1, y1, x2, y2) {
	        if(isDrawLink && drawlinkIns) {
	            var d = drawlinkIns.itemData();
	            d.source.x = x1;
	            d.source.y = y1;
	            d.target.x = x2;
	            d.target.y = y2;
	            drawlinkIns.update();
	        }
	    };
	    
	    /**
	     * 结束画连线
	     */
	    var endDrawLink = function() {
	        if(!isDrawLink) {
	            return;
	        }
	        if(drawlinkIns) {
	            drawlinkIns.el.remove();
	            drawlinkIns = null;
	        }
	        isDrawLink = false;
	    };
	
	    /**
	     * 增加一个节点界面操作
	     * @param node 节点数据对象
	     */
	    this.addNodeInUI = function(node) {
	    	self.addNode(node);
	        self.update(true);
	    };
	
	    /**
	     * 批量增加节点界面操作 
	     * @param nodes 节点数据对象数组
	     */
	    this.addNodesInUI = function(nodes) {
	        self.addNodes(nodes);
	        self.update(true);
	    };
	
	    /**
	     * 增加一条连线界面操作
	     * @param link 连线数据对象 
	     */
	    this.addLinkInUI = function(link) {
	    	self.addLink(link);
	        self.update(true);
	    };
	
	    /**
	     * 批量增加连线界面操作
	     * @param links 连线数据对象数组
	     */
	    this.addLinksInUI = function(links) {
	        self.addLinks(links);
	        self.update(true);
	    };
	
	    /**
	     * 删除节点界面操作 
	     * @param id 要删除的节点id
	     */
	    this.removeNodeInUI = function(id) {
	        self.removeNode(id);
	        self.update(true);
	    };
	    
	    /**
	     * 批量删除节点界面操作 
	     * @param ids 要删除的节点id数组
	     */
	    this.removeNodesInUI = function(ids) {
	        self.removeNodes(ids);
	        self.update(true);
	    };
	    
	    /**
	     * 删除连线界面操作 
	     * @param link 要删除的连线数据对象
	     */
	    this.removeLinkInUI = function(link) {
	        self.removeLink(link);
	        self.update(true);
	    };
	    
	    /**
	     * 批量删除连线界面操作 
	     * @param links 要删除的连线数据对象数组
	     */
	    this.removeLinksInUI = function(links) {
	        if(!links || !links.length) {
	            return;
	        }
	        self.removeLinks(links);
	        self.update(true);
	    };
	    
	    /**
	     * 批量删除选中节点和连线界面操作 
	     */
	    this.removeAllSelectedInUI = function() {
	    	var plugin, links = [], nodeIds = [];
	    	self.nodesIns.forEach(function(ins) {
	            plugin = ins.normalChild();
	            if(plugin && plugin.selected()){
	                nodeIds.push(plugin.el.data()[0].id);
	            }
	        });
	    	self.linksIns.forEach(function(ins) {
	    		plugin = ins.normalChild();
	            if(plugin && plugin.selected()){
	            	links.push(plugin.el.data()[0]);
	            }
	        });
	        self.removeNodes(nodeIds);
	        self.removeLinks(links);
	        self.update(true);
	    };
	    
	    /**
	     * 删除节点下的子节点，同时清除link信息界面操作 
	     * @param id 要删除的节点id
	     */
	    this.removeChildNodesInUI = function(id) {
	        self.removeChildNodes(id);
	        self.update(true);
	    };
	    
	    /**
	     * 展开节点界面操作
	     * @param id 要展开的节点id
	     * @param isExpandAll 是否强制展开所有子孙节点，默认为false,
	     *                    若为false则原先合拢的子孙节点在父节点展开后保持原有状态；若为true则强制展开所有子孙节点
	     */
	    this.expandNodeInUI = function(id, isExpandAll) {
	        self.expandNode(id, isExpandAll);
	        self.update(true);
	    };
	    
	    /**
	     * 合拢节点界面操作
	     * @param id 要合拢的节点id
	     */
	    this.collapseNodeInUI = function(id) {
	        self.collapseNode(id);
	        self.update(true);
	    };
	    
	    /**
	     * 展开或者合拢节点界面操作
	     * @param node 当前要展开或者合拢的节点数据对象
	     */
	    this.expandOrCollapseNodeInUI = function(node) {
	    	if(!node.enabledExpand) {
	            return;
	        }
	        self.expandOrCollapseNode(node);
	        self.update(true);
	    };
	    
	    // --------------------------------------------------------------------------
	    // change data control
	    // --------------------------------------------------------------------------
	    
	    /**
	     * 清空变更集数据
	     */
	    var clearChangeData = function() {
	        changeData.nodes.enter = {};
	        changeData.nodes.update = {};
	        changeData.links.enter = {};
	        changeData.links.update = {};
	        changeData.groups.enter = {};
	        changeData.groups.update = {};
	    };
	    
	    /**
	     * 添加数据到变更集
	     * @param arguments[0] 变更数据
	     * @param arguments[1] 目标源对象
	     */
	    var addItemsToChangeData = function() {
	    	if(arguments.length < 2) {
	    		return false;
	    	}
	        var source = arguments[1];
	        if(!ObjectUtil.isObject(source)) {
	            return;
	        }
	        if(ObjectUtil.isArray(arguments[0])) {
	            var items = arguments[0];
	            for(var item, i = 0, len = items.length; i < len; i++) {
	                item = items[i];
	                source[self.bindKeyFn(item)] = item;
	            }
	        } else {
	            var item = arguments[0];
	            source[self.bindKeyFn(item)] = item;
	        }
	    };
	    
	    /**
	     * 数据是否在变更集中
	     * @param arguments[0] 带检测项数据对象
	     * @param arguments[1] 目标源对象
	     * @return 返回检测结果
	     */
	    var isItemInChangeData = function() {
	    	if(arguments.length < 2) {
	    		return false;
	    	}
	        var source = arguments[1];
	        if(!ObjectUtil.isObject(source)) {
	            return false;
	        }
	        return source.hasOwnProperty(self.bindKeyFn(arguments[0]));
	    };
	    
	    /**
	     * 触发鹰眼变更
	     */
	    function fireContentChange(){
	        self.mainContainer().node().dispatchEvent(EventUtil.createEvent(BaseEvent.CONTENT_CHANGE,true,true));
	    }
	    
	    Topology.clazzName = "Topology";
	    
	    // 初始化
	    this.init();
	};
	
	Topology.struct = function(ghca_charts) {
		var BaseChart = ghca_charts.view.component.charts.baseChart;
		BaseChart.struct(ghca_charts);
	    Topology.prototype = Object.create(BaseChart.prototype);
	    Topology.prototype.constructor = Topology;
	};
	
	// --------------------------------------------------------------------------
	//
	// Const
	//
	// --------------------------------------------------------------------------
	
	//显示所有节点
	Topology.SHOW_ALL_LEVEL_NODES = 99999;
	
	//显示第一层级所有节点
	Topology.SHOW_FIRST_LEVEL_NODES = 0;
	
	//模式常量
	Topology.MODE_NORMAL 	= "normal";
	Topology.MODE_EDIT 		= "edit";
	
	module.exports = Topology;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {var Tree = function(_ele,_data, _layout) {
		
		// --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
		const BaseComponent = ghca_charts.view.component.baseComponent;
	    const BaseChart    = ghca_charts.view.component.charts.baseChart;
	    const ClassFactory = ghca_charts.view.util.classFactory;
	    const Constant     = ghca_charts.view.util.constant;
	    const EventUtil = ghca_charts.view.util.eventUtil;
	    const BaseEvent =  ghca_charts.events.BaseEvent;
	    const ObjectUtil =  ghca_charts.view.util.objectUtil;
	    const DataParser = ghca_charts.view.util.dataParser;
	
	    BaseChart.apply(this, arguments);
	
	    var self = this,
	        superZoomHandler = self.zoomHandler,
	        superResize = self.resize,
	        superInit = self.init,
	        superInitAllContainers = self.initAllContainers,
	        superAddListeners = self.addListeners;
	    self.className("tree");
	    //开始拖动节点
	    var startDrag = false;
	    //拖动中的节点
	    var draggingNode = null;
	    //目标节点
	    var targetNode = null;
	
	    var self = this;
	
	    //保存节点实例数据 id:ins
	    var nodeInsMap = d3.map();
	    this.nodeInsMap = function(){
	        return nodeInsMap;
	    }
	    //保存连线实例数据 id:ins
	    var linkInsMap = d3.map();
	    this.linkInsMap = function(){
	        return linkInsMap;
	    }
	    
	    //use start  //////////////////////
	    //默认排序
	    var sort = function(a,b){
	        return b.data.name.localeCompare(a.data.name);
	    };
	
	    /**
	     * 设置排序方式
	     * @param func
	     */
	    this.sort = function(func){
	        if(arguments.length){
	            sort = func;
	        }
	    }
	
	    /**
	     * 设置拖动位置
	     * @param elem 目标元素
	     * @param x x
	     * @param y y
	     */
	    this.setDragPosition = function(ele,d){
	        ele.attr("transform", "translate(" + [d.x, d.y] + ")");
	        var children = d.children;
	        var linkIns = self.linkInsMap().get(d.data[self.idKey()]);
	        if(linkIns)linkIns.render();
	        if(children){
	            children.forEach(function (child){
	                linkIns = self.linkInsMap().get(child.data[self.idKey()]);
	                if(linkIns)linkIns.render();
	            });
	        }
	        setTimeout(self.fireContentChange,100);
	    }
	
	    /**
	     * 节点开始拖动
	     */
	    this.node_dragStartHandler = function(d) {
	        d.x0 = d.x;
	        d.y0 = d.y;
	        startDrag = true;
	        d3.event.sourceEvent.stopPropagation();
	    };
	
	    /**
	     * 节点拖动中
	     */
	    this.node_dragHandler = function(d) {
	        // if(!d.parent)return;
	        if(!self.editable()){
	            return;
	        }
	        if(startDrag){
	            draggingNode = d;
	            if(draggingNode){
	                //暂时注释，会出现图层闪动
	             /*   self.nodesContainer.mainContainer().selectAll("g.tree-nodeContainer").sort(function(a, b) { // select the parent and sort the path's
	                    if (a.id != draggingNode.id) return 1; // a is not the hovered element, send "a" to the back
	                    else return -1; // a is the hovered element, bring "a" to the front
	                });*/
	                d.x = d3.event.x,d.y= d3.event.y;
	                d.data.x = d.x,d.data.y= d.y;
	                self.setDragPosition(d3.select(this),d);
	            }
	        }
	    };
	    /**
	     * 内容变更事件
	     */
	    this.fireContentChange = function(){
	        self.mainContainer().node().dispatchEvent(EventUtil.createEvent(BaseEvent.CONTENT_CHANGE,true,true));
	    }
	    /**
	     * 节点结束拖动
	     */
	    this.node_dragEndHandler = function(d) {
	        if(self.editable())
	            if (d.parent && draggingNode && targetNode && targetNode!=draggingNode && draggingNode.parent!=targetNode) {
	                draggingNode.data[self.parentKey()] = targetNode.data[self.idKey()];
	                self.update();
	            }else{
	                if(draggingNode) {
	                    d.x = d.x0,d.y=d.y0;
	                    self.setDragPosition(d3.select(this),d);
	                }
	            }
	        draggingNode = null;
	        startDrag = false;
	    };
	
	    var editable = false;
	    this.editable = function(value){
	        if(!arguments.length)return editable;
	        editable = value;
	        return this;
	    }
	    /**
	     * 节点唯一主键
	     * @type {string}
	     */
	    var idKey = "id";
	    this.idKey = function(value){
	        if(!arguments.length)return idKey;
	        idKey = value;
	        return this;
	    }
	    /**
	     * 节点唯一父主键
	     * @type {string}
	     */
	    var parentKey = "parentId";
	    this.parentKey = function(value){
	        if(!arguments.length)return parentKey;
	        parentKey = value;
	        return this;
	    }
	
	    /**
	     * 显示更多操作
	     * @type {Array}
	     */
	    var more = [];
	    this.more = function(value){
	        if(!arguments.length)return more;
	        if(value)
	            more = value;
	        return this;
	    }
	
	    /**
	     * 手动操作缩放
	     * @type {Array}
	     */
	    var useScale = true;
	    this.useScale = function(value){
	        if(!arguments.length)return useScale;
	        useScale = value;
	        return this;
	    }
	    //use end  //////////////////////
	
	    
	    //override start
	
	    /**
	     * 初始化方法
	     */
	    this.init = function(ele) {
	        superInit(ele);
	        var data = self.data();
	        self.idKey(data["idField"]);
	        self.parentKey(data["parentField"]);
	        self.editable(data["editable"]);
	        self.more(data["more"]);
	        // self.autoLayout(data["autoLayout"]);
	    };
	
	    /**
	     * 初始化图表包含的各个层级
	     */
	    this.initAllContainers = function() {
	        superInitAllContainers();
	        self.treeContainer =  self.mainContainer().append("g").attr("class", "tree-Container");
	        //放置所有连线的g元素
	        self.linksContainer = self.treeContainer.append("g").attr("class", "tree-linksContainer");
	        //放置所有节点的g元素
	//        self.nodesContainer = self.treeContainer.append("g").attr("class", "tree-nodesContainer");
	        
	        var nodesContainer = new BaseComponent();
	        nodesContainer.className("tree-nodesContainer");
	        nodesContainer.isTransform(false);
	        self.addChild(nodesContainer);
	        self.nodesContainer = nodesContainer;
	    };
	
	    /**
	     * 初始化添加所有监听的方法
	     */
	    this.addListeners = function() {
	        superAddListeners();
	        self.mainContainer().node().addEventListener("expandTool_collapsed",function(e){
	            event.stopImmediatePropagation();
	            var detail = e.detail;
	            detail.data.collapsed = detail.collapsed;
	            detail.data.more = true;
	            self.update();
	        });
	        self.mainContainer().node().addEventListener("moreTool_expand",function(e){
	            event.stopImmediatePropagation();
	            var detail = e.detail;
	            detail.data.moretool = false;
	            detail.parent.data.more = false;
	            self.update();
	        });
	        self.mainContainer().node().addEventListener(BaseEvent.EAGLE_EYE_DRAG,function(e){
	            event.stopImmediatePropagation();
	            var detail = e.detail;
	            self.x(detail.x);
	            self.y(detail.y);
	            self.renderTransform();
	            //IE 2013
	            self.linkInsMap().each(function(d){
	                d.render();
	            })
	        });
	    };
	
	    this.createLinkIns = function(target,d){
	        var ins = self.linkInsMap().get(d.data[self.idKey()]);
	        var rendererConfig;
	        //获取节点渲染器配置
	        if(d.data.edgeRenderer) {
	            rendererConfig = self.data().renderers[d.data.edgeRenderer];
	        }
	        if(!ins){
	            ins = ClassFactory.newLinkInstance(rendererConfig.clazz, [target, d]);
	            ins.config(rendererConfig.config);
	            // Concurrent.Thread.create(function(){
	            //      arguments[0].render();
	            // },ins);
	            // ins.render();
	            self.linkInsMap().set(d.data[self.idKey()],ins);
	        }else{
	            ins.data(d);
	            // ins.render();
	        }
	    }
	
	    this.createNodeIns = function(target,d){
	        // var d = node.data;
	        var ins = self.nodeInsMap().get(d.data[self.idKey()]);
	        // self.setNodeData(d);
	        if(!ins){
	            var rendererConfig;
	            //获取节点渲染器配置
	            if(d.data.nodeRenderer) {
	                rendererConfig = self.data().renderers[d.data.nodeRenderer];
	            }
	            if(rendererConfig && rendererConfig.type === "chart" && rendererConfig.series) {
	            	//若节点渲染器是一个组件，则重新设置一些配置数据
	                var nodeData = d.data;
	                rendererConfig = self.getRendererConfig(nodeData, "fill", "nodeRenderer");
	                if(rendererConfig && rendererConfig.type === "chart" && rendererConfig.series) {
	                    var chartData, series = rendererConfig.series;
	                    for(var j = 0, len1 = series.length; j < len1; j++) {
	                        chartData = series[j];
	                        //这里config设置的width和height值无效，渲染器组件宽高为线的高度值
	                        chartData.width = rendererConfig.width ? rendererConfig.width : 0;
	                        chartData.height = rendererConfig.height ? rendererConfig.height : 0;
	                        //pie的位置特殊处理
	                        if(chartData.type === "pie") {
	                            rendererConfig.x = -chartData.width / 2;
	                            rendererConfig.y = -chartData.height / 2;
	                        }
	                        //组装图表数据
	                        DataParser.createChartData(chartData, nodeData);
	                        if(d.hasOwnProperty("children"))
	                            nodeData.children = d.children;
	                    }
	                }
	                //渲染节点内容
	                ins = ClassFactory.newRenderersInstanceByData(d.nodeContainer, self, "tree-node", [nodeData])[0];
	            } else {
	            	//节点为plugin
	            	ins = ClassFactory.newNodeInstance(rendererConfig.clazz, [target, d]);
	                ins.config(rendererConfig.config);
	            }
	        	
	            if(ins.hasOwnProperty("ownerData")) {
	                ins.ownerData(self.data());
	            }
	            
	            // Concurrent.Thread.create(function(){
	            //     arguments[0].render();
	            // },ins);
	            // ins.render();
	            // ins.addEventListener("collapsed",function(e){
	            //     self.collapsed(e);
	            //     self.fireContentChange();
	            // });
	            self.nodeInsMap().set(d.data[self.idKey()],ins);
	        }else{
	        	if(ins instanceof BaseComponent) {
	//        		ins.update(d);
	        	} else {
	        		ins.data(d);
	        	}
	        }
	        d.ins = ins;
	        d.data.legendIns = ins;
	    }
	    /**
	     * 更新位置
	     */
	    this.updatePosition = function(){
	        var nodeSelections = self.nodesContainer.mainContainer().selectAll("g.tree-nodeContainer");
	        nodeSelections.transition()//这里有延时函数 可能会导致事件绑定过晚问题
	            .duration(function(d){
	                return d.depth*80;
	            })
	            .attr("transform",function(d){
	                return "translate(" + [d.x,d.y]  + ")";
	            }).on("start",function(d){                
	            var nodeIns = self.nodeInsMap().get(d.data[self.idKey()]);
	            if(nodeIns){
	                nodeIns.render();
	            }
	        }).on("end",function(d){
	            var linkIns = self.linkInsMap().get(d.data[self.idKey()]);
	            if(linkIns){
	                linkIns.render();
	            }
	        });
	        setTimeout(self.autoScaleHandler,800);
	    }
	
	    this.centerNodesAndSelected=function(id){
	        var nodes = self.nodeInsMap().values();
	        var node=null;
	        for(var i=0;i<nodes.length;i++){
	            if(nodes[i].data().id===id){
	                node=nodes[i];
	                break;
	            }
	        }
	        if(!node){
	            return;
	        }
	        var isSelect = arguments.length > 1 ? arguments[1] === true : false;
	        //取消所有节点选中状态
	        var nodesIns = nodes;
	    
	        self.setSelected(false, nodesIns);
	        
	        var currentX = NaN,
	            currentY = NaN;
	
	        var nodeIns = node;
	        if (isSelect) {
	            nodeIns.selected(true);
	        }
	        currentX = node.data().x;
	        currentY = node.data().y;
	     
	        if(isNaN(currentX) || isNaN(currentY)) {
	            return;
	        }
	        
	        //把搜索结果点外接矩形中心点移动到图 表中心位置
	        var x = self.x(), y = self.y(), 
	            moveX = self.width()/2, moveY = self.height()/2;
	        x = (moveX - currentX * self.scaleX()) * self.graph().scaleX();
	        y = (moveY - currentY * self.scaleY()) * self.graph().scaleY();
	        self.x(Math.round(x));
	        self.y(Math.round(y));
	        // self.layout().model().stop();
	        var transition = d3.transition().duration(self.animation() ? 500 : 0).ease(d3.easeExpOut);
	        self.renderTransform(transition);
	    }
	
	        /**
	     * 设置传入的对象是否显示选中状态
	     * @param selected 对象是否显示选中状态
	     * @param insArray 要设置的对象数组，若不传则为图表中的所有对象(节点+连线)
	     */
	    this.setSelected = function(selected, insArray) {
	        if(insArray) {
	            for (var i = 0, len = insArray.length; i < len; i++) {
	                insArray[i].selected(selected);
	            }
	        } else {
	            var nodes = self.nodeInsMap().values();
	            for (var i = 0, len = nodes.length; i < len; i++) {
	                nodes[i].selected(selected);
	            }
	        }
	    };
	
	    this.autoScaleHandler = function(){
	        if( self.useScale()){
	            setTimeout(self.fireContentChange,100);
	            return;
	        }
	        var node = self.mainContainer().node();
	
	        var rect = node.getBBox();
	        var targetWidth = rect.width,//边距
	            targetHeight = rect.height,//边距
	            width = self.width(),
	            height = self.height(),
	            x = 0;
	
	        var scale = width/targetWidth<height/targetHeight? width/targetWidth: height/targetHeight;
	
	        if(scale<1){
	            if(width>targetWidth*scale)x=(width-targetWidth*scale)/2;
	            self.scaleX(scale);
	            self.scaleY(scale);
	            self.x(x+Math.abs(rect.x*scale));
	            self.y((height-targetHeight*scale)/2+rect.y*scale);
	        }
	
	        self.renderTransform("position");
	
	        //IE 2013
	        self.linkInsMap().each(function(d){
	            d.render();
	        })
	        setTimeout(self.fireContentChange,100);
	    }
	    
	    this.updateView = function(){
	        var root = self.layout().treeRootNode();
	        var nodeDatas = self.nodesContainer.mainContainer().selectAll("g.tree-nodeContainer")
	            .data(root.descendants(),function(d){
	                return d.data[self.idKey()];
	            });
	        //删除实例映射
	        nodeDatas.exit().each(function(node){
	            self.nodeInsMap().remove(node.data[self.idKey()]);
	        });
	        nodeDatas.exit().remove();
	        nodeDatas.enter()
	            .each(function(d) {
	            	//这样写是为了可以插入子组件到渲染器中，图表子组件的父容器必须是baseComponent组件
	                var nodeContainer = new BaseComponent();
	                nodeContainer.className("tree-nodeContainer");
	                nodeContainer.isTransform(false);
	                self.nodesContainer.addChild(nodeContainer);
	                d.nodeContainer = nodeContainer;
	                nodeContainer.mainContainer()
	                    .data([d])
	                    .on("mouseover", function(d) {
	                        targetNode = d;
	                    })
	                    .on("mouseout", function() {
	                        targetNode = null;
	                    })
	                    .call(d3.drag()
	                        .on("start", self.node_dragStartHandler)
	                        .on("drag", self.node_dragHandler)
	                        .on("end", self.node_dragEndHandler));
	                });
	
	        var nodeSelections = self.nodesContainer.mainContainer().selectAll("g.tree-nodeContainer");
	        nodeSelections.each(function(d){
	            self.createNodeIns(d3.select(this),d);
	        });
	
	        var linkDatas = self.linksContainer.selectAll("g.tree-linkContainer")
	            .data(root.descendants().slice(1),function(d){return d.data[self.idKey()]});
	        linkDatas.exit().each(function(node){
	            self.linkInsMap().remove(node.data[self.idKey()]);
	        });
	        linkDatas.exit().remove();
	        linkDatas.enter().append("g")
	            .attr("class", "tree-linkContainer");
	
	        var linkSelections = self.linksContainer.selectAll("g.tree-linkContainer");
	        linkSelections.each(function(d){
	            self.createLinkIns(d3.select(this),d);
	        });
	        var callback = function(){
	            var self = arguments[0];
	            self.updatePosition();
	        }
	        if(Window.Concurrent)Concurrent.Thread.create(callback,self)
	        else callback(self);
	    }
	
	    this.zoomHandler = function(){
	        self.useScale(true);
	        superZoomHandler();
	    }
	
	    this.resize = function(){
	        self.useScale(false);
	        superResize();
	    }
	    /**
	     * 根据当前数据重新渲染内容，并重新计算布局内容
	     */
	    this.update = function() {
	    	if(!self.data() ||　!ObjectUtil.isArray(self.data().nodes) || self.data().nodes.length === 0) {
	    		return;
	    	}
	        self.layout().size([self.width(), self.height()/2]);
	        if(self.data().nodeSize){
	            self.layout().nodeSize(self.data().nodeSize);
	        }
	
	        var root = d3.stratify().id(function(d){
	            return d[idKey];
	        }).parentId(function(d){
	            return d[parentKey];
	        })(self.data().nodes);
	
	        root.sort(self.sort());
	
	        //删除不可见及不展开元素
	        root.descendants().forEach(function(node){
	            var data = node.data;
	            if(data["visible"] === false){
	                var parent = node.parent,children = parent?parent.children:undefined;
	                if(children)
	                    children.splice(children.indexOf(node),1);
	            }
	            if(data["collapsed"] === true){
	                node.children? node.children= undefined: delete node.children;
	            }
	            var more = self.more();
	            var length = more.length;
	            if(length>0 && node.depth<length && node.data.more!==false){
	                var count = more[node.depth],
	                children = node.children?node.children:[];
	                if(children.length>count){
	                    var v = count-1;//超出范围，这显示数量-1个加more
	                    children.splice(v-1,children.length-v);
	                    children[children.length-1].data.moretool = true;
	                }
	            }
	        });
	
	        self.layout().treeRootNode(root);
	
	        var callback = function(){
	            var self = arguments[0];
	            //布局
	            self.layout().update();
	
	            self.updateView();
	        }
	        if(Window.Concurrent)Concurrent.Thread.create(callback,self)
	        else callback(self);
	    };
	
	    Tree.clazzName = "Tree";
	    
	    // 初始化
	    this.init(_ele);
	};
	
	Tree.struct = function(ghca_charts) {
		var BaseChart = ghca_charts.view.component.charts.baseChart;
		BaseChart.struct(ghca_charts);
	    Tree.prototype = Object.create(BaseChart.prototype);
	    Tree.prototype.constructor = Tree;
	};
	
	module.exports = Tree;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {// treemap类
	    
	/**
	 * 构造方法 
	 * @param _data treemap配置数据
	 * @param _layout treemap布局对象，不传就为默认布局
	 */
	var Treemap = function(_data, _layout) {
		
	    // --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const BaseComponent = ghca_charts.view.component.baseComponent;
	    const BaseChart = ghca_charts.view.component.charts.baseChart;
	    const ClassFactory = ghca_charts.view.util.classFactory;
	    const ObjectUtil =  ghca_charts.view.util.objectUtil;
	
	    BaseChart.apply(this, arguments);
	    
	    var node,
	        self = this,
	        isInit = true,
	        superInit = self.init,
	        superInitAllContainers = self.initAllContainers,
	        superAddListeners = self.addListeners,
	        superRenderPosition = self.renderPosition,
	        superRefreshData = self.refreshData,
	        xScale = d3.scaleLinear(),
	        yScale = d3.scaleLinear();
	    
	    self.className("seriesTreemap");
	    //添加可从配置文件读取的属性名称
	//    self.addAttributes("attribute");
	
	    // --------------------------------------------------------------------------
	    //
	    // Attributes
	    //
	    // --------------------------------------------------------------------------
	
	    // ------------------------------
	    // nodeInsMap
	    // ------------------------------
	    
	    /**
	     * 节点实例map
	     */
	    var nodeInsMap = d3.map();
	    this.nodeInsMap = function(){
	        return nodeInsMap;
	    }
	    
	    // --------------------------------------------------------------------------
	    //
	    // override Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    /**
	     * 初始化方法
	     */
	    this.init = function() {
	        superInit();
	        
	        var items = self.data().data;
	        self.visibleItems(items);
	        self.itemsIns = [];
	    };
	    
	    /**
	     * 初始化图表包含的各个层级
	     */
	    this.initAllContainers = function() {
	        superInitAllContainers();
	        //放置所有项的g元素
	        if(!self.itemsContainer) {
	        	var itemsContainer = new BaseComponent();
	            itemsContainer.className("treemap-ItemsContainer");
	            var size = self.layout().size();
	            itemsContainer.width(size[0]);
	            itemsContainer.height(size[1]);
	            self.addChild(itemsContainer);
	            itemsContainer.bgRect.attr("id",  "treemap-bg-" + itemsContainer.id());
	            self.itemsContainer = itemsContainer;
	        }
	    };
	    
	    /**
	     * 初始化添加所有监听的方法
	     */
	    this.addListeners = function() {
	        superAddListeners();
	    };
	    
	    /**
	     * 刷新数据内容，生成需要的属性和相关值
	     */
	   this.refreshData = function() {
	        superRefreshData();
	        //生成visible属性，默认值为true
	        var items = self.data().data;
	        for(var item, i = 0, len = items.length; i < len; i++) {
	            item = items[i];
	            if(!item.hasOwnProperty("visible")) {
	                item.visible = true;
	            }
	        }
	    };
	    
	    /**
	     * 渲染图表内容相关位置 
	     */
	    this.renderPosition = function() {
	    	superRenderPosition();
	    	
	    	var itemsContainer = self.itemsContainer;
	        if(itemsContainer) {
	        	var size = self.layout().size();
	        	//内容居中
	            itemsContainer.x((self.width() - size[0]) / 2);
	            itemsContainer.y((self.height() - size[1]) / 2);
	            //刷新容器尺寸
	            itemsContainer.width(size[0]);
	            itemsContainer.height(size[1]);
	            itemsContainer.renderTransform();
	        }
	    };
	    
	    /**
	     * 根据当前数据重新渲染内容，并重新计算布局内容
	     */
	    this.update = function() {
	    	if(!self.data() ||　!ObjectUtil.isArray(self.data().data) || self.data().data.length === 0) {
	            return;
	        }
	    	self.refreshData();
	    	//只用当前可见的项作为渲染数据源
	        var items = self.data().data;
	        self.visibleItems(self.filterArrayByElementProperty(items, "visible", true));
	        
	        //计算布局，获取项数据数组
	        self.layout().update();
	        var leaves = self.layout().leaves();
	        node = self.layout().root();
	        
	    	//添加遮罩
	        var itemsContainer = self.itemsContainer;
	    	var itemsCon = itemsContainer.mainContainer();
	    	var bgId = itemsContainer.bgRect.attr("id");
	    	itemsCon
	    	   .append("clipPath").attr("id", function(d) {
	                return "treemap-clip-" + bgId;
	            })
	            .append("use").attr("xlink:href", function(d) {
	                return "#" + bgId;
	            });
	        itemsCon.attr("clip-path", function(d) {
	            return "url(#treemap-clip-" + bgId + ")";
	        });
	    	
	    	//render items
	        var treemapItemsUpdate = itemsCon.selectAll("g.treemap-item")
	            .data(leaves, function(d) {
	                return d.data[self.layout().stratifyId()];
	            });
	        //update
	        treemapItemsUpdate.
	            transition().duration(self.animation() ? 500 : 0)
	            .attr("transform", function(d) {
	                return "translate(" + d.x0 + "," + d.y0 + ")";
	            });
	        treemapItemsUpdate.each(function(d){
	            var ins = self.nodeInsMap().get(d.data["path"]);
	            if(ins) {
	            	//根据配置刷新数据内容
	                self.getRendererConfig(d.data, "fill");
	                ins.update(d);
	            }
	        });
	        //add
	        var treemapItemsEnter = treemapItemsUpdate.enter().append("g").attr("class", "treemap-item")
	            .attr("transform", function(d) {
	                return "translate(" + d.x0 + "," + d.y0 + ")";
	            })
	            .on("click", cellClickHandler);
	        treemapItemsEnter.each(function(d){
	        	var rendererConfig = self.getRendererConfig(d.data, "fill");
	            var clazz = (rendererConfig && rendererConfig.clazz) ? rendererConfig.clazz : "treemapNode";
	            var nodeIns = ClassFactory.newNodeInstance(clazz, [d3.select(this), d]);
	            nodeIns.isChartFirstInit(isInit);
	            nodeIns.render();
	            self.nodeInsMap().set(d.data["path"], nodeIns);
	            d.data.legendIns = nodeIns;
	        });
	        //delete
	        var treemapItemsExit = treemapItemsUpdate.exit();
	        treemapItemsExit.each(function(d){
	            self.nodeInsMap().remove(d.data[self.layout().stratifyId()]);
	        });
	        treemapItemsExit.remove();
	        
	        self.renderPosition();
	        isInit = false;
	    };
	    
	    /**
		 * override toString方法，用于打印本对象的一些基本信息
		 */
	    this.toString = function() {
	        return ("Treemap info: "   +
	                "\n   width:"     + self.width()      + 
	                "\n   height:"    + self.height()     + 
	                "\n   layout:"    + self.layout()     + 
	                "\n   data:"      + JSON.stringify(self.data(), null, 4));
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // listeners
	    //
	    // --------------------------------------------------------------------------
	    
	    var cellClickHandler = function(d) { 
	        return zoomCell(node == d.parent ? self.layout().root() : d.parent); 
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // private Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    var zoomCell = function(d) {
	    	var x = d.x0;
	    	var y = d.y0;
	    	var dx = d.x1 - d.x0;
	    	var dy = d.y1 - d.y0;
	    	var size = self.layout().size();
	        var kx = size[0] / dx, ky = size[1] / dy;
	        xScale.range([0, size[0]]);
	        yScale.range([0, size[1]]);
	        xScale.domain([x, x + dx]);
	        yScale.domain([y, y + dy]);
	
	        var t = self.itemsContainer.mainContainer().selectAll("g.treemap-item")
	            .transition().duration(self.animation() ? 500 : 0)
	            .attr("transform", function(d) { 
	                return "translate(" + xScale(d.x0) + "," + yScale(d.y0) + ")"; 
	            });
	
	        t.select("g.treemapNode rect")
	            .attr("width", function(d) { 
	                return kx * (d.x1 - d.x0);
	            })
	            .attr("height", function(d) { 
	                return ky * (d.y1 - d.y0); 
	            })
	
	        t.select("g.treemapNode g").attr("transform", function(d) { 
	        	var position = d.data.data.labelPosition;
	            if(!position) {
	                position = 'center';
	            }
	            
	            var labelPosition = position.toLowerCase(), tx = 0, ty = 0;
	            var labelBox = this.getBBox();
	            var nodeW = kx * (d.x1 - d.x0);
	            var nodeH = ky * (d.y1 - d.y0);
	            if(labelPosition == 'bottom') {
	                tx = labelBox.width / 2;
	                ty = nodeH - labelBox.height / 2;
	            } else if(labelPosition == 'left') {
	                tx = labelBox.width / 2;
	                ty = nodeH / 2;
	            } else if(labelPosition == 'right') {
	                tx = nodeW - labelBox.width / 2;
	                ty = nodeH / 2;
	            } else if(labelPosition == 'top') {
	                tx = labelBox.width / 2;
	                ty = labelBox.height / 2;
	            } else {
	                //default center
	                tx = nodeW / 2;
	                ty = nodeH / 2;
	            }
	            //水平边界判断
	            if(labelBox.width > nodeW) {
	                tx = labelBox.width / 2;
	            }
	            
	            return "translate("+tx+","+ty+")";
	        });
	
	        node = d;
	        d3.event.stopPropagation();
	    }
	    
	    Treemap.clazzName = "Treemap";
	    
	    // 初始化
	    self.init();
	};
	
	Treemap.struct = function(ghca_charts) {
		var BaseChart = ghca_charts.view.component.charts.baseChart;
		BaseChart.struct(ghca_charts);
	    Treemap.prototype = Object.create(BaseChart.prototype);
	    Treemap.prototype.constructor = Treemap;
	};
	
	// --------------------------------------------------------------------------
	//
	// Const
	//
	// --------------------------------------------------------------------------
	
	module.exports = Treemap;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {//垂直坐标轴
	    
	/**
	 * 构造方法 
	 * @param _parent 坐标轴项所在容器对象
	 * @param _data 坐标轴项数据
	 */
	var VerAxis = function(_parent, _data) {
	    
	    // --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const BaseAxis = ghca_charts.view.component.charts.baseAxis;
	    
	    BaseAxis.apply(this, arguments);
	
	    var self = this,
	        superRenderAxis = self.renderAxis;
	    
	    //设置坐标轴默认位置
	    self.position("left");
	    
	    // --------------------------------------------------------------------------
	    //
	    // Attributes
	    //
	    // --------------------------------------------------------------------------
	        
	    //------------------------------
	    //  attribute
	    //------------------------------
	    
	    // --------------------------------------------------------------------------
	    //
	    // public Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    /**
	     * 渲染坐标轴
	     */
	    this.renderAxis = function() {
	        superRenderAxis();
	        
	    	var yScale, yAxis, boundBox, boundW, boundH, axisX, axisY,
	            domain = self.domain(), type = self.type(), padding = self.padding(), isReverse = self.isReverse();
	        if(type === "time") {
	            yScale = d3.scaleTime().clamp(true);
	        } else if(type === "enum") {
	            yScale = d3.scaleBand();
	        } else {
	            //type is value
	            yScale = d3.scaleLinear().clamp(true);
	        }
	        boundBox = self.parentChart().bgNode().getBBox();
	        boundW = boundBox.width;
	        boundH = boundBox.height;
	        axisH = boundH - padding.top - padding.bottom;
	        axisY = padding.top;
	        yScale.domain(domain).range(isReverse ? [0, axisH] : [axisH, 0]);
	            
	        if(self.position() === "right") {
	            yAxis = d3.axisRight(yScale);
	            axisX = boundW - padding.right;
	        } else {
	            yAxis = d3.axisLeft(yScale);
	            axisX = padding.left;
	        }
	        self.x(axisX);
	        self.y(axisY);
	        self.height(axisH);
	        //set tick opt
	        var tick = self.tick();
	        for(var key in tick) {
	            if(yAxis.hasOwnProperty(key)) {
	                yAxis[key](tick[key]);
	            }
	        }
	        //render x axis
	        if(!self.axisContainer) {
	            self.axisContainer = self.parent.append("g").attr("class", "yAxis");
	        }
	        self.axisContainer
	            .style("visibility", self.visible() === false ? "hidden" : "visible")
	            .call(yAxis)
	            .attr("transform", "translate(" + axisX + "," + axisY + ")");
	            
	        self.scaleIns(yScale);
	        self.axisIns(yAxis);
	    };
	    
	    /**
	     * 渲染坐标轴说明标签
	     */
	    this.renderAxisLabel = function() {
	        var x, y, label, labelBox,
	            config = self.axisLabel(), 
	            text = config.text;
	            pos = config.pos, 
	            padding = config.padding;
	        if(text === "" || text === null || text === undefined) {
	            return;
	        }
	        
	        label = self.axisContainer.selectAll("text.axisLabel");
	        if(label.node() === null) {
	            label = self.axisContainer.append("text").attr("class", "axisLabel");
	        }
	        label.text(text);
	        
	        //设置坐标轴说明标签样式
	        self.setAxisLabelStyle();
	        
	        //计算布局
	        var labelBox = label.node().getBBox();
	        var maxTickWidth = 0;
	        var maxTickHeight = 0;
	        self.axisContainer.selectAll("g.tick").each(function(d){
	            var tickBox = d3.select(this).node().getBBox();
	            if(tickBox.width > maxTickWidth) {
	                maxTickWidth = tickBox.width;
	            }
	            if(tickBox.height > maxTickHeight) {
	                maxTickHeight = tickBox.height;
	            }
	        });
	        var rotate = -90, isAxisTop = false;
	        if(pos === "bottom") {
	        	y = self.height() - labelBox.width / 2; 
	        } else if(pos === "middle") {
	            y = self.height() / 2;    
	        } else if(pos === "axisTop") {
	            y = -labelBox.height / 2;
	            rotate = 0;
	            isAxisTop = true;
	        } else {//top default
	        	y = labelBox.width / 2;
	        }
	        if(self.position() === "left") {
	        	x = isAxisTop ? -labelBox.width / 2 - padding : -maxTickWidth - padding;
	        } else {//right
	            x = isAxisTop ? labelBox.width / 2 + padding : labelBox.height + maxTickWidth + padding;
	        }
	        
	        label.attr("transform", "translate(" + x + "," + y + ")rotate(" + rotate + ")");
	    };
	    
	     /**
	     * 渲染刻度对应网格
	     * @rect 网格区域矩形
	     */
	    this.renderTickLine = function(rect) {
	        var x1, x2, y;
	        if(self.position() === "left") {
	            x1 = 0;
	            x2 = rect.w;
	        } else {
	            x1 = 0;
	            x2 = -rect.w;
	        }
	        
	        var ticks = self.axisContainer.selectAll("g.tick");
	        var pathNode = self.axisContainer.select("path.domain").node();
	        var axisPathHeight = pathNode ? pathNode.getBBox().height : NaN;
	        ticks.each(function() {
	            var transform = d3.select(this).attr("transform");
	            var ty = parseFloat(transform.replace(/[^0-9.\-, ]/g,'').split(/[, ]/g)[1]) + 0.5;
	            //与x轴重叠的网格线不渲染，否会遮挡x轴线
	            if(!isNaN(axisPathHeight) && (Math.abs(ty - axisPathHeight) < 1 || ty < 1)) {
	                return;
	            }
	            y = ty;
	            var line = self.gridLineContainer.append("line").attr("class", "tickLine")
	                .attr("x1", x1).attr("y1", y).attr("x2", x2).attr("y2", y);
	        });
	    };
	    
	    /**
	     * 渲染刻度间对应网格
	     * @rect 网格区域矩形
	     */
	    this.renderInnerLine = function(rect) {
	        var x1, x2, y,
	        gapNum = self.gridLine().innerLine.gapNum;
	        if(gapNum < 1) {
	            return;
	        }
	        if(self.position() === "left") {
	            x1 = 0;
	            x2 = rect.w;
	        } else {
	            x1 = 0;
	            x2 = -rect.w;
	        }
	        
	        var ticks = self.axisContainer.selectAll("g.tick");
	        var dy, minY = NaN, maxY = NaN, n = gapNum + 1;
	        ticks.each(function() {
	            var transform = d3.select(this).attr("transform");
	            var ty = parseFloat(transform.replace(/[^0-9.\-, ]/g,'').split(/[, ]/g)[1]) + 0.5;
	            if(isNaN(ty)) {
	                ty = 0;
	            }
	            if(isNaN(minY)) {
	                minY = ty;
	            }
	            if(isNaN(maxY)) {
	                maxY = ty;
	            }
	            if(ty < minY) {
	                minY = ty;
	            }
	            if(ty > maxY) {
	                maxY = ty;
	            }
	        });
	        dy = (maxY - minY) / (ticks.nodes().length - 1) / n;
	        
	        //tick top part
	        for(y = minY - dy; y > 0; y -= dy) {
	            self.gridLineContainer.append("line").attr("class", "innerLine")
	                .attr("x1", x1).attr("y1", y).attr("x2", x2).attr("y2", y);
	        }
	        //tick part and bottom part
	        var i = 0, axisH = self.height();
	        for(y = minY; y < axisH; y += dy, i++) {
	            //若有tickLine,则跳过
	            if(i % n !== 0) {
	                self.gridLineContainer.append("line").attr("class", "innerLine")
	                    .attr("x1", x1).attr("y1", y).attr("x2", x2).attr("y2", y);
	            }
	        }
	    };
	    
	    /**
	     * 获取刻度坐标数据数组，该数组按升序排序。
	     * 若为水平坐标轴，则格式为[x1,...,xn]；若为垂直坐标轴，则格式为[y1,...,yn]
	     */
	    this.getTicksPos = function() {
	        var result = [];
	        var ticks = self.axisContainer.selectAll("g.tick");
	        ticks.each(function() {
	            var transform = d3.select(this).attr("transform");
	            var ty = parseFloat(transform.replace(/[^0-9.\-, ]/g,'').split(/[, ]/g)[1]) + 0.5;
	            result.push(ty);
	        });
	        result.sort(function(a, b){return a - b;});
	        return result;
	    };
	    
	    this.toString = function() {
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // private Methods
	    //
	    // --------------------------------------------------------------------------
	    
	};
	
	VerAxis.struct = function(ghca_charts) {
	    var BaseAxis = ghca_charts.view.component.charts.baseAxis;
	    BaseAxis.struct(ghca_charts);
	    VerAxis.prototype = Object.create(BaseAxis.prototype);
	    VerAxis.prototype.constructor = VerAxis;
	};
	
	// --------------------------------------------------------------------------
	//
	// Const
	//
	// --------------------------------------------------------------------------
	
	module.exports = VerAxis;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {/**
	 * 鹰眼组件
	 * @param renderSvgElement 渲染位置
	 * @param viewWidth 视图可视宽度
	 * @param viewHeight 视图可视高度
	 * @param targetSourceElement 目标svg元素
	 * @constructor
	 */
	var EagleEye = function (renderSvgElement,viewWidth,viewHeight,targetSourceElement) {
	    if(arguments.length<4){
	        console.error("缺少参数");
	        return;
	    }
	
	    const BaseEvent = ghca_charts.events.BaseEvent;
	    const UUIDUtil = ghca_charts.view.util.UUIDUtil;
	    const RegexUtil = ghca_charts.view.util.regexUtil;
	    const EventUtil = ghca_charts.view.util.eventUtil;
	    //力布局控制
	    var dragEnable = true;
	
	    //g0 用于居中 鹰眼视图内容，g1 缩放大小 g2 调整原始图在鹰眼中的位置 负为正，正为负，暂不考虑正情况
	    var
	        // g0Id = UUIDUtil.generateUUID(),
	        // g1Id = UUIDUtil.generateUUID(),
	        // g2Id=UUIDUtil.generateUUID(),
	        sourceGId = UUIDUtil.generateUUID(),
	        svgId = UUIDUtil.generateUUID(),
	        clipId = UUIDUtil.generateUUID(),
	        eyeActivityAreaId=UUIDUtil.generateUUID();
	        // bgId=UUIDUtil.generateUUID();
	    //鹰眼高宽度，模板
	    var  width = 200,
	         height = 200,
	         template =
	             "<svg xmlns='http://www.w3.org/2000/svg' id='{svgId}'  width='{width}' height='{height}'>" +
	             // "<rect style='stroke-width: 1px;stroke:{eyeBgColor};fill:{eyeBgColor};' rx='5' ry='5' height='{height}' width='{width}'></rect>"+
	             // "<defs>"+
	             //    "<clipPath id='{clipId}'>"+
	             //        "<rect height='{eyeHeight}' width='{eyeWidth}'></rect>"+
	             //    "</clipPath>"+
	             // "</defs>"+
	             "<g style='clip-path: url(#{clipId});'>"+
	                "<clipPath id='{clipId}'>"+
	                    "<rect height='{height}' width='{width}'></rect>"+
	                "</clipPath>"+
	                "<g transform='translate({g0tran})')>" +
	                    "<rect style='stroke:none;fill:{eyeViewBgColor};' height='{eyeHeight}' width='{eyeWidth}'></rect>"+
	                    "<g transform='scale({g1scale})'>" +
	                        "<g transform='translate({g2tran})' id='{sourceGId}'></g>" +
	                    "</g>" +
	                "<rect id='{eyeActivityAreaId}' x='0' y='0' style='stroke-width: 1px;stroke:{eyeActivityAreaColor};fill: {eyeActivityAreaColor}; fill-opacity: 0.0' height='0' width='0'></rect>" +
	                "</g>"+
	             "</g>";
	             //+
	            "</svg>";
	    this.width = function(value){
	        if (!arguments.length)
	            return width;
	        width = value;
	        return this;
	    };
	    this.height = function(value){
	        if (!arguments.length)
	            return height;
	        height = value;
	        return this;
	    };
	    this.dragEnable = function(value){
	        if (!arguments.length)
	            return dragEnable;
	        dragEnable = value;
	        return this;
	    };
	    /**
	     * 鹰眼背景，视图背景，活动区域背景颜色
	     */
	    var eyeBgColor = 'none',eyeViewBgColor = '#42AFFF',eyeActivityAreaColor='red';
	    this.eyeBgColor = function(value){
	        if (!arguments.length)
	            return eyeBgColor;
	        eyeBgColor = value;
	        return this;
	    };
	    this.eyeViewBgColor = function(value){
	        if (!arguments.length)
	            return eyeViewBgColor;
	        eyeViewBgColor = value;
	        return this;
	    };
	    this.eyeActivityAreaColor = function(value){
	        if (!arguments.length)
	            return eyeActivityAreaColor;
	        eyeActivityAreaColor = value;
	        return this;
	    };
	    /**
	     * 鹰眼视图缩放率
	     */
	    var scale = 1;
	    /**
	     * 目标元素的 缩放率，位置，旋转角度，宽，高，x,y
	     */
	    var targetScale,targetTran,targetRote,targetWidth,targetHight,targetX,targetY;
	    /**
	     * 目标元素的可视高宽
	     */
	    var targetViewWidth = viewWidth,targetViewHeight = viewHeight;
	    /**
	     * 鹰眼内容居中位置
	     */
	    var eyeContentX,eyeContentY,eyeWidth,eyeHeight;
	
	    /**
	     * 视图大小变更
	     * @param e
	     */
	    function changeViewWidth(e){
	        var detail = e.detail;
	        targetViewWidth  = detail.width;
	        targetViewHeight = detail.height;
	    }
	
	    /**
	     * 初始化要渲染的目标参数
	     */
	    function initTargetProperties(){
	
	        var traString = targetSourceElement.attr("transform");
	        targetTran = RegexUtil.translate(traString);
	        targetScale = RegexUtil.scale(traString);
	        targetRote = RegexUtil.rotate(traString);
	        
	        var node = targetSourceElement.node();
	        var rect = node.getBBox();
	        targetWidth = rect.width;
	        targetHight = rect.height;
	        targetX = rect.x;
	        targetY = rect.y;
	    }
	
	    /**
	     * 初始化鹰眼视图的缩放率，及居中位置
	     */
	    function initEyeProperties(){
	        scale = width/targetWidth<height/targetHight? width/targetWidth: height/targetHight;
	        eyeWidth = targetWidth*scale-2;
	        eyeHeight =  targetHight*scale;
	        eyeContentX = eyeWidth<width?(width-eyeWidth)/2:0;
	        eyeContentY = eyeHeight<height?(height-eyeHeight)/2:0;
	    }
	
	    /**
	     * 添加源目标事件的变更，更新鹰眼视图
	     */
	    function addTargetListener(){
	        targetSourceElement.node().addEventListener(BaseEvent.POSITION_CHANGE,function(e){
	            initTargetProperties();
	            renderRangeRect();
	        });
	        targetSourceElement.node().addEventListener(BaseEvent.CONTENT_CHANGE,function(e){
	            initTargetProperties();
	            initEyeProperties();
	            renderContent();
	        });
	        targetSourceElement.node().addEventListener(BaseEvent.SIZE_CHANGE,function(e){
	            changeViewWidth(e);
	            renderContent();
	        });
	        targetSourceElement.node().addEventListener(BaseEvent.EAGLE_EYE_DRAG_CHANGE,function(e){
	            var detail = e.detail;
	            dragEnable = detail.enable;
	        });
	    }
	
	    /**
	     * 需要渲染是调用该方法
	     */
	    function initialize(){
	        initTargetProperties();
	        initEyeProperties();
	        addTargetListener();
	    };
	    /**
	     * 渲染入口方法
	     */
	    this.render = function (){
	        initialize();
	        renderContent();
	    }
	
	    function renderContent(){
	        // var source = targetSourceElement.html();//
	        var data = {
	            eyeBgColor:eyeBgColor,
	            eyeViewBgColor:eyeViewBgColor,
	            eyeActivityAreaColor:eyeActivityAreaColor,
	            eyeWidth:eyeWidth,
	            eyeHeight:eyeHeight,
	            // bgId:bgId,
	            width:width,
	            height:height,
	            clipId:clipId,
	            svgId:svgId,
	            // g0Id:g0Id,
	            g0tran:[eyeContentX,eyeContentY].toString(),
	            // g1Id:g1Id,
	            g1scale:[scale,scale].toString(),
	            // g2Id:g2Id,
	            g2tran:[Math.abs(targetX),Math.abs(targetY)].toString(),
	            // source:source,
	            sourceGId:sourceGId,
	            eyeActivityAreaId:eyeActivityAreaId};
	        // renderSvgElement.node().addEventListener("DOMNodeInserted",function(){
	        //     // var g0 = d3.select(document.getElementById(g0Id));
	        //     // var g1 = d3.select(document.getElementById(g1Id));
	        //     // //     // var g1 = d3.select("g#"+g1Id);  d3获取有问题
	        //     // var g2 = d3.select(document.getElementById(g2Id));
	        //     // g0.attr("transform","translate("+[eyeContentX,eyeContentY]+")");
	        //     // g1.attr("transform","scale("+[scale,scale]+")");
	        //     // g2.attr("transform","translate("+[Math.abs(targetX),Math.abs(targetY)]+")");
	        // });
	
	        // renderSvgElement.html( RegexUtil.replace(RegexUtil.dataRegex,template,data));
	        // renderSvgElement.append();
	
	        // 通过 div 中转从 svg string 得到 svg nodes
	        var dummy = document.createElement('div');
	        dummy.innerHTML = RegexUtil.replace(RegexUtil.dataRegex,template,data);
	        renderSvgElement.selectAll("*").remove();
	        renderSvgElement.node().appendChild( dummy.childNodes[0].childNodes[0]);
	        var node = document.getElementById(sourceGId);
	        var cloneNode = targetSourceElement.node().cloneNode(true);
	        var childNodes = cloneNode.childNodes;
	        for (var i = 0, length = childNodes.length; i < length; i++) {
	            node.appendChild(childNodes[0]);
	        }
	        //渲染活动区域
	        renderRangeRect();
	    }
	
	    /**
	     * 渲染活动区域
	     */
	    function renderRangeRect(){
	        var tranX = Number(targetTran[0]),tranY = Number(targetTran[1]);
	        var scaleX = Number(targetScale[0]),scaleY = Number(targetScale[1]);
	        var rangeRect = d3.select(document.getElementById(eyeActivityAreaId));
	        rangeRect.attr("width",targetViewWidth/scaleX*scale);
	        rangeRect.attr("height",targetViewHeight/scaleY*scale);
	        rangeRect.attr("x",(Math.abs(targetX)-tranX/scaleX)*scale).attr("y",(Math.abs(targetY)-tranY/scaleY)*scale);
	        rangeRect.style("cursor", "move");
	        rangeRect.call(d3.drag()
	            .on("start", range_dragStartHandler)
	            .on("drag", range_dragHandler));
	    };
	
	    function range_dragStartHandler() {
	        d3.event.sourceEvent.stopPropagation();
	    };
	    /**
	     * 拖拽活动区域变更
	     */
	    function range_dragHandler() {
	        if(dragEnable==false)return;
	        var target = d3.select(this);
	        var rx = Number(target.attr("x")),ry = Number(target.attr("y"));
	        var x = rx+d3.event.dx,y = ry+d3.event.dy;
	        target.attr("x",x).attr("y",y);
	        changeTargetSourceViewPosition(x,y);
	        // targetSourceElement.node().dispatchEvent(EventUtil.createCustomEvent(BaseEvent.EAGLE_EYE_DRAG,true,true,{x:tranX- (x -(Math.abs(targetX)-tranX/scaleX)*scale)/scale*scaleX,y:tranY- (y -(Math.abs(targetY)-tranY/scaleY)*scale)/scale*scaleY}))
	    };
	
	    /**
	     * 变更源视图位置
	     * @param x
	     * @param y
	     */
	    function changeTargetSourceViewPosition(x,y) {
	        var tranX = Number(targetTran[0]),tranY = Number(targetTran[1]);
	        var scaleX = Number(targetScale[0]),scaleY = Number(targetScale[1]);
	
	        var targetTranslateX = tranX- (x -(Math.abs(targetX)-tranX/scaleX)*scale)/scale*scaleX;
	        var targetTranslateY = tranY- (y -(Math.abs(targetY)-tranY/scaleY)*scale)/scale*scaleY;
	
	        // targetSourceElement.attr("transform",  "translate("+[targetTranslateX,targetTranslateY]+")" +
	        //     "scale(" + targetScale + ")" +
	        //     "rotate(" + targetRote+ ")");
	        targetSourceElement.node().dispatchEvent(EventUtil.createCustomEvent(BaseEvent.EAGLE_EYE_DRAG,true,true,{x:targetTranslateX,y:targetTranslateY}));
	    };
	
	};
	
	EagleEye.prototype.constructor = EagleEye;
	module.exports = EagleEye;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {var EagleEyeContainer = function(_data, _layout) {
	
	    const BaseComponent = ghca_charts.view.component.baseComponent;
	    const eagleEye = ghca_charts.view.component.eagleEye;
	    const ElementUtil = ghca_charts.view.util.elementUtil;
	
	    BaseComponent.apply(this, arguments);
	    var self = this,
	        superInit = self.init,
	        superRenderChildren = self.renderChildren;
	
	    self.className("eagleEyeContainer");
	
	    var upTrianglePath = "M-0 0 L20 0 10 -10 L0 0 Z",
	        downTrianglePath  = "M10 0 L20 -10 0 -10 L10 0 Z";
	
	    var collapsed = false;
	    this.collapsed = function(p){
	        if(!arguments.length)return collapsed;
	        collapsed = p;
	        return this;
	    }
	    
	    var isShowCollapseBtn = true;
	    this.isShowCollapseBtn = function(p){
	        if(!arguments.length)return isShowCollapseBtn;
	        isShowCollapseBtn = p;
	        return this;
	    }
	
	    this.renderChildren = function() {
	        superRenderChildren();
	        var width = self.width(),height = self.height();
	        upTrianglePath = "M-"+(width-20)+" -1 L"+width+" -1 "+(width-10)+" -11 L"+(width-20)+" -1 Z";
	        downTrianglePath = "M"+(width-10)+" 0 L"+width+" -10 "+(width-20)+" -10 L"+(width-10)+" 0 Z";
	        var inst = new eagleEye(self.mainContainer().append("g"),self.parent().width(),self.parent().height(),self.parent().parent().mainContainer().select("g."+_data.eagleConfig.target.clazz));
	        inst.eyeViewBgColor(_data.eagleConfig.background.fill);
	        inst.width(self.width());
	        inst.height(self.height());
	        inst.render();
	        self.pathElement =  ElementUtil.createPath(self.mainContainer(),{
	        	"style":"cursor:hand",
	        	"stroke-width":2,
	        	"stroke":_data.eagleConfig.collapsedToolColor,
	        	"fill":_data.eagleConfig.collapsedToolColor, 
	        	"display": self.isShowCollapseBtn() ? "block" : "none"
	        	});
	        self.pathElement.on("click",function(){
	            d3.event.stopPropagation();
	            self.collapsed(!self.collapsed());
	            self.setCollapsedPath();
	            self.renderTransform();
	        });
	        self.setCollapsedPath();
	    };
	
	    this.setCollapsedPath = function(){
	        ElementUtil.setElementProperties(self.pathElement,{d:self.collapsed()?upTrianglePath:downTrianglePath});
	    }
	
	    this.renderTransform = function(transition) {
	        var con = transition ? self.mainContainer().transition(transition) : self.mainContainer();
	        con.attr("transform", function(d) {
	            return  "translate(" + self.x() + "," + (self.collapsed()?(self.y()+self.height()+2):self.y()) + ")" +
	                "scale(" + self.scaleX() + "," + self.scaleY() + ")" +
	                "rotate(" + self.rotate() + ")";
	        });
	    };
	    /**
	     * 初始化方法
	     */
	    this.init = function() {
	        superInit();
	        var eagleConfig = _data.eagleConfig;
	        self.collapsed(eagleConfig.collapsed);
	        self.isShowCollapseBtn(eagleConfig.hasOwnProperty("isShowCollapseBtn") ? eagleConfig.isShowCollapseBtn : true);
	    };
	
	    self.init();
	};
	
	EagleEyeContainer.struct = function(ghca_charts) {
	    var BaseComponent = ghca_charts.view.component.baseComponent;
	    BaseComponent.struct(ghca_charts);
	    EagleEyeContainer.prototype = Object.create(BaseComponent.prototype);
	    EagleEyeContainer.prototype.constructor = EagleEyeContainer;
	};
	
	module.exports = EagleEyeContainer;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {/**
	 * 地图系统组件
	 */
	function GisMap(_ele,_data){  
	    var BaseComponent = ghca_charts.view.component.baseComponent;   
	    const Global = ghca_charts.global;
	    BaseComponent.apply(this, [_data]);
	    var MAX_NUM=10;
	    var FileUtil = ghca_charts.view.util.fileUtil;
	    var self=this;
	    var superRender = self.render;
	    var superRenderChildren = self.renderChildren;
	    var superUpdate = self.update;
	    var map;
	    var markerClusterer;
	    var files=[];
	    var htmlLabel;
	    self.isCoordTransing=false;
	    self.coordTransIndex=0;
	
	    if (typeof(_ele) == 'string') {
	        _ele = document.getElementById(_ele);
	    }
	    if (_ele) {
	        self.parent(_ele);
	    } else {
	        throw new Error('GisMap构造方法中传入的容器_ele:' + _ele + "无法找到。");
	    }
	    
	    self.isLibsLoaded = false;
	    self.addAttributes("files");
	    self.className("gisMap");
		this.files = function(value) {
	        if (!arguments.length)
	            return files;
	        files = value;
	        return this;
	    };
	
	
	     /**
	     * 父容器宽度，重写该方法因为本组件的父容器不是svg元素，无法用node().getBBox()方法获取尺寸
	     */
	    this.parentWidth = function() {
	        return self.parent() ? self.parent().clientWidth : 0;
	    };
	   
	    // ------------------------------
	    // parentHeight
	    // ------------------------------
	    
	    /**
	     * 父容器高度，重写该方法因为本组件的父容器不是svg元素，无法用node().getBBox()方法获取尺寸
	     */
	    this.parentHeight = function() {
	        return self.parent() ? self.parent().clientHeight : 0;
	    };
	
	    this.render = function() {
	        //等待第三方库加载完毕后，再操作render
	        self.isLibsLoaded = false;
	        loadMapLib();
	    };
	
	     /**
	     * 依赖库加载
	     * @param {} callback 
	     */
	    function loadLibs(callback) {
	    	Global.isDebug && console.log("loadLibs");
	        var files = self.files();
	        FileUtil.loadFiles(files, callback);
	
	    };
	
	    function toLoadLibs(){
	        loadLibs(initMap);
	    }
	
	    function loadMapLib(){
	        var script=document.createElement("script");
	        script.type = "text/javascript";
	        script.src = "http://api.map.baidu.com/api?v=3.0&ak="+_data.mapKey+"&callback=initBDMap";
	        document.body.appendChild(script);
	        window.initBDMap=toLoadLibs;
	    }
	
	     /**
	     * 渲染放置所有内容的最外层容器
	     */
	    this.renderMainContainer = function() {
	        if(self.mainContainer()) {
	            self.mainContainer().remove();
	        }
	        //设置传入父容器样式
	        var style = self.parent().style;
	        style.overflow = "hidden";
	        
	        //创建容器元素
	        var mapDiv = d3.select(self.parent()).append("div")
	            .attr("class", self.className())
	            .attr("width", self.width())
	            .attr("height", self.height());
	        self.mainContainer(mapDiv);
	        //先设置mainContainer，再检测组件是否可见
	        self.validateVisible();
	    };
	
	    /**
	     * 渲染子容器
	     */
	    this.renderChildren = function() {
	        superRenderChildren();
	        renderMap();
	    };
	
	    function renderMap() {
	        if(!self.isLibsLoaded) {
	            return;
	        }
	        //移除并重新创建表格顶层容器
	        self.renderMainContainer();
	        self.updateOthers();
	    };
	
	    /**
	     * 初始化地图
	     */
	    function initMap(){
	        superRender();
	        self.isLibsLoaded = true;
	        BMapLib.TextIconOverlay.prototype.getStyleByText = function(text, styles){
	            return styles[0]; 
	        }
	
	        Global.isDebug && console.log("initMap");
	        var items=self.itemsData();
	        // items=null;
	        if(items){
	            createMap(new BMap.Point(items[0].pos[0],items[0].pos[1]));//配置定位
	        }else{
	            var myCity = new BMap.LocalCity();
	            myCity.get(function(result){//ip定位
	                var cityName = result.name;
	                createMap(cityName);
	            });
	        }                    
	    }
	
	    function createMap(cityName){
	        map=new BMap.Map(_ele.id,{enableMapClick: false});
	        map.centerAndZoom(new BMap.Point(116.331398,39.897445), 12);
	        map.enableScrollWheelZoom(true);
	        map.setMapStyle(self.mapStyle());
	        initMapControl();
	        self.data().textIconStyle.size=new BMap.Size(self.data().textIconStyle.size[0],self.data().textIconStyle.size[1]);
	        self.data().textIconStyle.anchor =new BMap.Size(self.data().textIconStyle.anchor[0],self.data().textIconStyle.anchor[1]);
	        markerClusterer= new BMapLib.MarkerClusterer(map,{styles:[self.data().textIconStyle]}); 
	        map.setCenter(cityName);
	        if(self.data().coordType!=5){//非百度经纬度坐标系
	            self.isCoordTransing=true;
	            oneTransCoord();
	        }else{
	            self.update();
	        }
	    }
	
	    function oneTransCoord(){
	        var datas=self.itemsData();
	        var num=datas.length;
	        var points=[];
	       for(var i=self.coordTransIndex;i<self.coordTransIndex+MAX_NUM;i++){//每次最多支持转换10个            
	            if(i>=num){
	                break;
	            }
	            var itemData=datas[i];
	            var p=new BMap.Point(itemData.pos[0],itemData.pos[1]);
	            points.push(p);
	       }
	       var convertor = new BMap.Convertor();
	        convertor.translate(points, self.data().coordType, 5, translateCallback);
	    }
	
	    function translateCallback(data){
	        if(data.status===0){
	            var datas=self.itemsData();
	            var num=datas.length;
	            for (var i = 0; i < data.points.length; i++) {
	                var itemData=datas[self.coordTransIndex];
	                itemData.pos[0]=data.points[0];
	                itemData.pos[1]=data.points[1];
	                self.coordTransIndex++;                
	            }
	
	            if(self.coordTransIndex!=num){
	                oneTransCoord();
	            }else{
	                self.isCoordTransing=false;
	                self.update();
	            }
	        }
	    }
	
	    /**
	     * 初始化地图控件
	     */
	    function initMapControl(){
	        if(self.data().scaleControl){
	            self.data().scaleControl.anchor=getBMapConst(self.data().scaleControl.anchor);
	            var scaleControl=new BMap.ScaleControl(self.data().scaleControl);
	            map.addControl(scaleControl);
	        }
	
	        if(self.data().navigationControl){
	            self.data().navigationControl.anchor=getBMapConst(self.data().navigationControl.anchor);
	            self.data().navigationControl.type=getBMapConst(self.data().navigationControl.type);
	            var navigationControl=new BMap.NavigationControl(self.data().navigationControl);
	            map.addControl(navigationControl);
	        }
	
	        if(self.data().mapTypeControl){
	            self.data().mapTypeControl.type=getBMapConst(self.data().mapTypeControl.type);
	            self.data().mapTypeControl.anchor=getBMapConst(self.data().mapTypeControl.anchor);
	            if(self.data().mapTypeControl.mapTypes){
	                for(var i=0;i<self.data().mapTypeControl.mapTypes.length;i++){
	                    self.data().mapTypeControl.mapTypes[i]=getBMapConst(self.data().mapTypeControl.mapTypes[i]);
	                }
	            }
	            var maptype=new BMap.MapTypeControl(self.data().mapTypeControl);
	            map.addControl(maptype);
	        }
	    }
	
	    /**
	     * 将字符串转换为百度地图对应常量
	     * @param {string} value 
	     */
	    function getBMapConst(value){
	        switch(value){
	            case "BMAP_ANCHOR_TOP_LEFT":
	            return BMAP_ANCHOR_TOP_LEFT;
	            case "BMAP_ANCHOR_TOP_RIGHT":
	            return BMAP_ANCHOR_TOP_RIGHT;
	            case "BMAP_ANCHOR_BOTTOM_LEFT":
	            return BMAP_ANCHOR_BOTTOM_LEFT;
	            case "BMAP_ANCHOR_BOTTOM_RIGHT":
	            return BMAP_ANCHOR_BOTTOM_RIGHT;
	            case "BMAP_NAVIGATION_CONTROL_LARGE":
	            return BMAP_NAVIGATION_CONTROL_LARGE;
	            case "BMAP_NAVIGATION_CONTROL_SMALL":
	            return BMAP_NAVIGATION_CONTROL_SMALL;
	            case "BMAP_NAVIGATION_CONTROL_PAN":
	            return BMAP_NAVIGATION_CONTROL_PAN;
	            case "BMAP_NAVIGATION_CONTROL_ZOOM":
	            return BMAP_NAVIGATION_CONTROL_ZOOM;
	            case "BMAP_MAPTYPE_CONTROL_HORIZONTAL":
	            return BMAP_MAPTYPE_CONTROL_HORIZONTAL;
	            case "BMAP_MAPTYPE_CONTROL_DROPDOWN":
	            return BMAP_MAPTYPE_CONTROL_DROPDOWN;
	            case "BMAP_MAPTYPE_CONTROL_MAP":
	            return BMAP_MAPTYPE_CONTROL_MAP;
	            case "BMAP_NORMAL_MAP":
	            return BMAP_NORMAL_MAP;
	            case "BMAP_PERSPECTIVE_MAP":
	            return BMAP_PERSPECTIVE_MAP;
	            case "BMAP_SATELLITE_MAP":
	            return BMAP_SATELLITE_MAP;
	            case "BMAP_HYBRID_MAP":
	            return BMAP_HYBRID_MAP;
	        }
	    }
	
	    /**
	     * 地图样式
	     */
	    this.mapStyle = function(){
	        return self.data() && self.data().mapStyle ? self.data().mapStyle : {style:"midnight"};
	    };
	
	    /**
	     * 地图数据
	     */
	    this.itemsData = function(){
	        return self.data() && self.data().data ? self.data().data : null;
	    };
	
	    /**
	     * 更新地图
	     */
	    this.update = function() {
	        if(self.isLibsLoaded===false||self.isCoordTransing===true){
	            return;
	        }
	        superUpdate();
	        renderMap();
	        Global.isDebug && console.log("update");
	        self.addOverlay();
	    }
	    
	    this.addOverlay=function (){
	        markerClusterer.clearMarkers();
	        var items=self.itemsData();
	        var num=items.length;
	        var pt = null;
	        var itemData=null;
	        var markers = [];
	        for(var i=0;i<num;i++){
	            itemData=items[i];
	            var markerop={
	                title:itemData.title,
	            }
	            if(itemData.icon){
	                markerop.icon=new BMap.Icon(itemData.icon.url,new BMap.Size(itemData.icon.width,itemData.icon.height));
	            }
	            pt=new BMap.Point(itemData.pos[0],itemData.pos[1]);
	            var marker=new BMap.Marker(pt,markerop);
	            if(self.data().windowInfo){
	                addClickHandler(itemData,marker);               
	            }
	            markers.push(marker);
	        }
	        
	
	        if(self.data().mode==="normal"){
	            for(var i=0;i<markers.length;i++){
	                map.addOverlay(markers[i]);
	            }
	        }else if(self.data().mode==="clusterer"){
	            markerClusterer.addMarkers(markers);
	        }        
	    }
	
	    function addClickHandler(content, marker) {
	        marker.addEventListener("click", function (e) {
	            openInfo(content, e)
	         }
	        );
	    }
	    
	    function test(){
	    	Global.isDebug && console.log("test");
	    }
	
	    function openInfo(content,e){
	        var htmlContent=self.getWindowInfo(content);
			var p = e.target;
	        var point = new BMap.Point(p.getPosition().lng, p.getPosition().lat);        
	        if(!htmlLabel){
	            var opts = {
	                position : point,    // 指定文本标注所在的地理位置
	                offset   : new BMap.Size(self.data().windowInfo.offset[0], self.data().windowInfo.offset[1])    //设置文本偏移量
	              }
	            htmlLabel = new BMap.Label(htmlContent, opts);  // 创建文本标注对象
	            htmlLabel.setStyle({
	                "background-color": "rgba(0,0,0,0)",
	                "border-color": "rgba(0,0,0,0)",
	                "color": "#fff",
	            });
	            map.addOverlay(htmlLabel);   
	            htmlLabel.addEventListener("click",function(e){
	                if(htmlLabel.isVisible()){
	                    htmlLabel.hide();
	                }
	            })
	        }else{
	            htmlLabel.setContent(htmlContent);
	            htmlLabel.setPosition(point);
	        }
	        map.panTo(point);
			htmlLabel.show();
		} 
	
	    self.init();
	}
	
	
	
	GisMap.struct = function(ghca_charts) {
	    var BaseComponent = ghca_charts.view.component.baseComponent;
	    BaseComponent.struct(ghca_charts);
	    GisMap.prototype = Object.create(BaseComponent.prototype);
	    GisMap.prototype.constructor = GisMap;
	    /**
	     * 信息弹窗获取函数（外部可重写）
	     * @param {*} data 
	     */
	    GisMap.prototype.getWindowInfo = function (data) {
	        return '<svg id="info_window_svg_' + data.id + '" verson="1.1" style="position:absolute;width:50px;height:200px;">' +
	            '<polyline points="0,195 25,50 50,50" style="stroke:rgba(68,123,175,0.75);stroke-width:2;fill:none;"/>' +
	            '</svg>' +
	            '<div id="info_window_content_' + data.id + '" class="info_window_content">' +
	            '<div class="tl_border"></div>' +
	            '<div class="tr_border"></div>' +
	            '<div class="bl_border"></div>' +
	            '<div class="br_border"></div>' +
	            '<div><span style="padding-left:26px;">序号：</span>' + data.id + '</div>' +
	            '<div><span style="padding-left:26px;">城市：</span>' + data.city + '</div>' +
	            '<div><span style="padding-left:2px;">职场名称：</span>' + data.name + '</div>' +
	            '<div><span style="padding-left:26px;">地址：</span>' + data.addr + '</div>' +
	            '<div><span style="padding-left:2px;">人力规模：</span>' + data.peopleNum + '</div>' +
	            '<div><span style="padding-left:2px;">UPS数量：</span>' + data.upsNum + '</div>' +
	            '<div><span style="padding-left:15px;">配线间：</span>' + data.dnNum + '</div>' +
	            '<div><span style="padding-left:26px;">容量：</span>' + data.progress + '%</div>' +
	            '</div>';
	    }
	};
	
	module.exports = GisMap;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {// comboBox类
	// api http://www.jeasyui.com/documentation/index.php
	    
	/**
	 * 构造方法 
	 * @param _ele 组件所在容器对象或者容器id，比如一个div
	 * @param _data 配置数据
	 */
	var ComboBox = function(_ele, _data) {
	    
	    // --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const BaseComponent = ghca_charts.view.component.baseComponent;
	    const FileUtil = ghca_charts.view.util.fileUtil;
	    const BaseEvent = ghca_charts.events.BaseEvent;
	    const EventUtil = ghca_charts.view.util.eventUtil;
	
	    BaseComponent.apply(this, [_data]);
	    
	    var self = this, 
	        superRenderSize = self.renderSize,
	        superRender = self.render,
	        superUpdate = self.update,
	        superRenderChildren = self.renderChildren;
	        
	    if (arguments.length < 1) {
	        throw new Error('传入参数个数错误,当前个数' + arguments.length + ",至少传入前1个参数。");
	    }
	    
	    if (typeof(_ele) == 'string') {
	        _ele = document.getElementById(_ele);
	    }
	    if (_ele) {
	        self.parent(_ele);
	    } else {
	        throw new Error('ComboBox构造方法中传入的容器_ele:' + _ele + "无法找到。");
	    }
	    
	    self.isLibsLoaded = false;
	    self.className("comboBox");
	    //添加可从配置文件读取的属性名称
	    self.addAttributes("valueField", "textField", "editable", "files");
	
	    // --------------------------------------------------------------------------
	    //
	    // Attributes
	    //
	    // --------------------------------------------------------------------------
	    
	    // ------------------------------
	    // valueField
	    // ------------------------------
	
	    /**
	     * 选项值对应数据中的键名称
	     */
	    var valueField = "id";
	    this.valueField = function(value) {
	        if (!arguments.length)
	            return valueField;
	        valueField = value;
	        return this;
	    };
	    
	    // ------------------------------
	    // textField
	    // ------------------------------
	
	    /**
	     * 选项文本对应数据中的键名称
	     */
	    var textField = "text";
	    this.textField = function(value) {
	        if (!arguments.length)
	            return textField;
	        textField = value;
	        return this;
	    };
	    
	    // ------------------------------
	    // editable
	    // ------------------------------
	
	    /**
	     * 文本输入框是否可编辑
	     */
	    var editable = true;
	    this.editable = function(value) {
	        if (!arguments.length)
	            return editable;
	        editable = value;
	        return this;
	    };
	    
	    // ------------------------------
	    // files
	    // ------------------------------
	
	    /**
	     * 第三方库文件列表
	     */
	    var files = [
	        "../js/easyui/themes/icon.css",
	        "../js/easyui/easyloader.js"
	    ];
	    this.files = function(value) {
	        if (!arguments.length)
	            return files;
	        files = value;
	        return this;
	    };
	
	    // ------------------------------
	    // parentWidth
	    // ------------------------------
	    
	    /**
	     * 父容器宽度，重写该方法因为本组件的父容器不是svg元素，无法用node().getBBox()方法获取尺寸
	     */
	    this.parentWidth = function() {
	        return self.parent() ? self.parent().clientWidth : 0;
	    };
	    
	    // ------------------------------
	    // parentHeight
	    // ------------------------------
	    
	    /**
	     * 父容器高度，重写该方法因为本组件的父容器不是svg元素，无法用node().getBBox()方法获取尺寸
	     */
	    this.parentHeight = function() {
	        return self.parent() ? self.parent().clientHeight : 0;
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // listeners
	    //
	    // --------------------------------------------------------------------------
	    
	    // --------------------------------------------------------------------------
	    //
	    // public Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    this.render = function() {
	        //等待第三方库加载完毕后，再操作render
	        self.isLibsLoaded = false;
	        loadLibs(afterLoadLibs);
	    };
	    
	    /**
	     * 渲染放置所有内容的最外层容器
	     */
	    this.renderMainContainer = function() {
	        if(self.mainContainer()) {
	            self.mainContainer().remove();
	            self.comboBox = null;
	            d3.selectAll(".combo-p").remove();
	        }
	        //设置传入父容器样式
	        var style = self.parent().style;
	        style.overflow = "hidden";
	        
	        //创建comboBox容器元素
	        var mainContainer = d3.select(self.parent()).append("div")
	            .attr("width", self.width())
	            .attr("height", self.height());
	        self.comboBox = mainContainer.append("div")
	            .attr("class", self.className())
	            .attr("width", self.width())
	            .attr("height", self.height());
	        self.mainContainer(mainContainer);
	        //先设置mainContainer，再检测组件是否可见
	        self.validateVisible();
	    };
	    
	    /**
	     * 渲染子容器
	     */
	    this.renderChildren = function() {
	        superRenderChildren();
	        
	        renderComboBox();
	    };
	    
	    /**
	     * 渲染组件尺寸
	     */
	    this.renderSize = function() {
	        superRenderSize();
	        
	        var mainContainer = self.mainContainer();
	        var comboBox = self.comboBox;
	        if(!mainContainer || !comboBox) {
	            return;
	        }
	        //设置图表容器大小
	        var w = self.width(), h = self.height();
	        mainContainer.attr("width", w).attr("height", h);
	        comboBox.attr("width", w).attr("height", h);
	        if($(comboBox.node()).combobox) {
	        	$(comboBox.node()).combobox({ 
	                width:w + 'px',
	                height:h + 'px'
	            });
	        }
	        validatePopScale();
	    };
	    
	    this.update = function() {
	        if(!self.isLibsLoaded) {
	            return;
	        }
	        superUpdate();
	        
	        renderComboBox();
	    };
	    
	    /**
	     * 用于打印本对象的一些基本信息
	     */
	    this.toString = function() {
	        return ("ComboBox info: " +
	                "\n   width:"     + self.width()      + 
	                "\n   height:"    + self.height()     + 
	                "\n   data:"      + JSON.stringify(this.data(), null, 4));
	    };
	
	    // --------------------------------------------------------------------------
	    //
	    // private Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    var afterLoadLibs = function() {
	        self.isLibsLoaded = true;
	        superRender();
	    };
	    
	    var renderComboBox = function() {
	        if(!self.isLibsLoaded) {
	            return;
	        }
	        //移除并重新创建表格顶层容器
	        self.renderMainContainer();
	        self.updateOthers();
	        
	        //渲染comboBox内容
	        var data = self.data().data;
	        var comboBox = $(self.comboBox.node());
	        var valueField = self.valueField();
	        var textField = self.textField();
	        var editable = self.editable();
	        easyloader.load('combobox', function() {
	            $(comboBox).combobox({ 
	            	width:self.width() + 'px',
	            	height:self.height() + 'px',
	                data:data, 
	                valueField:valueField, 
	                textField:textField,
	                editable:editable,
	                onChange:function(value) {
	                    for(var d, i = 0, len = data.length; i < len; i++) {
	                        d = data[i];
	                        if(d[valueField] == value) {
	                            var evt = EventUtil.createCustomEvent(BaseEvent.SELECT_CHANGE, true, true, d);
	                            this.dispatchEvent(evt);
	                            return;
	                        }
	                    }
	                } 
	            });
	            validatePopScale();
	        });
	    };
	    
	    var loadLibs = function(callback) {
	        var files = self.files();
	        FileUtil.loadFiles(files, callback);
	    };
	    
	    var validatePopScale = function() {
	        var graph = self.graph();
	        if(!graph) return;
	        var h = self.height();
	        var ty = -h * (1 - graph.scaleY());
	        d3.selectAll(".combo-p")
	            .style("transform-origin", "left top")
	            .style("transform", "translate(0px," + ty + "px)scale(" + graph.scaleX() + "," + graph.scaleY() + ")");
	    };
	    
	    self.init();
	};
	
	ComboBox.struct = function(ghca_charts) {
	    var BaseComponent = ghca_charts.view.component.baseComponent;
	    BaseComponent.struct(ghca_charts);
	    ComboBox.prototype = Object.create(BaseComponent.prototype);
	    ComboBox.prototype.constructor = ComboBox;
	};
	
	module.exports = ComboBox;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {// dateTimeBox类
	// api http://www.jeasyui.com/documentation/index.php
	    
	/**
	 * 构造方法 
	 * @param _ele 组件所在容器对象或者容器id，比如一个div
	 * @param _data 配置数据
	 */
	var DateTimeBox = function(_ele, _data) {
	    
	    // --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const BaseComponent = ghca_charts.view.component.baseComponent;
	    const FileUtil = ghca_charts.view.util.fileUtil;
	    const BaseEvent = ghca_charts.events.BaseEvent;
	    const EventUtil = ghca_charts.view.util.eventUtil;
	
	    BaseComponent.apply(this, [_data]);
	    
	    var self = this, 
	        superRenderSize = self.renderSize,
	        superRender = self.render,
	        superUpdate = self.update,
	        superRenderChildren = self.renderChildren;
	        
	    if (arguments.length < 1) {
	        throw new Error('传入参数个数错误,当前个数' + arguments.length + ",至少传入前1个参数。");
	    }
	    
	    if (typeof(_ele) == 'string') {
	        _ele = document.getElementById(_ele);
	    }
	    if (_ele) {
	        self.parent(_ele);
	    } else {
	        throw new Error('DateTimeBox构造方法中传入的容器_ele:' + _ele + "无法找到。");
	    }
	    
	    self.isLibsLoaded = false;
	    self.className("dateTimeBox");
	    //添加可从配置文件读取的属性名称
	    self.addAttributes("files", "value");
	
	    // --------------------------------------------------------------------------
	    //
	    // Attributes
	    //
	    // --------------------------------------------------------------------------
	    
	    // ------------------------------
	    // value
	    // ------------------------------
	
	    /**
	     * 默认日期字符串
	     */
	    var value = "";
	    this.value = function(value) {
	        if (!arguments.length)
	            return value;
	        value = value;
	        return this;
	    };
	    
	    // ------------------------------
	    // files
	    // ------------------------------
	
	    /**
	     * 第三方库文件列表
	     */
	    var files = [
	        "../js/easyui/themes/icon.css",
	        "../js/easyui/easyloader.js"
	    ];
	    this.files = function(value) {
	        if (!arguments.length)
	            return files;
	        files = value;
	        return this;
	    };
	
	    // ------------------------------
	    // parentWidth
	    // ------------------------------
	    
	    /**
	     * 父容器宽度，重写该方法因为本组件的父容器不是svg元素，无法用node().getBBox()方法获取尺寸
	     */
	    this.parentWidth = function() {
	        return self.parent() ? self.parent().clientWidth : 0;
	    };
	    
	    // ------------------------------
	    // parentHeight
	    // ------------------------------
	    
	    /**
	     * 父容器高度，重写该方法因为本组件的父容器不是svg元素，无法用node().getBBox()方法获取尺寸
	     */
	    this.parentHeight = function() {
	        return self.parent() ? self.parent().clientHeight : 0;
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // listeners
	    //
	    // --------------------------------------------------------------------------
	    
	    // --------------------------------------------------------------------------
	    //
	    // public Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    this.render = function() {
	        //等待第三方库加载完毕后，再操作render
	        self.isLibsLoaded = false;
	        loadLibs(afterLoadLibs);
	    };
	    
	    /**
	     * 渲染放置所有内容的最外层容器
	     */
	    this.renderMainContainer = function() {
	        if(self.mainContainer()) {
	            self.mainContainer().remove();
	        }
	        //设置传入父容器样式
	        var style = self.parent().style;
	        style.overflow = "hidden";
	        
	        //创建dateTimeBox容器元素
	        var dateTimeBox = d3.select(self.parent()).append("div")
	            .attr("class", self.className())
	            .attr("width", self.width())
	            .attr("height", self.height());
	        self.mainContainer(dateTimeBox);
	        //先设置mainContainer，再检测组件是否可见
	        self.validateVisible();
	    };
	    
	    /**
	     * 渲染子容器
	     */
	    this.renderChildren = function() {
	        superRenderChildren();
	        
	        renderDateTimeBox();
	    };
	    
	    /**
	     * 渲染组件尺寸
	     */
	    this.renderSize = function() {
	        superRenderSize();
	        var dateTimeBox = self.mainContainer();
	        if(!dateTimeBox) {
	            return;
	        }
	        //设置图表容器大小
	        var w = self.width(), h = self.height();
	        dateTimeBox.attr("width", w);
	        dateTimeBox.attr("height", h);
	//        renderDateTimeBox();
	    };
	    
	    this.update = function() {
	        if(!self.isLibsLoaded) {
	            return;
	        }
	        superUpdate();
	        
	        renderDateTimeBox();
	    };
	    
	    /**
	     * 用于打印本对象的一些基本信息
	     */
	    this.toString = function() {
	        return ("DateTimeBox info: " +
	                "\n   width:"     + self.width()      + 
	                "\n   height:"    + self.height()     + 
	                "\n   data:"      + JSON.stringify(this.data(), null, 4));
	    };
	
	    // --------------------------------------------------------------------------
	    //
	    // private Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    var afterLoadLibs = function() {
	        self.isLibsLoaded = true;
	        superRender();
	    };
	    
	    var renderDateTimeBox = function() {
	        if(!self.isLibsLoaded) {
	            return;
	        }
	        //移除并重新创建表格顶层容器
	        self.renderMainContainer();
	        self.updateOthers();
	        
	        //渲染dateTimeBox内容
	        var data = self.data().data;
	        var input = $(self.mainContainer().node());
	        easyloader.load('datetimebox', function() {
	            $(input).datetimebox({ 
	                value: self.value(), 
	                required: true, 
	                showSeconds: true,
	                currentText: "今日",
	                okText: "确定",
	                closeText: "关闭",
	                onChange:function(value) {
	                    var evt = EventUtil.createCustomEvent(BaseEvent.SELECT_CHANGE, true, true, value);
	                    this.dispatchEvent(evt);
	                } 
	            });
	        });
	    };
	    
	    var loadLibs = function(callback) {
	        var files = self.files();
	        FileUtil.loadFiles(files, callback);
	    };
	    
	    self.init();
	};
	
	DateTimeBox.struct = function(ghca_charts) {
	    var BaseComponent = ghca_charts.view.component.baseComponent;
	    BaseComponent.struct(ghca_charts);
	    DateTimeBox.prototype = Object.create(BaseComponent.prototype);
	    DateTimeBox.prototype.constructor = DateTimeBox;
	};
	
	module.exports = DateTimeBox;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {// IFrame类
	    
	/**
	 * 构造方法 
	 * @param _ele 组件所在容器对象或者容器id，比如一个div
	 * @param _data 配置数据
	 */
	var IFrame = function(_ele, _data) {
	    
	    // --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const BaseComponent = ghca_charts.view.component.baseComponent;
	    const FileUtil = ghca_charts.view.util.fileUtil;
	    const BaseEvent = ghca_charts.events.BaseEvent;
	    const EventUtil = ghca_charts.view.util.eventUtil;
	    const ObjectUtil = ghca_charts.view.util.objectUtil;
	    const Global = ghca_charts.global;
	
	    BaseComponent.apply(this, [_data]);
	    
	    var self = this, 
	        superRenderSize = self.renderSize,
	        superRender = self.render,
	        superUpdate = self.update,
	        superRenderChildren = self.renderChildren;
	        
	    if (arguments.length < 1) {
	        throw new Error('传入参数个数错误,当前个数' + arguments.length + ",至少传入前1个参数。");
	    }
	    
	    if (typeof(_ele) == 'string') {
	        _ele = document.getElementById(_ele);
	    }
	    if (_ele) {
	        self.parent(_ele);
	    } else {
	        throw new Error('IFrame构造方法中传入的容器_ele:' + _ele + "无法找到。");
	    }
	    
	    self.isLibsLoaded = false;
	    self.className("iFrame");
	    //添加可从配置文件读取的属性名称
	    self.addAttributes("files", "frameborder", "sandbox", "scrolling");
	
	    // --------------------------------------------------------------------------
	    //
	    // Attributes
	    //
	    // --------------------------------------------------------------------------
	    
	    // ------------------------------
	    // files
	    // ------------------------------
	
	    /**
	     * 第三方库文件列表
	     */
	    var files = [];
	    this.files = function(value) {
	        if (!arguments.length)
	            return files;
	        files = value;
	        return this;
	    };
	    
	    // ------------------------------
	    // src
	    // ------------------------------
	
	    /**
	     * iframe对应src
	     */
	    var src = "";
	    this.src = function(value) {
	        if (!arguments.length)
	            return src;
	        src = value;
	        return this;
	    };
	    
	    // ------------------------------
	    // frameborder
	    // ------------------------------
	
	    /**
	     * 规定是否显示框架周围的边框。0|1(默认值0)
	     */
	    var frameborder = 0;
	    this.frameborder = function(value) {
	        if (!arguments.length)
	            return frameborder;
	        frameborder = value;
	        return this;
	    };
	    
	    // ------------------------------
	    // sandbox
	    // ------------------------------
	
	    /**
	     * 启用一系列对 <iframe> 中内容的额外限制。可设置值：
	     * "" 
	     * "allow-forms" 
	     * "allow-same-origin" 
	     * "allow-scripts" 
	     * "allow-top-navigation"
	     */
	    var sandbox = "allow-scripts";
	    this.sandbox = function(value) {
	        if (!arguments.length)
	            return sandbox;
	        sandbox = value;
	        return this;
	    };
	    
	    // ------------------------------
	    // scrolling
	    // ------------------------------
	
	    /**
	     * 规定是否在 iframe 中显示滚动条。"yes"|"no"|"auto"(默认值"auto")
	     */
	    var scrolling = "auto";
	    this.scrolling = function(value) {
	        if (!arguments.length)
	            return scrolling;
	        scrolling = value;
	        return this;
	    };
	
	    // ------------------------------
	    // parentWidth
	    // ------------------------------
	    
	    /**
	     * 父容器宽度，重写该方法因为本组件的父容器不是svg元素，无法用node().getBBox()方法获取尺寸
	     */
	    this.parentWidth = function() {
	        return self.parent() ? self.parent().clientWidth : 0;
	    };
	    
	    // ------------------------------
	    // parentHeight
	    // ------------------------------
	    
	    /**
	     * 父容器高度，重写该方法因为本组件的父容器不是svg元素，无法用node().getBBox()方法获取尺寸
	     */
	    this.parentHeight = function() {
	        return self.parent() ? self.parent().clientHeight : 0;
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // listeners
	    //
	    // --------------------------------------------------------------------------
	    
	    // --------------------------------------------------------------------------
	    //
	    // public Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    this.render = function() {
	        //等待第三方库加载完毕后，再操作render
	        self.isLibsLoaded = false;
	        loadLibs(afterLoadLibs);
	    };
	    
	    /**
	     * 渲染放置所有内容的最外层容器
	     */
	    this.renderMainContainer = function() {
	    	if(self.mainContainer()) {
	            self.mainContainer().remove();
	        }
	    	//创建iFrame元素
	        var iFrame = d3.select(self.parent()).append("iFrame")
	            .attr("class", self.className());
	        self.mainContainer(iFrame);
	        
	        //设置传入父容器样式
	        var style = self.parent().style;
	        style.overflow = "hidden";
	        
	        self.renderSize();
	        //先设置mainContainer，再检测组件是否可见
	        self.validateVisible();
	    };
	    
	    /**
	     * 渲染子容器
	     */
	    this.renderChildren = function() {
	        superRenderChildren();
	        
	        renderIFrame();
	    };
	    
	    /**
	     * 渲染组件尺寸
	     */
	    this.renderSize = function() {
	        superRenderSize();
	        //设置图表容器大小
	        self.mainContainer().attr("width", self.width()).attr("height", self.height());
	    };
	    
	    this.update = function() {
	        if(!self.isLibsLoaded) {
	            return;
	        }
	        superUpdate();
	        
	        renderIFrame();
	    };
	    
	    /**
	     * 用于打印本对象的一些基本信息
	     */
	    this.toString = function() {
	        return ("IFrame info: " +
	                "\n   width:"     + self.width()      + 
	                "\n   height:"    + self.height()     + 
	                "\n   data:"      + JSON.stringify(this.data(), null, 4));
	    };
	
	    // --------------------------------------------------------------------------
	    //
	    // private Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    var afterLoadLibs = function() {
	        self.isLibsLoaded = true;
	        superRender();
	    };
	    
	    var renderIFrame = function() {
	        if(!self.isLibsLoaded) {
	            return;
	        }
	        //移除并重新创建表格顶层容器
	        self.renderMainContainer();
	        self.updateOthers();
	        
	        //渲染iframe内容
	        var data = self.data().data;
	        if(ObjectUtil.isArray(data) && data.length > 0) {
	        	self.src(data[0].src);
	        }
	        var attr = self.data().attr;
	        self.frameborder(attr.frameborder);
	        self.sandbox(attr.sandbox);
	        self.scrolling(attr.scrolling);
	        self.mainContainer()
	            .attr("width", self.width())
	            .attr("height", self.height())
	            .attr("src", self.src())
	            .attr("frameborder", self.frameborder())
	            .attr("sandbox", self.sandbox())
	            .attr("scrolling", self.scrolling());
	    };
	    
	    var loadLibs = function(callback) {
	        var files = self.files();
	        Global.isDebug && console.log(files)
	        FileUtil.loadFiles(files, callback);
	    };
	    
	    self.init();
	};
	
	IFrame.struct = function(ghca_charts) {
	    var BaseComponent = ghca_charts.view.component.baseComponent;
	    BaseComponent.struct(ghca_charts);
	    IFrame.prototype = Object.create(BaseComponent.prototype);
	    IFrame.prototype.constructor = IFrame;
	};
	
	module.exports = IFrame;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {// linkButton类
	// api http://www.jeasyui.com/documentation/index.php
	    
	/**
	 * 构造方法 
	 * @param _ele 组件所在容器对象或者容器id，比如一个div
	 * @param _data 配置数据
	 */
	var LinkButton = function(_ele, _data) {
	    
	    // --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const BaseComponent = ghca_charts.view.component.baseComponent;
	    const FileUtil = ghca_charts.view.util.fileUtil;
	    const BaseEvent = ghca_charts.events.BaseEvent;
	    const EventUtil = ghca_charts.view.util.eventUtil;
	    const Global = ghca_charts.global;
	
	    BaseComponent.apply(this, [_data]);
	    
	    var self = this, 
	        superRenderSize = self.renderSize,
	        superRender = self.render,
	        superUpdate = self.update,
	        superRenderChildren = self.renderChildren;
	        
	    if (arguments.length < 1) {
	        throw new Error('传入参数个数错误,当前个数' + arguments.length + ",至少传入前1个参数。");
	    }
	    
	    if (typeof(_ele) == 'string') {
	        _ele = document.getElementById(_ele);
	    }
	    if (_ele) {
	        self.parent(_ele);
	    } else {
	        throw new Error('LinkButton构造方法中传入的容器_ele:' + _ele + "无法找到。");
	    }
	    
	    self.isLibsLoaded = false;
	    self.className("linkButton");
	    //添加可从配置文件读取的属性名称
	    self.addAttributes("files");
	
	    // --------------------------------------------------------------------------
	    //
	    // Attributes
	    //
	    // --------------------------------------------------------------------------
	    
	    // ------------------------------
	    // files
	    // ------------------------------
	
	    /**
	     * 第三方库文件列表
	     */
	    var files = [
	        "../js/easyui/themes/icon.css",
	        "../js/easyui/easyloader.js"
	    ];
	    this.files = function(value) {
	        if (!arguments.length)
	            return files;
	        files = value;
	        return this;
	    };
	
	    // ------------------------------
	    // parentWidth
	    // ------------------------------
	    
	    /**
	     * 父容器宽度，重写该方法因为本组件的父容器不是svg元素，无法用node().getBBox()方法获取尺寸
	     */
	    this.parentWidth = function() {
	        return self.parent() ? self.parent().clientWidth : 0;
	    };
	    
	    // ------------------------------
	    // parentHeight
	    // ------------------------------
	    
	    /**
	     * 父容器高度，重写该方法因为本组件的父容器不是svg元素，无法用node().getBBox()方法获取尺寸
	     */
	    this.parentHeight = function() {
	        return self.parent() ? self.parent().clientHeight : 0;
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // listeners
	    //
	    // --------------------------------------------------------------------------
	    
	    // --------------------------------------------------------------------------
	    //
	    // public Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    this.render = function() {
	        //等待第三方库加载完毕后，再操作render
	        self.isLibsLoaded = false;
	        loadLibs(afterLoadLibs);
	    };
	    
	    /**
	     * 渲染放置所有内容的最外层容器
	     */
	    this.renderMainContainer = function() {
	        if(self.mainContainer()) {
	            self.mainContainer().remove();
	        }
	        //设置传入父容器样式
	        var style = self.parent().style;
	        style.overflow = "hidden";
	        
	        //创建linkButton容器元素
	        var linkButton = d3.select(self.parent()).append("div")
	            .attr("class", self.className())
	            .attr("width", self.width())
	            .attr("height", self.height());
	        self.mainContainer(linkButton);
	        //先设置mainContainer，再检测组件是否可见
	        self.validateVisible();
	    };
	    
	    /**
	     * 渲染子容器
	     */
	    this.renderChildren = function() {
	        superRenderChildren();
	        
	        renderLinkButton();
	    };
	    
	    /**
	     * 渲染组件尺寸
	     */
	    this.renderSize = function() {
	        superRenderSize();
	        var linkButton = self.mainContainer();
	        if(!linkButton) {
	            return;
	        }
	        //设置图表容器大小
	        var w = self.width(), h = self.height();
	        linkButton.attr("width", w);
	        linkButton.attr("height", h);
	//        renderLinkButton();
	    };
	    
	    this.update = function() {
	        if(!self.isLibsLoaded) {
	            return;
	        }
	        superUpdate();
	        
	        renderLinkButton();
	    };
	    
	    /**
	     * 用于打印本对象的一些基本信息
	     */
	    this.toString = function() {
	        return ("LinkButton info: " +
	                "\n   width:"     + self.width()      + 
	                "\n   height:"    + self.height()     + 
	                "\n   data:"      + JSON.stringify(this.data(), null, 4));
	    };
	
	    // --------------------------------------------------------------------------
	    //
	    // private Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    var afterLoadLibs = function() {
	        self.isLibsLoaded = true;
	        superRender();
	    };
	    
	    var renderLinkButton = function() {
	        if(!self.isLibsLoaded) {
	            return;
	        }
	        //移除并重新创建表格顶层容器
	        self.renderMainContainer();
	        self.updateOthers();
	        
	        //渲染linkButton内容
	        var data = self.data().data;
	        var linkBtn = $(self.mainContainer().node());
	        Global.isDebug && console.log("easyloader:"+easyloader);
	        easyloader.load('linkbutton', function() {
				for(var d, i = 0, len = data.length; i < len; i++) {
					d = data[i];
					var a = document.createElement("a");
					linkBtn.append(a);
					$(a).linkbutton(d).bind("click", function() {
						var options = $(this).linkbutton('options');
						if(options.selected === true) {
							var evt = EventUtil.createCustomEvent(BaseEvent.NODE_CLICK, true, true, options);
							this.dispatchEvent(evt);
						}
					});
				}
			});
	    };
	    
	    var loadLibs = function(callback) {
	        var files = self.files();
	        Global.isDebug && console.log(files)
	        FileUtil.loadFiles(files, callback);
	    };
	    
	    self.init();
	};
	
	LinkButton.struct = function(ghca_charts) {
	    var BaseComponent = ghca_charts.view.component.baseComponent;
	    BaseComponent.struct(ghca_charts);
	    LinkButton.prototype = Object.create(BaseComponent.prototype);
	    LinkButton.prototype.constructor = LinkButton;
	};
	
	module.exports = LinkButton;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {var MultiTextLabel = function(_ele,_data){
		const BaseComponent = ghca_charts.view.component.baseComponent;
		const FileUtil = ghca_charts.view.util.fileUtil;
	    const RegexUtil = ghca_charts.view.util.regexUtil;
		BaseComponent.apply(this,[_data]);
		
	    var self = this,
		superRenderSize = self.renderSize,
	    superRender = self.render,
	    superUpdate = self.update,
	    superRenderChildren = self.renderChildren;
	    var multiTextLabelContainer;
	    var multiTextLabel;
		
		if (arguments.length < 1) {
	        throw new Error('传入参数个数错误,当前个数' + arguments.length + ",至少传入前1个参数。");
	    }
	    
	    if (typeof(_ele) == 'string') {
	        _ele = document.getElementById(_ele);
	    }
	    if (_ele) {
	        self.parent(_ele);
	    } else {
	        throw new Error('LinkButton构造方法中传入的容器_ele:' + _ele + "无法找到。");
		}
	    
	    
		self.isLibsLoaded = false;
		self.className("multiTextLabel");
		self.addAttributes("files");
		var files=[];
		this.files = function(value) {
	        if (!arguments.length)
	            return files;
	        files = value;
	        return this;
	    };
		/**
		 * 渲染
		 */
		this.render = function() {
			self.isLibsLoaded = false;
	        loadLibs(afterLoadLibs);
		}
		
		var loadLibs = function(callback) {
	        var files = self.files();
	        FileUtil.loadFiles(files, callback);
	    };
		
		var afterLoadLibs = function() {
	        self.isLibsLoaded = true;
	        superRender();
	    };
		
		  /**
	     * 渲染放置所有内容的最外层容器
	     */
	    this.renderMainContainer = function() {
	        if(self.mainContainer()) {
	            self.mainContainer().remove();
	        }
	        //设置传入父容器样式
	        var style = self.parent().style;
	        style.overflow = "hidden";
	        
	        //创建容器元素
	        multiTextLabelContainer = d3.select(self.parent()).append("div")
	        .attr("class", self.className()+"Container");          
	        self.multiTextLabel=multiTextLabelContainer.append("div").attr("class",self.className());
	        self.mainContainer(multiTextLabelContainer);
	        //先设置mainContainer，再检测组件是否可见
	        self.validateVisible();
	    };
		
		  /**
	     * 渲染子容器
	     */
	    this.renderChildren = function() {
	        superRenderChildren();
	        
	        renderTextLabel();
	    };
	    
	    /**
	     * 渲染组件尺寸
	     */
	    this.renderSize = function() {
	        superRenderSize();
	       
	        var multiTextLabelJQ = $(self.multiTextLabel.node());
	        var multiTextLabelContainerJq=$(multiTextLabelContainer.node());
	        multiTextLabelContainerJq.css("width","100%");
	        multiTextLabelContainerJq.css("height","100%");
	        var dataCfg = self.data();
	        var labelCss=dataCfg.styles.labelStyle;
	        multiTextLabelJQ.css("position","relative");
	        if(labelCss["horizontalAlign"]==="center"){//水平居中
	           multiTextLabelJQ.css("left",(multiTextLabelContainerJq.width()-multiTextLabelJQ.width())*0.5);
	        }else if(labelCss["horizontalAlign"]==="left"){
	           multiTextLabelJQ.css("left",0);
	        }else{
	           multiTextLabelJQ.css("left",multiTextLabelContainerJq.width()-multiTextLabelJQ.width());
	        }
	        if(labelCss["verticalAlign"]==="middle"){//垂直居中
	           multiTextLabelJQ.css("top",(multiTextLabelContainerJq.height()-multiTextLabelJQ.height())*0.5);
	        }else if(labelCss["verticalAlign"]==="top"){
	           multiTextLabelJQ.css("top",0);
	        }else{
	           multiTextLabelJQ.css("top",multiTextLabelContainerJq.height()-multiTextLabelJQ.height());
	        }
	    };
	    
	    this.update = function() {
	        if(!self.isLibsLoaded) {
	            return;
	        }
	        superUpdate();
	        
	        renderTextLabel();
	    };
	    
	    var renderTextLabel = function() {
	    	 if(!self.isLibsLoaded) {
	            return;
	        }
	    	self.renderMainContainer();
	        self.updateOthers();
	        if(!self.multiTextLabel){
	            return;
	        }
	         var multiTextLabelJQ = $(self.multiTextLabel.node());
	         var dataCfg = self.data();
	         var data=dataCfg.data[0];//因为后台数据必须是数组格式所以这儿只能这样
	         var formatCfg=dataCfg.label;
	         var dataValue=getItemValue(data,formatCfg.key);
	
	         var v=getResultLabel(formatCfg.labelFormat,dataValue,data);
	         var labelCss=dataCfg.styles.labelStyle;
	         multiTextLabelJQ.html(v);
	         var multiTextLabelContainerJq=$(multiTextLabelContainer.node());
	         var containerCss=getLabelContainerCss(dataCfg.styles);
	         multiTextLabelContainerJq.css(containerCss);
	         multiTextLabelJQ.css(labelCss);
	         self.renderSize();
	    }
	
	    function getLabelContainerCss(config){   
	        var result={};
	       for (var key in config) {
	           if (key!=="labelStyle") {
	                result[key]=config[key];
	           }
	       }
	        if(result["background-color"]){
	            var c=d3.color(result["background-color"]);
	            if(result["backGroundOpacity"]){
	                c.opacity=result["backGroundOpacity"];
	            }
	            result["background-color"]=c.toString();
	        }
	        return result;
	    }
	    
	    
	    var labelFormat = null;
	    this.labelFormat = function(value) {
	        if (!arguments.length) return labelFormat;
	        labelFormat = value;
	        return this;
	    }
	
	    var getItemValue = function(d, key) {
	    	var value = null;
	    	try {
	    		if(RegexUtil.jsRegex.test(key)) {
	    			value = key.replace(RegexUtil.jsRegex, function() {
	                    return arguments.length > 1 ?  eval(arguments[1]) : "";
	                });
	    		} else {
	    			value = key.indexOf(".") !== -1 ? eval("d." + key) : d[key];
	    		}
	    	} catch(e) {
	    		value = null;
	    	}
	    	return value;
	    }
	
	    /**
	     * 根据labelFormat获取最终label的方法
	     * @param label labelFormat
	     * @param value 替换内容，支持{#script#},其中script为js脚本内容；支持{v},相当于{#d[key]#}
	     * @param defaultResult 默认最终label
	     * @param date 所有项数据
	     * @param d 当前项数据
	     */
	    var getResultLabel = function(label, value, data) {
	    	(value === null || value === undefined) && (value = "");
	    	if(!label) {
	    		return value;
	    	}
	        var result = label.replace(/{v}/ig, value);
	        if(!data){
	            return "";
	        }
	        return result.replace(RegexUtil.jsRegex, function() {
	            return arguments.length > 1 ? eval(arguments[1]) : "";
	        });
	    }
		
		this.toString = function(){
	
		}
		
		    /**
	     * 父容器宽度，重写该方法因为本组件的父容器不是svg元素，无法用node().getBBox()方法获取尺寸 
	     */
	    this.parentWidth = function() {
	        return self.parent() ? self.parent().clientWidth : 0;
	    };
	    
	    // ------------------------------
	    // parentHeight
	    // ------------------------------
	    
	    /**
	     * 父容器高度，重写该方法因为本组件的父容器不是svg元素，无法用node().getBBox()方法获取尺寸
	     */
	    this.parentHeight = function() {
	        return self.parent() ? self.parent().clientHeight : 0;
	    };
	    
	    self.init();
	}
	
	MultiTextLabel.struct = function(ghca_charts){
		var BaseComponent = ghca_charts.view.component.baseComponent;
	    BaseComponent.struct(ghca_charts);
	    MultiTextLabel.prototype = Object.create(BaseComponent.prototype);
	    MultiTextLabel.prototype.constructor = MultiTextLabel;
	}
	
	module.exports=MultiTextLabel;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {var TextLabel = function(_ele,_data){
		const BaseComponent = ghca_charts.view.component.baseComponent;
		const FileUtil = ghca_charts.view.util.fileUtil;
		 const RegexUtil = ghca_charts.view.util.regexUtil;
		BaseComponent.apply(this,[_data]);
		
		var self = this,
		superRenderSize = self.renderSize,
	    superRender = self.render,
	    superUpdate = self.update,
	    superRenderChildren = self.renderChildren;
		
		if (arguments.length < 1) {
	        throw new Error('传入参数个数错误,当前个数' + arguments.length + ",至少传入前1个参数。");
	    }
	    
	    if (typeof(_ele) == 'string') {
	        _ele = document.getElementById(_ele);
	    }
	    if (_ele) {
	        self.parent(_ele);
	    } else {
	        throw new Error('LinkButton构造方法中传入的容器_ele:' + _ele + "无法找到。");
		}
	    
	    
		self.isLibsLoaded = false;
		self.className("textLabel");
		self.addAttributes("files");
		var files=[];
		this.files = function(value) {
	        if (!arguments.length)
	            return files;
	        files = value;
	        return this;
	    };
		/**
		 * 渲染
		 */
		this.render = function() {
			self.isLibsLoaded = false;
	        loadLibs(afterLoadLibs);
		}
		
		var loadLibs = function(callback) {
	        var files = self.files();
	        FileUtil.loadFiles(files, callback);
	    };
		
		var afterLoadLibs = function() {
	        self.isLibsLoaded = true;
	        superRender();
	    };
		
		  /**
	     * 渲染放置所有内容的最外层容器
	     */
	    this.renderMainContainer = function() {
	        if(self.mainContainer()) {
	            self.mainContainer().remove();
	        }
	        //设置传入父容器样式
	        var style = self.parent().style;
	        style.overflow = "hidden";
	        
	        //创建容器元素
	        var textLabel = d3.select(self.parent()).append("div")
	            .attr("class", self.className());          
	           
	        self.mainContainer(textLabel);
	        //先设置mainContainer，再检测组件是否可见
	        self.validateVisible();
	    };
		
		  /**
	     * 渲染子容器
	     */
	    this.renderChildren = function() {
	        superRenderChildren();
	        
	        renderTextLabel();
	    };
	    
	    /**
	     * 渲染组件尺寸
	     */
	    this.renderSize = function() {
	        superRenderSize();
	        var textLabel = self.mainContainer();
	        if(!textLabel) {
	            return;
	        }
	        //设置图表容器大小
	        var w = self.width(), h = self.height();
	        textLabel.attr("width", w);
	        textLabel.attr("height", h);
	        textLabel = $(self.mainContainer().node());
	        if(!textLabel) {
	            return;
	        }
	        $(textLabel).css("widht",w);
	        $(textLabel).css("height",h);
	    };
	    
	    this.update = function() {
	        if(!self.isLibsLoaded) {
	            return;
	        }
	        superUpdate();
	        
	        renderTextLabel();
	    };
	    
	    var renderTextLabel = function() {
	    	 if(!self.isLibsLoaded) {
	            return;
	        }
	    	self.renderMainContainer();
	        self.updateOthers();
	        
	         var textLabel = $(self.mainContainer().node());
	         var dataCfg = self.data();
	         var data=dataCfg.data[0];//因为后台数据必须是数组格式所以这儿只能这样
	         var formatCfg=dataCfg.label;
	         var dataValue=getItemValue(data,formatCfg.key);
	
	         var v=getResultLabel(formatCfg.labelFormat,dataValue,data);
	         $(textLabel).css(dataCfg.styles);
	//         console.log(v);
	         
	         $(textLabel).html(v);
	         
	         self.renderSize();
	    }
	    
	    
	    var labelFormat = null;
	    this.labelFormat = function(value) {
	        if (!arguments.length) return labelFormat;
	        labelFormat = value;
	        return this;
	    }
	
	    var getItemValue = function(d, key) {
	    	var value = null;
	    	try {
	    		if(RegexUtil.jsRegex.test(key)) {
	    			value = key.replace(RegexUtil.jsRegex, function() {
	                    return arguments.length > 1 ?  eval(arguments[1]) : "";
	                });
	    		} else {
	    			value = key.indexOf(".") !== -1 ? eval("d." + key) : d[key];
	    		}
	    	} catch(e) {
	    		value = null;
	    	}
	    	return value;
	    }
	
	    /**
	     * 根据labelFormat获取最终label的方法
	     * @param label labelFormat
	     * @param value 替换内容，支持{#script#},其中script为js脚本内容；支持{v},相当于{#d[key]#}
	     * @param defaultResult 默认最终label
	     * @param date 所有项数据
	     * @param d 当前项数据
	     */
	    var getResultLabel = function(label, value, data, d) {
	    	(value === null || value === undefined) && (value = "");
	    	if(!label) {
	    		return value;
	    	}
	    	var result = label.replace(/{v}/ig, value);
	        return result.replace(RegexUtil.jsRegex, function() {
	            return arguments.length > 1 ? eval(arguments[1]) : "";
	        });
	    }
		
		this.toString = function(){
	
		}
		
		    /**
	     * 父容器宽度，重写该方法因为本组件的父容器不是svg元素，无法用node().getBBox()方法获取尺寸 
	     */
	    this.parentWidth = function() {
	        return self.parent() ? self.parent().clientWidth : 0;
	    };
	    
	    // ------------------------------
	    // parentHeight
	    // ------------------------------
	    
	    /**
	     * 父容器高度，重写该方法因为本组件的父容器不是svg元素，无法用node().getBBox()方法获取尺寸
	     */
	    this.parentHeight = function() {
	        return self.parent() ? self.parent().clientHeight : 0;
	    };
	    
	    self.init();
	}
	
	TextLabel.struct = function(ghca_charts){
		var BaseComponent = ghca_charts.view.component.baseComponent;
	    BaseComponent.struct(ghca_charts);
	    TextLabel.prototype = Object.create(BaseComponent.prototype);
	    TextLabel.prototype.constructor = TextLabel;
	}
	
	module.exports=TextLabel;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {// svg类
		
	/**
	 * 构造方法 
	 * @param _ele 组件所在容器对象或者容器id，比如一个div
	 * @param _data 配置数据
	 * @param _layout 布局对象，不传就为默认布局
	 */
	var SVG = function(_ele, _data, _layout) {
		
	    // --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const BaseComponent = ghca_charts.view.component.baseComponent;
	    const ObjectUtil = ghca_charts.view.util.objectUtil;
	    const Global = ghca_charts.global;
	
	    BaseComponent.apply(this, arguments);
	    
	    var self = this, 
	        superRenderSize = self.renderSize,
	        superRender = self.render,
	        superRenderChildren = self.renderChildren;
	        
	    if (arguments.length < 1) {
	        throw new Error('传入参数个数错误,当前个数' + arguments.length + ",至少传入前1个参数。");
	    }
	    
	    if (typeof(_ele) == 'string') {
	        _ele = document.getElementById(_ele);
	    }
	    if (_ele) {
	    	self.parent(_ele);
	    } else {
	    	throw new Error('SVG构造方法中传入的容器_ele:' + _ele + "无法找到。");
	    }
	
	    // --------------------------------------------------------------------------
	    //
	    // Attributes
	    //
	    // --------------------------------------------------------------------------
	
	    //------------------------------
	    //  className
	    //------------------------------
	    
	    /**
	     * 类名称，默认作为该容器的css样式名称，比如<g class='mainContainer'>
	     */
	    this.className = function(){
	        return "svgContainer";
	    }
	    
	    // ------------------------------
	    // parentWidth
	    // ------------------------------
	    
	    /**
	     * 父容器宽度，重写该方法因为svg的父容器不是svg元素时，无法用node().getBBox()方法获取尺寸
	     */
	    this.parentWidth = function() {
	    	return ObjectUtil.isDomByTagName(self.parent(), "g") ? 
	    	   self.parent().getBBox().width : 
	    	   (self.parent() ? self.parent().clientWidth : 0);
	//        return self.parent() ? self.parent().clientWidth : 0;
	    };
	    
	    // ------------------------------
	    // parentHeight
	    // ------------------------------
	    
	    /**
	     * 父容器高度，重写该方法因为svg的父容器不是svg元素时，无法用node().getBBox()方法获取尺寸
	     */
	    this.parentHeight = function() {
	    	return ObjectUtil.isDomByTagName(self.parent(), "g") ? 
	           self.parent().getBBox().height : 
	           (self.parent() ? self.parent().clientHeight : 0);
	//        return self.parent() ? self.parent().clientHeight : 0;
	    };
	    
	    // ------------------------------
	    // toolTipDiv
	    // ------------------------------
	    
	    /**
	     * toolTip使用的div
	     */
	    var toolTipDiv = null;
	    this.toolTipDiv = function(value) {
	        if (!arguments.length) return toolTipDiv;
	        toolTipDiv = value;
	        return this;
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // listeners
	    //
	    // --------------------------------------------------------------------------
	    
	    // --------------------------------------------------------------------------
	    //
	    // public Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    /**
	     * 渲染放置所有内容的最外层容器
	     */
	    this.renderMainContainer = function() {
	        if(self.mainContainer()) {
	            self.mainContainer().remove();
	        }
	        //设置传入父容器样式
	        var style = self.parent().style;
	        style.overflow = "hidden";
	        
	        //默认svg元素把父容器填满
	        self.percentWidth(100);
	        self.percentHeight(100);
	        //创建svg元素
	        var svg = d3.select(self.parent()).append("svg")
	            .attr("class", self.className())
	            .attr("width", self.width())
	            .attr("height", self.height())
	            //禁止选择svg中的文本内容
	            .attr("style", "-webkit-touch-callout: none;" +
	                    "-webkit-user-select: none;" +
	                    "-khtml-user-select: none;" +
	                    "-moz-user-select: none;" +
	                    "-ms-user-select: none;" +
	                    "user-select: none;");
	        self.mainContainer(svg);
	    };
	    
	    /**
	     * 渲染子容器
	     */
	    this.renderChildren = function() {
	    	superRenderChildren();
	    	
	    	//渲染toolTip使用的div
	        renderToolTipDiv();
	    };
	    
	    /**
	     * 渲染组件尺寸
	     */
	    this.renderSize = function() {
	    	superRenderSize();
	        svg = self.mainContainer();
	        if(!svg) {
	            return;
	        }
	        svg.attr("width", self.width());
	        svg.attr("height", self.height());
	    };
	    
	    /**
	     * 销毁本类实例的方法
	     */
	    this.destroy = function() {
	        if(self.mainContainer()) {
	            self.mainContainer().remove();
	        }
	        var parentCon = d3.select(self.parent());
	        var divClass = "toolTip-container-" + self.graph().id();
	        parentCon.select("div." + divClass).remove();
	    };
	    
	    /**
	     * 用于打印本对象的一些基本信息
	     */
	    this.toString = function() {
	        return ("SVG info: " +
	                "\n   width:"     + self.width()      + 
	                "\n   height:"    + self.height()     + 
	                "\n   layout:"    + self.layout()     + 
	                "\n   data:"      + JSON.stringify(this.data(), null, 4));
	    };
	
	    // --------------------------------------------------------------------------
	    //
	    // private Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    /**
	     * 渲染toolTip使用的div，该div处于body之下
	     */
	    var renderToolTipDiv = function() {
	//    	var parentCon = d3.select("body");
	    	var parentCon = d3.select(self.parent());
	    	var divClass = "toolTip-container-" + self.graph().id();
	    	//判断是否已创建div
	    	if(parentCon.select("div." + divClass).node() !== null) {
	    		return;
	    	}
	    	//添加toolTip使用的div
	        var div = parentCon.append("div").attr("class", divClass);
	            
	        //默认样式
	        var style = div.node().style;
	        style.position          = "absolute";
	        style.display           = "none";
	        style.borderStyle       = "solid";
	        style.whiteSpace        = "nowrap";
	        style.transition        = "left 0.2s, top 0.2s";
	        style.backgroundColor   = "rgba(50, 50, 50, 0.498039)";
	        style.borderWidth       = "0px";
	        style.borderColor       = "rgb(51, 51, 51)";
	        style.borderRadius      = "4px";
	        style.color             = "rgb(255, 255, 255)";
	        style.fontFamily        = "微软雅黑, Arial, Verdana, sans-serif";
	        style.fontSize          = "12px";
	        style.padding           = "5px";
	        style.left              = "0px";
	        style.top               = "0px";
	        style.pointerEvents     = "none";
	        //发布到可视化平台中的tooltip强行设置textAlign为left,否则会被平台强行设置成center.
	        if(Global.isUseByEVPlatform) {
	        	style.textAlign     = "left";
	        }
	        
	        self.toolTipDiv(div);
	    };
	    
	};
	
	SVG.struct = function(ghca_charts) {
		var BaseComponent = ghca_charts.view.component.baseComponent;
		BaseComponent.struct(ghca_charts);
	    SVG.prototype = Object.create(BaseComponent.prototype);
	    SVG.prototype.constructor = SVG;
	};
	
	module.exports = SVG;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {/**
	 * SVG画板类
	 * 依赖项如下:
	 * <link rel="stylesheet" type="text/css" href="../js/window/jquery.msgbox.css"/>
	 * <link rel="Stylesheet" type="text/css" href="../js/jpicker-1.1.6/css/jpicker-1.1.6.min.css" />
	 * <script type="text/javascript" src="../js/window/jquery-latest.min.js"></script>
	 * <script type="text/javascript" src="../js/window/jquery.dragndrop.min.js"></script>
	 * <script type="text/javascript" src="../js/window/jquery.msgbox.js"></script>
	 * <script type="text/javascript" src="../js/raphael.min.js" charset="utf-8"></script>
	 * <script type="text/javascript" src="../js/d3.min.js" charset="utf-8"></script>
	 * <script type="text/javascript" src="../js/ghca_charts.js" charset="utf-8"></script>
	 * <script type="text/javascript" src="../js/jpicker-1.1.6/jpicker-1.1.6.js" charset="utf-8"></script>
	 * <script type="text/javascript" src="../data/svgCanvas.js" charset="utf-8"></script>
	 */
		
	/**
	 * 构造方法 
	 * @param _data 画板配置数据
	 * @param _layout 画板布局对象，不传就为默认布局
	 */
	var SvgCanvas = function(_data, _layout) {
		
		// --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const Const           = ghca_charts.view.util.constant;
	    const BaseComponent   = ghca_charts.view.component.baseComponent;
	    const BaseEvent       = ghca_charts.events.BaseEvent;
	    const SelectUtil      = ghca_charts.view.util.selectUtil;
	    const ObjectUtil      = ghca_charts.view.util.objectUtil;
	    const CommonUtil      = ghca_charts.view.util.commonUtil;
	    const SvgUtil         = ghca_charts.view.util.svgUtil;
	    const EventUtil       = ghca_charts.view.util.eventUtil;
	    const MouseUtil       = ghca_charts.view.util.mouseUtil;
	
		BaseComponent.apply(this, arguments);
		
	    var self = this, 
	        superInit = self.init,
	        superResize = self.resize,
	        superUpdate = self.update,
	        superRenderBackground = self.renderBackground,
	        superRenderChildren = self.renderChildren;
	        
	    var currentCon, currentPath, pasteNodes, pasteNodesPos,
	        isMouseDown = false,
	        isDrawSelect = false,//是否正在执行框选操作过程
	        isShowWindow = false,//是否显示弹出窗口
	        startX = 0,
	        startY = 0,
	        toolBarBtns = [],
	        clipboard = null,//剪切板内容
	        cloneTx = 0, 
	        cloneTy = 0,
	        fontFamilies = ["sans-serif", "serif", "宋体", "微软雅黑", "黑体", "幼圆", "Arial", "Verdana"],
	        fontSizes = [9, 10, 11, 12, 13, 14, 15, 18, 20, 25, 30, 40],
	        defaultFont = {fontFamily:"serif", fontSize:20, fontColor:"#000000"},
	        propertyBarHeight = 30,
	        colorPickerConfig = {
	            window:{
	            	title:"拖拽选择颜色",
	                expandable:true,
	                alphaSupport:true,
	                effects:{
	                    type:'slide', // effect used to show/hide an expandable picker. Acceptable values "slide", "show", "fade"
	                    speed:{
	                        show:'fast', // duration of "show" effect. Acceptable values are "fast", "slow", or time in ms
	                        hide:'fast' // duration of "hide" effect. Acceptable value are "fast", "slow", or time in ms
	                    }
	                },
	                position:{
	                  x:"20px", // acceptable values "left", "center", "right", "screenCenter", or relative px value
	                  y:"20px" // acceptable values "top", "bottom", "center", or relative px value
	                }
	            },
	            color: {
	                active:new $.jPicker.Color()
	            },
	            images: {
	                clientPath:'' // Path to image files
	            },
	            localization:{
	                text:{
	                    title:'拖拽选择颜色',
	                    newColor:'新',
	                    currentColor:'旧',
	                    ok:'确定',
	                    cancel:'取消'
	                }
	            }
	        };
	
	    self.className("svgCanvas");
	    //添加可从配置文件读取的属性名称
	    self.addAttributes("mode", "dragable", "iconPath", "jpickerPath");
	    
	    // --------------------------------------------------------------------------
	    //
	    // Attributes
	    //
	    // --------------------------------------------------------------------------
	    
	    //------------------------------
	    //  mode
	    //------------------------------
	    
	    /**
	     * 画板当前模式(默认值edit) normal|edit
	     */
	    var mode = "edit";
	    this.mode = function(value) {
	        if (!arguments.length) 
	            return mode;
	        if(mode !== value) {
	        	mode = value;
	            validateMode();
	        }
	        return this;
	    }
	    
	    //------------------------------
	    //  state
	    //------------------------------
	    
	    /**
	     * 画板当前状态(默认值select) normal|select|draw
	     */
	    var state = "select";
	    this.state = function(value) {
	        if (!arguments.length) 
	            return state;
	        state = value;
	        
	        if(state === "normal") {
	        	removeEditListeners();
	        	if(self.mode() === "normal") {
	        		removeDragListeners();
	                self.ownerSVG().bgNode().style.cursor = "";
	        	} else {
	        		addDragListeners();
	                self.ownerSVG().bgNode().style.cursor = "move";
	        	}
	            self.content.attr("pointer-events", "none");
	        } else {
	        	self.ownerSVG().bgNode().style.cursor = "";
	        	removeDragListeners();
	            addEditListeners();
	            if(state === "draw") {
	            	self.ownerSVG().bgNode().style.cursor = "crosshair";
	            	self.content.attr("pointer-events", "none");
	            } else {//select
	            	self.content.attr("pointer-events", "");
	            }
	        }
	        //移除选中相关渲染显示
	        if(state !== "select") {
	        	//清除上一次的选中状态
	            removeControlPoints();
	        }
	        //若没有选中元素，则隐藏属性栏
	        var selectedNodes = SelectUtil.getSelectedNodes();
	        if(!selectedNodes || selectedNodes.length === 0) {
	        	self.propertyBar.style("display", "none");
	        }
	        return this;
	    };
	    
	    //------------------------------
	    //  drawType
	    //------------------------------
	    
	    /**
	     * 画板处于draw状态时的类型(默认值null) null|pencil|line|polyline|rect|circle|ellipse|text|image
	     */
	    var drawType = null;
	    this.drawType = function(value) {
	        if (!arguments.length) 
	            return drawType;
	        drawType = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  dragable
	    //------------------------------
	    
	    /**
	     * 画板整体内容是否可以通过拖动鼠标移动(默认值true)
	     */
	    var dragable = true;
	    this.dragable = function(value) {
	        if (!arguments.length) 
	            return dragable;
	        dragable = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  iconPath
	    //------------------------------
	    
	    /**
	     * 图标资源路径
	     */
	    var iconPath = "../image/svg_canvas/";
	    this.iconPath = function(value) {
	        if (!arguments.length) 
	            return iconPath;
	        iconPath = value;
	        SelectUtil.iconPath(iconPath);
	        return this;
	    };
	    
	    //------------------------------
	    //  jpickerPath
	    //------------------------------
	    
	    /**
	     * jpicker路径
	     */
	    var jpickerPath = "../js/jpicker-1.1.6/";
	    this.jpickerPath = function(value) {
	        if (!arguments.length) 
	            return jpickerPath;
	        jpickerPath = value;
	        return this;
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // listeners
	    //
	    // --------------------------------------------------------------------------
	    
	    /**
	     * 监听外部抛出开启和关闭编辑模式的事件
	     */
	    var openEditHandler = function(evt) {
	        self.mode((evt || window.event).detail.data === true ? "edit" : "normal");
	    };
	    
	    /**
	     * 画板内容开始拖动平移监听处理方法
	     */
	    var dragStartHandler = function() {
	    	d3.event && d3.event.stopImmediatePropagation && d3.event.stopImmediatePropagation();
	        if(!self.dragable()) {
	            return;
	        }
	    };
	    
	    /**
	     * 画板内容拖动平移进行中监听处理方法
	     */
	    var dragHandler = function() {
	    	d3.event && d3.event.stopImmediatePropagation && d3.event.stopImmediatePropagation();
	        if(!self.dragable()) {
	            return;
	        }
	        var x = self.x(), y = self.y();
	        self.x(x+d3.event.dx);
	        self.y(y+d3.event.dy);
	        self.renderTransform();
	    };
	    
	    /**
	     * 整个画板缩放的监听相关处理方法，鼠标滚轮触发
	     */
	    var zoomHandler = function() {
	    	d3.event && d3.event.stopImmediatePropagation && d3.event.stopImmediatePropagation();
	    	var scaleType = self.scaleType();
	    	//判断是否开启缩放功能
	    	if(scaleType === Const.NO_SCALE_TYPE) {
	    		return;
	    	}
	    	//判断是否是对布局关系的缩放
	        var isLayoutZoom = self.scaleType() !== Const.COMPONENT_SCALE_TYPE;
	        if(isLayoutZoom) {
	        	
	        } else {
	        	self.zoom(d3.event.deltaY > 0);
	        }
	    };
	    
	    var keyDownHandler = function() {
	    	d3.event && d3.event.stopImmediatePropagation && d3.event.stopImmediatePropagation();
	    	//屏蔽moveArea容器响应事件
	    	enableMoveAreaEvents(false);
	    	//----ctrl组合按键----
	        if(d3.event.ctrlKey) {
	            switch(d3.event.keyCode) {
	                case 65://ctrl+a [select all nodes]
	                    selectAllNodes();
	                    return;
	                case 67://ctrl+c [copy nodes]
	                    copy();
	                    return;
	                case 88://ctrl+x [cut nodes]
	                    cut();
	                    return;
	                case 86://ctrl+v [paste nodes]
	                    paste();
	                    return;
	                default:
	                    break;
	            }
	        }
	        //----shift组合按键----
	        if(d3.event.shiftKey) {
	            switch(d3.event.keyCode) {
	                case 38://shift+up arrow [move up 1px]
	                    moveUp(1);
	                    return;
	                case 39://shift+right arrow [move right 1px]
	                    moveRight(1);
	                    return;
	                case 40://shift+down arrow [move down 1px]
	                    moveDown(1);
	                    return;
	                case 37://shift+left arrow [move left 1px]
	                    moveLeft(1);
	                    return;
	                default:
	                    break;
	            }
	        }
	    	//----单个按键----
	    	switch(d3.event.keyCode) {
	    		case 46://delete [delete selected nodes]
	                removeSelectedNodes();
	                break;
	            case 27://esc [clear up selected state]
	                //若当前显示弹出窗口，则先关闭弹出窗口
	                if(!isShowWindow) {
	                    //清除上一次的选中状态
	                    removeControlPoints();
	                }
	                break;
	            case 38://up arrow [move up 5px]
	                moveUp(5);
	                break;
	            case 39://right arrow [move right 5px]
	                moveRight(5);
	                break;
	            case 40://down arrow [move down 5px]
	                moveDown(5);
	                break;
	            case 37://left arrow [move left 5px]
	                moveLeft(5);
	                break;
	    		default:
	                break;
	    	}
	    };
	    
	    var keyUpHandler = function() {
	    	d3.event && d3.event.stopImmediatePropagation && d3.event.stopImmediatePropagation();
	    	//解除屏蔽moveArea容器响应事件
	        enableMoveAreaEvents(true);
	    };
	    
	    var doubleClickHandler = function() {
	    	d3.event && d3.event.stopImmediatePropagation && d3.event.stopImmediatePropagation();
	    	var target = d3.event.target;
	    	//双击弹出元素对应编辑窗口
	    	if(target.getAttribute("class") === "moveArea") {
	    		var nodes = SelectUtil.getSelectedNodes();
	    		if(nodes.length === 1) {
	    			var tagName = nodes[0].tagName;
	    			showEditWindow(tagName, nodes[0]);
	    		}
	    	}
	    };
	    
	    var updatePorpertiesHandler = function() {
	    	self.propertyBar.style("display", "block");
	    	refreshProperties(event.detail);
	    };
	    
	    var hiddenPorpertiesHandler = function() {
	    	self.propertyBar.style("display", "none");
	    };
	    
	    var transformChangeHandler = function() {
	    	var nodes = SelectUtil.getSelectedNodes();
	    	setTransform(nodes);
	    };
	    
	    var fillChangeHandler = function(color, context) {
	        var nodes = SelectUtil.getSelectedNodes();
	        var fill = getRgba(color.val('rgba'));
	        setFill(nodes, fill);
	    };
	    
	    var strokeChangeHandler = function(color, context) {
	        var nodes = SelectUtil.getSelectedNodes();
	        var stroke = getRgba(color.val('rgba'));
	        setStroke(nodes, stroke);
	    };
	    
	    var strokeWidthChangeHandler = function(color, context) {
	        var nodes = SelectUtil.getSelectedNodes();
	        var strokeWidth = parseFloat(d3.event.currentTarget.value);
	        setStrokeWidth(nodes, strokeWidth);
	    };
	    
	    var moveLayerUpHandler = function() {
	    	d3.event && d3.event.stopImmediatePropagation && d3.event.stopImmediatePropagation();
	    	var nodes = SelectUtil.getSelectedNodes();
	    	if(nodes.length === 1) {
	    		moveLayerUp(nodes[0]);
	    	}
	    };
	    
	    var moveLayerDownHandler = function() {
	    	d3.event && d3.event.stopImmediatePropagation && d3.event.stopImmediatePropagation();
	        var nodes = SelectUtil.getSelectedNodes();
	        if(nodes.length === 1) {
	            moveLayerDown(nodes[0]);
	        }
	    };
	    
	    var moveLayerTopHandler = function() {
	    	d3.event && d3.event.stopImmediatePropagation && d3.event.stopImmediatePropagation();
	    	var nodes = SelectUtil.getSelectedNodes();
	        if(nodes.length === 1) {
	            moveLayerTop(nodes[0]);
	        }
	    };
	    
	    var moveLayerBottomHandler = function() {
	    	d3.event && d3.event.stopImmediatePropagation && d3.event.stopImmediatePropagation();
	    	var nodes = SelectUtil.getSelectedNodes();
	        if(nodes.length === 1) {
	            moveLayerBottom(nodes[0]);
	        }
	    };
	    
	    var mouseDownHandler = function() {
	        d3.event && d3.event.stopImmediatePropagation && d3.event.stopImmediatePropagation();
	    	//点击画板背景和元素之外的地方，则不执行绘制操作
	    	var nodes = SelectUtil.getAllNodes();
	    	var isOnBg = d3.event.target === self.ownerSVG().bgRect.node();
	    	var isOnNode = nodes.indexOf(d3.event.target) !== -1;
	        if(!isOnBg && !isOnNode) {
	            return;
	        }
	        d3.select(window).on("mousemove.svgCanvas", mouseMoveHandler, false);
	        d3.select(window).on("mouseup.svgCanvas", mouseUpHandler, false);
	        isMouseDown = true;
	        
	        var m = MouseUtil.mouse(self.content.node(), self.graph());
	        startX = parseInt(m[0]);
	        startY = parseInt(m[1]);
	        if(state === "select") {
	        	//点击画板背景，执行框选过程
	        	if(isOnBg) {
	        		isDrawSelect = true;
	        		createSelectRect();
	        	} else if(isOnNode) {//点击元素
	        		doSelect([d3.event.target]);
	        	}
	        } else if(state === "draw") {
	        	if(self.drawType() === "pencil") {
	        		currentPath = d3.path();
	                currentPath.moveTo(startX, startY);
	                currentCon = self.content.append("path").attr("fill", "none").attr("stroke", "black");
	        	} else if(self.drawType() === "line") {
	        		currentCon = self.content.append("line").attr("fill", "none").attr("stroke", "black");
	        	} else if(self.drawType() === "polyline") {
	                currentCon = self.content.append("polyline").attr("fill", "none").attr("stroke", "black");
	            } else if(self.drawType() === "rect") {
	                currentCon = self.content.append("rect").attr("fill", "white").attr("stroke", "black");
	            } else if(self.drawType() === "circle") {
	                currentCon = self.content.append("circle").attr("fill", "white").attr("stroke", "black");
	            } else if(self.drawType() === "ellipse") {
	                currentCon = self.content.append("ellipse").attr("fill", "white").attr("stroke", "black");
	            } else if(self.drawType() === "text") {
	                currentCon = self.content.append("text")
	                    .attr("x", startX).attr("y", startY)
	                    .attr("text-anchor", "start")
	                    .attr("dy", defaultFont.fontSize-1)
	                    .attr("font-family", defaultFont.fontFamily)
	                    .attr("font-size", defaultFont.fontSize)
	                    .attr("stroke-width", 0)
	                    .attr("stroke", defaultFont.fontColor)
	                    .attr("fill", defaultFont.fontColor)
	                    .attr("opacity", 1)
	                    .text("双击编辑");
	            } else if(self.drawType() === "image") {
	                currentCon = self.content.append("image")
	                    .attr("x", startX).attr("y", startY)
	                    .attr("preserveAspectRatio", "none")//xMinYMin meet
	                    .attr("xlink:href", self.iconPath() + "image.svg");
	            }
	        }
	    };
	    
	    var mouseMoveHandler = function() {
	    	d3.event && d3.event.stopImmediatePropagation && d3.event.stopImmediatePropagation();
	        if(!isMouseDown) return;
	         
	        if(state === "select") {
	        	if(isDrawSelect) {
	        		drawSelectRect();
	        	}
	        } else if(state === "draw") {
	            var m = MouseUtil.mouse(self.content.node(), self.graph());
	            var mx = parseInt(m[0]);
	            var my = parseInt(m[1]);
	            if(self.drawType() === "pencil") {
	            	currentPath.lineTo(mx, my);
	                currentCon.attr("d", currentPath.toString());
	            } else if(self.drawType() === "line") {
	                currentCon.attr("x1", startX).attr("y1", startY).attr("x2", mx).attr("y2", my);
	            } else if(self.drawType() === "polyline") {
	            	var dx = mx - startX;
	            	var dy = my - startY;
	            	var isHor = Math.abs(dx) > Math.abs(dy);
	            	var cp = isHor ? Math.round(startX + dx / 2) : Math.round(startY + dy / 2);
	            	var points = isHor ? 
	                	[startX, startY, cp, startY, cp, my, mx, my] : 
	                	[startX, startY, startX, cp, mx, cp, mx, my];
	                currentCon.attr("points", points);
	            } else if(self.drawType() === "circle") {
	                currentCon.attr("cx", startX).attr("cy", startY)
	                    .attr("r", Math.floor(Math.sqrt(Math.pow(startX-mx, 2)+Math.pow(startY-my, 2))));
	            } else if(self.drawType() === "ellipse") {
	                var rw, rh, cx, cy;
	                if(mx < startX) {
	                    rw = (startX - mx) / 2;
	                    cx = mx + rw;
	                } else {
	                    rw = (mx - startX) / 2;
	                    cx = startX + rw;
	                }
	                if(my < startY) {
	                    rh = (startY - my) / 2;
	                    cy = my + rh;
	                } else {
	                    rh = (my - startY) / 2;
	                    cy = startY + rh;
	                }
	                currentCon.attr("cx", cx).attr("cy", cy).attr("rx", rw).attr("ry", rh);
	            } else if(self.drawType() === "text") {
	                currentCon.attr("x", startX).attr("y", startY);
	            } else {
	                var w, h, sx, sy;
	                if(mx < startX) {
	                    w = startX - mx;
	                    sx = mx;
	                } else {
	                    w = mx - startX;
	                    sx = startX;
	                }
	                if(my < startY) {
	                    h = startY - my;
	                    sy = my;
	                } else {
	                    h = my - startY;
	                    sy = startY;
	                }
	                currentCon.attr("x", sx).attr("y", sy).attr("width", w).attr("height", h);
	            }
	        }
	    };
	    
	    var mouseUpHandler = function() {
	    	d3.event && d3.event.stopImmediatePropagation && d3.event.stopImmediatePropagation();
	        d3.select(window).on("mousemove.svgCanvas", null);
	        d3.select(window).on("mouseup.svgCanvas", null);
	        isMouseDown = false;
	        
	        if(state === "select") {
	        	if(isDrawSelect) {
	        		drawSelect();
	        		isDrawSelect = false;
	        	}
	        } else if(state === "draw") {
	        	var currentNode = currentCon.node();
	            var box = currentNode.getBBox();
	            if((box.width === 0 || box.height === 0) && self.drawType() !== "text") {
	                currentCon.remove();
	            } else {
	            	SelectUtil.addNode(currentNode);
	            	refreshNodesLayer();
	            	doSelect([currentNode]);
	        		showEditWindow(self.drawType(), currentNode);
	            }
	        }
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // public Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    /**
	     * 刷新数据内容，生成需要的属性和相关值
	     */
	    this.refreshData = function() {
	        var data = self.data();
	        if(!data) {
	            return;
	        }
	        //从配置读取指定的属性值
	        var attrs = self.attributes();
	        if(attrs) {
	           for(var key, i = 0, len = attrs.length; i < len; i++) {
	                key = attrs[i];
	                if(self.hasOwnProperty(key) && data.hasOwnProperty(key)) {
	                    self[key](data[key]);
	                }
	            }
	        }
	    };
	    
	    /**
	     * 初始化方法
	     */
	    this.init = function() {
	        superInit();
	        
	        colorPickerConfig.images.clientPath = self.jpickerPath() + "images/";
	    };
	    
	    /**
	     * 初始化图表包含的各个层级
	     */
	    this.initAllContainers = function() {
	    	self.content = self.mainContainer().append("g").attr("class", "content");
	    	self.selectCon = self.mainContainer().append("g").attr("class", "select-container");
	    	initToolBar();
	    	initPropertyBar();
	    	self.state("select");
	    	self.addEventListener(BaseEvent.EV_EVENT_OPEN_EDIT, openEditHandler);
	    };
	    
	    //override
	    this.update = function() {
	    	self.refreshData();
	    	validateMode();
	    	superUpdate();
	        updateNodes();
	    };
	    
	    //override
	    this.addListeners = function() {
	    	if(!self.parent()) {
	            return;
	        }
	        //添加缩放监听
	        self.parent().mainContainer().on("wheel", zoomHandler);
	    };
	    
	    //override
	    this.renderBackground = function() {
	    	superRenderBackground();
	    	if(self.bgRect) {
	    		self.bgRect.attr("pointer-events", "none");
	    	}
	    };
	    
	    //override
	    this.renderChildren = function() {
	        superRenderChildren();
	        
	        //初始化图表包含的各个层级
	        self.initAllContainers();
	        //根据当前数据重新布局并且渲染内容
	        self.update();
	    };
	    
	    //override
	    this.resize = function() {
	        superResize();
	        
	        var style = self.propertyBar.node().style;
	        style.top = (self.ownerSVG().height() - propertyBarHeight) + "px";
	    };
	    
	    //override
	    this.toJSON = function(isData) {
	    	var str = "";
	    	var d = self.data();
	    	if(!d) {
	    		return str;
	    	}
	    	d.data = cloneNodes(SelectUtil.getAllNodes(), true, false);
	    	str = JSON.stringify(isData === true ? {data:d.data} : d);
	        return str;
	    };
	    
	    //override
	    this.toString = function() {
	        return ("BaseChart info: " +
	                "\n   width:"     + self.width()      + 
	                "\n   height:"    + self.height()     + 
	                "\n   data:"      + JSON.stringify(this.data(), null, 4));
	    };
	
	    // --------------------------------------------------------------------------
	    //
	    // private Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    /**
	     * 验证当前画板模式
	     */
	    var validateMode = function() {
	    	if(!self.parent()) {
	    		return;
	    	}
	        if(self.mode() === "edit") {
	            self.state("select");
	            self.propertyBar.node().style.visibility = "visible";
	            self.toolBar.node().style.visibility = "visible";
	        } else {
	            self.state("normal");
	            self.propertyBar.node().style.visibility = "hidden";
	            self.toolBar.node().style.visibility = "hidden";
	        }
	    };
	    
	    var initPropertyBar = function() {
	    	if(!self.ownerSVG() || !self.ownerSVG().parent()) {
	            return;
	        }
	        var svg = self.ownerSVG();
	        var parentCon = d3.select(svg.parent());
	        self.propertyBar = parentCon.insert("div", "div.toolTip-container").attr("class", "property-bar");
	        //背景默认样式
	        var style = self.propertyBar.node().style;
	        style.position = "absolute";
	        style.display = "block";
	        style.backgroundColor = "rgb(242,242,242)";
	        style.left = "0px";
	        style.top = (svg.height() - propertyBarHeight) + "px";
	        style.width = svg.width() + "px";
	        style.height = propertyBarHeight + "px";
	        
	        //x
	        var xLabel = self.propertyBar.append("div").text("x:").attr("style", "margin-left:5px;float:left;");
	        self.xText = xLabel.append("input").attr("type", "text").attr("title", "修改x坐标")
	            .attr("style", "width:50px;height:18px;margin-top:4px;margin-left:2px;")
	            .on("change", transformChangeHandler);
	        //y    
	        var yLabel = self.propertyBar.append("div").text("y:").attr("style", "margin-left:5px;float:left;");
	        self.yText = yLabel.append("input").attr("type", "text").attr("title", "修改y坐标")
	            .attr("style", "width:50px;height:18px;margin-top:4px;margin-left:2px;")
	            .on("change", transformChangeHandler);
	        //width    
	        var widthLabel = self.propertyBar.append("div").text("宽:").attr("style", "margin-left:10px;float:left;");
	        self.widthText = widthLabel.append("input").attr("type", "text").attr("title", "修改宽度")
	            .attr("style", "width:50px;height:18px;margin-top:4px;margin-left:2px;")
	            .on("change", transformChangeHandler);
	        //height    
	        var heightLabel = self.propertyBar.append("div").text("高:").attr("style", "margin-left:5px;float:left;");
	        self.heightText = heightLabel.append("input").attr("type", "text").attr("title", "修改高度")
	            .attr("style", "width:50px;height:18px;margin-top:4px;margin-left:2px;")
	            .on("change", transformChangeHandler);
	        //rotate    
	        var rotateLabel = self.propertyBar.append("div").text("旋转:").attr("style", "margin-left:10px;float:left;");
	        self.rotatetText = rotateLabel.append("input").attr("type", "text").attr("title", "修改旋转角度")
	            .attr("style", "width:50px;height:18px;margin-top:4px;margin-left:2px;")
	            .on("change", transformChangeHandler);
	            
	        //move up z-index    
	        var upZIndexLabel = self.propertyBar.append("div").text("层级:").attr("style", "margin-left:10px;float:left;");
	        self.upZIndexBtn = upZIndexLabel.append("input").attr("type", "button").attr("value", "↑")
	            .attr("style", "margin-top:4px;margin-left:2px;").attr("title", "向上移动一个层级")
	            .on("click", moveLayerUpHandler);
	        //move down z-index
	        var downZIndexLabel = self.propertyBar.append("div").text("").attr("style", "margin-left:5px;float:left;");
	        self.downZIndexBtn = downZIndexLabel.append("input").attr("type", "button").attr("value", "↓")
	            .attr("style", "margin-top:4px;margin-left:2px;").attr("title", "向下移动一个层级")
	            .on("click", moveLayerDownHandler);
	        //move top z-index
	        var topZIndexLabel = self.propertyBar.append("div").text("").attr("style", "margin-left:5px;float:left;");
	        self.topZIndexBtn = topZIndexLabel.append("input").attr("type", "button").attr("value", "⇧")
	            .attr("style", "margin-top:4px;margin-left:2px;").attr("title", "移动到顶层")
	            .on("click", moveLayerTopHandler);
	        //move bottom z-index
	        var bottomZIndexLabel = self.propertyBar.append("div").text("").attr("style", "margin-left:5px;float:left;");
	        self.bottomZIndexBtn = bottomZIndexLabel.append("input").attr("type", "button").attr("value", "⇩")
	            .attr("style", "margin-top:4px;margin-left:2px;").attr("title", "移动到底层")
	            .on("click", moveLayerBottomHandler);
	            
	        //fill color
	        var fillColorLabel = self.propertyBar.append("div").attr("style", "margin-left:10px;margin-top:4px;float:left;").attr("title", "修改填充色");
	        fillColorLabel.append("img").attr("src", self.iconPath() + "fill.svg").attr("align", "top").attr("style", "width:24px;height:24px;");
	        self.fillCp = fillColorLabel.append("span").attr("id", "fillColor")
	            .attr("style", "margin-left:2px;");
	        $('#fillColor').jPicker(colorPickerConfig, fillChangeHandler);
	        
	        //stroke color
	        var strokeColorLabel = self.propertyBar.append("div").attr("style", "margin-left:10px;margin-top:4px;float:left;").attr("title", "修改笔触色");
	        strokeColorLabel.append("img").attr("src", self.iconPath() + "stroke.svg").attr("align", "top").attr("style", "width:24px;height:24px;");
	        self.strokeCp = strokeColorLabel.append("span").attr("id", "strokeColor")
	            .attr("style", "margin-left:2px;");
	        $('#strokeColor').jPicker(colorPickerConfig, strokeChangeHandler);
	        
	        //stroke width
	        var strokeWidthLabel = self.propertyBar.append("div").attr("style", "margin-left:5px;float:left;");
	        self.strokeWidthText = strokeWidthLabel.append("input").attr("type", "text").attr("title", "修改笔触粗细")
	            .attr("style", "width:30px;height:18px;margin-top:4px;margin-left:2px;")
	            .on("change", strokeWidthChangeHandler);
	    };
	    
	    var getRgba = function(all) {
	    	var r = all && all.r || '0';
	        var g = all && all.g || '0';
	        var b = all && all.b || '0';
	        var a = all && all.a/255 || '0';
	        var color = "rgba(" + [r,g,b,a] + ")";
	        return color;
	    };
	    
	    var rgbaToColor = function(rgba) {
	    	if(rgba === null || rgba === undefined || rgba === "" || rgba === "none") {
	    		rgba = "rgba(0,0,0,0)";
	    	}
	    	var color = d3.color(rgba).rgb();
	    	color.r = isNaN(color.r) ? 0 : color.r;
	    	color.g = isNaN(color.g) ? 0 : color.g;
	    	color.b = isNaN(color.b) ? 0 : color.b;
	    	return {r:color.r, g:color.g, b:color.b, a:Math.floor(color.opacity*255)};
	    };
	    
	    var refreshProperties = function(node) {
	    	var data = node.__data__;
	    	self.xText.node().value = data.x;
	    	self.yText.node().value = data.y;
	    	self.widthText.node().value = data.width;
	    	self.heightText.node().value = data.height;
	    	self.rotatetText.node().value = data.rotate;
	    	
	    	var fill = node.getAttribute("fill");
	    	fill = rgbaToColor(fill);
	    	$('#fillColor')[0].color.active.val('rgba', fill);
	    	
	    	var stroke = node.getAttribute("stroke");
	        stroke = rgbaToColor(stroke);
	        $('#strokeColor')[0].color.active.val('rgba', stroke);
	        
	        var strokeWidth = node.getAttribute("stroke-width");
	    	strokeWidth = strokeWidth === null ? "1" : strokeWidth.replace("px", "");
	        self.strokeWidthText.node().value = strokeWidth;
	    };
	    
	    var setTransform = function(nodes) {
	    	if(!nodes ||　nodes.length > 1) {
	    		return;
	    	}
	    	var node = nodes[0];
	        var data = node.__data__;
	        var oldRects = [{x:data.x, y:data.y, width:data.width, height:data.height}];
	        data.x = parseFloat(self.xText.node().value);
	        data.y = parseFloat(self.yText.node().value);
	        data.width = parseFloat(self.widthText.node().value);
	        data.height = parseFloat(self.heightText.node().value);
	        data.rotate = parseFloat(self.rotatetText.node().value);
	        
	        var nodes = [node];
	        SelectUtil.validateNodes(nodes, oldRects);
	        removeControlPoints();
	        doSelect(nodes);
	    };
	    
	    var setFill = function(nodes, fill) {
	        if(!nodes ||　nodes.length > 1) {
	            return;
	        }
	        var node = nodes[0];
	        node.setAttribute("fill", fill);
	    };
	    
	    var setStroke = function(nodes, stroke) {
	        if(!nodes ||　nodes.length > 1) {
	            return;
	        }
	        var node = nodes[0];
	        node.setAttribute("stroke", stroke);
	    };
	    
	    var setStrokeWidth = function(nodes, strokeWidth) {
	        if(isNaN(strokeWidth) || !nodes ||　nodes.length > 1) {
	            return;
	        }
	        var node = nodes[0];
	        node.setAttribute("stroke-width", strokeWidth+"px");
	    };
	    
	    var initToolBar = function() {
	    	if(!self.ownerSVG()) {
	    		return;
	    	}
	    	var parentCon = self.ownerSVG().mainContainer();
	        self.toolBar = parentCon.append("g").attr("class", "toolbar");
	        self.toolBar.attr("transform", "translate(" + [5, 5] + ")");
	        var btnSize = 24, btnGap = 5;
	        toolBarBtns.push(addButton("normal_btn", btnSize, btnSize, self.iconPath() + "normal.png", "拖拽", false, true));
	        toolBarBtns.push(addButton("select_btn", btnSize, btnSize, self.iconPath() + "select.png", "选择", true, true));
	        toolBarBtns.push(addButton("pencil_btn", btnSize, btnSize, self.iconPath() + "pencil.png", "铅笔工具", false, true));
	        toolBarBtns.push(addButton("line_btn", btnSize, btnSize, self.iconPath() + "line.png", "直线", false, true));
	        toolBarBtns.push(addButton("polyline_btn", btnSize, btnSize, self.iconPath() + "polyline.png", "折线", false, true));
	        toolBarBtns.push(addButton("rect_btn", btnSize, btnSize, self.iconPath() + "rectangle.png", "矩形", false, true));
	        toolBarBtns.push(addButton("circle_btn", btnSize, btnSize, self.iconPath() + "circle.png", "圆形", false, true));
	        toolBarBtns.push(addButton("ellipse_btn", btnSize, btnSize, self.iconPath() + "ellipse.png", "椭圆", false, true));
	        toolBarBtns.push(addButton("text_btn", btnSize, btnSize, self.iconPath() + "text.png", "文字", false, true));
	        toolBarBtns.push(addButton("image_btn", btnSize, btnSize, self.iconPath() + "image.svg", "图片", false, true));
	        toolBarBtns.push(addButton("delete_btn", btnSize, btnSize, self.iconPath() + "delete.png", "删除", false, false));
	        toolBarBtns.push(addButton("save_btn", btnSize, btnSize, self.iconPath() + "save.png", "保存", false, false));
	        for(var btn, btnX = 0, i = 0, len = toolBarBtns.length; i < len; i++) {
	        	btn = toolBarBtns[i];
	        	btn.attr("transform", "translate(" + [btnX, 0] + ")");
	        	btnX += btnSize + btnGap;
	        }
	        var box = self.toolBar.node().getBBox();
	        self.toolBar.insert("rect", ".normal_btn").attr("class", "toolbar-bg")
	            .attr("x",-1)
	            .attr("y",-1)
	            .attr("width", box.width+2)
	            .attr("height", box.height+2)
	            .attr("rx", 4)
	            .attr("ry", 4)
	            .attr("fill", "white")
	            .attr("stroke", "#666");
	    };
	    
	    var addButton = function(className, w, h, imgUrl, title, selected, isToggle) {
	    	var toolBar = self.toolBar;
	    	var btn = toolBar.append("g").attr("class", className);
	    	btn.on("mouseover", function(){
	    		d3.event.stopImmediatePropagation();
	            bg.attr("stroke","red");
	        }, false);
	        btn.on("mouseout", function(){
	        	d3.event.stopImmediatePropagation();
	            bg.attr("stroke","none");
	        }, false);
	        btn.on("mousedown", function() {
	        	if(!isToggle) {
	        		d3.select(window).on("mouseup", function() {
	        			d3.event.stopImmediatePropagation();
	        			d3.select(window).on("mouseup", null);
	                    btn.select(".bg").attr("fill", "white");
	        		}, false);
	        	}
	        	var target = d3.select(d3.event.currentTarget);
	        	target.select(".bg").attr("fill", "#ccc");
	        	if(isToggle) {
	        		toolBarBtns.forEach(function(b){
	                    if(b.node() !== target.node()) {
	                        b.select(".bg").attr("fill", "white");
	                    }
	                });
	        	}
	            var className = target.attr("class");
	            if(className === "normal_btn") {
	            	self.state("normal");
	            } else if(className === "select_btn") {
	            	self.state("select");
	            } else if(className === "pencil_btn") {
	                self.state("draw");
	                self.drawType("pencil");
	            } else if(className === "line_btn") {
	                self.state("draw");
	                self.drawType("line");
	            } else if(className === "polyline_btn") {
	                self.state("draw");
	                self.drawType("polyline");
	            } else if(className === "rect_btn") {
	                self.state("draw");
	                self.drawType("rect");
	            } else if(className === "circle_btn") {
	                self.state("draw");
	                self.drawType("circle");
	            } else if(className === "ellipse_btn") {
	                self.state("draw");
	                self.drawType("ellipse");
	            } else if(className === "text_btn") {
	                self.state("draw");
	                self.drawType("text");
	            } else if(className === "image_btn") {
	                self.state("draw");
	                self.drawType("image");
	            } else if(className === "delete_btn") {
	                removeSelectedNodes();
	            } else if(className === "save_btn") {
	            	//向外部抛出保存数据
	            	self.node().dispatchEvent(EventUtil.createCustomEvent(
	            	   BaseEvent.EV_EVENT_DATA_STORAGE, true, true, {data:self.toJSON(true)}));
	            }
	            d3.event.stopImmediatePropagation();//避免点击按钮松开鼠标键后进入mouseUpHandler
	        });
	        var bg = btn.append("rect")
	            .attr("class", "bg")
	            .attr("x",0)
	            .attr("y",0)
	            .attr("width",w+2)
	            .attr("height",h+2)
	            .attr("stroke","none")
	            .attr("fill",selected ? "#ccc" : "white");    
	        if(imgUrl) {
	            var img = btn.append("image")
	                .attr("x",1)
	                .attr("y",1)
	                .attr("width",w)
	                .attr("height",h)
	                .attr("xlink:href",imgUrl)
	                .attr("pointer-events", "none");
	        }
	        if(title !== null || title !== undefined || title !== "") {
	            btn.append("title").text(title);
	        }
	        return btn;
	    };
	    
	    var addDragListeners = function() {
	        self.parent().mainContainer().call(d3.drag()
	            .on("start", dragStartHandler, false)
	            .on("drag", dragHandler, false)
	        );
	    };
	    
	    var removeDragListeners = function() {
	        self.parent().mainContainer().on("mousedown.drag", null, false);
	    };
	    
	    var addEditListeners = function() {
			self.parent().mainContainer().on("mousedown.svgCanvas", mouseDownHandler, false);
	        self.parent().mainContainer().on("dblclick.svgCanvas", doubleClickHandler, false);
	        d3.select(window).on("keydown.window", keyDownHandler, false);
	        d3.select(window).on("keyup.window", keyUpHandler, false);
	        self.ownerSVG().addEventListener(BaseEvent.UPDATE_PROPERTIES, updatePorpertiesHandler);
	        self.ownerSVG().addEventListener(BaseEvent.HIDDEN_PROPERTIES, hiddenPorpertiesHandler);
	    };
	    
	    var removeEditListeners = function() {
			self.parent().mainContainer().on("mousedown.svgCanvas", null, false);
	        self.parent().mainContainer().on("dblclick.svgCanvas", null, false);
	        d3.select(window).on("mousemove.svgCanvas", null, false);
	        d3.select(window).on("mouseup.svgCanvas", null, false);
	        self.ownerSVG().removeEventListener(BaseEvent.UPDATE_PROPERTIES, updatePorpertiesHandler);
	        self.ownerSVG().removeEventListener(BaseEvent.HIDDEN_PROPERTIES, hiddenPorpertiesHandler);
	    };
	    
	    /**
	     * 设置元素的innerHTML内容
	     */
	    var setInnerHTML = function(parent, html) {
	    	//除了chrome/firefox以外的svg不支持innerHTML
	    	if(CommonUtil.isChrome() || CommonUtil.isFirefox()) {
	    		parent.innerHTML = html;
	    	} else {
	    		var doc = new DOMParser().parseFromString(
	        		'<svg xmlns="http://www.w3.org/2000/svg">' + html + '</svg>', 'application/xml');
	            var svgChildNodes = doc.documentElement.childNodes;
	            for (var i = 0, length = svgChildNodes.length; i < length; i++) {
	                //这里索引设置为0是因为当node被添加到parent以后，会从doc中删除
	                parent.appendChild(svgChildNodes[0]);
	            }
	    	}
	    };
	    
	    /**
	     * 克隆节点数组
	     */
	    var cloneNodes = function(nodes, isCloneData, isCloneNode) {
	        if(!nodes) {
	            return null;
	        }
	        var result = [];
	        for(var i = 0, len = nodes.length; i < len; i++) {
	            var node = nodes[i];
	            var cloneNode;
	            if(isCloneData) {
	            	cloneNode = {};
	            	var html = node.outerHTML;
	                cloneNode.html = html;
	                var data = ObjectUtil.cloneObj(node.__data__);
	                data.tx += cloneTx;
	                data.ty += cloneTy;
	                cloneNode.data = data;
	                if(isCloneNode) {
	                	var cloneObj = node.cloneNode(true);
	                    cloneNode.node = cloneObj;
	                    cloneObj.__data__ = data;
	                }
	            } else {
	            	cloneNode = node.cloneNode(true);
	            	var data = ObjectUtil.cloneObj(node.__data__);
	            	cloneNode.__data__ = data;
	            }
	            
	            result.push(cloneNode);
	        }
	        return result;
	    };
	    
	    //粘贴的元素位置是否产生的变化
	    var isPasteNodesPosChanged = function() {
	        if(!pasteNodes || !pasteNodesPos || pasteNodes.length !== pasteNodesPos.length) {
	            return false;
	        }
	        var pos = getPasteNodesPos();
	        for(var i = 0, len = pasteNodesPos.length; i < len; i++) {
	            if(pos[i].x !== pasteNodesPos[i].x ||　pos[i].y !== pasteNodesPos[i].y) {
	                return true;    
	            }
	        }
	        return false;
	    };
	    
	    //获取当前粘贴元素的位置
	    var getPasteNodesPos = function() {
	        if(!pasteNodes) {
	            return null;
	        }
	        var pos = [];
	        for(var i = 0, len = pasteNodes.length; i < len; i++) {
	            pos.push(pasteNodes[i].getBBox());
	        }
	        return pos;
	    };
	    
	    var showEditWindow = function(type, node) {
	    	if(!node){
	            return;
	        }
	        if(type === "text") {
	            showTextEditWindow(node);
	        } else if(type === "image") {
	            showImageEditWindow(node);
	        }
	        isShowWindow = true;
	    };
	    
	    var showTextEditWindow = function(node) {
	    	var textContent = node.textContent;
	    	var color = node.getAttribute("fill");
	    	var family = node.getAttribute("font-family");
	    	var size = parseInt(node.getAttribute("font-size"));
	    	var familyOptions = "";
	        for(var i = 0, len = fontFamilies.length; i < len; i++) {
	            var fontFamily = fontFamilies[i];
	            familyOptions += '<option value="' + fontFamily + '"' + (fontFamily === family ? ' selected="selected"' : '') + '>' + fontFamily + '</option>';
	        }
	        var sizeOptions = "";
	        for(var i = 0, len = fontSizes.length; i < len; i++) {
	            var fontSize = fontSizes[i];
	            sizeOptions += '<option value="' + fontSize + '"' + (fontSize === size ? ' selected="selected"' : '') + '>' + fontSize + '</option>';
	        }
	        var htmlStr = '<div style="padding-left:10px;padding-top:10px;">' +
	            '<div style="float:left;width:100%;">文本内容: <input type="text" id="text_content" style="width:390px;height:18px;padding-left:2px;margin-bottom:10px;" value="' + textContent + '"/></div>' +
	            '<div style="float:left;width:100%;">字体类型: <select id="text_family" style="width:100px;border: 1px solid #3c99f7;margin-bottom:10px;">' + familyOptions + '</select></div>' + 
	            '<div style="float:left;width:100%;">字体大小: <select id="text_size" style="width:100px;border: 1px solid #3c99f7;">' + sizeOptions + '</select></div>' + '</div>';
	        var closeFn = function() {
	        	isShowWindow = false;
	            if(!this.getValue()) {
	               this.remove();
	               return;
	            }
	            var textContent = $.trim(document.getElementById("text_content").value);
	            var family = document.getElementById("text_family").value;
	            var size = document.getElementById("text_size").value;
	            this.remove();
	            
	            if(textContent === "") {
	                alert("请填写文本内容");
	                return;
	            }
	            //设置输入的文本内容
	            d3.select(node).text(textContent).attr("font-family", family).attr("font-size", size).attr("dy", size-1);
	            var nodes = [node];
	            var d = node.__data__;
	            var box = node.getBBox();
	            d.x = box.x;
	            d.y = box.y;
	            d.width = box.width;
	            d.height = box.height;
	            SelectUtil.validateNodes(nodes);
	            removeControlPoints();
	            doSelect(nodes);
	        };
	        //显示弹出窗口
	        new $.msgbox({
	            width:480,
	            height:180,
	            title: '编辑文本',
	            type:"custom",
	            content: htmlStr,
	            bgOpacity: .8,
	            cache:true,
	            onClose:closeFn
	        }).show();
	        
	        //设置默认输入焦点和选中文本
	        var timer = setTimeout(function() {
	        	clearTimeout(timer);
	        	var textContent = document.getElementById("text_content");
	        	if(textContent) {
	        		textContent.focus();
	        		textContent.select();
	        	}
	        }, 100);
	    };
	    
	    var showImageEditWindow = function(node) {
	    	var imageUrl = node.getAttribute("xlink:href");
	    	if(!ObjectUtil.isString(imageUrl)) {
	    		imageUrl = "";
	    	}
	        var htmlStr = '<div style="padding-left:10px;padding-top:10px;">' +
	            '图片地址: <input type="text" id="image_url" style="width:390px;height:18px;padding-left:2px;" value="' + imageUrl + '"/></div>';
	        var closeFn = function() {
	        	isShowWindow = false;
	            if(!this.getValue()) {
	               this.remove();
	               return;
	            }
	            var imageUrl = $.trim(document.getElementById("image_url").value);
	            this.remove();
	            
	            if(imageUrl === "") {
	                alert("请填写图片地址");
	                return;
	            }
	            
	            //设置输入的图片地址
	            d3.select(node).attr("xlink:href", imageUrl);
	            var nodes = [node];
	            SelectUtil.validateNodes(nodes);
	            removeControlPoints();
	            doSelect(nodes);
	        };
	        //显示弹出窗口
	        new $.msgbox({
	            width:480,
	            height:120,
	            title: '编辑图片',
	            type:"custom",
	            content: htmlStr,
	            bgOpacity: .8,
	            cache:true,
	            onClose:closeFn
	        }).show();
	        
	        //设置默认输入焦点和选中文本
	        var timer = setTimeout(function() {
	            clearTimeout(timer);
	            var imageUrl = document.getElementById("image_url");
	            if(imageUrl) {
	                imageUrl.focus();
	                imageUrl.select();
	            }
	        }, 100);
	    };
	    
	    //刷新所有阶段层级,update为true时更新所有节点z-index值
	    var refreshNodesLayer = function(update) {
	        var nodes = SelectUtil.getAllNodes();
	        SvgUtil.sortByZIndex(nodes, false);
	        if(update) {
	            for(var i = 0, len = nodes.length; i < len; i++) {
	                var node = nodes[i];
	                node.setAttribute("z-index", i);
	            }
	        }
	    };
	    
	    // --------------------------------------------------------------------------
	    // action Methods
	    // --------------------------------------------------------------------------
	    
	    /**
	     * 创建框选矩形
	     */
	    var createSelectRect = function() {
	        if(self.selectCon) {
	            var con = self.selectCon;
	            var rect = con.select("rect.select");
	            if(rect.node() === null) {
	                con.append("rect")
	                    .attr("class", "select")
	                    .attr("x", startX)
	                    .attr("y", startY)
	                    .attr("stroke", "#0078d7")
	                    .attr("stroke-width", 1)
	                    .attr("fill", "#0078d7")
	                    .attr("fill-opacity", 0.1);
	            }
	        }
	    };
	    
	    /**
	     * 绘制框选矩形
	     */
	    var drawSelectRect = function() {
	        if(self.selectCon) {
	            var con = self.selectCon;
	            var rect = con.select("rect.select");
	            if(rect.node()) {
	                var sx, sy, mp = MouseUtil.mouse(con.node(), self.graph());
	                if(mp[0] < startX) {
	                    w = startX - mp[0];
	                    sx = mp[0];
	                } else {
	                    w = mp[0] - startX;
	                    sx = startX;
	                }
	                if(mp[1] < startY) {
	                    h = startY - mp[1];
	                    sy = mp[1];
	                } else {
	                    h = mp[1] - startY;
	                    sy = startY;
	                }
	                rect.attr("x", sx).attr("y", sy)
	                    .attr("width", w).attr("height", h);
	            }
	        }
	    };
	    
	    /**
	     * 移除框选矩形
	     */
	    var removeSelectRect = function() {
	        if(self.selectCon) {
	            self.selectCon.select("rect.select").remove();
	        }
	    };
	    
	    /**
	     * 清除上一次的选中状态
	     */
	    var removeControlPoints = function() {
	        var nodes = SelectUtil.getAllNodes();
	        SelectUtil.removeControlPoints(self.selectCon.node());
	    }
	    
	    /**
	     * 移除所有元素
	     */
	    var removeAllNodes = function() {
	    	selectAllNodes();
	    	removeSelectedNodes();
	    };
	    
	    /**
	     * 移除所有框选的元素
	     */
	    var removeSelectedNodes = function() {
	        SelectUtil.removeSelectedNodes();
	        SelectUtil.removeControlPoints(self.selectCon.node());
	        refreshNodesLayer(true);
	        if(SelectUtil.getAllNodes().length === 0) {
	            cloneTx = 0; 
	            cloneTy = 0;
	            pasteNodes = null;
	            pasteNodesPos = null;
	        }
	    };
	    
	    /**
	     * 选择所有元素
	     */
	    var selectAllNodes = function() {
	    	removeControlPoints();
	    	
	    	var origNodes = SelectUtil.getAllNodes();
	    	var nodes = [];
	    	for(var i = 0, len = origNodes.length; i < len; i++) {
	    		nodes.push(origNodes[i]);
	    	}
	    	doSelect(nodes);
	    };
	    
	    /**
	     * 根据数据实例化元素
	     */
	    var addNodes = function(nodesData, isSelected) {
	    	if(!nodesData) {
	    		return;
	    	}
	    	var addedNodes = [], content = self.content.node();
	    	for(var i = 0, len = nodesData.length; i < len; i++) {
	            var cloneNode = nodesData[i];
	            var data = cloneNode.data;
	            var node = cloneNode.node ? cloneNode.node : cloneNode.html;
	            content.appendChild(node);
	            SelectUtil.addNode(node, data);
	            addedNodes.push(node);
	        }
	        SelectUtil.validateNodes(addedNodes);
	        refreshNodesLayer();
	        if(isSelected) {
	        	removeControlPoints();
	        	doSelect(addedNodes);
	        }
	        return addedNodes;
	    };
	    
	    /**
	     * 重新绘制所有元素
	     */
	    var updateNodes = function() {
	        removeAllNodes();
	        
	        if(!self.data()) {
	            return;
	        }
	        var nodesData = self.data().data;
	        if(!nodesData || nodesData.length === 0) {
	            return;
	        }
	        
	        var addedNodes = [], content = self.content.node();
	        var nodesHTML = "";
	        for(var i = 0, len = nodesData.length; i < len; i++) {
	            nodesHTML += nodesData[i].html;
	        }
	        setInnerHTML(content, nodesHTML);
	        var children = content.childNodes;
	        for(var i = 0, len = nodesData.length; i < len; i++) {
	            var node = children[i];
	            var data = nodesData[i].data;
	            SelectUtil.addNode(node, data);
	            addedNodes.push(node);
	        }
	        SelectUtil.validateNodes(addedNodes);
	        refreshNodesLayer();
	    };
	    
	    /**
	     * 复制元素
	     */
	    var copy = function() {
	        var selectedNodes = SelectUtil.getSelectedNodes();
	        if(selectedNodes.length === 0) {
	        	return;
	        }
	        cloneTx = 0; 
	        cloneTy = 0;
	        pasteNodes = null;
	        pasteNodesPos = null;
	        var nodes = cloneNodes(selectedNodes);
	        clipboard = nodes;
	    };
	    
	    /**
	     * 剪切元素
	     */
	    var cut = function() {
	        copy();
	        removeSelectedNodes();
	    };
	    
	    /**
	     * 粘贴元素
	     */
	    var paste = function() {
	    	if(!clipboard || clipboard.length === 0) {
	    		return;
	    	}
	    	if(!isPasteNodesPosChanged()) {
	    		cloneTx += 10; 
	            cloneTy += 10;
	    	}
	    	var nodesData = cloneNodes(clipboard, true, true);
	        pasteNodes = addNodes(nodesData, true);
	        pasteNodesPos = getPasteNodesPos();
	    };
	    
	    /**
	     * 向上移动选中的元素
	     */
	    var moveUp = function(moveStep) {
	    	SelectUtil.moveNodes(0, moveStep);
	    };
	    
	    /**
	     * 向右移动选中的元素
	     */
	    var moveRight = function(moveStep) {
	        SelectUtil.moveNodes(1, moveStep);
	    };
	    
	    /**
	     * 向下移动选中的元素
	     */
	    var moveDown = function(moveStep) {
	        SelectUtil.moveNodes(2, moveStep);
	    };
	    
	    /**
	     * 向左移动选中的元素
	     */
	    var moveLeft = function(moveStep) {
	        SelectUtil.moveNodes(3, moveStep);
	    };
	    
	    /**
	     * 画区域选择操作
	     */
	    var drawSelect = function() {
	        //获取所有框选区域中的元素
	        var rectNode = self.selectCon.select("rect.select").node();
	        var selectedNodes = SelectUtil.getSelectedNodesInBBox(rectNode.getBBox());
	        //执行选择操作
	        doSelect(selectedNodes);
	        //移除框选矩形
	        removeSelectRect();
	    };
	    
	    /**
	     * 执行选择操作
	     */
	    var doSelect = function(selectedNodes) {
	        if(d3.event && (d3.event.shiftKey || d3.event.ctrlKey)) {
	            var currentSelectedNodes = SelectUtil.getSelectedNodes();
	            for(var i = 0, len = currentSelectedNodes.length; i < len; i++) {
	                var node = currentSelectedNodes[i];
	                var index = selectedNodes.indexOf(node);
	                if(index === -1) {
	                    selectedNodes.push(node);
	                } else {
	                    selectedNodes.splice(index, 1);
	                }
	            }
	        }
	        //清除上一次的选中状态
	        SelectUtil.removeControlPoints(self.selectCon.node());
	        //显示当前选中元素的选中状态
	        SelectUtil.showControlPoints(self.selectCon.node(), selectedNodes, self.graph());
	        //屏蔽moveArea容器响应事件 
	        enableMoveAreaEvents(false)
	    };
	    
	    //在select状态，若按下shift或ctrl键，则屏蔽moveArea容器响应事件，这样才能选中被moveArea挡住的元素
	    var enableMoveAreaEvents = function(enabled) {
	        if(enabled) {
	            d3.select("rect.moveArea").attr("pointer-events", "");
	        } else if(state === "select" &&　d3.event && (d3.event.ctrlKey || d3.event.shiftKey)) {
	            d3.select("rect.moveArea").attr("pointer-events", "none");
	        }
	    };
	    
	    /**
	     * 把元素深度像下移动一个层级
	     */
	    var moveLayerDown = function(node) {
	        var zIndex = parseInt(node.getAttribute("z-index"));
	        if(zIndex === 0) {
	            return;
	        }
	        zIndex--;
	        var nodes = SelectUtil.getAllNodes();
	        for(var i = 0, len = nodes.length; i < len; i++) {
	            var n = nodes[i];
	            var nodeZIndex = parseInt(n.getAttribute("z-index"));
	            if(nodeZIndex === zIndex) {
	                n.setAttribute("z-index", zIndex+1);
	                break;
	            }
	        }
	        node.setAttribute("z-index", zIndex);
	        
	        refreshNodesLayer();
	    };
	    
	    /**
	     * 把元素深度像上移动一个层级
	     */
	    var moveLayerUp = function(node) {
	        var nodes = SelectUtil.getAllNodes();
	        var zIndex = parseInt(node.getAttribute("z-index"));
	        if(zIndex === nodes.length - 1) {
	            return;
	        }
	        zIndex++;
	        for(var i = 0, len = nodes.length; i < len; i++) {
	            var n = nodes[i];
	            var nodeZIndex = parseInt(n.getAttribute("z-index"));
	            if(nodeZIndex === zIndex) {
	                n.setAttribute("z-index", zIndex-1);
	                break;
	            }
	        }
	        node.setAttribute("z-index", zIndex);
	        
	        refreshNodesLayer();
	    };
	    
	    /**
	     * 把元素移动到最上面的层级
	     */
	    var moveLayerTop = function(node) {
	        var zIndex = parseInt(node.getAttribute("z-index"));
	        var nodes = SelectUtil.getAllNodes();
	        var maxIndex = nodes.length - 1;
	        if(nodes.length === 0 || zIndex === maxIndex) {
	            return;
	        }
	        nodes[maxIndex].setAttribute("z-index", zIndex);
	        node.setAttribute("z-index", maxIndex);
	        
	        refreshNodesLayer();
	    };
	    
	    /**
	     * 把元素移动到最下面的层级
	     */
	    var moveLayerBottom = function(node) {
	        var zIndex = parseInt(node.getAttribute("z-index"));
	        if(zIndex === 0) {
	            return;
	        }
	        var nodes = SelectUtil.getAllNodes();
	        nodes[0].setAttribute("z-index", zIndex);
	        node.setAttribute("z-index", 0);
	        
	        refreshNodesLayer();
	    };
	    
	    SvgCanvas.clazzName = "SvgCanvas";
	    self.init();
	};
	
	SvgCanvas.struct = function(ghca_charts) {
		var BaseComponent = ghca_charts.view.component.baseComponent;
		BaseComponent.struct(ghca_charts);
	    SvgCanvas.prototype = Object.create(BaseComponent.prototype);
	    SvgCanvas.prototype.constructor = SvgCanvas;
	};
	
	module.exports = SvgCanvas;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {// table类
	    
	/**
	 * 构造方法 
	 * @param _ele 组件所在容器对象或者容器id，比如一个div
	 * @param _data 配置数据
	 */
	var Table = function(_ele, _data) {
	    
	    // --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const BaseComponent = ghca_charts.view.component.baseComponent;
	    const FileUtil = ghca_charts.view.util.fileUtil;
	    const TableColFormatterUtil=ghca_charts.view.util.tableColFormatterUtil;
	
	    BaseComponent.apply(this, [_data]);
	    
	    var self = this, 
	        superRenderSize = self.renderSize,
	        superRender = self.render,
	        superUpdate = self.update,
	        superRenderChildren = self.renderChildren;
	        
	    if (arguments.length < 1) {
	        throw new Error('传入参数个数错误,当前个数' + arguments.length + ",至少传入前1个参数。");
	    }
	    
	    if (typeof(_ele) == 'string') {
	        _ele = document.getElementById(_ele);
	    }
	    if (_ele) {
	        self.parent(_ele);
	    } else {
	        throw new Error('Table构造方法中传入的容器_ele:' + _ele + "无法找到。");
	    }
	    
	    self.isLibsLoaded = false;
	    self.className("table");
	    //添加可从配置文件读取的属性名称
	    self.addAttributes("files");
	
	    // --------------------------------------------------------------------------
	    //
	    // Attributes
	    //
	    // --------------------------------------------------------------------------
	    
	    // ------------------------------
	    // files
	    // ------------------------------
	
	    /**
	     * 第三方库文件列表
	     */
	    var files = [
	        "../js/table/css/tabulator.min.css", 
	        "../js/window/jquery-latest.min.js",
	        "../js/table/js/jquery-ui.min.js",
	        "../js/table/js/moment.min.js",
	        "../js/table/js/jquery.sparkline.min.js",
	        "../js/table/js/tabulator.min.js"
	    ];
	    this.files = function(value) {
	        if (!arguments.length)
	            return files;
	        files = value;
	        return this;
	    };
	
	
	    // ------------------------------
	    // parentWidth
	    // ------------------------------
	    
	    /**
	     * 父容器宽度，重写该方法因为table的父容器不是svg元素，无法用node().getBBox()方法获取尺寸
	     */
	    this.parentWidth = function() {
	        return self.parent() ? self.parent().clientWidth : 0;
	    };
	    
	    // ------------------------------
	    // parentHeight
	    // ------------------------------
	    
	    /**
	     * 父容器高度，重写该方法因为table的父容器不是svg元素，无法用node().getBBox()方法获取尺寸
	     */
	    this.parentHeight = function() {
	        return self.parent() ? self.parent().clientHeight : 0;
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // listeners
	    //
	    // --------------------------------------------------------------------------
	    
	    // --------------------------------------------------------------------------
	    //
	    // public Methods
	    //
	    // --------------------------------------------------------------------------
	    
	
	    this.render = function() {
	    	//等待第三方库加载完毕后，再操作render
	    	self.isLibsLoaded = false;
	    	loadLibs(afterLoadLibs);
	    };
	    
	    /**
	     * 渲染放置所有内容的最外层容器
	     */
	    this.renderMainContainer = function() {
	        if(self.mainContainer()) {
	            self.mainContainer().remove();
	        }
	        //设置传入父容器样式
	        var style = self.parent().style;
	        style.overflow = "hidden";
	        
	        //创建table容器元素
	        var table = d3.select(self.parent()).append("div")
	            .attr("class", self.className())
	            .attr("width", self.width())
	            .attr("height", self.height());
	        self.mainContainer(table);
	        //先设置mainContainer，再检测组件是否可见
	        self.validateVisible();
	    };
	    
	    /**
	     * 渲染子容器
	     */
	    this.renderChildren = function() {
	        superRenderChildren();
	        
	        renderTable();
	    };
	    
	    /**
	     * 渲染组件尺寸
	     */
	    this.renderSize = function() {
	        superRenderSize();
	        var table = self.mainContainer();
	        if(!table) {
	            return;
	        }
	        //设置图表容器大小
	        var w = self.width(), h = self.height();
	        table.attr("width", w);
	        table.attr("height", h);
	        //设置图表内容大小
	        var tableConfig = self.data() && self.data().tableConfig;
	        if(tableConfig) {
	        	tableConfig.width = w;
	        	tableConfig.height = h;
	        	try {
	        		$(table.node()).tabulator("redraw", true);
	        	} catch(e) {
	        		console.log(e);
	        	}
	        }
	    };
	    
	    this.update = function() {
	    	if(!self.isLibsLoaded) {
	    		return;
	        }
	
	    	superUpdate();
	    	
	    	renderTable();
	    };
	    
	    /**
	     * 用于打印本对象的一些基本信息
	     */
	    this.toString = function() {
	        return ("Table info: " +
	                "\n   width:"     + self.width()      + 
	                "\n   height:"    + self.height()     + 
	                "\n   data:"      + JSON.stringify(this.data(), null, 4));
	    };
	
	    // --------------------------------------------------------------------------
	    //
	    // private Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    var afterLoadLibs = function() {
	        self.isLibsLoaded = true;
	        superRender();
	    };
	    
	    var renderTable = function() {
	    	if(!self.isLibsLoaded) {
	            return;
	        }
	        //移除并重新创建表格顶层容器
	        self.renderMainContainer();
	        self.updateOthers();
	        //渲染表格内容
	    	var table = self.mainContainer().node();
	        var data = self.data();
	        TableColFormatterUtil.parseFormatter(data.tableConfig,data.colFormatter);
	
	        var themePath=data.themeroot+data.theme;
	        FileUtil.replaceFile("custom_tabulator_theme",themePath,function(){
	            $(table).tabulator(data.tableConfig);
	            $(table).tabulator("setData", data.tableData); 
	            self.renderSize();
	        });
	        self.renderSize();
	    };
	    
	    var loadLibs = function(callback) {
	        var files = self.files();
	        FileUtil.loadFiles(files, callback);
	    };
	    
	    self.init();
	};
	
	Table.struct = function(ghca_charts) {
	    var BaseComponent = ghca_charts.view.component.baseComponent;
	    BaseComponent.struct(ghca_charts);
	    Table.prototype = Object.create(BaseComponent.prototype);
	    Table.prototype.constructor = Table;
	};
	
	module.exports = Table;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 60 */
/***/ (function(module, exports) {

	var TagContainer = function(_data, _layout) {
	
	    const BaseComponent = ghca_charts.view.component.baseComponent;
	    const ImageTag = ghca_charts.view.elements.plugins.imageTag;
	    const ElementUtil = ghca_charts.view.util.elementUtil;
	    
	    BaseComponent.apply(this, arguments);
	    
	    var imageTag;
	    var self = this,
	        superInit = self.init,
	        superRenderChildren = self.renderChildren;
	
	    self.className("tagComponent");
	
	    this.renderChildren = function() {
	        superRenderChildren();
	        var config = _data.config;
	        var container = self.mainContainer().append("g");
	        if(!imageTag){
	            imageTag = new ImageTag(container,null);
	        }
	        imageTag.config(config);
	        imageTag.render();
	        ElementUtil.setElementProperties(container,{transform:"translate("+[self.width()/2,imageTag.actualHeight()/2]+")"});
	    };
	    /**
	     * 初始化方法
	     */
	    this.init = function() {
	        superInit();
	    };
	
	};
	
	TagContainer.struct = function(ghca_charts) {
	    var BaseComponent = ghca_charts.view.component.baseComponent;
	    BaseComponent.struct(ghca_charts);
	    TagContainer.prototype = Object.create(BaseComponent.prototype);
	    TagContainer.prototype.constructor = TagContainer;
	};
	
	module.exports = TagContainer;

/***/ }),
/* 61 */
/***/ (function(module, exports) {

	/* 可视化平台专用数据分发器类,通过平台请求数据,本组件只负责数据分发
	*/
		
	/**
	 * 构造方法 
	 * @param _data 配置数据
	 */
	var EvDataDispatcher = function(_data) {
		
	    // --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const BaseComponent = ghca_charts.view.component.baseComponent;
	    const ObjectUtil = ghca_charts.view.util.objectUtil;
	    const BaseEvent = ghca_charts.events.BaseEvent;
	    const RegexUtil = ghca_charts.view.util.regexUtil;
	    const EventUtil = ghca_charts.view.util.eventUtil;
	    const Global = ghca_charts.global;
	
	    BaseComponent.apply(this, arguments);
	    
	    var self = this, 
	    	superSetDataAndUpdate = self.setDataAndUpdate,
	        superRender = self.render;
	        
	    //添加可从配置文件读取的属性名称
	    self.addAttributes();
	    //非可视化组件都为轻型组件
	    self.isLight(true);
	    
	    // --------------------------------------------------------------------------
	    //
	    // Attributes
	    //
	    // --------------------------------------------------------------------------
	
	    //------------------------------
	    //  className
	    //------------------------------
	    
	    /**
	     * 类名称，默认作为该容器的css样式名称，比如<g class='mainContainer'>
	     */
	    this.className = function() {
	        return "evDataSource";
	    }
	    
	    // ------------------------------
	    // parentWidth
	    // ------------------------------
	    
	    /**
	     * 父容器宽度，重写该方法因为svg的父容器不是svg元素时，无法用node().getBBox()方法获取尺寸
	     */
	    this.parentWidth = function() {
	    	return ObjectUtil.isDomByTagName(self.parent(), "g") ? 
	    	   self.parent().getBBox().width : 
	    	   (self.parent() ? self.parent().clientWidth : 0);
	    };
	    
	    // ------------------------------
	    // parentHeight
	    // ------------------------------
	    
	    /**
	     * 父容器高度，重写该方法因为svg的父容器不是svg元素时，无法用node().getBBox()方法获取尺寸
	     */
	    this.parentHeight = function() {
	    	return ObjectUtil.isDomByTagName(self.parent(), "g") ? 
	           self.parent().getBBox().height : 
	           (self.parent() ? self.parent().clientHeight : 0);
	    };
	    
	    //------------------------------
	    //  items
	    //------------------------------
	    
	    /**
	     * 关联项数据对象列表
	     */
	    var items = [];
	    this.items = function() {
	        return items;
	    }
	    
	    // --------------------------------------------------------------------------
	    //
	    // listeners
	    //
	    // --------------------------------------------------------------------------
	    
	    
	    // --------------------------------------------------------------------------
	    //
	    // public Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    /**
	     * 获取关联项
	     * @param id 关联组件id
	     * @return 返回查找到的关联项数据对象，若没有则反回null。
	     */
	    this.getItem = function(id) {
	    	if(id === undefined) {
	    		return null;
	    	}
	    	for(var i = 0, len = items.length; i < len; i++) {
	    		if(items[i].id === id) {
	    			return items[i];
	    		}
	    	}
	    	return null;
	    };
	    
	    /**
	     * 添加关联项
	     * @param item 关联项数据对象，格式为{id//关联组件id, name//关联组件名称, filter//数据过滤方法}
	     */
	    this.addItem = function(item) {
	    	if(!item) {
	    		return;
	    	}
	    	var existItem = self.getItem(item.id);
	    	if(existItem) {
	    		//更新
	    		for(var key in item) {
	    			existItem[key] = item[key];
	    		}
	    	} else {
	    		//添加
	    		items.push(item);
	    	}
	    };
	    
	    /**
	     * 删除关联项
	     * @param id 关联组件id
	     * @return 返回被删除的关联项数据对象，若没有则反回null。
	     */
	    this.removeItem = function(id) {
	    	if(id === undefined) {
	    		return null;
	    	}
	    	for(var i = 0, len = items.length; i < len; i++) {
	    		if(items[i].id === id) {
	    			return items.splice(i, 1);
	    		}
	    	}
	    };
	    
	    /**
	     * 删除所有关联项
	     */
	    this.removeAllItems = function() {
	    	items.length = 0;
	    };
	    
	    /**
	     * 检测关联项，若在当前舞台中不存在关联项对应的组件实例，则自动从关联项队列中删除该关联项
	     * @param existIds 当前舞台存在的组件实例，格式为[id,...,id//舞台中实际存在组件实例id]
	     */
	    this.checkItems = function(existIds) {
	    	for(var id, i = 0; i < items.length; i++) {
	    		id = items[i].id;
	    		if(existIds.indexOf(id) === -1) {
	    			items.splice(i, 1);
	    			i--;
	    		}
	    	}
	    };
	    
	    //override
	    this.render = function() {
	        superRender();
	        init();
	    };
	    
	    /**
	     * override 设置数据内容成功后更新组件内容
	     * @param value 数据内容，格式为：{data:[]}或者{nodes:[],links:[]}等
	     * @return 返回是否设置成功
	     */
	    this.setDataAndUpdate = function(value) {
	        var result;
	    	//数据请求失败,此时value参数平台约定传入为undefined
	    	if(value === undefined) {
	    		result = false;
	    	} else {
	    		//数据请求成功,更新数据
	        	result = superSetDataAndUpdate(value);
	        	//分发数据到关联组件
	        	dispatchData();
	    	}
	    	//抛出请求完毕事件
	    	var evt = EventUtil.createCustomEvent(BaseEvent.REQ_DATA_COMPLETE, true, true, getDispatchData());
	        self.node().dispatchEvent(evt);
	        
	    	return result;
	    };
	    
	    /**
	     * override 销毁本类实例的方法
	     */
	    this.destroy = function() {
	    	self.removeAllItems();
	        if(self.mainContainer()) {
	            self.mainContainer().remove();
	        }
	    };
	    
	    /**
	     * override 用于打印本对象的一些基本信息
	     */
	    this.toString = function() {
	        return ("EvDataDispatcher info: "    		+
	                "\n   data:"      		+ JSON.stringify(this.data(), null, 4));
	    };
	
	    // --------------------------------------------------------------------------
	    //
	    // private Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    var init = function() {
	    	Global.isDebug && console.log("evDataSource init");
	    	self.mainContainer().style("display", "none");
	    };
	    
	    var dispatchData = function() {
	    	
	    };
	    
	    var getDispatchData = function() {
	    	return {
	    		data:self.data() ? self.data().data : []
	    	};
	    };
	    
	    self.init();
	};
	
	EvDataDispatcher.struct = function(ghca_charts) {
		var BaseComponent = ghca_charts.view.component.baseComponent;
		BaseComponent.struct(ghca_charts);
		EvDataDispatcher.prototype = Object.create(BaseComponent.prototype);
		EvDataDispatcher.prototype.constructor = EvDataDispatcher;
	};
	
	//--------------------------------------------------------------------------
	//
	// Const
	//
	// --------------------------------------------------------------------------
	
	module.exports = EvDataDispatcher;

/***/ }),
/* 62 */
/***/ (function(module, exports) {

	/* timer类
	 支持接收事件BaseEvent.TIMER_CONTROL，参数为:
	{
		action:Timer.START|Timer.STOP|Timer.RESET|Timer.DESTROY,
		//以下属性在action为reset时设置才会有效
		isAutoStart:true|false, 
		delay:0(ms), 
		gap:1000(ms), 
		times:-1, 
		handle:function|string
	}
	*/
		
	/**
	 * 构造方法 
	 * @param _data 配置数据
	 * @param _layout 布局对象，不传就为默认布局
	 */
	var Timer = function(_data, _layout) {
		
	    // --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const BaseComponent = ghca_charts.view.component.baseComponent;
	    const ObjectUtil = ghca_charts.view.util.objectUtil;
	    const BaseEvent = ghca_charts.events.BaseEvent;
	    const RegexUtil = ghca_charts.view.util.regexUtil;
	    const EventUtil = ghca_charts.view.util.eventUtil;
	    const Global = ghca_charts.global;
	
	    BaseComponent.apply(this, arguments);
	    
	    const DEFAULT_GAP   		= 1000;	//ms
	    const DEFAULT_DELAY 		= 0;	//ms
	    const DEFAULT_TIMES 		= -1;	
	    const DEFAULT_IS_AUTO_START = true;	
	    
	    const resetkeys = ["isAutoStart", "delay", "gap", "times", "handle"];
	    
	    var timer, delayTimer,
	    	self = this, 
	        superRender = self.render;
	        
	    //添加可从配置文件读取的属性名称
	    self.addAttributes.apply(self, resetkeys);
	    //非可视化组件都为轻型组件
	    self.isLight(true);
	    
	    // --------------------------------------------------------------------------
	    //
	    // Attributes
	    //
	    // --------------------------------------------------------------------------
	
	    //------------------------------
	    //  className
	    //------------------------------
	    
	    /**
	     * 类名称，默认作为该容器的css样式名称，比如<g class='mainContainer'>
	     */
	    this.className = function() {
	        return "timer";
	    }
	    
	    // ------------------------------
	    // parentWidth
	    // ------------------------------
	    
	    /**
	     * 父容器宽度，重写该方法因为svg的父容器不是svg元素时，无法用node().getBBox()方法获取尺寸
	     */
	    this.parentWidth = function() {
	    	return ObjectUtil.isDomByTagName(self.parent(), "g") ? 
	    	   self.parent().getBBox().width : 
	    	   (self.parent() ? self.parent().clientWidth : 0);
	    };
	    
	    // ------------------------------
	    // parentHeight
	    // ------------------------------
	    
	    /**
	     * 父容器高度，重写该方法因为svg的父容器不是svg元素时，无法用node().getBBox()方法获取尺寸
	     */
	    this.parentHeight = function() {
	    	return ObjectUtil.isDomByTagName(self.parent(), "g") ? 
	           self.parent().getBBox().height : 
	           (self.parent() ? self.parent().clientHeight : 0);
	    };
	    
	    //------------------------------
	    //  isRunning
	    //------------------------------
	    
	    /**
	     * 获取计时器是否正在运行。
	     */
	    var isRunning = false;
	    this.isRunning = function() {
	        return isRunning;
	    };
	    
	    //------------------------------
	    //  currentTimes
	    //------------------------------
	    
	    /**
	     * 获取计时器当前运行次数。
	     */
	    var currentTimes = 0;
	    this.currentTimes = function() {
	    	return currentTimes;
	    };
	    
	    //------------------------------
	    //  isAutoStart
	    //------------------------------
	    
	    /**
	     * 是否在经过delay时间自动开启计时器，若为false，则在外界触发启动计时器后，同样经过delay时间后才开启计时器。(默认值true)
	     */
	    var isAutoStart = DEFAULT_IS_AUTO_START;
	    this.isAutoStart = function(value) {
	        if (!arguments.length) return isAutoStart;
	        isAutoStart = ObjectUtil.isBoolean(value) ? value : DEFAULT_IS_AUTO_START;
	        return this;
	    };
	    
	    //------------------------------
	    //  delay
	    //------------------------------
	    
	    /**
	     * 延时多少毫秒后开启计时器。(默认值0)
	     */
	    var delay = DEFAULT_DELAY;
	    this.delay = function(value) {
	        if (!arguments.length) return delay;
	        delay = ObjectUtil.isNumber(value) ? value : DEFAULT_DELAY;
	        return this;
	    };
	    
	    //------------------------------
	    //  gap
	    //------------------------------
	    
	    /**
	     * 计时器心跳间隔毫秒。(默认值1000)
	     */
	    var gap = DEFAULT_GAP;
	    this.gap = function(value) {
	        if (!arguments.length) return gap;
	        gap = ObjectUtil.isNumber(value) ? value : DEFAULT_GAP;
	        return this;
	    };
	    
	    //------------------------------
	    //  times
	    //------------------------------
	    
	    /**
	     * 计时器执行次数，-1代表无限次，0代表0次，正数代表计时器执行对应次数后自动停止。(默认值-1)
	     */
	    var times = DEFAULT_TIMES;
	    this.times = function(value) {
	        if (!arguments.length) return times;
	        times = ObjectUtil.isNumber(value) ? value : DEFAULT_TIMES;
	        return this;
	    };
	    
	    //------------------------------
	    //  handle
	    //------------------------------
	    
	    /**
	     * 计时器心跳执行方法，function|string("{##}"格式)。(默认值null)
	     */
	    var handle = null;
	    this.handle = function(value) {
	        if (!arguments.length) return handle;
	        handle = value;
	        return this;
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // listeners
	    //
	    // --------------------------------------------------------------------------
	    
	    var controlHandler = function(e) {
	    	self.action(e.detail.data);
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // public Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    //override
	    this.render = function() {
	        superRender();
	        init();
	    };
	    
	    /**
	     * 外部调用控制计时器方法
	     * @param d {
				action:Timer.START|Timer.STOP|Timer.RESET|Timer.DESTROY,
				//以下属性在action为reset时设置才会有效
				isAutoStart:true|false, 
				delay:0(ms), 
				gap:1000(ms), 
				times:-1, 
				handle:function|string
			}
	     */
	    this.action = function(d) {
	    	if(!d) return;
	    	var action = d.action;
	    	switch(action) {
	    		case Timer.START:
	    			self.start();
	    			break;
	    		case Timer.STOP:
	    			self.stop();
	    			break;
	    		case Timer.RESET:
	    			//刷新传入配置
	    			for(var key in d) {
	    				if(resetkeys.indexOf(key) !== -1) {
	    					self[key](d[key]);
	    				}
	    			}
	    			self.reset();
	    			break;
	    		case Timer.DESTROY:
	    			self.destroy();
	    			break;
	    	}
	    };
	    
	    /**
	     * 启动计时器
	     */
	    this.start = function() {
	    	//判断是否是可视化编辑器中的编辑页面，若是则禁止启动计时器
	    	if((Global.isUseByEVPlatform && Global.isEVPlatformEditPage) || isRunning) return;
	    	
	    	delayTimer = setTimeout(function() {
	    		clearTimeout(delayTimer);
	    		timer = setInterval(timerEventHandler, self.gap());
	    		/*	立即执行第一次，否正会再setInterval中过了gap时间才执行第一次,这里必须放到setInterval之后执行，
	    			比如times为1时，setInterval还没有建立，就达到最大次数，无法用clearInterval停止计时器
				*/
	    		timerEventHandler();
	    	}, self.delay());
	    	
	    	isRunning = true;
	    	
	    	//抛出注册的开始事件
	    	var evt = EventUtil.createCustomEvent(BaseEvent.TIMER_STRAT, true, true, getDispatchData());
	        self.node().dispatchEvent(evt);
	    };
	    
	    /**
	     * 停止计时器，所有状态重置
	     */
	    this.stop = function() {
	    	if(delayTimer !== undefined) {
	    		clearInterval(delayTimer);
	    	}
	    	if(timer !== undefined) {
	    		clearInterval(timer);
	    	}
	    	currentTimes = 0;
	    	isRunning = false;
	    	
	    	//抛出注册的停止事件
	    	var evt = EventUtil.createCustomEvent(BaseEvent.TIMER_STOP, true, true, getDispatchData());
	        self.node().dispatchEvent(evt);
	    };
	    
	    /**
	     * 停止后重新启动计时器，所有状态重置
	     */
	    this.reset = function() {
	    	self.stop();
	    	self.start();
	    };
	    
	    /**
	     * 销毁本类实例的方法
	     */
	    this.destroy = function() {
	    	removeListeners();
	        self.stop();
	        if(self.mainContainer()) {
	            self.mainContainer().remove();
	        }
	    };
	    
	    /**
	     * 用于打印本对象的一些基本信息
	     */
	    this.toString = function() {
	        return ("Timer info: "    		+
	        		"\n   isRunning:" 		+ self.isRunning() 		+ 
	        		"\n   currentTimes:" 	+ self.currentTimes() 	+ 
	                "\n   data:"      		+ JSON.stringify(this.data(), null, 4));
	    };
	
	    // --------------------------------------------------------------------------
	    //
	    // private Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    var init = function() {
	    	Global.isDebug && console.log("timer init");
	    	self.mainContainer().style("display", "none");
	    	self.isAutoStart() && self.times() !== 0 && self.start();
	    };
	    
	    var addListeners = function() {
	    	if(!self.node()) return;
	    	self.node().addEventListener(BaseEvent.TIMER_CONTROL, controlHandler)
	    };
	    
	    var removeListeners = function() {
	    	if(!self.node()) return;
	    	self.node().removeEventListener(BaseEvent.TIMER_CONTROL, controlHandler);
	    };
	    
	    var timerEventHandler = function() {
			currentTimes++;
			
			//执行配置中注册的handle
			var handle = self.handle();
			if(ObjectUtil.isFunction(handle)) {
				handle();
			} else if(ObjectUtil.isString(handle)) {
				formatStrFn(handle, self.data().data);
			}
			
			//抛出注册的心跳事件
			var evt = EventUtil.createCustomEvent(BaseEvent.TIMER_EVENT, true, true, getDispatchData());
	        self.node().dispatchEvent(evt);
	        
	        //判断是否超过设定次数，若超过则停止计时器
	        if(self.times() > 0 && currentTimes >= self.times()) {
	        	self.stop();
	        }
		};
	    
	    var getDispatchData = function() {
	    	return {
	    		currentTimes:self.currentTimes(),
	    		delay:self.delay(),
	    		gap:self.gap(),
	    		times:self.times(),
	    		data:self.data() ? self.data().data : []
	    	};
	    };
	    
	    var formatStrFn = function(str, d) {
	        return str.replace(RegexUtil.jsRegex, function() {
	            return arguments.length > 1 ? eval(arguments[1]) : "";
	        });
	    };
	    
	    self.init();
	};
	
	Timer.struct = function(ghca_charts) {
		var BaseComponent = ghca_charts.view.component.baseComponent;
		BaseComponent.struct(ghca_charts);
		Timer.prototype = Object.create(BaseComponent.prototype);
		Timer.prototype.constructor = Timer;
	};
	
	//--------------------------------------------------------------------------
	//
	// Const
	//
	// --------------------------------------------------------------------------
	
	Timer.START 	= "start";
	Timer.STOP 		= "stop";
	Timer.RESET 	= "reset";
	Timer.DESTROY 	= "destroy";
	
	module.exports = Timer;

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {var BaseElement = function (_g,_data) {
		
		// --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const BaseEvent = ghca_charts.events.BaseEvent;
	
	    this.dispatch = d3.dispatch("dataChanged");
	    this.svgElement = null;
	    var self  = this;
	    /**
	     * element数据，变更会产生“dataChanged事件 baseEvent(taret,data)
	     */
	    var data = _data;
	    this.data = function(value){
	        if (!arguments.length)
	            return data;
	        var changeFunc = function(){
	            data = value;
	            self.dispatch.call("dataChanged",this , new BaseEvent(self,{data:value}));
	        }
	        if(window._){
	            if(!_.isEqual(value,data)){//数据发生变更才发出变更事件
	                changeFunc();
	            }
	        }else{
	            changeFunc();
	        }
	        return this;
	    }
	    
	    /**
	     * 缓存外接矩形
	     */
	    var bBox = {x:0, y:0, width:0, height:0};
	    this.getBBox = function(value) {
	        return bBox;
	    };
	    this.resetBBox = function(x, y, width, height) {
	    	bBox.x =parseFloat(x);
	    	bBox.y = parseFloat(y);
	    	bBox.width = parseFloat(width);
	    	bBox.height = parseFloat(height);
	    };
	
	    this.style = function(name,value){
	        if(self.svgElement)
	            self.svgElement.style(name,value);
	    }
	    this.attribute = function(name,value){
	        if(self.svgElement)
	            self.svgElement.attr(name,value);
	    }
	    /**
	     * 渲染调用
	     */
	    this.render = function(){
	        var data = self.data();
	        for(var key in data) {
	            if(self.hasOwnProperty(key)) {
	                self[key](data[key]);
	            }
	        }
	        self.addListener("dataChanged",function(e){
	           self.dataChangeHandler(e); 
	        });
	    }
	    /**
	     * 数据变更
	     * @param event
	     */
	    this.dataChangeHandler = function(event){
	        
	    }
	    /**
	     * 渲染后的高度
	     * @returns {number}
	     */
	    this.elementHeight = function() {
	        return self.getBBox().height;
	    };
	    /**
	     * 渲染后的高度
	     * @returns {number}
	     */
	    this.elementWidth = function() {
	        return self.getBBox().width;
	    };
	    /**
	     * 自定义事件监听
	     * @returns {exports}
	     */
	    this.addListener = function() {
	        var value = self.dispatch.on.apply(self.dispatch, arguments);
	        return value === self.dispatch ? self : value;
	    };
	    /**
	     * 监听
	     */
	    this.on = function() {
	        if(self.svgElement)
	            self.svgElement.on.apply(self.svgElement,arguments);
	    };
	};
	
	BaseElement.struct = function(ghca_charts) {
	    BaseElement.prototype.constructor = BaseElement;
	};
	
	module.exports = BaseElement;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 64 */
/***/ (function(module, exports) {

	var CircleElement = function (_element,_data) {
		
		// --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const BaseElement = ghca_charts.view.elements.baseElement;
	
	    BaseElement.apply(this,arguments);
	    var self  = this;
	    self.svgElement = _element.append("circle");
	    var superRenderFunc = this.render;
	    /**
	     * border形状终结butt，round，square
	     */
	    var linecap="butt";
	    this.linecap = function(value){
	        if (!arguments.length)
	            return linecap;
	        linecap = value;
	        return this;
	    }
	
	
	    /**
	     * 透明度
	     * @type {number}
	     */
	    var opacity=1;
	    this.opacity = function(value){
	        if (!arguments.length)
	            return opacity;
	        opacity = value;
	        return this;
	    }
	    /**
	     * border透明度
	     * @type {number}
	     */
	    var borderOpacity=1;
	    this.borderOpacity = function(value){
	        if (!arguments.length)
	            return borderOpacity;
	        borderOpacity = value;
	        return this;
	    }
	    /**
	     * 圆点y default radius
	     * @type {number}
	     */
	    var cy;
	    this.cy = function(value){
	        if (!arguments.length)
	            return cy;
	        cy = value;
	        return this;
	    }
	
	
	    /**
	     * 圆点x default radius
	     * @type {number}
	     */
	    var cx;
	    this.cx = function(value){
	        if (!arguments.length)
	            return cx;
	        cx = value;
	        return this;
	    }
	    /**
	     * 半径
	     * @type {number}
	     */
	    var radius;
	    this.radius = function(value){
	        if (!arguments.length)
	            return radius;
	        radius = value;
	        return this;
	    }
	    /**
	     * 线宽
	     * @type {number}
	     */
	    var border = 0;
	    this.border = function(value){
	        if (!arguments.length)
	            return border;
	        border = value;
	        return this;
	    }
	    /**
	     * 线的间隔
	     * @type {number or %}
	     */
	    var dashoffset;
	    this.dashoffset = function(value){
	        if (!arguments.length)
	            return dashoffset;
	        dashoffset = value;
	        return this;
	    }
	    /**
	     * 线的段长 ary
	     * @type {string}
	     */
	    var dasharray;
	    this.dasharray = function(value){
	        if (!arguments.length)
	            return dasharray;
	        dasharray = value;
	        return this;
	    }
	    /**
	     * 边框颜色
	     * @type {string}
	     */
	    var borderColor="none";
	    this.borderColor = function(value){
	        if (!arguments.length)
	            return borderColor;
	        borderColor = value;
	        return this;
	    }
	    /**
	     * 背景颜色 默认无背景
	     * @type {string}
	     */
	    var color="none";
	    this.color = function(value){
	        if (!arguments.length)
	            return color;
	        color = value;
	        return this;
	    }
	    //override
	    this.render = function(){
	        superRenderFunc();
	        self.svgElement
	            .style("fill",self.color())
	            .style("fill-opacity",self.opacity())
	            .attr("r",self.radius());
	        if(self.border()!=0){
	            self.svgElement.style("stroke",self.borderColor())
	                .style("stroke-linecap",self.linecap())
	                .style("stroke-width",self.border())
	                .style("stroke-opacity",self.borderOpacity())
	            if(self.dasharray())
	                self.svgElement.style("stroke-dasharray",self.dasharray());
	            if(self.dashoffset())
	                self.svgElement.style("stroke-dashoffset",self.dashoffset());
	        }
	
	        self.cx()!=undefined?self.svgElement.style("cx",self.cx()):self.svgElement.style("cx",self.radius());
	        self.cy()!=undefined?self.svgElement.style("cy",self.cy()):self.svgElement.style("cy",self.radius());
	        
	        self.resetBBox(self.cx(), self.cy(), self.radius()*2, self.radius()*2);
	    }
	    //override
	    this.dataChangeHandler = function(event){
	         self.render();
	    }
	};
	
	CircleElement.struct = function(ghca_charts) {
		var BaseElement = ghca_charts.view.elements.baseElement;
		BaseElement.struct(ghca_charts);
	    CircleElement.prototype = Object.create(BaseElement.prototype);
	    CircleElement.prototype.constructor = CircleElement;
	};
	
	module.exports = CircleElement;

/***/ }),
/* 65 */
/***/ (function(module, exports) {

	var ImageElement = function (_element,_data) {
		
		// --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const BaseElement = ghca_charts.view.elements.baseElement;
	
	    BaseElement.apply(this,arguments);
	    var self  = this;
	    self.svgElement = _element.append("image");
	    var superRenderFunc = this.render;
	
	    /**
	     * 图片宽度
	     * @type {number}
	     */
	    var imageWidth=32;
	    this.imageWidth = function(value){
	        if (!arguments.length)
	            return imageWidth;
	        imageWidth = value;
	        return this;
	    }
	    /**
	     * 图片高度
	     * @type {number}
	     */
	    var imageHeight=32;
	    this.imageHeight = function(value){
	        if (!arguments.length)
	            return imageHeight;
	        imageHeight = value;
	        return this;
	    }
	    /**
	     * 图片链接地址
	     * @type {string}
	     */
	    var url=null;
	    this.url = function(value){
	        if (!arguments.length)
	            return url;
	        url = value;
	        return this;
	    }
	    /**
	     * 透明度
	     * @type {number}
	     */
	    var opacity=1;
	    this.opacity = function(value){
	        if (!arguments.length)
	            return opacity;
	        opacity = value;
	        return this;
	    }
	    //override
	    this.render = function(){
	        superRenderFunc();
	        
	        self.svgElement
	            .attr("x",-self.imageWidth()/2)
	            .attr("y",-self.imageHeight()/2)
	            .attr("width",self.imageWidth())
	            .attr("height",self.imageHeight())
	            .attr("xlink:href",self.url())
	            .style("opacity",self.opacity());
	            
	        self.resetBBox(-self.imageWidth()/2, -self.imageHeight()/2, self.imageWidth(), self.imageHeight());
	    }
	    //override
	    this.dataChangeHandler = function(event){
	         self.render();
	    }
	};
	
	ImageElement.struct = function(ghca_charts) {
		var BaseElement = ghca_charts.view.elements.baseElement;
		BaseElement.struct(ghca_charts);
	    ImageElement.prototype = Object.create(BaseElement.prototype);
	    ImageElement.prototype.constructor = ImageElement;
	};
	
	module.exports = ImageElement;

/***/ }),
/* 66 */
/***/ (function(module, exports) {

	var MuliTextElement = function (_element,_data) {
		
		// --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const BaseElement = ghca_charts.view.elements.baseElement;
	    const StringUtil = ghca_charts.view.util.stringUtil;
	
	    BaseElement.apply(this,arguments);
	    var self = this;
	    self.svgElement = _element.append("text");
	    var superRenderFunc = this.render;
	    /**
	     * 多行文本框文本
	     */
	    var text;
	    this.text = function(value){
	        if (!arguments.length)
	            return text;
	        text = value;
	        return this;
	    }
	    /**
	     * 显示最大行数，默认1行
	     */
	    var textLine = 1;
	    this.textLine = function(value){
	        if (!arguments.length)
	            return textLine;
	        textLine = value;
	        return this;
	    }
	    /**
	     * 字体大小
	     * @type {number}
	     */
	    var fontSize = 16;
	    this.fontSize = function(value){
	        if (!arguments.length)
	            return fontSize;
	        fontSize = value;
	        return this;
	    }
	    /**
	     * 字体样式
	     * @type {string}
	     */
	    var fontFamily = "宋体";
	    this.fontFamily = function(value){
	        if (!arguments.length)
	            return fontFamily;
	        fontFamily = value;
	        return this;
	    }
	    /**
	     * 字体颜色
	     * @type {string}
	     */
	    var color = "#000000";
	    this.color = function(value){
	        if (!arguments.length)
	            return color;
	        color = value;
	        return this;
	    }
	    /**
	     * text-decoration	是否带下划线。可选值有：none、underline、overline和line-through
	     * @type {string}
	     */
	    var textDecoration = "none";
	    this.textDecoration = function(value){
	        if (!arguments.length)
	            return textDecoration;
	        textDecoration = value;
	        return this;
	    }
	    /**
	     * stroke	文字的描边颜色。默认文字只有填充色，没有描边，添加描边将使文字变粗
	     */
	    var borderColor;
	    this.borderColor = function(value){
	        if (!arguments.length)
	            return borderColor;
	        borderColor = value;
	        return this;
	    }
	    /**
	     * stroke-width	文字描边的宽度
	     */
	    var border = 0;
	    this.border = function(value){
	        if (!arguments.length)
	            return border;
	        border = value;
	        return this;
	    }
	
	    /**
	     * 单行像素
	     * @type {string}
	     */
	    var width = 0;
	    this.width = function(value){
	        if (!arguments.length)
	            return width;
	        width = value;
	        return this;
	    }
	    
	    //override
	    this.render = function(){
	        superRenderFunc();
	        self.svgElement.style("font-size",self.fontSize())
	            .style("font-family",self.fontFamily())
	            .style("pointer-events","all")
	            .style("fill",self.color())
	            .style("text-decoration",self.textDecoration())
	            .style("stroke-width",self.border());
	        if(self.borderColor())
	            self.svgElement.style("stroke",self.borderColor());
	        self.svgElement.selectAll("*").remove();
	        var texts = StringUtil.splitByLine(self.text(),self.width(),self.fontSize(),self.textLine());
	        self.svgElement.selectAll("tspan")
	            .data(texts)
	            .enter()
	            .append("tspan")
	            .attr("x",0)
	            .attr("dy",self.fontSize())
	            .text(function(d){
	                return d;
	            });
	        
	        var rect = StringUtil.measureText(texts, self.fontSize(), self.fontFamily());
	        self.resetBBox(0, 0, rect.width, rect.height);
	    }
	    //override
	    this.dataChangeHandler = function(event){
	        self.render();
	    }
	};
	
	MuliTextElement.struct = function(ghca_charts) {
		var BaseElement = ghca_charts.view.elements.baseElement;
		BaseElement.struct(ghca_charts);
	    MuliTextElement.prototype = Object.create(BaseElement.prototype);
	    MuliTextElement.prototype.constructor = MuliTextElement;
	};
	
	module.exports = MuliTextElement;

/***/ }),
/* 67 */
/***/ (function(module, exports) {

	var PathElement = function (_element,_data) {
		
		// --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const BaseElement = ghca_charts.view.elements.baseElement;
	
	    BaseElement.apply(this,arguments);
	    var self  = this;
	    self.svgElement = _element.append("path");
	    var superRenderFunc = this.render;
	    /**
	     * border形状终结butt，round，square
	     */
	    var linecap="butt";
	    this.linecap = function(value){
	        if (!arguments.length)
	            return linecap;
	        linecap = value;
	        return this;
	    }
	
	
	    /**
	     * 透明度
	     * @type {number}
	     */
	    var opacity=1;
	    this.opacity = function(value){
	        if (!arguments.length)
	            return opacity;
	        opacity = value;
	        return this;
	    }
	    /**
	     * border透明度
	     * @type {number}
	     */
	    var borderOpacity=1;
	    this.borderOpacity = function(value){
	        if (!arguments.length)
	            return borderOpacity;
	        borderOpacity = value;
	        return this;
	    }
	
	    var path = "";
	    this.path = function(){
	        if (!arguments.length)
	            return path;
	        path = arguments[0];
	        return this;
	    }
	
	    /**
	     * 线宽
	     * @type {number}
	     */
	    var border = 0;
	    this.border = function(value){
	        if (!arguments.length)
	            return border;
	        border = value;
	        return this;
	    }
	    /**
	     * 线的间隔
	     * @type {number or %}
	     */
	    var dashoffset;
	    this.dashoffset = function(value){
	        if (!arguments.length)
	            return dashoffset;
	        dashoffset = value;
	        return this;
	    }
	    /**
	     * 线的段长 ary
	     * @type {string}
	     */
	    var dasharray;
	    this.dasharray = function(value){
	        if (!arguments.length)
	            return dasharray;
	        dasharray = value;
	        return this;
	    }
	    /**
	     * 边框颜色
	     * @type {string}
	     */
	    var borderColor="none";
	    this.borderColor = function(value){
	        if (!arguments.length)
	            return borderColor;
	        borderColor = value;
	        return this;
	    }
	    /**
	     * 背景颜色 默认无背景
	     * @type {string}
	     */
	    var color="none";
	    this.color = function(value){
	        if (!arguments.length)
	            return color;
	        color = value;
	        return this;
	    }
	    //override
	    this.render = function(){
	        superRenderFunc();
	
	        self.svgElement.style("stroke",self.borderColor())
	            .style("stroke-linecap",self.linecap())
	            .style("stroke-width",self.border())
	            .style("stroke-opacity",self.borderOpacity())
	            .style("fill",self.color())
	            .style("fill-opacity",self.opacity())
	            .attr("d",self.path());
	        if(self.dasharray())
	            self.svgElement.style("stroke-dasharray",self.dasharray());
	        if(self.dashoffset())
	            self.svgElement.style("stroke-dashoffset",self.dashoffset());
	    }
	    //override
	    this.dataChangeHandler = function(event){
	        self.render();
	    }
	};
	
	PathElement.struct = function(ghca_charts) {
		var BaseElement = ghca_charts.view.elements.baseElement;
		BaseElement.struct(ghca_charts);
	    PathElement.prototype = Object.create(BaseElement.prototype);
	    PathElement.prototype.constructor = PathElement;
	};
	
	module.exports = PathElement;

/***/ }),
/* 68 */
/***/ (function(module, exports) {

	var ImageTag = function (_element,_data) {
	
	    // --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	
	    const Plugin = ghca_charts.view.elements.plugins.plugin;
	    const ImageElement = ghca_charts.view.elements.imageElement;
	    const MulitextElement = ghca_charts.view.elements.mulitextElement;
	
	    Plugin.apply(this,arguments);
	    var self = this;
	    var textElements = [],imageElement;
	
	    self.config({
	        image:{},
	        text:{}
	    });
	
	    //override
	    this.nameSpace = function(){
	        return "imageTag";
	    }
	
	    //override
	    this.update = function(g){
	
	    }
	    //override
	    this.drawPlugin = function(g){
	        var config = self.config();
	        var textContainer = g.append("g");
	        config.text.forEach(function(config){
	            var w = textContainer.node().getBBox().width;
	            var h = textContainer.node().getBBox().height;
	            var mulitextElement = new MulitextElement(textContainer,config);
	            mulitextElement.render();
	            mulitextElement.attribute("transform","translate("+[w,-h/2]+")");
	            textElements.push(mulitextElement);
	        });
	        var icfg = config.image;
	        icfg = this.width
	        imageElement = new ImageElement(g,config.image);
	        imageElement.render();
	        textContainer.attr("transform","translate("+[-textContainer.node().getBBox().width/2,imageElement.elementHeight()/2+10]+")");
	    }
	};
	
	ImageTag.struct = function(ghca_charts) {
	    var Plugin = ghca_charts.view.elements.plugins.plugin;
	    Plugin.struct(ghca_charts);
	    ImageTag.prototype = Object.create(Plugin.prototype);
	    ImageTag.prototype.constructor = ImageTag;
	};
	
	module.exports = ImageTag;

/***/ }),
/* 69 */
/***/ (function(module, exports) {

	var BaseLabel = function (_element,_data,_parent) {
		
	    // --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const ElementUtil = ghca_charts.view.util.elementUtil;
	    const ObjectUtil = ghca_charts.view.util.objectUtil;
	    const Plugin = ghca_charts.view.elements.plugins.plugin;
	    const RegexUtil = ghca_charts.view.util.regexUtil;
	
	    Plugin.apply(this,arguments);
	    var self = this,rect,text,
	        superNameSpaceFunction = this.nameSpace,
	        superDrawPluginFunction = this.drawPlugin,
	        superBindEventsFunction = this.bindEvents;
	
	    //override
	    this.nameSpace = function(){
	        return "baseLabel";
	    }
	    //override
	    this.actualWidth = function(){
	        return Number(rect.attr("width"));
	    }
	    //override
	    this.actualHeight = function(){
	        return Number(rect.attr("height"));
	    }
	    //override
	    this.drawPlugin = function(g){
	        superDrawPluginFunction(g);
	      /*  g.each(function (d) {
	            rect =  ElementUtil.createRect(g,d.backGroundProperties);
	            text   = ElementUtil.createText(g,d.labelProperties);
	            text.text(d.name);
	            var width = text.node().getBBox().width;
	            var height = text.node().getBBox().height;
	            ElementUtil.setElementProperties(rect,{x:-width/2,y:-height/2,width:width,height:height,rx:2,ry:2});
	            ElementUtil.setElementProperties(text,{"text-anchor":"middle","dy":"0.31em"});
	        });*/
	        rect = ElementUtil.createRect(g,_data.backGroundProperties);
	        text = ElementUtil.createText(g,_data.labelProperties);
	        text.text(_data.name);
	        ElementUtil.setElementProperties(text,{"text-anchor":"middle","dy":"0.31em"});
	        var box = text.node().getBBox();
	        var width = box.width;
	        var height = box.height;
	        ElementUtil.setElementProperties(rect,{x:-width/2,y:-height/2,width:width,height:height,rx:2,ry:2});
	        if(_data.labelProperties && _parent) {
	        	for(var key in _data.labelProperties) {
	            	var value = _data.labelProperties[key];
	            	text.attr(key, ObjectUtil.isString(value) ? formatStr(value, _parent.data()) : value);
	    		}
	        }
	    }
	    
	    //override
	    this.update = function(d) {
	    	if(d) {
	    		_data = d;
	    	}
	    	if(!text) return;
	    	text.text(_data.name);
	    	ElementUtil.setElementProperties(text,_data.labelProperties);
	        ElementUtil.setElementProperties(text,{"text-anchor":"middle","dy":"0.31em"});
	        ElementUtil.setElementProperties(rect,_data.backGroundProperties);
	        var box = text.node().getBBox();
	        var width = box.width;
	        var height = box.height;
	        ElementUtil.setElementProperties(rect,{x:-width/2,y:-height/2,width:width,height:height,rx:2,ry:2});
	        if(_data.labelProperties && _parent) {
	        	for(var key in _data.labelProperties) {
	            	var value = _data.labelProperties[key];
	            	text.attr(key, ObjectUtil.isString(value) ? formatStr(value, _parent.data()) : value);
	    		}
	        }
	    }
	
	    //override
	    this.bindEvents = function(g){
	        superBindEventsFunction(g);
	    }
	    
	    var formatStr = function(str, d) {
	        return str.replace(RegexUtil.jsRegex, function() {
	            return arguments.length > 1 ? eval(arguments[1]) : "";
	        });
	    };
	};
	
	BaseLabel.struct = function(ghca_charts) {
		var Plugin = ghca_charts.view.elements.plugins.plugin;
		Plugin.struct(ghca_charts);
	    BaseLabel.prototype = Object.create(Plugin.prototype);
	    BaseLabel.prototype.constructor = BaseLabel;
	};
	
	module.exports = BaseLabel;

/***/ }),
/* 70 */
/***/ (function(module, exports) {

	var GroupLabel = function (_element,_data) {
		
	    // --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const ElementUtil = ghca_charts.view.util.elementUtil;
	    const Plugin = ghca_charts.view.elements.plugins.plugin;
	
	    Plugin.apply(this,arguments);
	    var self = this,rect,text,
	        superNameSpaceFunction = this.nameSpace,
	        superDrawPluginFunction = this.drawPlugin,
	        superBindEventsFunction = this.bindEvents;
	
	    //override
	    this.nameSpace = function(){
	        return "grouplabel";
	    }
	    //override
	    this.actualWidth = function(){
	        return Number(rect.attr("width"));
	    }
	    //override
	    this.actualHeight = function(){
	        return Number(rect.attr("height"));
	    }
	    //override
	    this.drawPlugin = function(g){
	        superDrawPluginFunction(g);
	      /*  g.each(function (d) {
	            rect =  ElementUtil.createRect(g,d.backGroundProperties);
	            text   = ElementUtil.createText(g,d.labelProperties);
	            text.text(d.name);
	            var width = text.node().getBBox().width;
	            var height = text.node().getBBox().height;
	            ElementUtil.setElementProperties(rect,{x:-width/2,y:-height/2,width:width,height:height,rx:2,ry:2});
	            ElementUtil.setElementProperties(text,{"text-anchor":"middle","dy":"0.31em"});
	        });*/
	        rect = ElementUtil.createRect(g,_data.backGroundProperties);
	        text = ElementUtil.createText(g,_data.labelProperties);
	        text.text(_data.name);
	        ElementUtil.setElementProperties(text,{"text-anchor":"middle","dy":"0.31em"});
	        var box = text.node().getBBox();
	        var width = box.width;
	        var height = box.height;
	        ElementUtil.setElementProperties(rect,{x:-width/2,y:-height/2,width:width,height:height,rx:2,ry:2});
	    }
	    
	    //override
	    this.update = function(d) {
	    	if(d) {
	    		_data = d;
	    	}
	    	if(!text) return;
	    	text.text(_data.name);
	        ElementUtil.setElementProperties(text,{"text-anchor":"middle","dy":"0.31em"});
	        ElementUtil.setElementProperties(text,_data.labelProperties);
	        var box = text.node().getBBox();
	        var width = box.width;
	        var height = box.height;
	        ElementUtil.setElementProperties(rect,{x:-width/2,y:-height/2,width:width,height:height,rx:2,ry:2});
	    }
	
	    //override
	    this.bindEvents = function(g){
	        superBindEventsFunction(g);
	    }
	};
	
	GroupLabel.struct = function(ghca_charts) {
		var Plugin = ghca_charts.view.elements.plugins.plugin;
		Plugin.struct(ghca_charts);
	    GroupLabel.prototype = Object.create(Plugin.prototype);
	    GroupLabel.prototype.constructor = GroupLabel;
	};
	
	module.exports = GroupLabel;

/***/ }),
/* 71 */
/***/ (function(module, exports) {

	var Label = function (_element,_data) {
		
		// --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const ElementUtil = ghca_charts.view.util.elementUtil;
	    const Plugin = ghca_charts.view.elements.plugins.plugin;
	    const RectElement = ghca_charts.view.elements.rectElement;
	    const MulitextElement = ghca_charts.view.elements.mulitextElement;
	    const RegexUtil = ghca_charts.view.util.regexUtil;
	
	    Plugin.apply(this,arguments);
	    var self = this;
	    var rectElement,mulitextElement,titleElement;
	
	    self.config({
	        text:"{name}",
	        maxWidth:60,
	        backGroundColor:"green",
	        backGroundOpacity:.3,
	        borderRadius:4,
	        padding:4,
	        fontColor:"0x000000",
	        fontFamily:"宋体",
	        fontSize:12,
	        textLine:3,
	        visible:true
	    });
	
	    var textFunc;
	    this.textFunc = function(value){
	        if(!arguments.length)return;
	        textFunc = value;
	    }
	   
	    //override
	    this.nameSpace = function(){
	        return "label";
	    }
	
	    //override
	    this.update = function(g){
	        var config = self.config();
	        var text = config.text;
	        if(text && text.indexOf("{#") === 0) {
	            text = self.formatStr(text)(self.data().data);
	        } else {
	            text = this.textFunc()==undefined?RegexUtil.replace(RegexUtil.dataRegex,text,self.data()):this.textFunc()(self.data());
	        }
	        titleElement.text(text);
	        mulitextElement.data({text:text,fontSize:config.fontSize,color:config.fontColor,width:config.maxWidth,textLine:config.textLine?config.textLine:1,fontFamily:config.fontFamily});
	        mulitextElement.attribute("transform","translate("+[config.padding,config.padding]+")");
	        rectElement.data({rx:config.borderRadius,ry:config.borderRadius,color:config.backGroundColor,opacity:config.backGroundOpacity});
	        var width = mulitextElement.elementWidth() + (2 * config.padding);
	        var height = mulitextElement.elementHeight() + (2 * config.padding);
	        rectElement.svgElement.attr("width", width).attr("height", height);
	        self.visible(config.visible == undefined ?true:config.visible==true);
	        self.resetBBox(0, 0, width, height);
	    }
	    //override
	    this.drawPlugin = function(g){
	        var config = self.config();
	        var text = config.text;
	        if(text && text.indexOf("{#") === 0) {
	        	text = self.formatStr(text)(self.data().data);
	        } else {
	        	text = this.textFunc()==undefined?RegexUtil.replace(RegexUtil.dataRegex,text,self.data()):this.textFunc()(self.data());
	        }
	        titleElement = g.append("title");
	        titleElement.text(text);
	        rectElement = new RectElement(g,{rx:config.borderRadius,ry:config.borderRadius,color:config.backGroundColor,opacity:config.backGroundOpacity});
	        rectElement.render();
	        mulitextElement = new MulitextElement(g,{text:text,fontSize:config.fontSize,color:config.fontColor,width:config.maxWidth,textLine:config.textLine?config.textLine:1,fontFamily:config.fontFamily});
	        mulitextElement.render();
	        mulitextElement.attribute("transform","translate("+[config.padding,config.padding]+")");
	        // mulitextElement.attribute("pointer-events", "none");
	        var width = mulitextElement.elementWidth() + (2 * config.padding);
	        var height = mulitextElement.elementHeight() + (2 * config.padding);
	        rectElement.svgElement.attr("width", width).attr("height", height);
	        // rectElement.svgElement.attr("pointer-events", "none");
	        self.visible(config.visible == undefined ?true:config.visible==true);
	        self.resetBBox(0, 0, width, height);
	    }
	};
	
	Label.struct = function(ghca_charts) {
		var Plugin = ghca_charts.view.elements.plugins.plugin;
		Plugin.struct(ghca_charts);
	    Label.prototype = Object.create(Plugin.prototype);
	    Label.prototype.constructor = Label;
	};
	
	module.exports = Label;

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {var PackLabel = function (_element,_data,_transition) {
		
		// --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const Plugin = ghca_charts.view.elements.plugins.plugin;
	    const StringUtil = ghca_charts.view.util.stringUtil;
	    const ObjectUtil = ghca_charts.view.util.objectUtil;
	
	    Plugin.apply(this,arguments);
	    var text, self = this, labelShowRadius = 50;
	    
	    /**
	     * 当前缩放系数
	     */
	    var scaleK = 1;
	    this.scaleK = function(){
	    	if(arguments.length === 0)
	    	   return scaleK;
	        scaleK = arguments[0];
	        return this;
	    }
	
	    //override
	    this.nameSpace = function(){
	        return "packLabel";
	    }
	    
	    var labelPos = function() {
	        return _data.data && _data.data.clazzProperties && _data.data.clazzProperties.labelPos ? 
	            _data.data.clazzProperties.labelPos : "outer";
	    };
	    
	    var labelFill = function() {
	    	return labelPos() === "outer" ? 
	            _data.hasOwnProperty("legendColor") ? _data.legendColor : "#000" : "#000";
	    };
	    
	    var midAngle = function (d){
	        return d.startAngle + (d.endAngle - d.startAngle) / 2;
	    };
	    
	    //override
	    this.drawPlugin = function(g){
	    	var pos = labelPos();
	        text = g.append("text").style("display", pos === "none" ? "none" : "block");
	        if(pos === "none") {
	        	return;
	        }
	        var labelConfig = _data.data.labelProperties;  
	        var textStr = _data.data.labelProperties.text;
	        var textContent = textStr ? self.formatStr(textStr) : null;
	        if(pos === "innerRing") {
	        	text
	                .attr("fill", function(d) {
	                    return labelFill();
	                })
	                .attr("pointer-events", "none")
	                .attr("opacity", 0)
	                .attr("text-anchor", "middle")
	                .transition(_transition)
	                .on("end", function(){
	                    d3.select(this).transition().attr("opacity", 1);
	                });
	                
	            var textPath = text.append("textPath");
	            var fontSize = (labelConfig["fontSize"] || labelConfig["font-size"]);
	            if(ObjectUtil.isString(fontSize)) {
	            	fontSize = parseInt(fontSize.split("px")[0]);
	            }
	            if(isNaN(fontSize)) {
	            	fontSize = 12;
	            }
	            var radius = self.scaleK() * _data.outerRadius + fontSize/2 - 4;
	            var pathLen = (_data.endAngle - _data.startAngle) * radius - 1;
	            textPath.each(function(d) {
	            	var content = textContent ? textContent(d) : d.value;
	            	var texts = StringUtil.splitByLine(content, pathLen, fontSize, 1);
	                textPath.text("");
	                textPath.selectAll("tspan")
	                    .data(texts)
	                    .enter()
	                    .append("tspan")
	                    .text(function(d) {
	                        return pathLen < 10 ? "" : d;
	                    });
	                textPath
	                    .attr("xlink:href", self.graph().getCustomId("#pack-node-path-", _data.id))
	                    .attr("startOffset", "50%");
	                text.attr("title", content).style("display", radius > labelShowRadius ? "block" : "none");
	            });
	        } else {
	        	text
	                .text(textContent ? textContent : function (d) {
	                    return d.value;
	                })
	                .attr("fill", function(d) {
	                    return labelFill();
	                })
	                .attr("pointer-events", "none")
	                .attr("dy", ".35em");
	                if(pos === "innerRing") {
	                	text.attr("opacity", 0)
	                        .transition(_transition)
	                        .styleTween("text-anchor", textAnchorTween)
	                        .attrTween("transform", transformRenderTween)
	                        .on("end", function(){
	                            d3.select(this).transition().attr("opacity", 1);
	                        });
	                } else {
	                	text.transition(_transition)
	                        .styleTween("text-anchor", textAnchorTween)
	                        .attrTween("transform", transformRenderTween);
	                }
	        }
	            
	        for(var key in labelConfig){
	        	var value = labelConfig[key];
	            text.attr(key, ObjectUtil.isString(value) ? self.formatStr(value) : value);
	        }
	    }
	    
	    //override
	    this.update = function(t) {
	    	if(text) {
	    		_data = self.data();
	    		text.datum(_data);
	    		var pos = labelPos();
	    		text.style("display", pos === "none" ? "none" : "block");
	            if(labelPos() === "none") {
	                return;
	            }
	            var labelConfig = _data.data.labelProperties;
	    		var textStr = _data.data.labelProperties.text;
	            var textContent = textStr ? self.formatStr(textStr) : null;
	            if(pos === "innerRing") {
	            	text.text("")
	            	    .attr("fill", function(d) {
	                        return labelFill();
	                    })
	                    .attr("pointer-events", "none")
	                    .attr("opacity", 0)
	                    .attr("text-anchor", "middle")
	                    .transition(t)
	                    .on("end", function(){
	                        d3.select(this).transition().attr("opacity", 1);
	                    });
	                
	                var textPath = text.select("textPath");
	                if(textPath.node() === null) {
	                	textPath = text.append("textPath");
	                }
	                var fontSize = (labelConfig["fontSize"] || labelConfig["font-size"]);
	                if(ObjectUtil.isString(fontSize)) {
	                    fontSize = parseInt(fontSize.split("px")[0]);
	                }
	                if(isNaN(fontSize)) {
	                    fontSize = 12;
	                }
	                var radius = self.scaleK() * _data.outerRadius + fontSize/2 - 4;
	                var pathLen = (_data.endAngle - _data.startAngle) * radius - 1;
	                textPath.each(function(d) {
	                    var content = textContent ? textContent(d) : d.value;
	                    var texts = StringUtil.splitByLine(content, pathLen, fontSize, 1);
	                    textPath.text("");
	                    textPath.selectAll("tspan")
	                        .data(texts)
	                        .enter()
	                        .append("tspan")
	                        .text(function(d) {
	                            return pathLen < 10 ? "" : d;
	                        });
	                    textPath
	                        .attr("xlink:href", self.graph().getCustomId("#pack-node-path-", _data.id))
	                        .attr("startOffset", "50%");
	                    text.attr("title", content).style("display", radius > labelShowRadius ? "block" : "none");
	                });
	            } else {
	            	text.selectAll("textPath").remove();
	            	text
	                    .attr("fill", function(d) {
	                        return labelFill();
	                    })
	                    .text(textContent ? textContent : function (d) {
	                        return d.value;
	                    })
	                if(pos === "innerRing") {
	                    text.attr("opacity", 0)
	                        .transition(t)
	                        .styleTween("text-anchor", textAnchorTween)
	                        .attrTween("transform", transformUpdateTween)
	                        .on("end", function(){
	                            d3.select(this).transition().attr("opacity", 1);
	                        });
	                } else {
	                    text.transition(t)
	                        .styleTween("text-anchor", textAnchorTween)
	                        .attrTween("transform", transformUpdateTween);
	                }
	            }
	            for(var key in labelConfig){
	            	var value = labelConfig[key];
	                text.attr(key, ObjectUtil.isString(value) ? self.formatStr(value) : value);
	            }
	    	}
	    }
	    
	    var transformRenderTween = function(d) {
	        this._current = this._current || d;
	        var interpolate, gapX;
	        if(labelPos() === "outer") {
	        	interpolate = d3.interpolate({startAngle:this._current.startAngle, endAngle:this._current.endAngle}, d);
	            gapX = d.lineSize + 5;
	            this._current = interpolate(0);
	            return function(t) {
	                var d2 = interpolate(t);
	                var pos = d.outerArc2.centroid(d2);
	                pos[0] += (100 * (1 - t) + gapX) * (midAngle(d2) < Math.PI ? 1 : -1);
	                return "translate("+ pos +")";
	            };
	        } else {
	        	if(d.startAngle === 0 && d.endAngle >= 6.283185307179586) {
	        		return function(t) {
	                    return "translate(0)";
	                };
	        	}
	        	interpolate = d3.interpolate({startAngle:0, endAngle:0}, d);
	            this._current = interpolate(0);
	            return function(t) {
	                var d2 = interpolate(t);
	                var pos = d.arc.centroid(d2);
	                return "translate("+ pos +")";
	            };
	        }
	    };
	    
	    var transformUpdateTween = function(d) {
	        this._current = this._current || d;
	        var interpolate, gapX;
	        if(labelPos() === "outer") {
	            interpolate = d3.interpolate({startAngle:this._current.startAngle, endAngle:this._current.endAngle}, d);
	            gapX = d.lineSize + 5;
	            this._current = interpolate(0);
	            return function(t) {
	                var d2 = interpolate(t);
	                var pos = d.outerArc2.centroid(d2);
	                pos[0] += gapX * (midAngle(d2) < Math.PI ? 1 : -1);
	                return "translate("+ pos +")";
	            };
	        } else {
	        	if(d.startAngle === 0 && d.endAngle >= 6.283185307179586) {
	                return function(t) {
	                    return "translate(0)";
	                };
	            }
	            interpolate = d3.interpolate({startAngle:this._current.startAngle, endAngle:this._current.endAngle}, d);
	            this._current = interpolate(0);
	            return function(t) {
	                var d2 = interpolate(t);
	                var pos = d.arc.centroid(d2);
	                return "translate("+ pos +")";
	            };
	        }
	    };
	    
	    var textAnchorTween = function(d) {
	        this._current = this._current || d;
	        if(labelPos() === "outer") {
	        	var interpolate = d3.interpolate({startAngle:this._current.startAngle, endAngle:this._current.endAngle}, d);
	            this._current = interpolate(0);
	            return function(t) {
	                var d2 = interpolate(t);
	                return midAngle(d2) < Math.PI ? "start" : "end";
	            };
	        } else {
	        	return function(t) {
	        		return "middle";
	        	}
	        }
	    };
	};
	
	PackLabel.struct = function(ghca_charts) {
		var Plugin = ghca_charts.view.elements.plugins.plugin;
		Plugin.struct(ghca_charts);
	    PackLabel.prototype = Object.create(Plugin.prototype);
	    PackLabel.prototype.constructor = PackLabel;
	};
	
	module.exports = PackLabel;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {var PieLabel = function (_element,_data,_transition) {
		
		// --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const Plugin = ghca_charts.view.elements.plugins.plugin;
	    const StringUtil = ghca_charts.view.util.stringUtil;
	    const ObjectUtil = ghca_charts.view.util.objectUtil;
	
	    Plugin.apply(this,arguments);
	    var text, self = this;
	
	    //override
	    this.nameSpace = function(){
	        return "pieLabel";
	    }
	    
	    var labelPos = function() {
	        return _data.data && _data.data.clazzProperties && _data.data.clazzProperties.labelPos ? 
	            _data.data.clazzProperties.labelPos : "outer";
	    };
	    
	    var labelFill = function() {
	    	return labelPos() === "outer" ? 
	            (_data.hasOwnProperty("legendColor") ? _data.legendColor : "#000") : "#000";
	    };
	    
	    var midAngle = function (d){
	        return d.startAngle + (d.endAngle - d.startAngle) / 2;
	    };
	    
	    //override
	    this.drawPlugin = function(g){
	    	var pos = labelPos();
	        text = g.append("text").style("display", pos === "none" ? "none" : "block");
	        if(pos === "none") {
	        	return;
	        }
	        var labelConfig = _data.data.labelProperties;  
	        var textStr = _data.data.labelProperties.text;
	        var textContent = textStr ? self.formatStr(textStr) : null;
	        if(pos === "innerRing" && !(_data.innerRadius === 0 && _data.startAngle === 0 && _data.endAngle >= 6.283185307179586)) {
	        	text
	                .attr("fill", function(d) {
	                    return labelFill();
	                })
	                .attr("pointer-events", "none")
	                .attr("opacity", 0)
	                .transition(_transition)
	                .on("end", function(){
	                    d3.select(this).transition().attr("opacity", 1);
	                });
	                
	            var textPath = text.append("textPath");
	            var fontSize = (labelConfig["fontSize"] || labelConfig["font-size"]);
	            if(ObjectUtil.isString(fontSize)) {
	            	fontSize = parseInt(fontSize.split("px")[0]);
	            }
	            if(isNaN(fontSize)) {
	            	fontSize = 12;
	            }
	            var radius = (_data.innerRadius + _data.outerRadius - 12) / 2;
	            var pathLen = (_data.endAngle - _data.startAngle) * radius - 15;
	            textPath.each(function(d) {
	            	var content = textContent ? textContent(d) : d.value;
	            	var texts = StringUtil.splitByLine(content, pathLen, fontSize, 1);
	                textPath.text("");
	                textPath.selectAll("tspan")
	                    .data(texts)
	                    .enter()
	                    .append("tspan")
	                    .text(function(d) {
	                        return pathLen < 10 ? "" : d;
	                    });
	                textPath.attr("xlink:href", self.graph().getCustomId("#sunburst-node-path-", _data.id));
	                text.attr("title", content);
	            });
	        } else {
	        	text
	                .text(textContent ? textContent : function (d) {
	                    return d.value;
	                })
	                .attr("fill", function(d) {
	                    return labelFill();
	                })
	                .attr("pointer-events", "none")
	                .attr("dy", ".35em");
	                if(pos === "innerRing") {
	                	text.attr("opacity", 0)
	                        .transition(_transition)
	                        .styleTween("text-anchor", textAnchorTween)
	                        .attrTween("transform", transformRenderTween)
	                        .on("end", function(){
	                            d3.select(this).transition().attr("opacity", 1);
	                        });
	                } else {
	                	text.transition(_transition)
	                        .styleTween("text-anchor", textAnchorTween)
	                        .attrTween("transform", transformRenderTween);
	                }
	        }
	            
	        for(var key in labelConfig){
	        	var value = labelConfig[key];
	            text.attr(key, ObjectUtil.isString(value) ? self.formatStr(value) : value);
	        }
	    }
	    
	    //override
	    this.update = function(t) {
	    	if(text) {
	    		_data = self.data();
	    		text.datum(_data);
	    		var pos = labelPos();
	    		text.style("display", pos === "none" ? "none" : "block");
	            if(labelPos() === "none") {
	                return;
	            }
	            var labelConfig = _data.data.labelProperties;
	    		var textStr = _data.data.labelProperties.text;
	            var textContent = textStr ? self.formatStr(textStr) : null;
	            if(pos === "innerRing" && !(_data.innerRadius === 0 && _data.startAngle === 0 && _data.endAngle >= 6.283185307179586)) {
	            	text.text("")
	            	    .attr("fill", function(d) {
	                        return labelFill();
	                    })
	                    .attr("pointer-events", "none")
	                    .attr("opacity", 0)
	                    .style("text-anchor", "")
	                    .transition(t)
	                    .on("end", function(){
	                        d3.select(this).transition().attr("opacity", 1);
	                    });
	                
	                var textPath = text.select("textPath");
	                if(textPath.node() === null) {
	                	textPath = text.append("textPath");
	                }
	                var fontSize = (labelConfig["fontSize"] || labelConfig["font-size"]);
	                if(ObjectUtil.isString(fontSize)) {
	                    fontSize = parseInt(fontSize.split("px")[0]);
	                }
	                if(isNaN(fontSize)) {
	                    fontSize = 12;
	                }
	                var radius = (_data.innerRadius + _data.outerRadius - 12) / 2;
	                var pathLen = (_data.endAngle - _data.startAngle) * radius - 15;
	                textPath.each(function(d) {
	                    var content = textContent ? textContent(d) : d.value;
	                    var texts = StringUtil.splitByLine(content, pathLen, fontSize, 1);
	                    textPath.text("");
	                    textPath.selectAll("tspan")
	                        .data(texts)
	                        .enter()
	                        .append("tspan")
	                        .text(function(d) {
	                            return pathLen < 10 ? "" : d;
	                        });
	                    textPath.attr("xlink:href", self.graph().getCustomId("#sunburst-node-path-", _data.id));
	                    text.attr("title", content);
	                });
	            } else {
	            	text.selectAll("textPath").remove();
	            	text
	                    .attr("fill", function(d) {
	                        return labelFill();
	                    })
	                    .text(textContent ? textContent : function (d) {
	                        return d.value;
	                    })
	                if(pos === "innerRing") {
	                    text.attr("opacity", 0)
	                        .transition(t)
	                        .styleTween("text-anchor", textAnchorTween)
	                        .attrTween("transform", transformUpdateTween)
	                        .on("end", function(){
	                            d3.select(this).transition().attr("opacity", 1);
	                        });
	                } else {
	                    text.transition(t)
	                        .styleTween("text-anchor", textAnchorTween)
	                        .attrTween("transform", transformUpdateTween);
	                }
	            }
	            for(var key in labelConfig){
	            	var value = labelConfig[key];
	                text.attr(key, ObjectUtil.isString(value) ? self.formatStr(value) : value);
	            }
	    	}
	    }
	    
	    var transformRenderTween = function(d) {
	        this._current = this._current || d;
	        var interpolate, gapX;
	        if(labelPos() === "outer") {
	        	interpolate = d3.interpolate({startAngle:this._current.startAngle, endAngle:this._current.endAngle}, d);
	            gapX = d.lineSize + 5;
	            this._current = interpolate(0);
	            return function(t) {
	                var d2 = interpolate(t);
	                var pos = d.outerArc2.centroid(d2);
	                pos[0] += (100 * (1 - t) + gapX) * (midAngle(d2) < Math.PI ? 1 : -1);
	                return "translate("+ pos +")";
	            };
	        } else {
	        	if(d.startAngle === 0 && d.endAngle >= 6.283185307179586) {
	        		return function(t) {
	                    return "translate(0)";
	                };
	        	}
	        	interpolate = d3.interpolate({startAngle:0, endAngle:0}, d);
	            this._current = interpolate(0);
	            return function(t) {
	                var d2 = interpolate(t);
	                var pos = d.arc.centroid(d2);
	                return "translate("+ pos +")";
	            };
	        }
	    };
	    
	    var transformUpdateTween = function(d) {
	        this._current = this._current || d;
	        var interpolate, gapX;
	        if(labelPos() === "outer") {
	            interpolate = d3.interpolate({startAngle:this._current.startAngle, endAngle:this._current.endAngle}, d);
	            gapX = d.lineSize + 5;
	            this._current = interpolate(0);
	            return function(t) {
	                var d2 = interpolate(t);
	                var pos = d.outerArc2.centroid(d2);
	                pos[0] += gapX * (midAngle(d2) < Math.PI ? 1 : -1);
	                return "translate("+ pos +")";
	            };
	        } else {
	        	if(d.startAngle === 0 && d.endAngle >= 6.283185307179586) {
	                return function(t) {
	                    return "translate(0)";
	                };
	            }
	            interpolate = d3.interpolate({startAngle:this._current.startAngle, endAngle:this._current.endAngle}, d);
	            this._current = interpolate(0);
	            return function(t) {
	                var d2 = interpolate(t);
	                var pos = d.arc.centroid(d2);
	                return "translate("+ pos +")";
	            };
	        }
	    };
	    
	    var textAnchorTween = function(d) {
	        this._current = this._current || d;
	        if(labelPos() === "outer") {
	        	var interpolate = d3.interpolate({startAngle:this._current.startAngle, endAngle:this._current.endAngle}, d);
	            this._current = interpolate(0);
	            return function(t) {
	                var d2 = interpolate(t);
	                return midAngle(d2) < Math.PI ? "start" : "end";
	            };
	        } else {
	        	return function(t) {
	        		return "middle";
	        	}
	        }
	    };
	};
	
	PieLabel.struct = function(ghca_charts) {
		var Plugin = ghca_charts.view.elements.plugins.plugin;
		Plugin.struct(ghca_charts);
	    PieLabel.prototype = Object.create(Plugin.prototype);
	    PieLabel.prototype.constructor = PieLabel;
	};
	
	module.exports = PieLabel;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 74 */
/***/ (function(module, exports) {

	var ToPoLabel = function (_element,_data) {
		
		// --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const ElementUtil = ghca_charts.view.util.elementUtil;
	    const Plugin = ghca_charts.view.elements.plugins.plugin;
	    const RectElement = ghca_charts.view.elements.rectElement;
	    const MulitextElement = ghca_charts.view.elements.mulitextElement;
	    const RegexUtil = ghca_charts.view.util.regexUtil;
	    const ObjectUtil =  ghca_charts.view.util.objectUtil;
	
	    Plugin.apply(this,arguments);
	    var self = this;
	    var rectElement,mulitextElement;
	
	    self.config({
	        text:"{name}",
	        maxWidth:60,
	        backGroundColor:"green",
	        backGroundOpacity:.3,
	        borderRadius:4,
	        padding:4,
	        fontColor:"0x000000",
	        fontFamily:"宋体",
	        fontSize:12,
	        textLine:3,
	        visible:true
	    });
	
	    var textFunc;
	    this.textFunc = function(value){
	        if(!arguments.length)return;
	        textFunc = value;
	    }
	   
	    //override
	    this.nameSpace = function(){
	        return "topolabel";
	    }
	
	    //override
	    this.update = function(g){
	        var config = self.getRegConfig();
	
	        // titleElement.text(config.text);
	        mulitextElement.data({
	            text:config.text,
	            fontSize:config.fontSize,
	            color:config.fontColor,
	            width:config.maxWidth,
	            textLine:config.textLine?config.textLine:1,
	            fontFamily:config.fontFamily
	        });
	        mulitextElement.attribute("transform","translate("+[config.padding,config.padding]+")");
	        rectElement.data({
	            rx:config.borderRadius,
	            ry:config.borderRadius,
	            color:config.backGroundColor,
	            opacity:config.backGroundOpacity
	        });
	        var width = mulitextElement.elementWidth() + (2 * config.padding);
	        var height = mulitextElement.elementHeight() + (2 * config.padding);
	        rectElement.svgElement.attr("width", width).attr("height", height);
	        var vis = config.visible;
	        if (vis) {
	            vis = config.text.length > 0;
	        }
	        self.visible(vis);
	        self.resetBBox(0, 0, width, height);
	    }
	
	    /**
	     * 获取规则匹配的配置
	     */
	    this.getRegConfig=function(){
	        var config = ObjectUtil.cloneObj(self.config());
	        if(config.text && config.text.indexOf("{#") === 0) {
	            config.text = self.formatStr(config.text)(self.data().data);
	        } else {
	            config.text = this.textFunc()==undefined?RegexUtil.replace(RegexUtil.dataRegex,config.text,self.data()):this.textFunc()(self.data());
	        }
	        if(config.fontColor && config.fontColor.indexOf("{#") === 0) {
	            config.fontColor = self.formatStr(config.fontColor)(self.data().data);
	        } else {
	            config.fontColor = RegexUtil.replace(RegexUtil.dataRegex,config.fontColor,self.data());
	        }
	        if(config.backGroundColor && config.backGroundColor.indexOf("{#") === 0) {
	            config.backGroundColor = self.formatStr(config.backGroundColor)(self.data().data);
	        } else {
	            config.backGroundColor = RegexUtil.replace(RegexUtil.dataRegex,config.backGroundColor,self.data());
	        }
	        if(config.backGroundOpacity && config.backGroundOpacity.indexOf("{#") === 0) {
	            config.backGroundOpacity = self.formatStr(config.backGroundOpacity)(self.data().data);
	        } else {
	            config.backGroundOpacity = RegexUtil.replace(RegexUtil.dataRegex,config.backGroundOpacity,self.data());
	        }
	        return config;
	    }
	
	
	    //override
	    this.drawPlugin = function(g){
	        var config = self.getRegConfig();
	        var text = config.text;
	        // titleElement = g.append("title");
	        // titleElement.text(text);
	
	        rectElement = new RectElement(g,{rx:config.borderRadius,ry:config.borderRadius,color:config.backGroundColor,opacity:config.backGroundOpacity});
	        rectElement.render();
	
	        mulitextElement = new MulitextElement(g,{text:text,fontSize:config.fontSize,color:config.fontColor,width:config.maxWidth,textLine:config.textLine?config.textLine:1,fontFamily:config.fontFamily});
	        mulitextElement.render();
	        mulitextElement.attribute("transform","translate("+[config.padding,config.padding]+")");
	        // mulitextElement.attribute("pointer-events", "none");
	        var width = mulitextElement.elementWidth() + (2 * config.padding);
	        var height = mulitextElement.elementHeight() + (2 * config.padding);
	        rectElement.svgElement.attr("width", width).attr("height", height);
	        // rectElement.svgElement.attr("pointer-events", "none");
	        var vis=config.visible;
	        if(vis){
	            vis=text.length>0;
	        }
	        self.visible(vis);
	        self.resetBBox(0, 0, width, height);
	    }
	
	    this.getRectElement=function(){
	        return rectElement;
	    }  
	
	    this.remove=function(){
	        rectElement.svgElement.remove();
	        mulitextElement.svgElement.remove();
	    }
	};
	
	ToPoLabel.struct = function(ghca_charts) {
		var Plugin = ghca_charts.view.elements.plugins.plugin;
		Plugin.struct(ghca_charts);
	    ToPoLabel.prototype = Object.create(Plugin.prototype);
	    ToPoLabel.prototype.constructor = ToPoLabel;
	};
	
	module.exports = ToPoLabel;

/***/ }),
/* 75 */
/***/ (function(module, exports) {

	var LinkMap = function() {
	    
	    this.getMap = function() {
	        var map = {};
	        //注册内部连线类
	        map.baselink = ghca_charts.view.elements.plugins.links.baseLink;
	        map.curvelink = ghca_charts.view.elements.plugins.links.curveLink;
	        map.parallellink = ghca_charts.view.elements.plugins.links.parallelLink;
	        map.sankeylink = ghca_charts.view.elements.plugins.links.sankeyLink;
	        map.link = ghca_charts.view.elements.plugins.links.link;
	        map.configlink = ghca_charts.view.elements.plugins.links.configLink;
	        
	        //注册外部连线类
	        var outerMap = ghca_charts.global.outerPlugins && ghca_charts.global.outerPlugins.linkMap;
	        if(outerMap) {
	            for(var name in outerMap) {
	                map[name] = outerMap[name];
	            }
	        }
	        
	        return map;
	    };
	};
	
	LinkMap.struct = function(ghca_charts) {
	    LinkMap.prototype.constructor = LinkMap;
	};
	
	module.exports = LinkMap;

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {var BaseNode = function (_element,_data) {
		
		// --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const ElementUtil = ghca_charts.view.util.elementUtil;
	    const Plugin = ghca_charts.view.elements.plugins.plugin;
	    const BaseLabel = ghca_charts.view.elements.plugins.label.baseLabel;
	    const BaseEvent = ghca_charts.events.BaseEvent;
	    const math = ghca_charts.view.util.math;
	    const RegexUtil = ghca_charts.view.util.regexUtil;
	    const BaseComponent = ghca_charts.view.component.baseComponent;
	
	    Plugin.apply(this,arguments);
	    var self = this,
	        superDrawPluginFunction = this.drawPlugin,
	        superBindEventsFunction = this.bindEvents;
	    self.dispatch = d3.dispatch("selectedChange");
	    self.mainPathElement = _element;
	    self.checkPathElement = _element;
	    self.labelElement =  _element;
	    self.label;
	    var _selected = false;
	    //override
	    this.data = function(){
	        return _data.data;
	    };
	    //override
	//    this.visible = function(_visible){
	//        if(_visible)
	//            ElementUtil.setElementProperties(_element,{display:"block"});
	//        else
	//            ElementUtil.setElementProperties(_element,{display:"none"});
	//    }
	    /**
	     * 是否显示箭头
	     */
	    var isShowArrow = false;
	    this.isShowArrow = function(value) {
	        if (!arguments.length)
	            return isShowArrow;
	        isShowArrow = value;
	        return this;
	    };
	    /**
	     * 节点选中
	     * @param _selected
	     * @returns {*}
	     */
	    this.selected = function(_p){
	        if(!arguments.length)return _selected;
	        _selected = _p;
	        self.dispatch.call("selectedChange",this , new BaseEvent(self,{selected:_selected}));
	        return this;
	    }
	    //override
	    this.nameSpace = function(){
	        return "baseLink";
	    }
	
	    //override
	    this.drawPlugin = function(g){
	        superDrawPluginFunction(g);
	        g.each(function (d) {
	        	self.isShowArrow(self.data().showArrow ? true : false);
	            var group = d3.select(this);
	            self.checkPathElement = ElementUtil.createPath(group,self.data().linkCheckProperties);
	            self.mainPathElement  = ElementUtil.createPath(group,self.data().linkProperties);
	            self.createLabel(group,_data);
	            self.setPath(self.mainPathElement,_data);
	            self.setPath(self.checkPathElement,_data);
	        });
	    }
	    //override
	    this.update = function(){
	        self.setPath(self.mainPathElement,_data);
	        self.setPath(self.checkPathElement,_data);
	        if(self.label && self.labelElement)
	            self.labelLayout(self.labelElement,self.label,_data);
	    }
	
	
	    //override
	    this.bindEvents = function(g){
	        superBindEventsFunction(g);
	        g.on('mouseover', function(d) {
	            self.mouseOverHandler();
	        });
	        g.on('mouseout', function(d) {
	            self.mouseOutHandler();
	        });
	        g.on('click', function(d) {
	            self.selected(!_selected);
	        });
	        self.on("selectedChange."+self.nameSpace(),function(e){
	            self.selectedChange(e.data.selected);
	        });
	    }
	
	    /**
	     * 自定义事件监听
	     * @returns {exports}
	     */
	    this.on = function() {
	        var value = self.dispatch.on.apply(self.dispatch, arguments);
	        return value === self.dispatch ? self : value;
	    };
	
	
	    this.selectedChange = function(seleced){
	        if(seleced){
	            self.checkPathElement.attr("opacity",0.5);
	        }else{
	            self.checkPathElement.attr("opacity",0);
	        }
	    }
	    this.mouseOverHandler = function(){
	        if(!self.selected())
	            self.checkPathElement.attr("opacity",0.5);
	    }
	    this.mouseOutHandler = function(){
	        if(!self.selected())
	            self.checkPathElement.attr("opacity",0);
	    }
	
	    this.setPath = function(mainPathElement,d){
	        var path  = d3.path();
	        var target = self.isShowArrow() ? {x:d.target.cx, y:d.target.cy} : d.target;
	        path.moveTo(d.source.x,d.source.y);
	        path.lineTo(target.x,target.y);
	        ElementUtil.setElementProperties(mainPathElement,{"d": path.toString()});
	    }
	
	    this.createLabel = function(group, d) {
			if (!d.data.label) {
				return;
			}
			self.labelElement = group.append("g");
			var labelData = d.data.label;
			labelData.name = d.name;
			self.label = new BaseLabel(self.labelElement, labelData, self);
			self.label.render();
			self.labelLayout(self.labelElement, self.label, d);
		}
	    /**
		 * label布局
		 * 
		 * @param element
		 * @param plugin
		 * @param position
		 */
	    this.labelLayout = function(element,plugin,data){
	        var position = math.calculateCenter(data.source, data.target);
	        var angle = math.linkAngle(data.source,data.target)
	        ElementUtil.setElementProperties(element,{transform:"translate(" + [position.x,position.y] + ")"+" rotate(" + angle + ")"});
	    }
	    
	    this.addArrow = function(pathElement) {
	    	var svg = d3.select(pathElement.node().ownerSVGElement);
	        var defs = svg.select("svg defs"); 
	        if(defs.node() === null) {
	            defs = svg.append("defs");
	        }
	        var arrowMarker = defs.select("marker#link-arrow");
	        if(arrowMarker.node() === null) {
	            arrowMarker = defs.append("marker")
	                .attr("id","link-arrow")  
	                .attr("markerUnits","strokeWidth")  
	                .attr("markerWidth","6")  
	                .attr("markerHeight","4")  
	                .attr("viewBox","0 0 6 4")   
	                .attr("refX",6)  
	                .attr("refY",2)  
	                .attr("orient","auto");  
	              
	            var arrow_path = "M0,0 L6,2 L0,4"; 
	            var pathConfig = self.data().linkProperties;
	            arrowMarker.append("path")  
	                        .attr("d", arrow_path)  
	                        .attr("fill", "none")
	                        .attr("stroke", pathConfig["stroke"])
	                        .attr("stroke-opacity", pathConfig["stroke-opacity"]);
	        }
	        pathElement.attr("marker-end","url(#link-arrow)");
	        var source = RegexUtil.replace(RegexUtil.dataRegex,_data.source,self.data()),
	            target = RegexUtil.replace(RegexUtil.dataRegex,_data.target,self.data());
	        //计算交点
	        if(self.isShowArrow()) {
	            var ins = target.ins;
	            var isComponent = ins instanceof BaseComponent;
	            var targetRect = ins ? 
	//                (isComponent ? ins.node().getBBox() : ins.mainPlugin.el.node().getBBox()) : 
	                (isComponent ? ins.node().getBBox() : ins.mainPlugin.getBBox()) : 
	            	{x:d3.event.x, y:d3.event.y, width:0, height:0};
	            var w = targetRect.width;
	            var h = targetRect.height;
	            var x = isComponent ? target.x + ins.x() : target.x + targetRect.x;
	            var y = isComponent ? target.y + ins.y() : target.y + targetRect.y;
	//            d3.select(document).selectAll("g.topo-nodesContainer").append("rect")
	//                .attr("x", x)
	//                .attr("y", y)
	//                .attr("width", w)
	//                .attr("height", h)
	//                .attr("stroke", "red")
	//                .attr("fill", "none");
	            var cp, nameSpace = self.nameSpace();
	            if(nameSpace === "curveLink" && _data.lineIndex > 0) {
	            	targetRect.x = x;    
	                targetRect.y = y;
	                //计算并记录控制点
	                var fontSize = self.label ? self.label.actualHeight() : 12;
	                var array = math.parallelDeviationPoint(source, target, fontSize*3, _data.lineIndex);
	                _data.controlX = array[1].x;
	                _data.controlY = array[1].y;
	                cp = math.calcQBezCurveAndRectIntersects(source, {x:array[1].x, y:array[1].y}, target, targetRect);
	                //取第一个点
	                if(cp.length > 0) {
	                	cp = cp[0];
	                }
	            } else {
	            	delete _data.controlX;
	                delete _data.controlY;
	            	cp = math.getCrossPointInRectAndSegment(x, y, w, h, source.x, source.y, target.x, target.y);
	            }
	            //记录交点坐标
	            if(cp && cp.length === 2) {
	                target.cx = cp[0];
	                target.cy = cp[1];
	                
	//                d3.select(document).selectAll("g.topo-nodesContainer").append("circle")
	//                    .attr("cx", cp[0])
	//                    .attr("cy", cp[1])
	//                    .attr("r", 2)
	//                    .attr("fill", "black");
	            } else {
	                target.cx = target.x;
	                target.cy = target.y;
	            }
	        }
	    };
	};
	
	BaseNode.struct = function(ghca_charts) {
		var Plugin = ghca_charts.view.elements.plugins.plugin;
		Plugin.struct(ghca_charts);
	    BaseNode.prototype = Object.create(Plugin.prototype);
	    BaseNode.prototype.constructor = BaseNode;
	};
	
	module.exports = BaseNode;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {var ConfigLink = function (_element, _data) {
	
	    // --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	
	    const math = ghca_charts.view.util.math;
	    const Plugin = ghca_charts.view.elements.plugins.plugin;
	    const CommonUtil = ghca_charts.view.util.commonUtil;
	    const ElementUtil = ghca_charts.view.util.elementUtil;
	    const BaseEvent = ghca_charts.events.BaseEvent;
	    const PathElement = ghca_charts.view.elements.pathElement;
	    // const Label = ghca_charts.view.elements.plugins.label.label;
	    const BaseComponent = ghca_charts.view.component.baseComponent;
	    const ClassFactory = ghca_charts.view.util.classFactory;
	    const RegexUtil = ghca_charts.view.util.regexUtil;
	    const ObjectUtil = ghca_charts.view.util.objectUtil;
	    const EventUtil = ghca_charts.view.util.eventUtil;
	    const UUID = ghca_charts.view.util.UUIDUtil;
	
	    Plugin.apply(this, arguments);
	
	    var self = this;
	    var pathElement, label, labelContainer, arrow;
	    var isShowArrow = false;
	    var fontSizeScale = 2;
	    var spCache = {},
	        tpCache = {};
	    var source, target; //连线起点终点数据对象
	    var sourceCx, sourceCy, targetCx, targetCy; //连线起点、终点交点坐标
	    self.dispatch = d3.dispatch("selectedChange");
	    self.plugins = [];
	    //override
	    this.nameSpace = function () {
	        return "link";
	    }
	    self.config({
	        source: "{source}",
	        target: "{target}",
	        math: 2,
	        num: 6,
	        besselX: true,
	        path: {
	            dasharray: "5,5",
	            borderWidth: 2,
	            borderColor: "{color}",
	            borderOpacity: .6,
	            overDasharray: "5,5",
	            overBorderWidth: 10,
	            overBorderColor: "red",
	            overBorderOpacity: .8
	        },
	        label: {
	            clazz: "label",
	            config: {
	                text: "{name}:{value}",
	                maxWidth: 60,
	                backGroundColor: "green",
	                backGroundOpacity: .3,
	                borderRadius: 4,
	                padding: 4,
	                fontColor: "0x000000",
	                fontFamily: "宋体",
	                fontSize: 12
	            }
	        }
	    });
	
	    // ------------------------------
	    // id
	    // ------------------------------
	
	    var id = UUID.generateUUID();
	    this.id = function (value) {
	        return id;
	    };
	
	    var _selected = false;
	    this.selected = function (_p) {
	        if (!arguments.length) return _selected;
	        _selected = _p;
	        self.dispatch.call("selectedChange", this, new BaseEvent(self, {
	            selected: _selected
	        }));
	        return this;
	    }
	    this.selectedChange = function (seleced) {
	        var config = self.config();
	        var pathConfig = config.path;
	        if (seleced) {
	            pathElement.data({
	                borderColor: RegexUtil.replace(RegexUtil.dataRegex, pathConfig.overBorderColor, self.data()),
	                border: RegexUtil.replace(RegexUtil.dataRegex, pathConfig.overBorderWidth, self.data()),
	                dasharray: RegexUtil.replace(RegexUtil.dataRegex, pathConfig.dasharray, self.data()),
	                borderOpacity: pathConfig.overBorderOpacity
	            });
	        } else {
	            pathElement.data({
	                borderColor: RegexUtil.replace(RegexUtil.dataRegex, pathConfig.borderColor, self.data()),
	                border: RegexUtil.replace(RegexUtil.dataRegex, pathConfig.borderWidth, self.data()),
	                dasharray:RegexUtil.replace(RegexUtil.dataRegex, pathConfig.dasharray, self.data()),
	                borderOpacity: pathConfig.borderOpacity
	            });
	        }
	    }
	    var pathFunc;
	    this.pathFunc = function (func) {
	        if (!arguments.length) return pathFunc;
	        pathFunc = func;
	        return this;
	    }
	    //override
	    this.nameSpace = function () {
	        return "configlink";
	    }
	
	    //override
	    this.update = function (g) {
	        source = RegexUtil.replace(RegexUtil.dataRegex, self.config().source, self.data());
	        target = RegexUtil.replace(RegexUtil.dataRegex, self.config().target, self.data());
	        // if (!source.ins || !target.ins) {
	        //     return;
	        // }
	        //临时写法
	        if (g === "topo") {
	            isShowArrow = arrow ? arrow.visible === true : false;
	            if (label) {
	                label.transform("translate(" + [-label.actualWidth() / 2, -label.actualHeight() / 2] + ")");
	            }
	            if (labelContainer) {
	                labelContainer.attr("transform", position());
	            }
	            startFlux(self.el);
	            setPath();
	        } else {
	            var config = self.config();
	            var pathConfig = config.path;
	            isShowArrow = arrow ? arrow.visible === true : false;
	            var labelConfig = config.label ? config.label.config : null;
	            if (labelConfig) {
	
	                if (labelContainer) {
	                    labelContainer.attr("transform", position());
	                    if (label) {
	                        label.data(self.data());
	                        label.config(labelConfig);
	                        label.render();
	                        label.transform("translate(" + [-label.actualWidth() / 2, -label.actualHeight() / 2] + ")");
	
	                    }
	                }
	            }
	
	            // pathElement.borderColor(RegexUtil.replace(RegexUtil.dataRegex,pathConfig.borderColor,self.data()));
	            // pathElement.border(pathConfig.borderWidth);
	            // pathElement.dasharray(pathConfig.dasharray);
	            // pathElement.borderOpacity(pathConfig.borderOpacity);
	            // pathElement.data({borderColor:RegexUtil.replace(RegexUtil.dataRegex,pathConfig.borderColor,self.data()),
	            //     border:pathConfig.borderWidth,dasharray:pathConfig.dasharray
	            //     ,borderOpacity:pathConfig.borderOpacity});
	
	            startFlux(self.el);
	
	            // pathElement.render();
	
	            if (label) {
	                label.render()
	            }
	
	            setPath();
	
	        }
	        self.plugins.forEach(function (d, i) {
	            d.render();
	            pluginLayout(d, d);
	        });
	    }
	
	    //override
	    this.drawPlugin = function (g) {
	        g.attr("style", "cursor:pointer;");
	        var config = self.config();
	        source = RegexUtil.replace(RegexUtil.dataRegex, self.config().source, self.data());
	        target = RegexUtil.replace(RegexUtil.dataRegex, self.config().target, self.data());
	        // if (!source.ins || !target.ins) {
	        //     return;
	        // }
	        var pathConfig = config.path;
	        arrow = pathConfig.arrow;
	        isShowArrow = arrow ? arrow.visible === true : false;
	        pathElement = new PathElement(g, {
	            borderColor: RegexUtil.replace(RegexUtil.dataRegex, pathConfig.borderColor, self.data()),
	            border: RegexUtil.replace(RegexUtil.dataRegex, pathConfig.borderWidth, self.data()),
	            dasharray: RegexUtil.replace(RegexUtil.dataRegex, pathConfig.dasharray, self.data()),
	            borderOpacity: pathConfig.borderOpacity
	        });
	        var labelConfig = config.label ? config.label.config : null;
	        if (labelConfig) {
	            labelContainer = g.append("svg:g");
	            label = ClassFactory.newPluginInstance(config.label.clazz, [labelContainer, self.data()]);
	            label.config(labelConfig);
	        }
	
	        startFlux(g);
	
	        // pathElement.render();
	
	        if (label) {
	            label.render();
	            label.transform("translate(" + [-label.actualWidth() / 2, -label.actualHeight() / 2] + ")");
	            labelContainer.attr("transform", position());
	        }
	        var plugins = config.plugins;
	        if (plugins) {
	            plugins.forEach(function (d, i) {
	                if (d.render == undefined || RegexUtil.replace(RegexUtil.dataRegex, d.render, self.data()) == "true") {
	                    var plugin = ClassFactory.newPluginInstance(d.clazz, [g, self.data()]);
	                    plugin.config(d.config);
	                    plugin.render();
	                    self.plugins.push(plugin);
	                    pluginLayout(plugin, d);
	                }
	            });
	        }
	        setPath();
	    }
	
	    /**
	     * 开启流量监控
	     * @param g
	     */
	    function startFlux(g) {
	        var config = self.config();
	        var pathConfig = config.path;
	        var flux = RegexUtil.replace(RegexUtil.dataRegex, config.flux, self.data());
	
	        stopFlux(g);
	        if (!flux || flux === config.flux) {
	            pathElement.data({
	                borderColor: RegexUtil.replace(RegexUtil.dataRegex, pathConfig.borderColor, self.data()),
	                border: RegexUtil.replace(RegexUtil.dataRegex, pathConfig.borderWidth, self.data()),
	                dasharray: RegexUtil.replace(RegexUtil.dataRegex, pathConfig.dasharray, self.data()),
	                borderOpacity: pathConfig.borderOpacity
	            });
	            setArrowProperty("link-arrow" + self.id(), "stroke", RegexUtil.replace(RegexUtil.dataRegex, pathConfig.borderColor, self.data()));
	            return;
	        }
	        var labelConfig = config.label ? config.label.config : null;
	        if (labelConfig) {
	            var c = ObjectUtil.cloneObj(labelConfig);
	            c.text = flux.value;
	            label.config(c);
	        }
	        pathElement.data({
	            borderColor: flux.borderColor,
	            dasharray: "10,10",
	            border: flux.borderWidth,
	            borderOpacity: pathConfig.borderOpacity
	        });
	        if (arrow) {
	            setArrowProperty("link-arrow" + self.id(), "stroke", flux.borderColor);
	        }
	        var path = g.select("path");
	        if (path) {
	            ElementUtil.setElementStyles(path, {
	                "stroke-dashoffset": "500"
	            });
	            path.transition()
	                .duration(50000)
	                .ease(d3.easeLinear)
	                .style("stroke-dashoffset", 0)
	                .on("end", function () {
	                    startFlux(g);
	                });
	        }
	    }
	
	    /**
	     * 关闭流量监控
	     * @param g
	     */
	    function stopFlux(g) {
	        var path = g.select("path");
	        if (path) {
	            path.interrupt();
	        }
	    }
	
	    function pluginLayout(plugin, d) {
	        var array = centerPointAndAngle();
	        // var config = self.config();
	        // var source = RegexUtil.replace(RegexUtil.dataRegex,config.source,self.data()),
	        //     target = RegexUtil.replace(RegexUtil.dataRegex,config.target,self.data());
	        // var angle = math.getPointAngle(source,target);
	        // console.log("==========angle",angle)
	        var position = array[0];
	        var point = [position.x, position.y];
	        if (label) {
	            point = math.circumferencePoint(label.actualWidth(), 0, position);
	        }
	        plugin.transform("translate(" + point + ")");
	    }
	
	    //override
	    this.bindEvents = function (g) {
	        g.on('mouseover', function (d) {
	            var evt = EventUtil.createCustomEvent(BaseEvent.SHOW_TOOL_TIP, true, true);
	            d3.select(this).node().dispatchEvent(evt);
	            mouseOverHandler();
	        });
	        g.on('mousemove', function (d) {
	            var evt = EventUtil.createCustomEvent(BaseEvent.UPDATE_TOOL_TIP, true, true, d);
	            d3.select(this).node().dispatchEvent(evt);
	        });
	        g.on('mouseout', function (d) {
	            var evt = EventUtil.createCustomEvent(BaseEvent.HIDE_TOOL_TIP, true, true);
	            d3.select(this).node().dispatchEvent(evt);
	            mouseOutHandler();
	        });
	        g.on('click', function (d) {
	            var evt = EventUtil.createCustomEvent(BaseEvent.LINK_CLICK, true, true, {
	                data: d
	            });
	            d3.select(this).node().dispatchEvent(evt);
	            self.selected(!_selected);
	        });
	        self.dispatch.on("selectedChange." + self.nameSpace(), function (e) {
	            self.selectedChange(e.data.selected);
	        });
	    }
	
	    var pathFunction = null;
	    this.pathFunction = function (value) {
	        if (!arguments.length)
	            return pathFunction;
	        pathFunction = value;
	        return this;
	    };
	
	    function arrowForNoIE(pathElement, key, value) {
	        if (CommonUtil.isIE()) {
	            //            var pathNode = pathElement.svgElement.node();
	            //            var parentNode = pathNode.parentNode;
	            //            parentNode.removeChild(pathNode);
	            //            parentNode.appendChild(pathNode);
	        } else {
	            pathElement.svgElement.attr(key, value);
	        }
	    }
	
	    function setArrowProperty(id, key, value) {
	        var svg = d3.select(pathElement.svgElement.node().ownerSVGElement);
	        var defs = svg.select("svg defs");
	        if (defs.node() === null) {
	            defs = svg.append("defs");
	        }
	        var arrowMarkerPath = defs.select("marker#" + id + " path");
	        if (arrowMarkerPath) {
	            arrowMarkerPath.attr(key, value);
	        }
	    }
	
	    function mouseOverHandler() {
	        var config = self.config();
	        var flux = RegexUtil.replace(RegexUtil.dataRegex, config.flux, self.data());
	        if (flux && flux !== config.flux)
	            return;
	        if (!self.selected()) {
	            var pathConfig = config.path;
	            var borderColor = RegexUtil.replace(RegexUtil.dataRegex, pathConfig.overBorderColor, self.data());
	            var border = RegexUtil.replace(RegexUtil.dataRegex, pathConfig.overBorderWidth, self.data());
	            pathElement.data({
	                borderColor: borderColor,
	                border: border,
	                dasharray: RegexUtil.replace(RegexUtil.dataRegex, pathConfig.dasharray, self.data()),
	                borderOpacity: pathConfig.overBorderOpacity
	            });
	            if (arrow) {
	                setArrowProperty("link-arrow-over", "stroke", borderColor);
	                setArrowProperty("link-arrow-over", "fill", borderColor);
	                arrowForNoIE(pathElement, arrow.position === "start" ? "marker-start" : "marker-end", "url(#link-arrow-over)");
	            }
	        }
	    }
	
	    function mouseOutHandler() {
	        var config = self.config();
	        var flux = RegexUtil.replace(RegexUtil.dataRegex, config.flux, self.data());
	        if (flux && flux !== config.flux)
	            return;
	        if (!self.selected()) {
	            var pathConfig = config.path;
	            var borderColor = RegexUtil.replace(RegexUtil.dataRegex, pathConfig.borderColor, self.data());
	            var border = RegexUtil.replace(RegexUtil.dataRegex, pathConfig.borderWidth, self.data());
	            pathElement.data({
	                borderColor: borderColor,
	                border: border,
	                dasharray: RegexUtil.replace(RegexUtil.dataRegex, pathConfig.dasharray, self.data()),
	                borderOpacity: pathConfig.borderOpacity
	            });
	            if (arrow) {
	                setArrowProperty("link-arrow-over", "stroke", borderColor);
	                setArrowProperty("link-arrow-over", "fill", borderColor);
	                arrowForNoIE(pathElement, arrow.position === "start" ? "marker-start" : "marker-end", "url(#link-arrow" + self.id() + ")");
	            }
	        }
	    }
	
	    function setPath() {
	        //是否启用箭头图标
	        if (isShowArrow) {
	            addArrow(arrow.position === "start");
	            //刷新连线与两端节点外交矩形交点
	            refreshIntersectPoints();
	        }
	        pathElement.path(path(true));
	        pathElement.render();
	    }
	
	    function addArrow(isStartArrow) {
	        if (isStartArrow) {
	            addStartArrow();
	        } else {
	            addEndArrow();
	        }
	    }
	
	    //refreshIntersectPoints
	    function refreshIntersectPoints() {
	        var linkPath = path();
	        calcLinkIntersectionWithBound(source, linkPath, true);
	        calcLinkIntersectionWithBound(target, linkPath, false);
	    }
	
	    var nodeBound, spNode, epNode;
	    var boundRect = {
	        x: 0,
	        y: 0,
	        width: 0,
	        height: 0
	    };
	
	    function calcLinkIntersectionWithBound(target, path2, isStart) {
	        var ins = target.ins;
	        var isComponent = ins instanceof BaseComponent;
	        if (ins) {
	            if (isComponent) {
	                boundRect.x = target.x + ins.x();
	                boundRect.y = target.y + ins.y();
	                boundRect.width = ins.width();
	                boundRect.height = ins.height();
	            } else {
	                var bBox = ins.mainPlugin.getBBox();
	                boundRect.x = target.x + bBox.x;
	                boundRect.y = target.y + bBox.y;
	                boundRect.width = bBox.width;
	                boundRect.height = bBox.height;
	            }
	        } else {
	            boundRect.x = d3.event.x;
	            boundRect.y = d3.event.y;
	            boundRect.width = 0;
	            boundRect.height = 0;
	        }
	        var w = Math.round(boundRect.width);
	        var h = Math.round(boundRect.height);
	        var x = Math.round(boundRect.x);
	        var y = Math.round(boundRect.y);
	        var d3Path = d3.path();
	        //根据配置数据选择不同的外接图形
	        if (ins && ins.boundType() === "circle") {
	            d3Path.arc(Math.round(x), Math.round(y), Math.round(Math.max(w / 2, h / 2)), 0, math.TWO_PI);
	        } else {
	            d3Path.rect(x, y, w, h);
	        }
	
	        //计算交点
	        var path1 = d3Path.toString();
	        //获取两条路径交点集合数组
	        var cps = Raphael.pathIntersection(path1, path2);
	        //取第一个点作为需要的交点
	        if (cps.length > 0) {
	            var cp = cps[0];
	            isStart ? (sourceCx = Math.round(cp.x)) : (targetCx = Math.round(cp.x));
	            isStart ? (sourceCy = Math.round(cp.y)) : (targetCy = Math.round(cp.y));
	        } else {
	            isStart ? (sourceCx = undefined) : (targetCx = undefined);
	            isStart ? (sourceCy = undefined) : (targetCy = undefined);
	        }
	
	        //        //画出外接矩形，测试时使用
	        //        if(!nodeBound) {
	        //        	nodeBound = d3.select(document).select("g.topo-nodesContainer").append("path");
	        //        }
	        //        nodeBound.attr("d", path1)
	        //            .attr("stroke", "red").attr("stroke-opacity", 0.75).attr("fill", "none");
	        //            
	        //        //画出交点，测试时使用  
	        //        var pointNode;
	        //        if(isStart) {
	        //        	if(!spNode) {
	        //        		spNode = d3.select(document).select("g.topo-nodesContainer").append("circle");
	        //        	}
	        //        	pointNode = spNode;
	        //        } else {
	        //            if(!epNode) {
	        //                epNode = d3.select(document).select("g.topo-nodesContainer").append("circle");
	        //            }
	        //            pointNode = epNode;
	        //        }
	        //        if(cps.length > 0) {
	        //        	pointNode.attr("cx", cps[0].x).attr("cy", cps[0].y)
	        //                .attr("r", 2).attr("fill", "black");
	        //        }
	    }
	
	    function addEndArrow() {
	        var config = self.config();
	        var svg = d3.select(pathElement.svgElement.node().ownerSVGElement);
	        var defs = svg.select("svg defs");
	        if (defs.node() === null) {
	            defs = svg.append("defs");
	        }
	        //arrow marker
	        var arrowMarker = defs.select("marker#link-arrow" + self.id());
	        if (arrowMarker.node() === null) {
	            arrowMarker = defs.append("marker").attr("id", "link-arrow" + self.id());
	            arrowMarker.append("path");
	        }
	        arrowMarker
	            .attr("markerUnits", "strokeWidth")
	            .attr("markerWidth", "4")
	            .attr("markerHeight", "4")
	            .attr("viewBox", "0 0 5 4")
	            .attr("refX", 4)
	            .attr("refY", 2)
	            .attr("orient", "auto")
	            .style("display", isShowArrow ? "block" : "none");
	
	        var pathConfig = config.path;
	        var stroke = RegexUtil.replace(RegexUtil.dataRegex, pathConfig.borderColor, self.data());
	        arrowMarker.select("path")
	            .attr("d", "M0,0 L4,2 L0,4 Z")
	            .attr("fill", stroke)
	            .attr("stroke", stroke)
	            .attr("stroke-opacity", pathConfig.borderOpacity);
	
	        arrowForNoIE(pathElement, "marker-end", "url(#link-arrow" + self.id() + ")");
	
	        //over arrow marker
	        var arrowOverMarker = defs.select("marker#link-arrow-over");
	        if (arrowOverMarker.node() === null) {
	            arrowOverMarker = defs.append("marker").attr("id", "link-arrow-over");
	            arrowOverMarker.append("path");
	        }
	        arrowOverMarker
	            .attr("markerUnits", "strokeWidth")
	            .attr("markerWidth", "4")
	            .attr("markerHeight", "4")
	            .attr("viewBox", "0 0 5 4")
	            .attr("refX", 4)
	            .attr("refY", 2)
	            .attr("orient", "auto")
	            .style("display", isShowArrow ? "block" : "none");
	
	        var overStroke = RegexUtil.replace(RegexUtil.dataRegex, pathConfig.overBorderColor, self.data());
	        arrowOverMarker.select("path")
	            .attr("d", "M0,0 L4,2 L0,4 Z")
	            .attr("fill", overStroke)
	            .attr("stroke", overStroke)
	            .attr("stroke-opacity", pathConfig.overBorderOpacity);
	
	        //      cp = math.getCrossPointInRectAndSegment(x, y, w, h, source.x, source.y, target.x, target.y);
	    };
	
	    function addStartArrow() {
	        var config = self.config();
	        var svg = d3.select(_element.node().ownerSVGElement);
	        var defs = svg.select("svg defs");
	        if (defs.node() === null) {
	            defs = svg.append("defs");
	        }
	        var arrowMarker = defs.select("marker#link-arrow" + self.id());
	        if (arrowMarker.node() === null) {
	            arrowMarker = defs.append("marker").attr("id", "link-arrow" + self.id());
	            arrowMarker.append("path");
	        }
	        arrowMarker
	            .attr("markerUnits", "strokeWidth")
	            .attr("markerWidth", "4")
	            .attr("markerHeight", "4")
	            .attr("viewBox", "0 0 5 4")
	            .attr("refX", 0)
	            .attr("refY", 2)
	            .attr("orient", "auto")
	            .style("display", isShowArrow ? "block" : "none");
	
	        var pathConfig = self.config().path;
	        var stroke = RegexUtil.replace(RegexUtil.dataRegex, pathConfig.borderColor, self.data());
	        arrowMarker.select("path")
	            .attr("d", "M4,0 L0,2 L4,4 Z")
	            .attr("fill", stroke)
	            .attr("stroke", stroke)
	            .attr("stroke-opacity", pathConfig.borderOpacity);
	
	        arrowForNoIE(pathElement, "marker-start", "url(#link-arrow" + self.id() + ")");
	
	        //over arrow marker
	        var arrowOverMarker = defs.select("marker#link-arrow-over");
	        if (arrowOverMarker.node() === null) {
	            arrowOverMarker = defs.append("marker").attr("id", "link-arrow-over");
	            arrowOverMarker.append("path");
	        }
	        arrowOverMarker
	            .attr("markerUnits", "strokeWidth")
	            .attr("markerWidth", "4")
	            .attr("markerHeight", "4")
	            .attr("viewBox", "0 0 5 4")
	            .attr("refX", 0)
	            .attr("refY", 2)
	            .attr("orient", "auto")
	            .style("display", isShowArrow ? "block" : "none");
	
	        var overStroke = RegexUtil.replace(RegexUtil.dataRegex, pathConfig.overBorderColor, self.data());
	        arrowOverMarker.select("path")
	            .attr("d", "M4,0 L0,2 L4,4 Z")
	            .attr("fill", overStroke)
	            .attr("stroke", overStroke)
	            .attr("stroke-opacity", pathConfig.overBorderOpacity);
	    }
	
	    function position() {
	        if (!label) {
	            return;
	        }
	        var array = centerPointAndAngle();
	        var position = array[0];
	        return "translate(" + [position.x, position.y] + ")" + " rotate(" + array[1] + ")";
	    }
	
	    var labelP;
	
	    function centerPointAndAngle() {
	        var config = self.config();
	        var angle, position;
	        //若显示箭头，则有交点时使用交点数据cx,cy，没有则使用中心点数据x,y
	        var sp = source;
	        var tp = target;
	        if (isShowArrow) {
	            !isNaN(sourceCx) && (spCache.x = sourceCx, spCache.y = sourceCy, sp = spCache);
	            !isNaN(targetCx) && (tpCache.x = targetCx, tpCache.y = targetCy, tp = tpCache);
	        }
	        if (config.math) {
	            switch (config.math) {
	                case 1:
	                    position = math.calculateCenter(sp, tp);
	                    break;
	                case 2:
	                    var num = parseInt(RegexUtil.replace(RegexUtil.dataRegex, config.num, self.data()));
	                    var array = math.parallelDeviationPoint(sp, tp, label.actualHeight() * fontSizeScale, num);
	                    position = math.calcBezCurvePointWithTime(array[1], source, target, 0.5);
	                    break;
	                case 3:
	                    position = math.calculateCenter(sp, tp);
	                    break;
	                case 4:
	                    position = math.radialCenterPoint(RegexUtil.replace(RegexUtil.dataRegex, config.source, self.data()), RegexUtil.replace(RegexUtil.dataRegex, config.target, self.data()));
	                    angle = math.radialLinkAngle(RegexUtil.replace(RegexUtil.dataRegex, config.source, self.data()), RegexUtil.replace(RegexUtil.dataRegex, config.target, self.data()));
	                    break;
	                case 5:
	                    var isVer = config.path ? config.path.isVer : false;
	                    position = math.calculateCenter(sp, tp);
	                    angle = isVer ? 0 : (sp.y < tp.y ? 90 : -90);
	                    break;
	            }
	        }
	        if (!position)
	            position = math.calculateCenter(sp, tp);
	        if (!angle)
	            angle = math.linkAngle(sp, tp);
	
	        //        //画出结果点，测试时使用  
	        //        if(!labelP) {
	        //            labelP = d3.select(document).select("g.topo-nodesContainer").append("circle");
	        //        }
	        //        labelP.attr("cx", position.x).attr("cy", position.y)
	        //            .attr("r", 2).attr("fill", "#000");
	
	        return [position, angle];
	    }
	
	    function path(isUseCp) {
	        var config = self.config();
	        //若设置使用交点，则有交点时使用交点数据cx,cy，没有则使用中心点数据x,y
	        var sp = source;
	        var tp = target;
	        if (isUseCp) {
	            !isNaN(sourceCx) && (spCache.x = sourceCx, spCache.y = sourceCy, sp = spCache);
	            !isNaN(targetCx) && (tpCache.x = targetCx, tpCache.y = targetCy, tp = tpCache);
	        }
	        if (config.math) {
	            switch (config.math) {
	                case 2:
	                    var num = RegexUtil.replace(RegexUtil.dataRegex, config.num, self.data());
	                    var offset = label ? (label.actualHeight() == 0 ? 12 : label.actualHeight()) : 12; //IE获取为0？；
	                    return math.quadraticCurveLinkPath(sp, tp, offset * 2, num);
	                case 3:
	                    return math.besselLinkPath(sp, tp, config.besselX);
	                case 4:
	                    return math.radialLinkPath(sp, tp, RegexUtil.replace(RegexUtil.dataRegex, config.target, self.data()));
	                case 5:
	                    var addSize = config.path ? config.path.addSize : undefined;
	                    var isVer = config.path ? config.path.isVer : false;
	                    return math.polylinePath(sp, tp, isVer, addSize);
	                case 1:
	                default:
	                    return math.baseLinkPath(sp, tp);
	            }
	        } else {
	            return pathFunction();
	        }
	    }
	};
	
	ConfigLink.struct = function (ghca_charts) {
	    var Plugin = ghca_charts.view.elements.plugins.plugin;
	    Plugin.struct(ghca_charts);
	    ConfigLink.prototype = Object.create(Plugin.prototype);
	    ConfigLink.prototype.constructor = ConfigLink;
	};
	
	module.exports = ConfigLink;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {var CurveLink = function (_element,_data) {
		
		// --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const ElementUtil = ghca_charts.view.util.elementUtil;
	    const BaseLink = ghca_charts.view.elements.plugins.links.baseLink;
	    const Math = ghca_charts.view.util.math;
	
	    BaseLink.apply(this,arguments);
	    var self = this;
	
	    //override
	    this.nameSpace = function(){
	        return "curveLink";
	    }
	    //override
	    this.setPath = function(pathElement,d){
	    	var isShowArrow = self.isShowArrow();
	    	if(isShowArrow) {
	            self.addArrow(pathElement);
	        }
	        var target = isShowArrow ? {x:d.target.cx, y:d.target.cy} : d.target;
	        // var ele = self.label.select("text"),fontSize=16;
	        // console.info(ele);
	        // if(ele)fontSize = ele.node().getBBox().height;
	        fontSize = self.label ? self.label.actualHeight() : 12;
	        var array = Math.parallelDeviationPoint(d.source,target,fontSize*3,d.lineIndex);
	        var controlX = isShowArrow && d.hasOwnProperty("controlX") ? d.controlX : array[1].x;
	        var controlY = isShowArrow && d.hasOwnProperty("controlY") ? d.controlY : array[1].y;
	        var path  = d3.path();
	        path.moveTo(d.source.x,d.source.y);
	        path.quadraticCurveTo(controlX,controlY,target.x,target.y);
	        ElementUtil.setElementProperties(pathElement,{d:path.toString()});
	    }
	    //override
	    this.labelLayout = function(element,plugin,d){
	        var array = Math.parallelDeviationPoint(d.source,d.target,plugin.actualHeight()*1.5,d.lineIndex);
	        ElementUtil.setElementProperties(element,{transform:"translate(" + [array[1].x,array[1].y] + ")"+
	        " rotate(" + Math.linkAngle(d.source,d.target) + ")"});
	    }
	};
	
	CurveLink.struct = function(ghca_charts) {
		var BaseLink = ghca_charts.view.elements.plugins.links.baseLink;
		BaseLink.struct(ghca_charts);
	    CurveLink.prototype = Object.create(BaseLink.prototype);
	    CurveLink.prototype.constructor = CurveLink;
	};
	
	module.exports = CurveLink;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {var Link = function (_element,_data) {
		
		// --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const math = ghca_charts.view.util.math;
	    const Plugin = ghca_charts.view.elements.plugins.plugin;
	    const CommonUtil = ghca_charts.view.util.commonUtil;
	    const ElementUtil = ghca_charts.view.util.elementUtil;
	    const BaseEvent = ghca_charts.events.BaseEvent;
	    const PathElement = ghca_charts.view.elements.pathElement;
	    const Label = ghca_charts.view.elements.plugins.label.label;
	    const BaseComponent = ghca_charts.view.component.baseComponent;
	    const ClassFactory = ghca_charts.view.util.classFactory;
	    const RegexUtil = ghca_charts.view.util.regexUtil;
	    const ObjectUtil =  ghca_charts.view.util.objectUtil;
	    const EventUtil = ghca_charts.view.util.eventUtil;
	    const UUID = ghca_charts.view.util.UUIDUtil;
	
	    Plugin.apply(this,arguments);
	    
	    var self = this;
	    var pathElement, label,labelContainer, arrow;
	    var isShowArrow = false;
	    var fontSizeScale=2;
	    var spCache = {}, tpCache = {};
	    var source, target;//连线起点终点数据对象
	    var sourceCx, sourceCy, targetCx, targetCy;//连线起点、终点交点坐标
	    self.dispatch = d3.dispatch("selectedChange");
	    self.plugins = [];
	    //override
	    this.nameSpace = function(){
	        return "link";
	    }
	    self.config({
	        source:"{source}",
	        target:"{target}",
	        math:2,
	        num:6,
	        besselX:true,
	        path:{
	            dasharray:"5,5",
	            borderWidth:2,
	            borderColor:"{color}",
	            borderOpacity:.6,
	            overDasharray:"5,5",
	            overBorderWidth:10,
	            overBorderColor:"red",
	            overBorderOpacity:.8
	        },
	        label:{
	            clazz:"label",
	            config:{
	                text:"{name}:{value}",
	                maxWidth:60,
	                backGroundColor:"green",
	                backGroundOpacity:.3,
	                borderRadius:4,
	                padding:4,
	                fontColor:"0x000000",
	                fontFamily:"宋体",
	                fontSize:12  
	            }
	        }
	    });
	    
	    // ------------------------------
	    // id
	    // ------------------------------
	
	    var id = UUID.generateUUID();
	    this.id = function(value) {
	        return id;
	    };
	    
	    var _selected = false;
	    this.selected = function(_p){
	        if(!arguments.length)return _selected;
	        _selected = _p;
	        self.dispatch.call("selectedChange",this , new BaseEvent(self,{selected:_selected}));
	        return this;
	    }
	    this.selectedChange = function(seleced){
	        var config = self.config();
	        var pathConfig = config.path;
	        if(seleced){
	            pathElement.data({
	                borderColor:RegexUtil.replace(RegexUtil.dataRegex,pathConfig.overBorderColor,self.data()),
	                border:RegexUtil.replace(RegexUtil.dataRegex,pathConfig.overBorderWidth,self.data()),
	                dasharray:pathConfig.overDasharray,
	                borderOpacity:pathConfig.overBorderOpacity
	            });
	        }else{
	            pathElement.data({
	                borderColor:RegexUtil.replace(RegexUtil.dataRegex,pathConfig.borderColor,self.data()),
	                border:RegexUtil.replace(RegexUtil.dataRegex,pathConfig.borderWidth,self.data()),
	                dasharray:pathConfig.dasharray,
	                borderOpacity:pathConfig.borderOpacity
	            });
	        }
	    }
	    var pathFunc;
	    this.pathFunc = function(func){
	        if(!arguments.length)return pathFunc;
	        pathFunc = func;
	        return this;
	    }
	    //override
	    this.nameSpace = function(){
	        return "link";
	    }
	
	    //override
	    this.update = function(g) {
	    	var config = self.config();
	    	var pathConfig = config.path;
	        arrow = pathConfig.arrow;
	    	var data = self.data();
	    	source = RegexUtil.replace(RegexUtil.dataRegex,config.source,data);
	        target = RegexUtil.replace(RegexUtil.dataRegex,config.target,data);
	        pathElement.borderColor(RegexUtil.replace(RegexUtil.dataRegex,pathConfig.borderColor,data));
	        pathElement.border(pathConfig.borderWidth);
	        pathElement.dasharray(pathConfig.dasharray);
	        pathElement.borderOpacity(pathConfig.borderOpacity);
	        pathElement.data({borderColor:RegexUtil.replace(RegexUtil.dataRegex,pathConfig.borderColor,data),
	            border:pathConfig.borderWidth,dasharray:pathConfig.dasharray
	            ,borderOpacity:pathConfig.borderOpacity});
	        isShowArrow = arrow ? arrow.visible === true : false;
	        var labelConfig = config.label ? config.label.config : null;
	        if(labelConfig) {
	            if(labelContainer) {
	                labelContainer.attr("transform",position());
	                if(label) {
	                    label.config(labelConfig);
	                    label.render();
	                    label.transform("translate(" + [Math.round(-label.actualWidth()/2),Math.round(-label.actualHeight()/2)] + ")");
	                }
	            }
	        }
	        setPath();
	        self.plugins.forEach(function(d,i){
	            d.render();
	            pluginLayout(d,d);
	        });
	    }
	    
	    //override
	    this.drawPlugin = function(g){
	    	g.attr("style","cursor:pointer;");
	        var config = self.config();
	        source = RegexUtil.replace(RegexUtil.dataRegex,config.source,self.data());
	        target = RegexUtil.replace(RegexUtil.dataRegex,config.target,self.data());
	        var pathConfig = config.path;
	        arrow = pathConfig.arrow;
	        isShowArrow = arrow ? arrow.visible === true : false;
	        pathElement = new PathElement(g,{
	            borderColor:RegexUtil.replace(RegexUtil.dataRegex,pathConfig.borderColor,self.data()),
	            border:RegexUtil.replace(RegexUtil.dataRegex,pathConfig.borderWidth,self.data()),
	            dasharray:pathConfig.dasharray,
	            borderOpacity:pathConfig.borderOpacity
	        });
	        var labelConfig = config.label ? config.label.config : null;
	        if(labelConfig) {
		        labelContainer = g.append("svg:g");
	            label = new Label(labelContainer,self.data());
	            label.config(labelConfig);
	        }
	
	        if(label){
	            label.render();
	            label.transform("translate(" + [Math.round(-label.actualWidth()/2),Math.round(-label.actualHeight()/2)] + ")");
	            labelContainer.attr("transform",position());
	        }
	        var plugins = config.plugins;
	        if(plugins){
	            plugins.forEach(function(d,i){
	                if(d.render==undefined || RegexUtil.replace(RegexUtil.dataRegex,d.render,self.data())=="true"){
	                    var plugin = ClassFactory.newPluginInstance(d.clazz,[g,self.data()]);
	                    plugin.config(d.config);
	                    plugin.render();
	                    self.plugins.push(plugin);
	                    pluginLayout(plugin,d);
	                }
	            });
	        }
	        setPath();
	    }
	
	    function pluginLayout(plugin,d){
	        var array = centerPointAndAngle();
	        // var config = self.config();
	        // var source = RegexUtil.replace(RegexUtil.dataRegex,config.source,self.data()),
	        //     target = RegexUtil.replace(RegexUtil.dataRegex,config.target,self.data());
	        // var angle = math.getPointAngle(source,target);
	        // console.log("==========angle",angle)
	        var position = array[0];
	        var point = [position.x,position.y];
	        if(label){
	            point = math.circumferencePoint(label.actualWidth(),0,position);
	        }
	        plugin.transform("translate(" + point + ")");
	    }
	
	    //override
	    this.bindEvents = function(g){
	        g.on('mouseover', function(d) {
	        	var evt = EventUtil.createCustomEvent(BaseEvent.SHOW_TOOL_TIP, true, true);
	            d3.select(this).node().dispatchEvent(evt);
	            mouseOverHandler();
	        });
	        g.on('mousemove', function(d) {
	            var evt = EventUtil.createCustomEvent(BaseEvent.UPDATE_TOOL_TIP, true, true, d);
	            d3.select(this).node().dispatchEvent(evt);
	        });
	        g.on('mouseout', function(d) {
	            var evt = EventUtil.createCustomEvent(BaseEvent.HIDE_TOOL_TIP, true, true);
	            d3.select(this).node().dispatchEvent(evt);
	            mouseOutHandler();
	        });
	        g.on('click', function(d) {
	        	var evt = EventUtil.createCustomEvent(BaseEvent.LINK_CLICK, true, true, {data:d});
	            d3.select(this).node().dispatchEvent(evt);
	            self.selected(!_selected);
	        });
	        self.dispatch.on("selectedChange."+self.nameSpace(),function(e){
	            self.selectedChange(e.data.selected);
	        });
	    }
	    
	    var pathFunction = null;
	    this.pathFunction = function(value) {
	        if (!arguments.length)
	            return pathFunction;
	        pathFunction = value;
	        return this;
	    };
	    
	    function arrowForNoIE(pathElement, key, value) {
	        if(CommonUtil.isIE()) {
	//            var pathNode = pathElement.svgElement.node();
	//            var parentNode = pathNode.parentNode;
	//            parentNode.removeChild(pathNode);
	//            parentNode.appendChild(pathNode);
	        } else {
	        	pathElement.svgElement.attr(key, value);
	        }
	    }
	    
	    function setArrowProperty(id, key, value) {
	    	var svg = d3.select(pathElement.svgElement.node().ownerSVGElement);
	        var defs = svg.select("svg defs"); 
	        if(defs.node() === null) {
	            defs = svg.append("defs");
	        }
	        var arrowMarkerPath = defs.select("marker#" + id + " path");
	        if(arrowMarkerPath) {
	            arrowMarkerPath.attr(key, value);
	        }
	    }
	
	    function mouseOverHandler(){
	        var config = self.config();
	        var flux = RegexUtil.replace(RegexUtil.dataRegex,config.flux,self.data());
	        if(flux && flux !== config.flux)
	            return;
	        if(!self.selected()) {
	            var pathConfig = config.path;
	            var borderColor = RegexUtil.replace(RegexUtil.dataRegex,pathConfig.overBorderColor,self.data());
	            var border = RegexUtil.replace(RegexUtil.dataRegex,pathConfig.overBorderWidth,self.data());
	        	pathElement.data({
	        	   borderColor:borderColor,
	        	   border:border,
	        	   dasharray:pathConfig.overDasharray,
	        	   borderOpacity:pathConfig.overBorderOpacity
	    	    });
	            if(arrow) {
	            	setArrowProperty("link-arrow-over", "stroke", borderColor);
	            	setArrowProperty("link-arrow-over", "fill", borderColor);
	                arrowForNoIE(pathElement, arrow.position === "start" ? "marker-start" : "marker-end", isShowArrow ? "url(#link-arrow-over)" : null);
	            }
	        }
	    }
	    
	    function mouseOutHandler(){
	        var config = self.config();
	        var flux = RegexUtil.replace(RegexUtil.dataRegex,config.flux,self.data());
	        if(flux && flux !== config.flux)
	            return;
	        if(!self.selected()) {
	            var pathConfig = config.path;
	        	var borderColor = RegexUtil.replace(RegexUtil.dataRegex,pathConfig.borderColor,self.data());
	        	var border = RegexUtil.replace(RegexUtil.dataRegex,pathConfig.borderWidth,self.data());
	            pathElement.data({
	                borderColor:borderColor,
	                border:border,
	                dasharray:pathConfig.dasharray,
	                borderOpacity:pathConfig.borderOpacity
	            });
	            if(arrow) {
	            	setArrowProperty("link-arrow-over", "stroke", borderColor);
	            	setArrowProperty("link-arrow-over", "fill", borderColor);
	                arrowForNoIE(pathElement, arrow.position === "start" ? "marker-start" : "marker-end", isShowArrow ? "url(#link-arrow" + self.id() + ")" : null);
	            }
	        }
	    }
	
	    function setPath() {
	    	//当有箭头配置时，检测是否启用箭头
	    	if(arrow) {
	    		//是否启用箭头图标
	        	if(isShowArrow) {
	        		addArrow(arrow.position === "start");
	        	} else {
	        		arrowForNoIE(pathElement, arrow.position === "start" ? "marker-start" : "marker-end", null);
	        	}
	        	//刷新连线与两端节点外交矩形交点
	            refreshIntersectPoints();
	    	}
	        
	        pathElement.path(path(true));
	        pathElement.render();
	    }
	    
	    function addArrow(isStartArrow) {
	    	if(isStartArrow) {
	    		addStartArrow();
	    	} else {
	    		addEndArrow();
	    	}
	    }
	    
	    //refreshIntersectPoints
	    function refreshIntersectPoints() {
	        var linkPath = path();
	        calcLinkIntersectionWithBound(source, linkPath, true);
	        calcLinkIntersectionWithBound(target, linkPath, false);
	    }
	    
	    var nodeBound, spNode, epNode;
	    var boundRect = {x:0, y:0, width:0, height:0};
	    var is2DLib;
	    try {
	    	is2DLib = Intersection ? true : false;
	    } catch(e) {
	    	is2DLib = false;
	    }
	    if(is2DLib) {
	    	var pathNode1 = document.createElement("path");
	        pathNode1.setAttribute("d", "");
	        var pathNode2 = document.createElement("path");
	        pathNode2.setAttribute("d", "");
	        var pathShape1 = new Path(pathNode1);
	        var pathShape2 = new Path(pathNode2);
	    }
	    function calcLinkIntersectionWithBound(target, path2, isStart) {
	    	var ins = target.ins;
	        var isComponent = ins instanceof BaseComponent;
	        if(ins) {
	        	if(isComponent) {
	        		boundRect.x        = target.x + ins.x();
	                boundRect.y        = target.y + ins.y();
	                boundRect.width    = ins.width();
	                boundRect.height   = ins.height();
	        	} else {
	        		var bBox = ins.mainPlugin.getBBox();
	        		boundRect.x        = target.x + bBox.x;
	                boundRect.y        = target.y + bBox.y;
	                boundRect.width    = bBox.width;
	                boundRect.height   = bBox.height;
	        	}
	        } else {
	        	boundRect.x        = d3.event.x;
	        	boundRect.y        = d3.event.y;
	        	boundRect.width    = 0;
	        	boundRect.height   = 0;
	        }
	        var w = Math.round(boundRect.width);
	        var h = Math.round(boundRect.height);
	        var x = Math.round(boundRect.x);
	        var y = Math.round(boundRect.y);
	        var d3Path = d3.path();
	        //根据配置数据选择不同的外接图形
	        if(ins.boundType() === "circle") {
	    		d3Path.arc(Math.round(x+w/2), Math.round(y+h/2), Math.round(Math.max(w/2, h/2)), 0, math.TWO_PI); 
	        } else {
	        	if(is2DLib) {
	        		d3Path.moveTo(x, y);
	                d3Path.lineTo(x+w, y);
	                d3Path.lineTo(x+w, y+h);
	                d3Path.lineTo(x, y+h);
	                d3Path.lineTo(x, y);
	        	} else {
	        		d3Path.rect(x, y, w, h);
	        	}
	        }
	        
	        //计算交点
	        var path1 = d3Path.toString();
	        //获取两条路径首个交点
	        var cps;
	        if(is2DLib) {
	        	pathShape1.parseData(path1);
	            pathShape2.parseData(path2);
	            cps = Intersection.intersectPathShape(pathShape1, pathShape2, true).points;//效率较高
	        } else {
	        	cps = Raphael.getPathFirstIntersection(path1, path2);//效率较低
	        }
	        
	        //取第一个点作为需要的交点
	        if(ObjectUtil.isArray(cps) && cps.length > 0) {
	        	var cp = cps[0];
	        	isStart ? (sourceCx = Math.round(cp.x)) : (targetCx = Math.round(cp.x)); 
	        	isStart ? (sourceCy = Math.round(cp.y)) : (targetCy = Math.round(cp.y)); 
	        } else {
	            isStart ? (sourceCx = undefined) : (targetCx = undefined); 
	            isStart ? (sourceCy = undefined) : (targetCy = undefined);
	        }
	        
	//        //画出外接矩形，测试时使用
	//        if(!nodeBound) {
	//        	nodeBound = d3.select(document).select("g.topo-nodesContainer").append("path");
	//        }
	//        nodeBound.attr("d", path1)
	//            .attr("stroke", "red").attr("stroke-opacity", 0.75).attr("fill", "none");
	//            
	//        //画出交点，测试时使用  
	//        var pointNode;
	//        if(isStart) {
	//        	if(!spNode) {
	//        		spNode = d3.select(document).select("g.topo-nodesContainer").append("circle");
	//        	}
	//        	pointNode = spNode;
	//        } else {
	//            if(!epNode) {
	//                epNode = d3.select(document).select("g.topo-nodesContainer").append("circle");
	//            }
	//            pointNode = epNode;
	//        }
	//        if(cps.length > 0) {
	//        	pointNode.attr("cx", cps[0].x).attr("cy", cps[0].y)
	//                .attr("r", 2).attr("fill", "black");
	//        }
	    }
	    
	    function addEndArrow() {
	    	var config = self.config();
	        var svg = d3.select(pathElement.svgElement.node().ownerSVGElement);
	        var defs = svg.select("svg defs"); 
	        if(defs.node() === null) {
	            defs = svg.append("defs");
	        }
	        //arrow marker
	        var arrowMarker = defs.select("marker#link-arrow" + self.id());
	        if(arrowMarker.node() === null) {
	            arrowMarker = defs.append("marker").attr("id", "link-arrow" + self.id());  
	            arrowMarker.append("path");
	        }
	        arrowMarker
	            .attr("markerUnits","strokeWidth")  
	            .attr("markerWidth","4")  
	            .attr("markerHeight","4")  
	            .attr("viewBox","0 0 5 4")   
	            .attr("refX",4)  
	            .attr("refY",2)  
	            .attr("orient","auto")
	            .style("display", isShowArrow ? "block" : "none");  
	              
	        var pathConfig = config.path;
	        var stroke = RegexUtil.replace(RegexUtil.dataRegex,pathConfig.borderColor,self.data());
	        arrowMarker.select("path") 
	            .attr("d", "M0,0 L4,2 L0,4 Z")  
	            .attr("fill", stroke)
	            .attr("stroke", stroke)
	            .attr("stroke-opacity", pathConfig.borderOpacity);
	            
	        arrowForNoIE(pathElement, "marker-end", "url(#link-arrow"+self.id()+")");
	        
	        //over arrow marker
	        var arrowOverMarker = defs.select("marker#link-arrow-over");
	        if(arrowOverMarker.node() === null) {
	            arrowOverMarker = defs.append("marker").attr("id", "link-arrow-over");  
	            arrowOverMarker.append("path");
	        }
	        arrowOverMarker
	            .attr("markerUnits","strokeWidth")  
	            .attr("markerWidth","4")  
	            .attr("markerHeight","4")  
	            .attr("viewBox","0 0 5 4")   
	            .attr("refX",4)  
	            .attr("refY",2)  
	            .attr("orient","auto")
	            .style("display", isShowArrow ? "block" : "none");  
	         
	        var overStroke = RegexUtil.replace(RegexUtil.dataRegex,pathConfig.overBorderColor,self.data());
	        arrowOverMarker.select("path") 
	            .attr("d", "M0,0 L4,2 L0,4 Z")  
	            .attr("fill", overStroke)
	            .attr("stroke", overStroke)
	            .attr("stroke-opacity", pathConfig.overBorderOpacity);
	    };
	    
	    function addStartArrow() {
	    	var config = self.config();
	    	var svg = d3.select(_element.node().ownerSVGElement);
	        var defs = svg.select("svg defs");
	        if(defs.node() === null) {
	            defs = svg.append("defs");
	        }
	        var arrowMarker = defs.select("marker#link-arrow" + self.id());
	        if(arrowMarker.node() === null) {
	        	arrowMarker = defs.append("marker").attr("id", "link-arrow" + self.id());  
	            arrowMarker.append("path");
	        }
	        arrowMarker
	            .attr("markerUnits","strokeWidth")  
	            .attr("markerWidth","4")  
	            .attr("markerHeight","4")  
	            .attr("viewBox","0 0 5 4")   
	            .attr("refX",0)  
	            .attr("refY",2)  
	            .attr("orient","auto")
	            .style("display", isShowArrow ? "block" : "none");  
	              
	        var pathConfig = self.config().path;
	        var stroke = RegexUtil.replace(RegexUtil.dataRegex,pathConfig.borderColor,self.data());
	        arrowMarker.select("path")  
	            .attr("d", "M4,0 L0,2 L4,4 Z")  
	            .attr("fill", stroke)
	            .attr("stroke", stroke)
	            .attr("stroke-opacity", pathConfig.borderOpacity);
	                
	        arrowForNoIE(pathElement, "marker-start", "url(#link-arrow" + self.id() + ")");
	        
	        //over arrow marker
	        var arrowOverMarker = defs.select("marker#link-arrow-over");
	        if(arrowOverMarker.node() === null) {
	            arrowOverMarker = defs.append("marker").attr("id", "link-arrow-over");  
	            arrowOverMarker.append("path");
	        }
	        arrowOverMarker
	            .attr("markerUnits","strokeWidth")  
	            .attr("markerWidth","4")  
	            .attr("markerHeight","4")  
	            .attr("viewBox","0 0 5 4")   
	            .attr("refX",0)  
	            .attr("refY",2)  
	            .attr("orient","auto")
	            .style("display", isShowArrow ? "block" : "none");  
	        
	        var overStroke = RegexUtil.replace(RegexUtil.dataRegex,pathConfig.overBorderColor,self.data());
	        arrowOverMarker.select("path") 
	            .attr("d", "M4,0 L0,2 L4,4 Z") 
	            .attr("fill", overStroke)
	            .attr("stroke", overStroke)
	            .attr("stroke-opacity", pathConfig.overBorderOpacity);
	    }
	
	    function position() {
	    	if(!label) {
	    		return;
	    	}
	        var array = centerPointAndAngle();
	    	var position = array[0];
	        return "translate(" + [Math.round(position.x),Math.round(position.y)] + ")"+" rotate(" + array[1] + ")";
	    }
	
	    var labelP;
	    function centerPointAndAngle() {
	        var config = self.config();
	        var angle, position;
	        //若显示箭头，则有交点时使用交点数据cx,cy，没有则使用中心点数据x,y
	        var sp = source;
	        var tp = target;
	        if(isShowArrow) {
	            !isNaN(sourceCx) && (spCache.x = sourceCx, spCache.y = sourceCy, sp = spCache);
	            !isNaN(targetCx) && (tpCache.x = targetCx, tpCache.y = targetCy, tp = tpCache);
	        }
	        if(config.math){
	            switch(config.math){
	                case 1:
	                    position = math.calculateCenter(sp,tp);
	                    break;
	                case 2:
	                    var num = parseInt(RegexUtil.replace(RegexUtil.dataRegex,config.num,self.data()));
	                    var array = math.parallelDeviationPoint(sp,tp,label.actualHeight()*fontSizeScale,num);    
	                    position =  math.calcBezCurvePointWithTime(array[1],source,target,0.5);
	                    break;
	                case 3:
	                    position = math.calculateCenter(sp,tp);
	                    break;
	                case 4:
	                    position = math.radialCenterPoint(RegexUtil.replace(RegexUtil.dataRegex,config.source,self.data()),RegexUtil.replace(RegexUtil.dataRegex,config.target,self.data()));
	                    angle = math.radialLinkAngle(RegexUtil.replace(RegexUtil.dataRegex,config.source,self.data()),RegexUtil.replace(RegexUtil.dataRegex,config.target,self.data()));
	                    break;
	                case 5:
	                    var isVer = config.path ? config.path.isVer : false;
	                    position = math.calculateCenter(sp,tp);
	                    angle = isVer ? 0 : (sp.y < tp.y ? 90 : -90);
	                    break;
	            }
	        }
	        if(!position)
	           position = math.calculateCenter(sp,tp);
	        if(!angle)
	           angle = math.linkAngle(sp,tp);
	           
	//        //画出结果点，测试时使用  
	//        if(!labelP) {
	//            labelP = d3.select(document).select("g.topo-nodesContainer").append("circle");
	//        }
	//        labelP.attr("cx", position.x).attr("cy", position.y)
	//            .attr("r", 2).attr("fill", "#000");
	            
	        return [position,angle];
	    }
	
	    function path(isUseCp) {
	        var config = self.config();
	        //若设置使用交点，则有交点时使用交点数据cx,cy，没有则使用中心点数据x,y
	        var sp = source;
	        var tp = target;
	        if(isUseCp) {
	        	!isNaN(sourceCx) && (spCache.x = sourceCx, spCache.y = sourceCy, sp = spCache);
	            !isNaN(targetCx) && (tpCache.x = targetCx, tpCache.y = targetCy, tp = tpCache);
	        }
	        if(config.math) {
	            switch(config.math) {
	                case 2:
	                    var num = RegexUtil.replace(RegexUtil.dataRegex,config.num,self.data());
	                    var offset = label ? (label.actualHeight()==0?12:label.actualHeight()) : 12;//IE获取为0？；
	                    return math.quadraticCurveLinkPath(sp,tp,offset*2,num);
	                case 3:
	                    return math.besselLinkPath(sp,tp,config.besselX);
	                case 4:
	                    return math.radialLinkPath(sp,tp,RegexUtil.replace(RegexUtil.dataRegex,config.target,self.data()));
	                case 5:
	                    var addSize = config.path ? config.path.addSize : undefined;
	                    var isVer = config.path ? config.path.isVer : false;
	                    return math.polylinePath(sp,tp,isVer,addSize);
	                case 1:
	                default:
	                    return math.baseLinkPath(sp,tp);
	            }
	        } else {
	        	return pathFunction();
	        }
	    }
	};
	
	Link.struct = function(ghca_charts) {
		var Plugin = ghca_charts.view.elements.plugins.plugin;
		Plugin.struct(ghca_charts);
	    Link.prototype = Object.create(Plugin.prototype);
	    Link.prototype.constructor = Link;
	};
	
	module.exports = Link;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {var CurveLink = function (_element,_data) {
		
		// --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const ElementUtil = ghca_charts.view.util.elementUtil;
	    const BaseLink = ghca_charts.view.elements.plugins.links.baseLink;
	    const Math = ghca_charts.view.util.math;
	
	    BaseLink.apply(this,arguments);
	    var self = this;
	
	    //override
	    this.nameSpace = function(){
	        return "parallelLink";
	    }
	    //override
	    this.setPath = function(pathElement,d){
	    	if(self.isShowArrow()) {
	            self.addArrow(pathElement);
	        }
	        var target = self.isShowArrow() ? {x:d.target.cx, y:d.target.cy} : d.target;
	//        var ele = _element.select("text"),fontSize=16;
	//        if(ele)fontSize = ele.node().getBBox().height;
	        fontSize = self.label ? self.label.actualHeight() : 12;
	        var array = Math.parallelDeviationPoint(d.source,target,fontSize*1.5,d.lineIndex);
	        var path  = d3.path();
	        var sx = d.source.x, sy = d.source.y, ex = target.x, ey = target.y, x = array[0].x, y = array[0].y;
	        path.moveTo(sx,sy);
	        //这里这样比较是因为若xy都相同，则这条线是从自身画到自身，若显示箭头，则箭头方向错误，所以当自身画到自身时，则省略掉这段线段
	        if(sx !== x || sy !== y) {
	        	path.lineTo(x,y);
	        }
	        x = array[2].x, y = array[2].y;
	        if(ex !== x || ey !== y) {
	            path.lineTo(x,y);
	        }
	        path.lineTo(ex,ey);
	        ElementUtil.setElementProperties(pathElement,{d:path.toString()});
	    }
	    //override
	    this.labelLayout = function(element,plugin,d){
	        var array = Math.parallelDeviationPoint(d.source,d.target,plugin.actualHeight()*1.5,d.lineIndex);
	        ElementUtil.setElementProperties(element,{transform:"translate(" + [array[1].x,array[1].y] + ")"+
	        " rotate(" + Math.linkAngle(d.source,d.target) + ")"});
	    }
	};
	
	CurveLink.struct = function(ghca_charts) {
		var BaseLink = ghca_charts.view.elements.plugins.links.baseLink;
		BaseLink.struct(ghca_charts);
	    CurveLink.prototype = Object.create(BaseLink.prototype);
	    CurveLink.prototype.constructor = CurveLink;
	};
	
	module.exports = CurveLink;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {var SankeyLink = function (_element,_data) {
		
		// --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const ElementUtil = ghca_charts.view.util.elementUtil;
	    const BaseLink = ghca_charts.view.elements.plugins.links.baseLink;
	    const MathUtil = ghca_charts.view.util.math;
	    const RegexUtil = ghca_charts.view.util.regexUtil;
	
	    BaseLink.apply(this,arguments);
	    var self = this;
	    var superDrawPluginFunction = this.drawPlugin;
	    
	    //--------------------------------------------------------------------------
	    //
	    //  Attributes
	    //
	    //--------------------------------------------------------------------------
	    
	    // ------------------------------
	    // path
	    // ------------------------------
	
	    /**
	     * 连线路径描述字符串，比如"M0,0 L1,1"
	     */
	    var path = null;
	    this.path = function(value) {
	        if (!arguments.length)
	            return path;
	        path = value;
	        return this;
	    };
	
	    // ------------------------------
	    // pathFunction
	    // ------------------------------
	
	    /**
	     * 连线路径生成方法，若注册该方法，则按该方法返回的内容渲染path，忽略path属性
	     */
	    var pathFunction = null;
	    this.pathFunction = function(value) {
	        if (!arguments.length)
	            return pathFunction;
	        pathFunction = value;
	        return this;
	    };
	
	    // ------------------------------
	    // sort
	    // ------------------------------
	
	    /**
	     * 连线排序规则方法，若注册该方法，则按该方法对连线进行排序
	     */
	    var sortFunction = null;
	    this.sortFunction = function(value) {
	        if (!arguments.length)
	            return sortFunction;
	        sortFunction = value;
	        return this;
	    };
	
	    // ------------------------------
	    // title
	    // ------------------------------
	
	    /**
	     * path元素的title内容字符串
	     */
	    var title = null;
	    this.title = function(value) {
	        if (!arguments.length)
	            return title;
	        title = value;
	        return this;
	    };
	
	    // ------------------------------
	    // titleFunction
	    // ------------------------------
	
	    /**
	     * title生成规则方法，若注册该方法，则按该方法返回的内容显示title，忽略title属性
	     */
	    var titleFunction = null;
	    this.titleFunction = function(value) {
	        if (!arguments.length)
	            return titleFunction;
	        titleFunction = value;
	        return this;
	    };
	    
	    //override
	    this.nameSpace = function(){
	        return "sankeyLink";
	    }
	     //override
	    this.selectedChange = function(seleced){
	
	    }
	    //override
	    this.mouseOverHandler = function(){
	        self.mainPathElement.attr('stroke-opacity', 0.6);
	    };
	    //override
	    this.mouseOutHandler = function(){
	        self.mainPathElement.attr('stroke-opacity', 0.3);
	    };
	
	    //override
	    this.drawPlugin = function(g){
	        superDrawPluginFunction(g);
	    }
	    //override
	    this.setPath = function(pathElement,data){
	        self.refreshData(_data.data.clazzProperties);
	        var path = self.pathFunction() ? self.pathFunction()() : self.path();
	    	var duration = self.animation() ? 300 : 0;
	    	pathElement.attr("visibility", "hidden");
	    	pathElement.transition().duration(duration).ease(d3.easeLinear)
	    	    .on("start", function(d){
	                pathElement.attr("visibility", "visible");
	            })
	            .delay(function(d){
	                return d.source.level * (duration - 10);
	            })
	            .attrTween("d", function (d) {
	                var interpolate = d3.interpolate({target:{x:d.source.x + 10}}, d);
	                return function (t) {
	                    return path(interpolate(t));
	                };
	            })
	            .attrTween("stroke-width", function (d) {
	                var interpolate = d3.interpolate({dy:Math.max(1, d.dy)}, d);
	                return function (t) {
	                    return interpolate(t).dy;
	                };
	            });
	        if(self.sortFunction()) {
	            pathElement.sort(self.sortFunction());
	        }
	        pathElement.selectAll("path-title").remove();
	        if(self.titleFunction()) {
	            pathElement.append("title").attr("class", "path-title").text(self.titleFunction());
	        } else if(self.title()) {
	            pathElement.append("title").attr("class", "path-title").text(formatTitleFn);
	        }
	        ElementUtil.setElementProperties(pathElement, _data.data.useProperties);
	    }
	    //override
	    this.labelLayout = function(element,plugin,data){
	        var position = MathUtil.calculateCenter(data.source, data.target);
	        ElementUtil.setElementProperties(element,{transform:"translate(" + [position.x,position.y] + ")"});
	    }
	    
	    /**
	     * 刷新传入配置数据到相应参数的方法
	     * @param data 配置数据
	     */
	    this.refreshData = function(data) {
	        if(data) {
	           for(var key in data) {
	                if(this.hasOwnProperty(key)) {
	                    this[key](data[key]);
	                }
	            }
	        }
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // private Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    /**
	     * 替换title中的特殊字符串内容，比如{#d.name#}替换为渲染数据中的name属性的值,{##}中的内容是可执行的js
	     */
	     var formatTitleFn = function(d) {
	        var titleStr = self.title();
	        return titleStr.replace(RegexUtil.jsRegex, function() {
	            return arguments.length > 1 ? eval(arguments[1]) : "";
	        });
	    };
	};
	
	SankeyLink.struct = function(ghca_charts) {
		var BaseLink = ghca_charts.view.elements.plugins.links.baseLink;
		BaseLink.struct(ghca_charts);
	    SankeyLink.prototype = Object.create(BaseLink.prototype);
	    SankeyLink.prototype.constructor = SankeyLink;
	};
	
	module.exports = SankeyLink;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 82 */
/***/ (function(module, exports) {

	var NodeMap = function() {
	    
	    this.getMap = function() {
	        var map = {};
	        //注册内部节点类
	        map.basenode = ghca_charts.view.elements.plugins.nodes.baseNode;
	        map.arcclass = ghca_charts.view.elements.plugins.nodes.arcClass;
	        map.sankeynode = ghca_charts.view.elements.plugins.nodes.sankeyNode;
	        map.baselabel = ghca_charts.view.elements.plugins.label.baseLabel;
	        map.node = ghca_charts.view.elements.plugins.nodes.node;
	        map.hbarnode = ghca_charts.view.elements.plugins.nodes.hBarNode;
	        map.vbarnode = ghca_charts.view.elements.plugins.nodes.vBarNode;
	        map.linenode = ghca_charts.view.elements.plugins.nodes.lineNode;
	        map.imagenode = ghca_charts.view.elements.plugins.nodes.imageNode;
	        map.circleshape = ghca_charts.view.elements.shape.circleShape;
	        map.rectshape = ghca_charts.view.elements.shape.rectShape;
	        map.groupnode = ghca_charts.view.elements.plugins.nodes.groupNode;
	        map.configgroupnode = ghca_charts.view.elements.plugins.nodes.configGroupNode;
	        map.treemapnode = ghca_charts.view.elements.plugins.nodes.treemapNode;
	        map.sunburstnode = ghca_charts.view.elements.plugins.nodes.sunburstNode;
	        map.packnode = ghca_charts.view.elements.plugins.nodes.packNode;
	        map.iconNode = ghca_charts.view.elements.plugins.nodes.iconNode;
	        map.hprogressbarnode = ghca_charts.view.elements.plugins.nodes.hProgressBarNode;
	        
	        //注册外部节点类
	        var outerMap = ghca_charts.global.outerPlugins && ghca_charts.global.outerPlugins.nodeMap;
	        if(outerMap) {
	            for(var name in outerMap) {
	                map[name] = outerMap[name];
	            }
	        }
	        
	        return map;
	    };
	};
	
	NodeMap.struct = function(ghca_charts) {
	    NodeMap.prototype.constructor = NodeMap;
	};
	
	module.exports = NodeMap;

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {var ArcClass = function (_element,_data) {
		
		// --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const ElementUtil = ghca_charts.view.util.elementUtil;
	    const ObjectUtil = ghca_charts.view.util.objectUtil;
	    const PieLabel = ghca_charts.view.elements.plugins.label.pieLabel;
	    const BaseNode = ghca_charts.view.elements.plugins.nodes.baseNode;
	
	    BaseNode.apply(this,arguments);
	    var self = this;
	    var arc, isPlayAnimation = false;
	    var defaulfConfig = {
	        clazz:'arcClass',
	        //默认连线的颜色、类型属性等配置项
	        clazzProperties:{outerRadius:100, innerRadius:0, cornerRadius:0, padAngle:0, animation:true},
	        labelProperties:{'font-size':'0.8em',"pointer-events":"none", text:"{#Math.round(d.percent*1000)/10+'%'#}"},
	        //用户更改颜色连线的类型属性配置项
	        useProperties:{}
	    };
	    
		//--------------------------------------------------------------------------
	    //
	    //  Attributes
	    //
	    //--------------------------------------------------------------------------
	    
	    // ------------------------------
	    // outerRadius
	    // ------------------------------
	    
	    /**
	     * 渲染呈现的弧外半径
	     */
	    var outerRadius = 20;
	    this.outerRadius = function(value) {
	        if (!arguments.length)
	            return innerRadius + (outerRadius - innerRadius) * 
	                (self.data().hasOwnProperty("radiusPercent") ? self.data().radiusPercent　: 1);
	        outerRadius = value;
	        return this;
	    };
	    
	    // ------------------------------
	    // origOuterRadius
	    // ------------------------------
	    
	     /**
	     * 原始弧外半径，不乘以玫瑰图的半径百分比
	     */
	    this.origOuterRadius = function() {
	        return outerRadius;
	    };
	    
	    // ------------------------------
	    // innerRadius
	    // ------------------------------
	
	    /**
	     * 弧内半径
	     */
	    var innerRadius = 0;
	    this.innerRadius = function(value) {
	        if (!arguments.length)
	            return innerRadius;
	        innerRadius = value;
	        return this;
	    };
	
	    // ------------------------------
	    // startAngle
	    // ------------------------------
	
	    /**
	     * 开始弧度
	     */
	    var startAngle = 0;
	    this.startAngle = function(value) {
	        if (!arguments.length)
	            return startAngle;
	        startAngle = value;
	        return this;
	    };
	
	    // ------------------------------
	    // endAngle
	    // ------------------------------
	
	    /**
	     * 结束弧度
	     */
	    var endAngle = Math.PI / 2;
	    this.endAngle = function(value) {
	        if (!arguments.length)
	            return endAngle;
	        endAngle = value;
	        return this;
	    };
	
	    // ------------------------------
	    // cornerRadius
	    // ------------------------------
	
	    /**
	     * 弧圆角
	     */
	    var cornerRadius = 0;
	    this.cornerRadius = function(value) {
	        if (!arguments.length)
	            return cornerRadius;
	        cornerRadius = value;
	        return this;
	    };
	
	    // ------------------------------
	    // padAngle
	    // ------------------------------
	
	    /**
	     * 弧间隔
	     */
	    var padAngle = 0;
	    this.padAngle = function(value) {
	        if (!arguments.length)
	            return padAngle;
	        padAngle = value;
	        return this;
	    };
	
	    // ------------------------------
	    // title
	    // ------------------------------
	
	    /**
	     * path元素的title内容字符串
	     */
	    var title = null;
	    this.title = function(value) {
	        if (!arguments.length)
	            return title;
	        title = value;
	        return this;
	    };
	
	    // ------------------------------
	    // titleFunction
	    // ------------------------------
	
	    /**
	     * title生成规则方法，若注册该方法，则按该方法返回的内容显示title，忽略title属性
	     */
	    var titleFunction = null;
	    this.titleFunction = function(value) {
	        if (!arguments.length)
	            return titleFunction;
	        titleFunction = value;
	        return this;
	    };
	    
	    // ------------------------------
	    // labelPos
	    // ------------------------------
	
	    /**
	     * 标签类型，outer|inner(默认outer)
	     */
	    var labelPos = "outer";
	    this.labelPos = function(value) {
	        if (!arguments.length)
	            return labelPos;
	        labelPos = value;
	        return this;
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // public Methods
	    //
	    // --------------------------------------------------------------------------
	
	//    //override
	//    this.data = function(){
	//        return _data.data;
	//    }
	
	    //override
	    this.nameSpace = function(){
	        return "arcClass";
	    }
	
	    //override
	    this.drawPlugin = function(g){
	    	if(!self.mainElemet) {
	    		if(!self.data().data) {
	    			self.data().data = ObjectUtil.cloneObj(defaulfConfig);
	    		}
	    		var nodeData = self.data().data.clazzProperties;
	    		self.refreshData(nodeData);
	    		
	    		self.mainElement = g.append("path");
	    		
	    		arc = d3.arc()
	                .outerRadius(self.outerRadius())
	                .innerRadius(self.innerRadius())
	                .cornerRadius(self.cornerRadius())
	                .padAngle(self.padAngle());
	
	            ElementUtil.setElementProperties(self.mainElement, nodeData);
	            self.setLegendColor();
	            
	            //title
	            if(self.titleFunction()) {
	                self.mainElement.append("title").attr("class", "path-title").text(self.titleFunction());
	            } else if(self.title()) {
	                self.mainElement.append("title").attr("class", "path-title").text(self.formatStr(self.title()));
	            }
	            
	            //arc
	            var transition;
	            if(self.isChartFirstInit()) {
	            	transition = d3.transition().duration(self.animation() ? 2000 : 0).ease(d3.easeExpOut);
	                self.mainElement
	                    .attr("transform", "rotate(-179)scale(0.1)")
	                    .transition(transition)
	                    .attr("transform", "rotate(0)scale(1)")
	                    .on("start", function() {
	                        isPlayAnimation = true;
	                    })
	                    .on("end", function() {
	                        isPlayAnimation = false;
	                    })
	                    .attrTween("d", function (d) {
	                        var interpolate = d3.interpolate({startAngle:0, endAngle:d.endAngle - 0.5}, d);
	                        return function (t) {
	                            return arc(interpolate(t));
	                        };
	                    });
	                    
	            } else {
	            	transition = d3.transition().duration(self.animation() ? 500 : 0).ease(d3.easeExpOut);
	                self.mainElement
	                    .transition(transition)
	                    .on("start", function() {
	                        isPlayAnimation = true;
	                    })
	                    .on("end", function() {
	                        isPlayAnimation = false;
	                    })
	                    .attrTween("d", function (d) {
	                        var interpolate = d3.interpolate({startAngle:d.endAngle, endAngle:d.endAngle}, d);
	                        return function (t) {
	                            return arc(interpolate(t));
	                        };
	                    });
	            }
	            
	            //label
	            if(self.data().data.labelProperties) {
	            	refreshArc();
	            	self.label = new PieLabel(g.append("g"), self.data(), transition);
	                self.label.isChartFirstInit(self.isChartFirstInit());
	                self.label.render();
	                
	                //outer
	                if(self.labelPos() === "outer" && !self.polyline) {
	                    self.polyline = g.append("polyline").datum(self.data())
	                        .attr("opacity", 0.5)
	                        .attr("stroke", function(d) {
	                            return d.hasOwnProperty("legendColor") ? d.legendColor : "#000";
	                        })
	                        .attr("stroke-width", "1.5px")
	                        .attr("fill", "none");
	                
	                    self.polyline
	                        .transition(transition)
	                        .attrTween("points", polylineRenderTween);
	                }
	            }
	    	}
	    }
	    
	    //override
	    this.update = function() {
	    	var transition = d3.transition().duration(self.animation() ? 500 : 0).ease(d3.easeExpOut);
	        if(self.mainElement) {
	        	self.mainElement.datum(self.data());
	        	var nodeData = self.data().data.clazzProperties;
	            self.refreshData(nodeData);
	            
	        	arc = d3.arc()
	                .outerRadius(self.outerRadius())
	                .innerRadius(self.innerRadius())
	                .cornerRadius(self.cornerRadius())
	                .padAngle(self.padAngle());
	
	            ElementUtil.setElementProperties(self.mainElement, nodeData);
	            self.setLegendColor();
	            //title
	            if(self.titleFunction()) {
	                self.mainElement.select("title.path-title").text(self.titleFunction());
	            } else if(self.title()) {
	                self.mainElement.select("title.path-title").text(self.formatStr(self.title()));
	            }
	            
	            self.selectedChange(false);
	            
	            self.mainElement
	                .transition(transition)
	                .on("start", function() {
	                        isPlayAnimation = true;
	                    })
	                .on("end", function() {
	                    isPlayAnimation = false;
	                })
	                .attrTween("d", function (d) {
	                	this._current = this._current || d;
	                    var interpolate = d3.interpolate({startAngle:this._current.startAngle, endAngle:this._current.endAngle}, d);
	                    this._current = interpolate(0);
	                    return function (t) {
	                        return arc(interpolate(t));
	                    };
	                });
	        }
	        //label
	        if(self.label) {
	            refreshArc();
	            self.label.data(self.data());
	            self.label.update(transition);
	            //outer
	            if(self.labelPos() === "outer") {
	            	if(!self.polyline) {
	            		self.polyline = self.mainContainer().append("polyline")
	            	}
	                self.polyline
	                    .datum(self.data())
	                    .attr("opacity", 0.5)
	                    .attr("stroke", function(d) {
	                        return d.hasOwnProperty("legendColor") ? d.legendColor : "#000";
	                    })
	                    .attr("stroke-width", "1.5px")
	                    .attr("fill", "none")
	                    .transition(transition)
	                    .attrTween("points", polylineUpdateTween);
	            } else {
	            	if(self.polyline) {
	            		self.polyline.remove();
	            		self.polyline = null;
	            	}
	            }
	        }
	    };
	
	    //override
	    this.mouseOverHandler = function(){
	    	if(isPlayAnimation) return;
	        var r = self.outerRadius();
	        var k = (r + 10) / r;
	        if(k > 1.05) {
	            k = 1.05;
	        }
	        ElementUtil.setElementProperties(self.animation() ? self.mainElement.transition() : self.mainElement,{transform:"scale(" + k + ")"});
	    }
	    //override
	    this.mouseOutHandler = function(){
	    	if(isPlayAnimation) return;
	        ElementUtil.setElementProperties(self.animation() ? self.mainElement.transition() : self.mainElement,{transform:"scale(1)"});
	    }
	
	    //override
	    this.selectedChange = function(seleced){
	    	if(isPlayAnimation) return;
	        ElementUtil.setElementProperties(this.animation() ? _element.transition() : _element,{transform:seleced==true?arcMoveOut:arcMoveIn});
	    }
	
	    /**
	     * 刷新传入配置数据到相应参数的方法
	     * @param data 配置数据
	     */
	    this.refreshData = function(data) {
	        if(data) {
	            for(var key in data) {
	                if(this.hasOwnProperty(key)) {
	                    this[key](data[key]);
	                }
	            }
	        }
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // priavte Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    var refreshArc = function() {
	    	if(self.labelPos() === "outer") {
	    		var r = self.outerRadius();
	            var origR = self.origOuterRadius();
	            var distance = origR * 0.2;
	            distance = distance < 10 ? 10 : (distance > 20 ? 20 : distance);
	            var outerArc1 = d3.arc().innerRadius(r).outerRadius(r);
	            var outerArcRadius = origR + distance;
	            var outerArc2 = d3.arc().innerRadius(outerArcRadius).outerRadius(outerArcRadius);
	            self.data().outerArc1 = outerArc1;
	            self.data().outerArc2 = outerArc2;
	            self.data().lineSize = 15;
	    	} else {
	    		self.data().arc = arc;
	    	}
	    }
	
	    /**
	     * 弧形向外移动方法
	     */
	    var arcMoveOut = function (d) {
	        var p = arc.centroid(d);
	        var angle = Math.atan(p[1]/p[0]);
	        var moveLen = self.outerRadius() * 0.1;
	        if(moveLen > 10) {
	            moveLen = 10;
	        }
	        var absCos = Math.abs(moveLen * Math.cos(angle));
	        var absSin = Math.abs(moveLen * Math.sin(angle));
	        p[0] = p[0] > 0 ? absCos : -absCos;
	        p[1] = p[1] > 0 ? absSin : -absSin;
	        return "translate(" + p + ")";
	    };
	
	    /**
	     * 弧形向内移动到初始位置方法
	     */
	    var arcMoveIn = function (d) {
	        return "translate(0, 0)";
	    };
	    
	    var midAngle = function (d){
	        return d.startAngle + (d.endAngle - d.startAngle) / 2;
	    };
	    
	    var polylineRenderTween = function(d) {
	        this._current = this._current || d;
	        var interpolate = d3.interpolate({startAngle:this._current.startAngle, endAngle:this._current.endAngle}, d);
	        this._current = interpolate(0);
	        var outerArc1 = d.outerArc1;
	        var outerArc2 = d.outerArc2;
	        return function(t) {
	            var d2 = interpolate(t);
	            var startP = outerArc1.centroid(d2);
	            var centerP = outerArc2.centroid(d2);
	            var endP = outerArc2.centroid(d2);
	            centerP[1] = (centerP[1] - startP[1]) * t + startP[1];
	            endP[1] = (endP[1] - startP[1]) * t + startP[1];
	            endP[0] += d.lineSize * (midAngle(d2) < Math.PI ? 1 : -1);
	            return [startP, centerP, endP];
	        };          
	    };
	    
	    var polylineUpdateTween = function(d) {
	        this._current = this._current || d;
	        var interpolate = d3.interpolate({startAngle:this._current.startAngle, endAngle:this._current.endAngle}, d);
	        this._current = interpolate(0);
	        var outerArc1 = d.outerArc1;
	        var outerArc2 = d.outerArc2;
	        return function(t) {
	            var d2 = interpolate(t);
	            var pos = outerArc2.centroid(d2);
	            pos[0] += d.lineSize * (midAngle(d2) < Math.PI ? 1 : -1);
	            return [outerArc1.centroid(d2), outerArc2.centroid(d2), pos];
	        };        
	    };
	};
	
	ArcClass.struct = function(ghca_charts) {
		var BaseNode = ghca_charts.view.elements.plugins.nodes.baseNode;
		BaseNode.struct(ghca_charts);
	    ArcClass.prototype = Object.create(BaseNode.prototype);
	    ArcClass.prototype.constructor = BaseNode;
	};
	
	module.exports = ArcClass;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {
	var BaseNode = function (_element,_data) {
		
		// --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const ElementUtil = ghca_charts.view.util.elementUtil;
	    const BaseLabel = ghca_charts.view.elements.plugins.label.baseLabel;
	    const Plugin = ghca_charts.view.elements.plugins.plugin;
	    const BaseEvent = ghca_charts.events.BaseEvent;
	    const EventUtil = ghca_charts.view.util.eventUtil;
	
	    Plugin.apply(this,arguments);
	    var self = this,
	        superDrawPluginFunction = this.drawPlugin,
	        superBindEventsFunction = this.bindEvents;
	    self.dispatch = d3.dispatch("selectedChange");
	    self.mainElement = _element;
	    self.backGroundElement = _element;
	    var _selected = false;
	//    //override
	//    this.data = function(){
	//        return _data.data;
	//    }
	    /**
	     * 节点选中
	     * @param _selected
	     * @returns {*}
	     */
	    this.selected = function(_p){
	         if(!arguments.length)return _selected;
	        _selected = _p;
	        self.dispatch.call("selectedChange",this , new BaseEvent(self,{selected:_selected}));
	        return this;
	    }
	    this.selectedChange = function(seleced){
	        if(self.backGroundElement)
	            if(seleced){
	                self.backGroundElement.attr("opacity",0.5);
	            }else{
	                self.backGroundElement.attr("opacity",0);
	            }
	    }
	    this.mouseOverHandler = function(){
	        if(!self.selected()&&self.backGroundElement)
	            self.backGroundElement.attr("opacity",0.5);
	    }
	    this.mouseOutHandler = function(){
	        if(!self.selected()&&self.backGroundElement)
	            self.backGroundElement.attr("opacity",0);
	    }
	    //override
	    this.nameSpace = function(){
	        return "baseNode";
	    }
	    
	    //override
	    this.actualWidth = function(){
	        if(self.backGroundElement)
	            return self.backGroundElement.node().getBBox().width;
	        return 0;
	    }
	    //override
	    this.actualHeight = function(){
	        if(self.backGroundElement)
	            return self.backGroundElement.node().getBBox().height;
	        return 0;
	    }
	    //override
	    this.drawPlugin = function(g){
	        superDrawPluginFunction(g);
	        self.mainElement = ElementUtil.createCircle(g,self.data().data.circleProperties);
	        self.backGroundElement =  ElementUtil.createCircle(g,self.data().data.circleCheckProperties);
	        self.createLabel(g,self.data());
	        self.setLegendColor();
	    }
	    
	    //override
	    this.bindEvents = function(g){
	        superBindEventsFunction(g);
	        g.on('mouseover', function(d) {
	        	var evt = EventUtil.createCustomEvent(BaseEvent.SHOW_TOOL_TIP, true, true);
	            d3.select(this).node().dispatchEvent(evt);
	            self.mouseOverHandler();
	        });
	        g.on('mousemove', function(d) {
	            var evt = EventUtil.createCustomEvent(BaseEvent.UPDATE_TOOL_TIP, true, true, d);
	            d3.select(this).node().dispatchEvent(evt);
	        });
	        g.on('mouseout', function(d) {
	        	var evt = EventUtil.createCustomEvent(BaseEvent.HIDE_TOOL_TIP, true, true);
	            d3.select(this).node().dispatchEvent(evt);
	            self.mouseOutHandler();
	        });
	        g.on('click', function(d) {
	        	var evt = EventUtil.createCustomEvent(BaseEvent.NODE_CLICK, true, true, d);
	            d3.select(this).node().dispatchEvent(evt);
	            self.selected(!_selected);
	        });
	        self.on("selectedChange."+self.nameSpace(),function(e){
	            self.selectedChange(e.data.selected);
	        });
	    }
	    /**
	     * 自定义事件监听
	     * @returns {exports}
	     */
	    this.on = function() {
	        var value = self.dispatch.on.apply(self.dispatch, arguments);
	        return value === self.dispatch ? self : value;
	    };
	
	    this.createLabel = function(group,d){
	    	if(!d.data.label) {
	    		return;
	    	}
	        var labelG = group.append("g");
	        var labelData = d.data.label;
	        labelData.name = d.name==""?"":d.name;
	        var label =  new BaseLabel(labelG,labelData,self);
	        label.render();
	        self.labelLayout(labelG,label,d);
	    }
	    /**
	     * 替换图例
	     */
	    this.setLegendColor = function(){
	        if(self.data().legendColor){
	            ElementUtil.setElementProperties(self.mainElement,{"fill":self.data().legendColor});
	        }
	    }
	    /**
	     * label布局
	     * @param element
	     * @param plugin
	     * @param position
	     */
	    this.labelLayout = function(element,plugin,d){
	        var position = d.data.labelPosition;
	        if(!position)position = 'bottom';
	        var w = self.actualWidth(),
	            h  = self.actualHeight(),
	            rh = plugin.actualHeight(),
	            rw = plugin.actualWidth();
	        
	        var labelPosition = position.toLowerCase(),translate;
	
	        if(labelPosition === 'top')
	            translate = "translate(" + [0,-h/2-rh/2] + ")";
	        else if(labelPosition === 'bottom')
	            translate = "translate(" + [0,h/2+Number(rh/2)] + ")";
	        else if(labelPosition === 'left')
	            translate = "translate(" + [-w/2-rw/2,0] + ")";
	        else if(labelPosition === 'right')
	            translate = "translate(" + [w/2+rw/2,0] + ")";
	        else if(labelPosition === 'center')
	            translate = "translate(" + [0,0] + ")";
	        ElementUtil.setElementProperties(element,{transform:translate});
	    }
	};
	
	BaseNode.struct = function(ghca_charts) {
		var Plugin = ghca_charts.view.elements.plugins.plugin;
		Plugin.struct(ghca_charts);
	    BaseNode.prototype = Object.create(Plugin.prototype);
	    BaseNode.prototype.constructor = BaseNode;
	};
	
	module.exports = BaseNode;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 85 */
/***/ (function(module, exports) {

	var Circle = function (_element,_data) {
		
		// --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const Plugin = ghca_charts.view.elements.plugins.plugin;
	    const CircleElement = ghca_charts.view.elements.circleElement;
	    const ObjectUtil = ghca_charts.view.util.objectUtil;
	    const RegexUtil = ghca_charts.view.util.regexUtil;
	
	    Plugin.apply(this,arguments);
	    var self = this,
	        circleElement = _element;
	
	    self.config({
	        cx:0,
	        cy:0,
	        radius:10,
	        border:2,
	        borderColor:"green",
	        linecap:"butt",
	        color:"red"
	        // dasharray:circumference,
	        // dashoffset:stroke_percentage
	    });
	
	
	//    //override
	//    this.actualWidth = function(){
	//       return self.config().radius*2;
	//    }
	//    //override
	//    this.actualHeight = function(){
	//        return self.config().radius*2;
	//    }
	
	    //override
	    this.nameSpace = function(){
	        return "circle";
	    }
	    //override
	    this.update = function(g){
	    	var config = ObjectUtil.cloneObj(self.config());
	    	config.color = RegexUtil.replace(RegexUtil.dataRegex,config.color,self.data());
	        config.borderColor = RegexUtil.replace(RegexUtil.dataRegex,config.borderColor,self.data());
	        config.radius = RegexUtil.replace(RegexUtil.dataRegex,config.radius,self.data());
	        circleElement.data(config);
	        self.resetBBox(-config.radius, -config.radius, config.radius*2, config.radius*2);
	    }
	    //override
	    this.drawPlugin = function(g){
	        var config = ObjectUtil.cloneObj(self.config());
	        config.color = RegexUtil.replace(RegexUtil.dataRegex,config.color,self.data());
	        config.borderColor = RegexUtil.replace(RegexUtil.dataRegex,config.borderColor,self.data());
	        config.radius = RegexUtil.replace(RegexUtil.dataRegex,config.radius,self.data());
	        circleElement = new CircleElement(g,config);
	        circleElement.render();
	        self.resetBBox(-config.radius, -config.radius, config.radius*2, config.radius*2);
	    }
	};
	
	Circle.struct = function(ghca_charts) {
		var Plugin = ghca_charts.view.elements.plugins.plugin;
		Plugin.struct(ghca_charts);
	    Circle.prototype = Object.create(Plugin.prototype);
	    Circle.prototype.constructor = Circle;
	};
	
	module.exports = Circle;

/***/ }),
/* 86 */
/***/ (function(module, exports) {

	var ConfigGroupNode = function (_element,_data) {
	    
	    // --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const ElementUtil = ghca_charts.view.util.elementUtil;
	    const GroupLabel = ghca_charts.view.elements.plugins.label.groupLabel;
	    const BaseNode = ghca_charts.view.elements.plugins.nodes.baseNode;
	    const ObjectUtil =  ghca_charts.view.util.objectUtil;
	    const RegexUtil = ghca_charts.view.util.regexUtil;
	    BaseNode.apply(this,arguments);
	    
	    var self = this;
	        
	    //--------------------------------------------------------------------------
	    //
	    //  Attributes
	    //
	    //--------------------------------------------------------------------------
	    
	    // ------------------------------
	    // attribute
	    // ------------------------------
	
	    //--------------------------------------------------------------------------
	    //
	    //  public Methods
	    //
	    //--------------------------------------------------------------------------
	    
	    //override
	    this.nameSpace = function(){
	        return "configgroupnode";
	    }
	    
	    // //override
	    // this.data = function(){
	    //     return _data;
	    // }
	    
	    //override
	    this.bindEvents = function(g){
	    	
	    }
	
	    //override
	    this.setLegendColor = function(configData) {
	    	var fill = "#d7fea2", stroke = "gray",dasharray="0,0";//默认配置
	    	if(_data.legendColor) {//图例颜色
	    		fill = _data.legendColor;
	    		stroke = _data.legendColor;
	        } else if(configData && configData.nodeProperties) {//用户设置颜色
	            var p = configData.nodeProperties;
	            if(p.fill) {
	                fill = p.fill;
	            }
	            if(p.stroke) {
	                stroke = p.stroke;
	            }
	            if(p.dasharray){
	                dasharray=p.dasharray;
	            }
	        }
	        self.mainElement.attr("fill", fill).attr("stroke", stroke);
	        self.mainElement.attr("stroke-dasharray",dasharray);
	    }
	
	    //override
	    this.drawPlugin = function(g) {
	    	if(_data.path === "") {
	    		return;
	        }
	        
	        var configData=setRegData();
	
	
	        g.attr("pointer-events", "visiblefill ");//可视化区域响应鼠标事件
	        self.mainElement = ElementUtil.createPath(g, configData.nodeProperties);
	        self.mainElement.attr("class", "group-area").attr("d", _data.path)
	        self.setLegendColor(configData);
	        self.createLabel(g,configData);
	    }
	
	    function setRegData(){
	        var data=ObjectUtil.cloneObj(_data.data);
	        data.nodeProperties.fill=RegexUtil.replace(RegexUtil.dataRegex,data.nodeProperties.fill,self.data());
	        data.nodeProperties["fill-opacity"]=RegexUtil.replace(RegexUtil.dataRegex,data.nodeProperties["fill-opacity"],self.data());
	        data.label.backGroundProperties["fill"]=RegexUtil.replace(RegexUtil.dataRegex, data.label.backGroundProperties["fill"],self.data());
	        data.label.backGroundProperties["opacity"]=RegexUtil.replace(RegexUtil.dataRegex,data.label.backGroundProperties["opacity"],self.data());
	        data.label.labelProperties["fill"]=RegexUtil.replace(RegexUtil.dataRegex,data.label.labelProperties["fill"],self.data());
	        return data;
	    }
	    
	    //override
	    this.update = function() {
	    	if(self.mainElement) {
	            var configData=setRegData();
	            self.mainElement.attr("d", self.data().path);
	    		self.setLegendColor(configData);
	            if(self.label) {
	            	if(_data.path === "") {
	            		self.label.el.attr("display", "none");
	            	} else {
	            		self.label.el.attr("display", "block");
	            		var labelData = configData.label;
	                    labelData.name = labelData.name ?　labelData.name　: _data.name;
	                    self.label.update(labelData);
	            		self.labelLayout(self.labelG, self.label, configData, true);
	            	}
	            }
	    	}
	    };
	    
	     //override
	    this.createLabel = function(group, d) {
	        if(!d || !d.label) {
	            return;
	        }
	        self.labelG = group.append("g").attr("pointer-events", "none");
	        var labelData = d.label;
	        labelData.name = labelData.name ?　labelData.name　: d.name;
	        self.label =  new GroupLabel(self.labelG, labelData, self);
	        self.label.render();
	        self.labelLayout(self.labelG, self.label, d, false);
	    }
	    
	    //override
	    this.labelLayout = function(element, plugin, d) {
	        var position = d.labelPosition;
	        if(position === 'none') {
	            element.style("display", "none");
	            return;
	        } else {
	            element.style("display", "block");
	        }
	        if(!position)
	            position = 'top';
	        
	        var labelPosition = position.toLowerCase(), translate, tx = 0, ty = 0;
	        var labelBox = element.node().getBBox();
	        var point;
	        if(labelPosition === 'bottom') {
	        	point = getBottomPoint(_data.pathPoints);
	            tx = point[0];
	            ty = point[1] + labelBox.height / 2;
	        } else if(labelPosition === 'left') {
	        	point = getLeftPoint(_data.pathPoints);
	            tx = point[0] - labelBox.width / 2;
	            ty = point[1];
	        } else if(labelPosition === 'right') {
	        	point = getRightPoint(_data.pathPoints);
	            tx = point[0] + labelBox.width / 2;
	            ty = point[1];
	        } else if(labelPosition === 'center') {
	        	var pathBox = self.mainElement.node().getBBox();
	            tx = pathBox.x + pathBox.width / 2;
	            ty = pathBox.y + pathBox.height / 2;
	        } else if(labelPosition === 'insidetop') {
	        	point = getTopPoint(_data.pathPoints);
	            tx = point[0];
	            ty = point[1] + labelBox.height / 2;
	        } else if(labelPosition === 'insidebottom') {
	        	point = getBottomPoint(_data.pathPoints);
	            tx = point[0];
	            ty = point[1] - labelBox.height / 2;
	        } else if(labelPosition === 'insideleft') {
	        	point = getLeftPoint(_data.pathPoints);
	            tx = point[0] + labelBox.width / 2;
	            ty = point[1];
	        } else if(labelPosition === 'insideright') {
	        	point = getRightPoint(_data.pathPoints);
	            tx = point[0] - labelBox.width / 2;
	            ty = point[1];
	        } else {
	            //default top
	        	point = getTopPoint(_data.pathPoints);
	            tx = point[0];
	            ty = point[1] - labelBox.height / 2;
	        }
	        element.attr("transform", "translate("+tx+","+ty+")");
	    };
	    
	    var getTopPoint = function(points) {
	    	var result = null, xArray = [];
	    	for(var p, i = 0, len = points.length; i < len; i++) {
	    		p = points[i];
	    		if(result === null || p[1] < result[1]) {
	    			result = p;
	    			xArray.length = 0;
	    			xArray.push(p[0]);
	    		} else if(p[1] === result[1]) {
	    			xArray.push(p[0]);
	    		}
	    	}
	    	if(xArray.length > 1) {
	    		var totalX = 0;
	            for(var i = 0, len = xArray.length; i < len; i++) {
	                totalX += xArray[i]
	            }
	            var avgX = totalX / xArray.length;
	    	}
	    	return result ? [avgX ? avgX : result[0], result[1]] : null;
	    };
	    
	    var getBottomPoint = function(points) {
	        var result = null, xArray = [];
	        for(var p, i = 0, len = points.length; i < len; i++) {
	            p = points[i];
	            if(result === null || p[1] > result[1]) {
	                result = p;
	                xArray.length = 0;
	                xArray.push(p[0]);
	            } else if(p[1] === result[1]) {
	                xArray.push(p[0]);
	            }
	        }
	        if(xArray.length > 1) {
	            var totalX = 0;
	            for(var i = 0, len = xArray.length; i < len; i++) {
	                totalX += xArray[i]
	            }
	            var avgX = totalX / xArray.length;
	        }
	        return result ? [avgX ? avgX : result[0], result[1]] : null;
	    };
	    
	    var getLeftPoint = function(points) {
	        var result = null, yArray = [];
	        for(var p, i = 0, len = points.length; i < len; i++) {
	            p = points[i];
	            if(result === null || p[0] < result[0]) {
	                result = p;
	                yArray.length = 0;
	                yArray.push(p[1]);
	            } else if(p[0] === result[0]) {
	                yArray.push(p[1]);
	            }
	        }
	        if(yArray.length > 1) {
	            var totalY = 0;
	            for(var i = 0, len = yArray.length; i < len; i++) {
	                totalY += yArray[i]
	            }
	            var avgY = totalY / yArray.length;
	        }
	        return result ? [result[0], avgY ? avgY : result[1]] : null;
	    };
	    
	    var getRightPoint = function(points) {
	        var result = null, yArray = [];
	        for(var p, i = 0, len = points.length; i < len; i++) {
	            p = points[i];
	            if(result === null || p[0] > result[0]) {
	                result = p;
	                yArray.length = 0;
	                yArray.push(p[1]);
	            } else if(p[0] === result[0]) {
	                yArray.push(p[1]);
	            }
	        }
	        if(yArray.length > 1) {
	            var totalY = 0;
	            for(var i = 0, len = yArray.length; i < len; i++) {
	                totalY += yArray[i]
	            }
	            var avgY = totalY / yArray.length;
	        }
	        return result ? [result[0], avgY ? avgY : result[1]] : null;
	    };
	};
	
	ConfigGroupNode.struct = function(ghca_charts) {
	    var BaseNode = ghca_charts.view.elements.plugins.nodes.baseNode;
	    BaseNode.struct(ghca_charts);
	    ConfigGroupNode.prototype = Object.create(BaseNode.prototype);
	    ConfigGroupNode.prototype.constructor = ConfigGroupNode;
	};
	
	module.exports = ConfigGroupNode;

/***/ }),
/* 87 */
/***/ (function(module, exports) {

	var DemoImageNode = function (_element,_data) {
		
		// --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const Plugin = ghca_charts.view.elements.plugins.plugin;
	    const Label = ghca_charts.view.elements.plugins.label.label;
	    const ImageElement = ghca_charts.view.elements.imageElement;
	    const ObjectUtil = ghca_charts.view.util.objectUtil;
	    const RegexUtil = ghca_charts.view.util.regexUtil;
	
	    Plugin.apply(this,arguments);
	    var self = this,
	        imageElement = null,
	        icon1 = null,
	        icon2 = null,
	        icon3 = null,
	        label1 = null,
	        label2 = null,
	        label3 = null;
	        
	    self.config({
	    	imageWidth:32,
	        imageHeight:32,
	        opacity:1
	    });
	
	
	    //override
	    this.nameSpace = function(){
	        return "demoImageNode";
	    }
	    //override
	    this.update = function(g){
	    	if(imageElement) {
	    		imageElement.data(self.config());
	    	}
	    	if(icon1) {
	            icon1.data(self.config().icon1);
	        }
	        if(icon2) {
	            icon2.data(self.config().icon2);
	        }
	        if(icon3) {
	            icon3.data(self.config().icon3);
	        }
	        if(label1) {
	            label1.data(self.config().label1);
	        }
	        if(label2) {
	            label2.data(self.config().label2);
	        }
	        if(label3) {
	            label3.data(self.config().label3);
	        }
	    }
	    //override
	    this.drawPlugin = function(g){
	        var config = ObjectUtil.cloneObj(self.config());
	        imageElement = new ImageElement(g,config);
	        imageElement.render();
	        
	        var box, iconTop = 10, iconGap = 2, 
	            tx = -config.imageWidth / 2 + config.icon1.imageWidth / 2;
	            ty = config.imageHeight / 2 + iconTop,
	            labelY = 0;
	        icon1 = new ImageElement(g,config.icon1);
	        icon1.render();
	        icon1.svgElement.attr("transform", "translate(" + tx +"," + ty + ")");
	        
	        var label1Con = g.append("svg:g").attr("pointer-events", "none");
	        label1 = new Label(label1Con,self.data());
	        label1.config(config.label1);
	        label1.render();
	        box = label1Con.node().getBBox();
	        labelY = ty + config.icon1.imageHeight/2 - box.height;
	        label1Con.attr("transform", "translate(" + -4 +"," + labelY + ")");
	        
	        icon2 = new ImageElement(g,config.icon2);
	        icon2.render();
	        ty += config.icon1.imageHeight + iconGap;
	        icon2.svgElement.attr("transform", "translate(" + tx +"," + ty + ")");
	        
	        var label2Con = g.append("svg:g").attr("pointer-events", "none");
	        label2 = new Label(label2Con,self.data());
	        label2.config(config.label2);
	        label2.render();
	        box = label2Con.node().getBBox();
	        labelY = ty + config.icon2.imageHeight/2 - box.height;
	        label2Con.attr("transform", "translate(" + -4 +"," + labelY + ")");
	        
	        icon3 = new ImageElement(g,config.icon3);
	        icon3.render();
	        ty += config.icon2.imageHeight + iconGap;
	        icon3.svgElement.attr("transform", "translate(" + tx +"," + ty + ")");
	        
	        var label3Con = g.append("svg:g").attr("pointer-events", "none");
	        label3 = new Label(label3Con,self.data());
	        label3.config(config.label3);
	        label3.render();
	        box = label3Con.node().getBBox();
	        labelY = ty + config.icon3.imageHeight/2 - box.height;
	        label3Con.attr("transform", "translate(" + -4 +"," + labelY + ")");
	        
	        var bg = g.select("rect.bgRect");
	        if(bg.node() === null) {
	        	box = g.node().getBBox(); 
	        	console.log(box);
	        	g.insert("rect", "image")
	            	.attr("class", "bgRect")
	            	.attr("x", box.x)
	            	.attr("y", box.y)
	            	.attr("width", box.width)
	            	.attr("height", box.height)
	            	.attr("fill", "white")
	        }
	    }
	};
	
	DemoImageNode.struct = function(ghca_charts) {
		var Plugin = ghca_charts.view.elements.plugins.plugin;
		Plugin.struct(ghca_charts);
	    DemoImageNode.prototype = Object.create(Plugin.prototype);
	    DemoImageNode.prototype.constructor = DemoImageNode;
	};
	
	module.exports = DemoImageNode;

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {var ExpandTool = function (_element,_data) {
		
		// --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const ElementUtil = ghca_charts.view.util.elementUtil;
	    const Plugin      = ghca_charts.view.elements.plugins.plugin;
	    const RegexUtil   = ghca_charts.view.util.regexUtil;
	    const EventUtil = ghca_charts.view.util.eventUtil;
	
	    Plugin.apply(this,arguments);
	    var self = this,
	        superDrawPluginFunction = this.drawPlugin,
	        superBindEventsFunction = this.bindEvents;
	    self.dispatch = d3.dispatch("collapsed");
	    
	    self.config({
	        collapsed:"{data.collapsed}"
	    });
	    
	    var collapsed = true,
	        backGroundCircle,
	        pathElement,
	        collapsedPath = "M-4 0 L4 0 M0 -4 L0 4 Z",
	        expandedPath  = "M-4 0 L4 0 Z";
	
	    this.collapsed = function(p){
	        if(!arguments.length)return collapsed;
	        collapsed = p;
	        self.data().collapsed = p;
	        ElementUtil.setElementProperties(pathElement,{d:(p==true?collapsedPath:expandedPath)});
	        if(self.isRender()){
	            self.el.node().dispatchEvent(EventUtil.createCustomEvent(self.config().events,true,true,self.data()));
	        }
	        return this;
	    }
	    //override
	    this.nameSpace = function(){
	        return "expandTool";
	    }
	
	    //override
	    this.actualWidth = function(){
	        return 5;
	    }
	    //override
	    this.actualHeight = function(){
	        return 5;
	    }
	    //override
	    this.drawPlugin = function(g){
	        superDrawPluginFunction(g);
	        // g.each(function (d) {
	        //     var group = d3.select(this);
	            backGroundCircle = ElementUtil.createCircle(g,{r:5,"stroke-width":1,stroke:"#2585c0","stroke-opacity":1,fill:"white",opacity:0.6});
	            pathElement = ElementUtil.createPath(g,{"stroke-width":2,"stroke":"#2585c0","fill":"none"});
	            self.collapsed(RegexUtil.replace(RegexUtil.dataRegex,self.config().collapsed,self.data())=="true");
	        var param = RegexUtil.replace(RegexUtil.dataRegex,self.config().visible,self.data());
	        if(param == false|| param==self.config().visible)
	            self.visible(false);
	        // });
	    }
	
	    //override
	    this.bindEvents = function(g){
	        superBindEventsFunction(g);
	        g.on("click",function(){
	            d3.event.stopPropagation();
	            self.collapsed(!self.collapsed());
	        }).on("dblclick.extool",this.stopEvent)
	            .on("mouseover",this.stopEvent)
	            .on("mousedown",this.stopEvent)
	            .on("mouseover",this.stopEvent)
	            .on("mousemove",this.stopEvent);
	    }
	    this.stopEvent = function(){
	        d3.event.stopPropagation();
	    }
	};
	
	ExpandTool.struct = function(ghca_charts) {
		var Plugin = ghca_charts.view.elements.plugins.plugin;
		Plugin.struct(ghca_charts);
	    ExpandTool.prototype = Object.create(Plugin.prototype);
	    ExpandTool.prototype.constructor = ExpandTool;
	};
	
	
	module.exports = ExpandTool;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 89 */
/***/ (function(module, exports) {

	var GroupNode = function (_element,_data) {
	    
	    // --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const ElementUtil = ghca_charts.view.util.elementUtil;
	    const BaseLabel = ghca_charts.view.elements.plugins.label.baseLabel;
	    const BaseNode = ghca_charts.view.elements.plugins.nodes.baseNode;
	
	    BaseNode.apply(this,arguments);
	    
	    var self = this;
	        
	    //--------------------------------------------------------------------------
	    //
	    //  Attributes
	    //
	    //--------------------------------------------------------------------------
	    
	    // ------------------------------
	    // attribute
	    // ------------------------------
	
	    //--------------------------------------------------------------------------
	    //
	    //  public Methods
	    //
	    //--------------------------------------------------------------------------
	    
	    //override
	    this.nameSpace = function(){
	        return "groupNode";
	    }
	    
	//    //override
	//    this.data = function(){
	//        return _data.data;
	//    }
	    
	    //override
	    this.bindEvents = function(g){
	    	
	    }
	
	    //override
	    this.setLegendColor = function() {
	    	var fill = "#d7fea2", stroke = "gray";//默认配置
	    	if(_data.legendColor) {//图例颜色
	    		fill = _data.legendColor;
	    		stroke = _data.legendColor;
	        } else if(_data.data && _data.data.nodeProperties) {//用户设置颜色
	            var p = _data.data.nodeProperties;
	            if(p.fill) {
	                fill = p.fill;
	            }
	            if(p.stroke) {
	                stroke = p.stroke;
	            }
	        }
	        self.mainElement.attr("fill", fill).attr("stroke", stroke);
	    }
	
	    //override
	    this.drawPlugin = function(g) {
	    	if(self.data().path === "") {
	    		return;
	    	}
	        g.attr("pointer-events", "visiblefill ");//可视化区域响应鼠标事件
	        self.mainElement = ElementUtil.createPath(g, self.data().data.nodeProperties);
	        self.mainElement.attr("class", "group-area").attr("d", self.data().path)
	        self.setLegendColor();
	        self.createLabel(g,self.data());
	    }
	    
	    //override
	    this.update = function() {
	    	if(self.mainElement) {
	    		self.mainElement.attr("d", self.data().path);
	    		ElementUtil.setElementProperties(self.mainElement, self.data().data.nodeProperties);  		
	    		self.setLegendColor();
	            if(self.label) {
	            	if(self.data().path === "") {
	            		self.label.el.attr("display", "none");
	            	} else {
	            		self.label.el.attr("display", "block");
	            		var labelData = self.data().data.label;
	                    labelData.name = labelData.name ?　labelData.name　: self.data().name;
	                    self.label.update(labelData);
	            		self.labelLayout(self.labelG, self.label, self.data(), true);
	            	}
	            }
	    	}
	    };
	    
	     //override
	    this.createLabel = function(group, d) {
	        if(!d.data || !d.data.label) {
	            return;
	        }
	        self.labelG = group.append("g").attr("pointer-events", "none");
	        var labelData = d.data.label;
	        labelData.name = labelData.name ?　labelData.name　: d.name;
	        self.label =  new BaseLabel(self.labelG, labelData, self);
	        self.label.render();
	        self.labelLayout(self.labelG, self.label, d, false);
	    }
	    
	    //override
	    this.labelLayout = function(element, plugin, d) {
	        var position = d.data.labelPosition;
	        if(position === 'none') {
	            element.style("display", "none");
	            return;
	        } else {
	            element.style("display", "block");
	        }
	        if(!position)
	            position = 'top';
	        
	        var labelPosition = position.toLowerCase(), translate, tx = 0, ty = 0;
	        var labelBox = element.node().getBBox();
	        var point;
	        if(labelPosition === 'bottom') {
	        	point = getBottomPoint(self.data().pathPoints);
	            tx = point[0];
	            ty = point[1] + labelBox.height / 2;
	        } else if(labelPosition === 'left') {
	        	point = getLeftPoint(self.data().pathPoints);
	            tx = point[0] - labelBox.width / 2;
	            ty = point[1];
	        } else if(labelPosition === 'right') {
	        	point = getRightPoint(self.data().pathPoints);
	            tx = point[0] + labelBox.width / 2;
	            ty = point[1];
	        } else if(labelPosition === 'center') {
	        	var pathBox = self.mainElement.node().getBBox();
	            tx = pathBox.x + pathBox.width / 2;
	            ty = pathBox.y + pathBox.height / 2;
	        } else if(labelPosition === 'insidetop') {
	        	point = getTopPoint(self.data().pathPoints);
	            tx = point[0];
	            ty = point[1] + labelBox.height / 2;
	        } else if(labelPosition === 'insidebottom') {
	        	point = getBottomPoint(self.data().pathPoints);
	            tx = point[0];
	            ty = point[1] - labelBox.height / 2;
	        } else if(labelPosition === 'insideleft') {
	        	point = getLeftPoint(self.data().pathPoints);
	            tx = point[0] + labelBox.width / 2;
	            ty = point[1];
	        } else if(labelPosition === 'insideright') {
	        	point = getRightPoint(self.data().pathPoints);
	            tx = point[0] - labelBox.width / 2;
	            ty = point[1];
	        } else {
	            //default top
	        	point = getTopPoint(self.data().pathPoints);
	            tx = point[0];
	            ty = point[1] - labelBox.height / 2;
	        }
	        element.attr("transform", "translate("+tx+","+ty+")");
	    };
	    
	    var getTopPoint = function(points) {
	    	var result = null, xArray = [];
	    	for(var p, i = 0, len = points.length; i < len; i++) {
	    		p = points[i];
	    		if(result === null || p[1] < result[1]) {
	    			result = p;
	    			xArray.length = 0;
	    			xArray.push(p[0]);
	    		} else if(p[1] === result[1]) {
	    			xArray.push(p[0]);
	    		}
	    	}
	    	if(xArray.length > 1) {
	    		var totalX = 0;
	            for(var i = 0, len = xArray.length; i < len; i++) {
	                totalX += xArray[i]
	            }
	            var avgX = totalX / xArray.length;
	    	}
	    	return result ? [avgX ? avgX : result[0], result[1]] : null;
	    };
	    
	    var getBottomPoint = function(points) {
	        var result = null, xArray = [];
	        for(var p, i = 0, len = points.length; i < len; i++) {
	            p = points[i];
	            if(result === null || p[1] > result[1]) {
	                result = p;
	                xArray.length = 0;
	                xArray.push(p[0]);
	            } else if(p[1] === result[1]) {
	                xArray.push(p[0]);
	            }
	        }
	        if(xArray.length > 1) {
	            var totalX = 0;
	            for(var i = 0, len = xArray.length; i < len; i++) {
	                totalX += xArray[i]
	            }
	            var avgX = totalX / xArray.length;
	        }
	        return result ? [avgX ? avgX : result[0], result[1]] : null;
	    };
	    
	    var getLeftPoint = function(points) {
	        var result = null, yArray = [];
	        for(var p, i = 0, len = points.length; i < len; i++) {
	            p = points[i];
	            if(result === null || p[0] < result[0]) {
	                result = p;
	                yArray.length = 0;
	                yArray.push(p[1]);
	            } else if(p[0] === result[0]) {
	                yArray.push(p[1]);
	            }
	        }
	        if(yArray.length > 1) {
	            var totalY = 0;
	            for(var i = 0, len = yArray.length; i < len; i++) {
	                totalY += yArray[i]
	            }
	            var avgY = totalY / yArray.length;
	        }
	        return result ? [result[0], avgY ? avgY : result[1]] : null;
	    };
	    
	    var getRightPoint = function(points) {
	        var result = null, yArray = [];
	        for(var p, i = 0, len = points.length; i < len; i++) {
	            p = points[i];
	            if(result === null || p[0] > result[0]) {
	                result = p;
	                yArray.length = 0;
	                yArray.push(p[1]);
	            } else if(p[0] === result[0]) {
	                yArray.push(p[1]);
	            }
	        }
	        if(yArray.length > 1) {
	            var totalY = 0;
	            for(var i = 0, len = yArray.length; i < len; i++) {
	                totalY += yArray[i]
	            }
	            var avgY = totalY / yArray.length;
	        }
	        return result ? [result[0], avgY ? avgY : result[1]] : null;
	    };
	};
	
	GroupNode.struct = function(ghca_charts) {
	    var BaseNode = ghca_charts.view.elements.plugins.nodes.baseNode;
	    BaseNode.struct(ghca_charts);
	    GroupNode.prototype = Object.create(BaseNode.prototype);
	    GroupNode.prototype.constructor = GroupNode;
	};
	
	module.exports = GroupNode;

/***/ }),
/* 90 */
/***/ (function(module, exports) {

	var HBarNode = function (_element,_data) {
	    
	    // --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const ElementUtil = ghca_charts.view.util.elementUtil;
	    const BaseLabel = ghca_charts.view.elements.plugins.label.baseLabel;
	    const ColorUtil = ghca_charts.view.util.colorUtil;
	    const BaseNode = ghca_charts.view.elements.plugins.nodes.baseNode;
	
	    BaseNode.apply(this,arguments);
	    
	    var self = this;
	        
	    //--------------------------------------------------------------------------
	    //
	    //  Attributes
	    //
	    //--------------------------------------------------------------------------
	    
	    // ------------------------------
	    // attribute
	    // ------------------------------
	
	    //--------------------------------------------------------------------------
	    //
	    //  public Methods
	    //
	    //--------------------------------------------------------------------------
	    
	    //override
	    this.nameSpace = function(){
	        return "hBarNode";
	    }
	    
	//    //override
	//    this.data = function(){
	//        return _data.data;
	//    }
	
	    //override
	    this.mouseOverHandler = function() {
	        self.mainElement
	            .attr("fill-opacity", 0.5);
	    }
	    
	    //override
	    this.mouseOutHandler = function() {
	        self.mainElement
	            .attr("fill-opacity", 1);
	    }
	
	    //override
	    this.selectedChange = function(seleced) {
	    }
	    
	    //override
	    this.drawPlugin = function(g){
	    	var data = self.data().data;
	    	var p = data && data.hasOwnProperty("clazzProperties") ? data.clazzProperties : null;
	        var eleConfig = {rx:4};
	        if(p) {
	            for(var k in p) {
	                eleConfig[k] = p[k];
	            }
	        }
	    	self.mainElement = g.append("rect");
	        self.mainElement
	            .attr("class", "bar-rect")
	            .attr("fill", function(d){
	                return d.legendColor;
	            })
	            .attr("y", function(d) {
	                return d.y;
	            })
	            .attr("height", function(d) {
	                return d.dy;
	            })
	            .attr("x", 1)
	            .attr("width", 0);
	        ElementUtil.setElementProperties(self.mainElement, eleConfig);
	            
	        self.mainElement
	            .transition().duration(self.animation() ? 1000 : 0)
	            .attr("x", function(d) {
	                return d.x;
	            })
	            .attr("width", function(d) {
	                return d.dx;
	            });
	        self.createLabel(g,self.data());
	    }
	    
	    //override
	    this.update = function() {
	    	if(self.mainElement) {
	    		var data = self.data().data;
	            var p = data && data.hasOwnProperty("clazzProperties") ? data.clazzProperties : null;
	            var eleConfig = {rx:4};
	            if(p) {
	                for(var k in p) {
	                    eleConfig[k] = p[k];
	                }
	            }
	    		self.mainElement.datum(self.data())
	    		    .transition().duration(self.animation() ? 500 : 0)
	    		    .attr("fill", function(d){
	                    return d.legendColor;
	                })
	                .attr("y", function(d) {
	                    return d.y;
	                })
	                .attr("height", function(d) {
	                    return d.dy;
	                })
	                .attr("x", function(d) {
	                    return d.x;
	                })
	                .attr("width", function(d) {
	                    return d.dx;
	                });
	            ElementUtil.setElementProperties(self.mainElement, eleConfig);
	            if(self.label) {
	                var labelData = self.data().data.label;
	                labelData.name = labelData.format ?　self.formatStr(labelData.format)(self.data())　: self.data().value;
	                self.label.update(labelData);
	                self.labelLayout(self.labelG, self.label, self.data(), true);
	            }
	    	}
	    };
	    
	     //override
	    this.createLabel = function(group, d) {
	        if(!d.data || !d.data.label || d.value === null || d.value === undefined) {
	            return;
	        }
	        self.labelG = group.append("g").attr("pointer-events", "none");
	        var labelData = d.data.label;
	        labelData.name = labelData.format ?　self.formatStr(labelData.format)(d)　: d.value;
	        self.label = new BaseLabel(self.labelG, labelData, self);
	        self.label.render();
	        self.labelLayout(self.labelG, self.label, d, false);
	    }
	    
	    //override
	    this.labelLayout = function(element, plugin, d, isUpdate){
	        var position = d.data.labelPosition;
	        if(position === 'none') {
	            element.style("display", "none");
	            return;
	        } else {
	            element.style("display", "block");
	        }
	        if(!position)
	            position = 'right';
	        
	        var translate, labelPosition = position.toLowerCase(), tx = 0, ty = 0;
	        var labelBox = element.node().getBBox();
	        if(labelPosition == 'bottom') {
	            tx = d.x + d.dx / 2;
	            ty = d.y + d.dy + labelBox.height / 2;
	        } else if(labelPosition == 'left') {
	            tx = 1 + labelBox.width / 2;
	            ty = d.y + d.dy / 2;
	        } else if(labelPosition == 'top') {
	            tx = d.x + d.dx / 2;
	            ty = d.y - labelBox.height / 2;
	        } else if(labelPosition == 'center') {
	            tx = d.x + d.dx / 2;
	            ty = d.y + d.dy / 2;
	        } else if(labelPosition == 'insidetop') {
	            tx = d.x + d.dx / 2;
	            ty = d.y + labelBox.height / 2;
	        } else if(labelPosition == 'insidebottom') {
	            tx = d.x + d.dx / 2;
	            ty = d.y + d.dy - labelBox.height / 2;
	        } else if(labelPosition == 'insideleft') {
	            tx = d.x + labelBox.width / 2;
	            ty = d.y + d.dy / 2;
	        } else if(labelPosition == 'insideright') {
	            tx = d.x + d.dx - labelBox.width / 2;
	            ty = d.y + d.dy / 2;
	        } else {
	            //default right
	            tx = d.x + d.dx + labelBox.width / 2 + 3;
	            ty = d.y + d.dy / 2;
	        }
	        if(isUpdate) {
	             element
	                .transition().duration(self.animation() ? 500 : 0)
	                .attr("transform", "translate("+tx+","+ty+")");
	        } else {
	             element
	                .attr("transform", "translate("+1+","+ty+")")
	                .transition().duration(self.animation() ? 1000 : 0)
	                .attr("transform", "translate("+tx+","+ty+")");
	        }
	    }
	};
	
	HBarNode.struct = function(ghca_charts) {
	    var BaseNode = ghca_charts.view.elements.plugins.nodes.baseNode;
	    BaseNode.struct(ghca_charts);
	    HBarNode.prototype = Object.create(BaseNode.prototype);
	    HBarNode.prototype.constructor = HBarNode;
	};
	
	module.exports = HBarNode;

/***/ }),
/* 91 */
/***/ (function(module, exports) {

	var HProgressBarNode = function (_element,_data) {
	    
	    // --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const ElementUtil = ghca_charts.view.util.elementUtil;
	    const BaseLabel = ghca_charts.view.elements.plugins.label.baseLabel;
	    const ColorUtil = ghca_charts.view.util.colorUtil;
	    const BaseNode = ghca_charts.view.elements.plugins.nodes.baseNode;
	
	    BaseNode.apply(this,arguments);
	    
	    var self = this;
	        
	    //--------------------------------------------------------------------------
	    //
	    //  Attributes
	    //
	    //--------------------------------------------------------------------------
	    
	    // ------------------------------
	    // attribute
	    // ------------------------------
	
	    //--------------------------------------------------------------------------
	    //
	    //  public Methods
	    //
	    //--------------------------------------------------------------------------
	    
	    //override
	    this.nameSpace = function(){
	        return "hProgressBarNode";
	    }
	    
	//    //override
	//    this.data = function(){
	//        return _data.data;
	//    }
	
	    //override
	    this.mouseOverHandler = function() {
	        self.mainElement
	            .attr("fill-opacity", 0.5);
	    }
	    
	    //override
	    this.mouseOutHandler = function() {
	        self.mainElement
	            .attr("fill-opacity", 1);
	    }
	
	    //override
	    this.selectedChange = function(seleced) {
	    }
	    
	    //override
	    this.drawPlugin = function(g){
	    	var data = self.data().data;
	    	var p = data && data.hasOwnProperty("clazzProperties") ? data.clazzProperties : null;
	    	
	        //background rect
	    	var bgRect = p.bgRect;
	    	var defaultBgRect = {rx:4};
	        if(bgRect) {
	            for(var k in bgRect) {
	                defaultBgRect[k] = bgRect[k];
	            }
	        }
	        self.bgRect = g.append("rect")
	            .attr("class", "bg-rect")
	            .attr("x", function(d) {
	                return d.x;
	            })
	            .attr("y", function(d) {
	                return d.y;
	            })
	            .attr("width", function(d) {
	                return d.bgWidth;
	            })
	            .attr("height", function(d) {
	                return d.bgHeight;
	            });
	        ElementUtil.setElementProperties(self.bgRect, defaultBgRect);
	            
	        //progress bar rect 
	        var eleConfig = {rx:4};
	        if(p) {
	            for(var k in p) {
	                eleConfig[k] = p[k];
	            }
	        }
	        self.mainElement = g.append("rect")
	            .attr("class", "bar-rect")
	            .attr("x", function(d) {
	                return d.x;
	            })
	            .attr("y", function(d) {
	                return d.y;
	            })
	            .attr("height", function(d) {
	                return d.height;
	            })
	            .attr("width", 0);
	        ElementUtil.setElementProperties(self.mainElement, eleConfig);
	        self.setLegendColor();
	            
	        self.mainElement
	            .transition().duration(self.animation() ? 1000 : 0)
	            .attr("width", function(d) {
	                return d.width;
	            });
	        self.createLabel(g, self.data());
	    };
	    
	    //override
	    this.update = function() {
	    	if(self.mainElement) {
	    		//更新渲染器绑定数据
	    		self.el && self.el.datum(self.data());
	    		
	    		var data = self.data().data;
	            var p = data && data.hasOwnProperty("clazzProperties") ? data.clazzProperties : null;
	            
	            //background rect
	            var bgRect = p.bgRect;
	            var defaultBgRect = {rx:4};
	            if(bgRect) {
	                for(var k in bgRect) {
	                    defaultBgRect[k] = bgRect[k];
	                }
	            }
	            self.bgRect
	                .transition().duration(self.animation() ? 500 : 0)
	                .attr("x", function(d) {
	                    return d.x;
	                })
	                .attr("y", function(d) {
	                    return d.y;
	                })
	                .attr("width", function(d) {
	                    return d.bgWidth;
	                })
	                .attr("height", function(d) {
	                    return d.bgHeight;
	                });
	            ElementUtil.setElementProperties(self.bgRect, defaultBgRect);
	            
	            //progress bar rect 
	            var eleConfig = {rx:4};
	            if(p) {
	                for(var k in p) {
	                    eleConfig[k] = p[k];
	                }
	            }
	    		self.mainElement.datum(self.data())
	    		    .transition().duration(self.animation() ? 500 : 0)
	                .attr("y", function(d) {
	                    return d.y;
	                })
	                .attr("height", function(d) {
	                    return d.height;
	                })
	                .attr("x", function(d) {
	                    return d.x;
	                })
	                .attr("width", function(d) {
	                    return d.width;
	                });
	            ElementUtil.setElementProperties(self.mainElement, eleConfig);
	            self.setLegendColor();
	            
	            if(self.label1) {
	                var labelData1 = data.label1;
	                labelData1.name = labelData1.format ?　self.formatStr(labelData1.format)(self.data())　: self.data().value;
	                self.label1.update(labelData1);
	                self.labelLayout(self.label1G, self.label1, self.data(), true, data.label1Position);
	            }
	            if(self.label2) {
	                var labelData2 = data.label2;
	                labelData2.name = labelData2.format ?　self.formatStr(labelData2.format)(self.data())　: self.data().value;
	                self.label2.update(labelData2);
	                self.labelLayout(self.label2G, self.label2, self.data(), true, data.label2Position);
	            }
	    	}
	    };
	    
	     //override
	    this.createLabel = function(group, d) {
	        if(!d.data || d.value === null || d.value === undefined) {
	            return;
	        }
	        
	        var labelData1 = d.data.label1;
	        if(labelData1) {
	        	self.label1G = group.append("g").attr("pointer-events", "none");
	        	labelData1.name = labelData1.format ?　self.formatStr(labelData1.format)(d)　: d.value;
	            self.label1 = new BaseLabel(self.label1G, labelData1, self);
	            self.label1.render();
	            self.labelLayout(self.label1G, self.label1, d, false, d.data.label1Position);
	        }
	        
	        var labelData2 = d.data.label2;
	        if(labelData2) {
	        	self.label2G = group.append("g").attr("pointer-events", "none");
	            labelData2.name = labelData2.format ?　self.formatStr(labelData2.format)(d)　: d.value;
	            self.label2 = new BaseLabel(self.label2G, labelData2, self);
	            self.label2.render();
	            self.labelLayout(self.label2G, self.label2, d, false, d.data.label2Position);
	        }
	    }
	    
	    //override
	    this.labelLayout = function(element, plugin, d, isUpdate, position){
	        if(position === 'none') {
	            element.style("display", "none");
	            return;
	        } else {
	            element.style("display", "block");
	        }
	        if(!position)
	            position = 'center';
	        
	        var translate, labelPosition = position.toLowerCase(), tx = 0, ty = 0;
	        var labelBox = element.node().getBBox();
	        if(labelPosition == 'left') {
	            tx = 1 + labelBox.width / 2;
	            ty = d.y + d.bgHeight / 2;
	        } else if(labelPosition == 'right') {
	            tx = d.x + d.bgWidth + labelBox.width / 2 + 3;
	            ty = d.y + d.bgHeight / 2;
	        } else if(labelPosition == 'top') {
	            tx = d.x + d.bgWidth / 2;
	            ty = d.y - labelBox.height / 2;
	        } else if(labelPosition == 'bottom') {
	            tx = d.x + d.bgWidth / 2;
	            ty = d.y + d.bgHeight + labelBox.height / 2;
	        } else if(labelPosition == 'center') {
	            tx = d.x + d.bgWidth / 2;
	            ty = d.y + d.bgHeight / 2;
	        } else if(labelPosition == 'topleft') {
	            tx = d.x + labelBox.width / 2;
	            ty = d.y - labelBox.height / 2;
	        } else if(labelPosition == 'topright') {
	            tx = d.x + d.bgWidth - labelBox.width / 2;
	            ty = d.y - labelBox.height / 2;
	        } else if(labelPosition == 'bottomleft') {
	            tx = d.x + labelBox.width / 2;
	            ty = d.y + d.bgHeight + labelBox.height / 2;
	        } else if(labelPosition == 'bottomright') {
	            tx = d.x + d.bgWidth - labelBox.width / 2;
	            ty = d.y + d.bgHeight + labelBox.height / 2;
	        } else if(labelPosition == 'insideleft') {
	            tx = d.x + labelBox.width / 2;
	            ty = d.y + d.bgHeight / 2;
	        } else if(labelPosition == 'insideright') {
	            tx = d.x + d.bgWidth - labelBox.width / 2;
	            ty = d.y + d.bgHeight / 2;
	        } else {
	            //default center
	            tx = d.x + d.bgWidth / 2;
	            ty = d.y + d.bgHeight / 2;
	        }
	        if(isUpdate) {
	             element
	                .transition().duration(self.animation() ? 500 : 0)
	                .attr("transform", "translate("+tx+","+ty+")");
	        } else {
	             element
	                .attr("transform", "translate("+1+","+ty+")")
	                .transition().duration(self.animation() ? 0 : 0)
	                .attr("transform", "translate("+tx+","+ty+")");
	        }
	    }
	};
	
	HProgressBarNode.struct = function(ghca_charts) {
	    var BaseNode = ghca_charts.view.elements.plugins.nodes.baseNode;
	    BaseNode.struct(ghca_charts);
	    HProgressBarNode.prototype = Object.create(BaseNode.prototype);
	    HProgressBarNode.prototype.constructor = HProgressBarNode;
	};
	
	module.exports = HProgressBarNode;

/***/ }),
/* 92 */
/***/ (function(module, exports) {

	var IconNode = function (_element,_data) {
		
		// --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const Plugin = ghca_charts.view.elements.plugins.plugin;
	    const ImageElement = ghca_charts.view.elements.imageElement;
	    const ObjectUtil = ghca_charts.view.util.objectUtil;
	    const RegexUtil = ghca_charts.view.util.regexUtil;
	    const RectElement = ghca_charts.view.elements.rectElement;
	
	    Plugin.apply(this,arguments);
	    var self = this,
	        imageElement = _element,
	        backgroundEle;
	
	    self.config({
	    	imageWidth:32,
	        imageHeight:32,
	        opacity:1
	    });
	
	    //override
	    this.nameSpace = function(){
	        return "iconNode";
	    }
	    //override
	    this.update = function(g){
	    	if(imageElement) {
	            var config = ObjectUtil.cloneObj(self.config());
	            config.url = RegexUtil.replace(RegexUtil.dataRegex,config.url,self.data());
	            config.imageWidth = RegexUtil.replace(RegexUtil.dataRegex,config.imageWidth,self.data());
	            config.imageHeight = RegexUtil.replace(RegexUtil.dataRegex,config.imageHeight,self.data());
	            config.opacity = RegexUtil.replace(RegexUtil.dataRegex,config.opacity,self.data());
	                    
	    		imageElement.data(config);
	    	}
	    	if(backgroundEle && self.config().background) {
	            backgroundEle.data(self.config().background);
	        }
	        self.resetBBox(parseFloat(imageElement.svgElement.attr("x")),parseFloat(imageElement.svgElement.attr("y")), config.imageWidth, config.imageHeight);
	    }
	    //override
	    this.drawPlugin = function(g){
	        var config = ObjectUtil.cloneObj(self.config());
	        config.url = RegexUtil.replace(RegexUtil.dataRegex,config.url,self.data());
	        config.imageWidth = RegexUtil.replace(RegexUtil.dataRegex,config.imageWidth,self.data());
	        config.imageHeight = RegexUtil.replace(RegexUtil.dataRegex,config.imageHeight,self.data());
	        config.opacity = RegexUtil.replace(RegexUtil.dataRegex,config.opacity,self.data());
	        if(config.background) {
	        	backgroundEle = new RectElement(g, config.background);
	            backgroundEle.render();
	        }
	        imageElement = new ImageElement(g,config);
	        imageElement.render();
	        imageElement.svgElement.attr("class","icon_image");
	        self.resetBBox(parseFloat(imageElement.svgElement.attr("x")),parseFloat(imageElement.svgElement.attr("y")), config.imageWidth, config.imageHeight);
	    }
	};
	
	IconNode.struct = function(ghca_charts) {
		var Plugin = ghca_charts.view.elements.plugins.plugin;
		Plugin.struct(ghca_charts);
	    IconNode.prototype = Object.create(Plugin.prototype);
	    IconNode.prototype.constructor = IconNode;
	};
	
	module.exports = IconNode;

/***/ }),
/* 93 */
/***/ (function(module, exports) {

	var ImageNode = function (_element,_data) {
		
		// --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const Plugin = ghca_charts.view.elements.plugins.plugin;
	    const ImageElement = ghca_charts.view.elements.imageElement;
	    const ObjectUtil = ghca_charts.view.util.objectUtil;
	    const RegexUtil = ghca_charts.view.util.regexUtil;
	    const CircleElement = ghca_charts.view.elements.circleElement;
	
	    Plugin.apply(this,arguments);
	    var self = this,
	        imageElement = _element,
	        backgroundEle;
	
	    self.config({
	    	imageWidth:32,
	        imageHeight:32,
	        opacity:1
	    });
	
	    //override
	    this.nameSpace = function(){
	        return "imageNode";
	    }
	    //override
	    this.update = function(g){
	    	if(imageElement) {
	            var config = ObjectUtil.cloneObj(self.config());
	            config.color = RegexUtil.replace(RegexUtil.dataRegex,config.color,self.data());
	            config.url = RegexUtil.replace(RegexUtil.dataRegex,config.url,self.data());
	            config.imageWidth = RegexUtil.replace(RegexUtil.dataRegex,config.imageWidth,self.data());
	            config.imageHeight = RegexUtil.replace(RegexUtil.dataRegex,config.imageHeight,self.data());
	    		imageElement.data(config);
	    	}
	    	if(backgroundEle && self.config().background) {
	            backgroundEle.data(self.config().background);
	        }
	        self.resetBBox(-config.imageWidth/2, -config.imageHeight/2, config.imageWidth, config.imageHeight);
	    }
	    //override
	    this.drawPlugin = function(g){
	        var config = ObjectUtil.cloneObj(self.config());
	        config.color = RegexUtil.replace(RegexUtil.dataRegex,config.color,self.data());
	        config.url = RegexUtil.replace(RegexUtil.dataRegex,config.url,self.data());
	        config.imageWidth = RegexUtil.replace(RegexUtil.dataRegex,config.imageWidth,self.data());
	        config.imageHeight = RegexUtil.replace(RegexUtil.dataRegex,config.imageHeight,self.data());
	        if(config.background) {
	        	backgroundEle = new CircleElement(g, config.background);
	            backgroundEle.render();
	        }
	        imageElement = new ImageElement(g,config);
	        imageElement.render();
	        self.resetBBox(-config.imageWidth/2, -config.imageHeight/2, config.imageWidth, config.imageHeight);
	    }
	};
	
	ImageNode.struct = function(ghca_charts) {
		var Plugin = ghca_charts.view.elements.plugins.plugin;
		Plugin.struct(ghca_charts);
	    ImageNode.prototype = Object.create(Plugin.prototype);
	    ImageNode.prototype.constructor = ImageNode;
	};
	
	module.exports = ImageNode;

/***/ }),
/* 94 */
/***/ (function(module, exports) {

	var LineNode = function (_element,_data) {
	    
	    // --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const BaseLabel = ghca_charts.view.elements.plugins.label.baseLabel;
	    const BaseNode = ghca_charts.view.elements.plugins.nodes.baseNode;
	    const ElementUtil = ghca_charts.view.util.elementUtil;
	
	    BaseNode.apply(this,arguments);
	    
	    var self = this,
	        eleConfig = {r:3, "stroke-width":1.5};
	        
	    //--------------------------------------------------------------------------
	    //
	    //  Attributes
	    //
	    //--------------------------------------------------------------------------
	    
	//    // ------------------------------
	//    // radius
	//    // ------------------------------
	//    
	//    /**
	//     * 半径
	//     */
	//    var radius = 3;
	//    this.radius = function(value){
	//        if (!arguments.length) return radius;
	//        radius = value;
	//        return this;
	//    };
	//    
	//    // ------------------------------
	//    // strokeWidth
	//    // ------------------------------
	//    
	//    /**
	//     * 边线宽度
	//     */
	//    var strokeWidth = 1.5;
	//    this.strokeWidth = function(value){
	//        if (!arguments.length) return strokeWidth;
	//        strokeWidth = value;
	//        return this;
	//    };
	
	    //--------------------------------------------------------------------------
	    //
	    //  public Methods
	    //
	    //--------------------------------------------------------------------------
	    
	    //override
	    this.nameSpace = function(){
	        return "lineNode";
	    };
	    
	//    //override
	//    this.data = function(){
	//        return _data.data;
	//    };
	
	    //override
	    this.mouseOverHandler = function() {
	        self.mainElement
	            .attr("r", eleConfig.r + 1)
	            .attr("stroke-width", eleConfig["stroke-width"] + 1);
	    };
	    
	    //override
	    this.mouseOutHandler = function() {
	    	self.mainElement
	            .attr("r", eleConfig.r)
	            .attr("stroke-width", eleConfig["stroke-width"]);
	    };
	
	    //override
	    this.selectedChange = function(seleced) {
	    };
	    
	    //override
	    this.drawPlugin = function(g){
	    	parseEleConfig();
	        self.mainElement = g.append("circle");
	        var t = self.mainElement
	            .attr("class", "point-circle")
	            .attr("cx", function(d) {
	                return d.x;
	            })
	            .attr("cy", function(d) {
	                return d.y;
	            })
	            .attr("r", 0)
	            .attr("fill",  function(d) {
	                return d.hasOwnProperty("legendColor") ? d.legendColor :　"white";
	            })
	            .attr("stroke", function(d) {
	                return d.hasOwnProperty("legendColor") ? d.legendColor :　"blue";
	            })
	            .transition().duration(self.animation() ? 1000 : 0)
	        ElementUtil.setElementProperties(t, eleConfig);
	        self.createLabel(g,self.data());
	    };
	    
	    //override
	    this.update = function() {
	    	if(self.mainElement) {
	            parseEleConfig();
	    		var t = self.mainElement.datum(self.data())
	    		    .transition().duration(self.animation() ? 500 : 0)
	                .attr("cx", function(d) {
	                    return d.x;
	                })
	                .attr("cy", function(d) {
	                    return d.y;
	                })
	                .attr("fill",  function(d) {
	                    return d.hasOwnProperty("legendColor") ? d.legendColor :　"white";
	                })
	                .attr("stroke", function(d) {
	                    return d.hasOwnProperty("legendColor") ? d.legendColor :　"blue";
	                });
	            ElementUtil.setElementProperties(t, eleConfig);
	    	}
	    	if(self.label) {
	    		var labelData = self.data().data.label;
	            labelData.name = labelData.name ?　labelData.name　: self.data().value;
	    		self.label.update(labelData);
	    		self.labelLayout(self.labelG, self.label, self.data(), true);
	    	}
	    };
	    
	    //override
	    this.createLabel = function(group, d) {
	        if(!d.data || !d.data.label || d.value === null || d.value === undefined) {
	            return;
	        }
	        self.labelG = group.append("g").attr("pointer-events", "none");
	        var labelData = d.data.label;
	        labelData.name = labelData.name ?　labelData.name　: d.value;
	        self.label =  new BaseLabel(self.labelG, labelData, self);
	        self.label.render();
	        self.labelLayout(self.labelG, self.label, d, false);
	    };
	    
	    //override
	    this.labelLayout = function(element, plugin, d, isUpdate){
	        var position = d.data.labelPosition;
	        if(position === 'none') {
	            element.style("display", "none");
	            return;
	        } else {
	            element.style("display", "block");
	        }
	        if(!position)
	            position = 'top';
	        
	        var labelPosition = position.toLowerCase(),translate, tx = 0, ty = 0;
	        var labelBox = element.node().getBBox();
	        var r = eleConfig.r + eleConfig["stroke-width"] + 2;
	        if(labelPosition == 'bottom') {
	            tx = d.x;
	            ty = d.y + r + labelBox.height / 2;
	        } else if(labelPosition == 'left') {
	            tx = d.x - r - labelBox.width / 2;
	            ty = d.y;
	        } else if(labelPosition == 'right') {
	            tx = d.x + r + labelBox.width / 2;
	            ty = d.y;
	        } else if(labelPosition == 'center') {
	            tx = d.x;
	            ty = d.y;
	        } else {
	        	//default top
	        	tx = d.x;
	            ty = d.y - r - labelBox.height / 2;
	        }
	        if(isUpdate) {
	        	 element
	                .transition().duration(self.animation() ? 500 : 0)
	                .attr("transform", "translate("+tx+","+ty+")");
	        } else {
	        	 element
	                .attr("transform", "translate("+tx+","+ty+")")
	                .transition().duration(self.animation() ? 1000 : 0)
	                .attr("transform", "translate("+tx+","+ty+")");
	        }
	    };
	    
	    //--------------------------------------------------------------------------
	    //
	    //  private Methods
	    //
	    //--------------------------------------------------------------------------
	    
	    var parseEleConfig = function() {
	        var data = self.data().data;
	        var p = data && data.hasOwnProperty("clazzProperties") ? data.clazzProperties : null;
	        eleConfig = {r:3, "stroke-width":1.5};
	        if(p) {
	            for(var k in p) {
	                eleConfig[k] = p[k];
	            }
	        }
	    };
	};
	
	LineNode.struct = function(ghca_charts) {
	    var BaseNode = ghca_charts.view.elements.plugins.nodes.baseNode;
	    BaseNode.struct(ghca_charts);
	    LineNode.prototype = Object.create(BaseNode.prototype);
	    LineNode.prototype.constructor = LineNode;
	};
	
	module.exports = LineNode;

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {var MoreTool = function (_element,_data) {
	
	    // --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	
	    const Plugin = ghca_charts.view.elements.plugins.plugin;
	    const EventUtil = ghca_charts.view.util.eventUtil;
	
	    Plugin.apply(this,arguments);
	    var self = this;
	
	    self.config({
	        "text":"更多...",
	        "fontColor":"#2585c0",
	        "fontFamily":"微软雅黑",
	        "fontSize":14,
	    });
	    //override
	    this.actualWidth = function(){
	        return 0;
	    }
	    //override
	    this.actualHeight = function(){
	        return 0;
	    }
	
	    //override
	    this.nameSpace = function(){
	        return "moreTool";
	    }
	    //override
	    this.update = function(g){
	    }
	    //override
	    this.drawPlugin = function(g){
	        var config = self.config();
	        self.textElement =
	            g.append("text").style("font-size",config.fontSize)
	                .style("font-family",config.fontFamily)
	                .style("fill",config.fontColor)
	                .style("pointer-events","all")
	                .attr("dx",config.fontSize*2)
	                .attr("dy",config.fontSize/2)
	                .text(config.text);
	    }
	    //override
	    this.bindEvents = function(g){
	        g.on('mouseover', function(d) {
	            d3.event.stopPropagation();
	            self.textElement.style("fill","#FF6633")
	        });
	
	        g.on('mouseout', function(d) {
	            d3.event.stopPropagation();
	            self.textElement.style("fill",self.config().fontColor)
	        });
	        g.on('click', function(d) {
	            d3.event.stopPropagation();
	            self.el.node().dispatchEvent(EventUtil.createCustomEvent(self.config().events,true,true,self.data()));
	            self.el.remove();
	        });
	
	    }
	};
	
	MoreTool.struct = function(ghca_charts) {
	    var Plugin = ghca_charts.view.elements.plugins.plugin;
	    Plugin.struct(ghca_charts);
	    MoreTool.prototype = Object.create(Plugin.prototype);
	    MoreTool.prototype.constructor = MoreTool;
	};
	
	module.exports = MoreTool;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {var Node = function (_element,_data) {
	    // if(!window.node){
	    //     window.node=1;
	    // }
	    // window.node=window.node+1;
	    // console.log(window.node);
	    // --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const Plugin = ghca_charts.view.elements.plugins.plugin;
	    const RegexUtil = ghca_charts.view.util.regexUtil;
	    const ClassFactory = ghca_charts.view.util.classFactory;
	    const BaseEvent   = ghca_charts.events.BaseEvent;
	    const EventUtil = ghca_charts.view.util.eventUtil;
	
	    Plugin.apply(this,arguments);
	    var self = this,
	        superDrawPluginFunction = this.drawPlugin,
	        superBindEventsFunction = this.bindEvents;
	    self.dispatch = d3.dispatch("selectedChange","collapsed");
	    self.mainPlugin = null;
	    self.backGroundPlugin = null;
	    self.labelContainer = null;
	    self.labelPlugin = null;
	    self.plugins = [];
	
	    self.config({
	    	boundType:"circle",
	        main:{
	            clazz:"circle",
	            config:{
	                cx:0,
	                cy:0,
	                radius:10,
	                border:2,
	                borderColor:"green",
	                linecap:"butt",
	                color:"red"
	            }
	        },
	        backGround:{
	            clazz:"circle",
	            config:{
	                cx:0,
	                cy:0,
	                radius:15,
	                border:2,
	                borderColor:"green",
	                linecap:"butt",
	                color:"none"
	            }
	        },
	        label:{
	            clazz:"label",
	            position:"{labelPosition}",
	            rotate:"{labelRotateAngle}",
	            config:{
	                text:"{name}",
	                maxWidth:60,
	                backGroundColor:"green",
	                backGroundOpacity:.3,
	                borderRadius:4,
	                padding:4,
	                fontColor:"0x000000",
	                fontFamily:"宋体",
	                fontSize:12,
	                textLine:3,
	                visible:true
	            }
	        },
	        plugins:[
	            {
	                clazz:"expandTool",
	                config:{
	
	                }
	            }
	        ]
	    });
	
	    /**
	     * 节点选中
	     * @param _selected
	     * @returns {*}
	     */
	    var _selected = false;
	    this.selected = function(_p){
	        if(!arguments.length)return _selected;
	        _selected = _p;
	        self.dispatch.call("selectedChange",this , new BaseEvent(self,{selected:_selected}));
	        return this;
	    }
	    this.selectedChange = function(seleced){
	        if(self.backGroundPlugin)
	            if(seleced){
	                self.backGroundPlugin.visible(true);
	            }else{
	                self.backGroundPlugin.visible(false);
	            }
	    }
	    this.mouseOverHandler = function(){
	        if(!self.selected()&&self.backGroundPlugin)
	            self.backGroundPlugin.visible(true);
	    }
	    this.mouseOutHandler = function(){
	        if(!self.selected()&&self.backGroundPlugin)
	            self.backGroundPlugin.visible(false);
	    }
	    //override
	    this.nameSpace = function(){
	        return "node";
	    }
	
	//    //override
	//    this.actualWidth = function(){
	//        var bw = self.backGroundPlugin?self.backGroundPlugin.actualWidth():0;
	//        var mw = self.mainPlugin ? self.mainPlugin.actualWidth() : 0;
	//        return bw>mw?bw:mw;
	//    }
	//    //override
	//    this.actualHeight = function(){
	//        var bh = self.backGroundPlugin?self.backGroundPlugin.actualHeight():0;
	//        var mh = self.mainPlugin ? self.mainPlugin.actualHeight() : 0;
	//        return bh>mh?bh:mh;
	//    }
	    //override
	    this.update = function(g){
	    	var config = self.config();
	    	self.boundType(config.boundType);
	    	if(config.backGround && self.backGroundPlugin) {
	            self.backGroundPlugin.config(config.backGround.config);
	            self.backGroundPlugin.visible(false);
	            self.backGroundPlugin.update();
	        }
	        if(config.main && self.mainPlugin) {
	            self.mainPlugin.ownerData(self.ownerData());
	            self.mainPlugin.config(config.main.config);
	            self.mainPlugin.update();
	        }
	        
	        var x = self.mainPlugin?self.mainPlugin.getBBox().x:0;
	        var y = self.mainPlugin?self.mainPlugin.getBBox().y:0;
	        var bw = self.backGroundPlugin?self.backGroundPlugin.actualWidth():0;
	        var mw = self.mainPlugin ? self.mainPlugin.actualWidth() : 0;
	        var width = bw>mw?bw:mw;
	        var bh = self.backGroundPlugin?self.backGroundPlugin.actualHeight():0;
	        var mh = self.mainPlugin ? self.mainPlugin.actualHeight() : 0;
	        var height = bh>mh?bh:mh;
	        self.resetBBox(x, y, width, height);
	        
	    	if(config.label && self.labelContainer) {
	    		self.labelPlugin.config(config.label.config);
	    		self.labelPlugin.update();
	    		labelLayout();
	    	}
	
	        self.plugins.forEach(function(d,i){
	            d.render();
	        });
	    }
	    //override
	    this.drawPlugin = function(g){
	        // if(!window.drawPluginnode){
	        //     window.drawPluginnode=1;
	        // }
	        // window.drawPluginnode=window.drawPluginnode+1;
	        // console.log("drawPluginnode:"+window.drawPluginnode);
	        superDrawPluginFunction(g);
	        g.attr("style","cursor:pointer;")
	        if(self.data().data && self.data().data.config)
	            self.config(self.data().data.config);
	        var config = self.config();
	
	        self.boundType(config.boundType);
	        if(config.backGround) {
	        	self.backGroundPlugin = ClassFactory.newPluginInstance(config.backGround.clazz,[g,self.data()]);
	            self.backGroundPlugin.config(config.backGround.config);
	            self.backGroundPlugin.visible(false);
	            self.backGroundPlugin.render();
	        }
	        if(config.main) {
	            
	        	self.mainPlugin = ClassFactory.newPluginInstance(config.main.clazz,[g,self.data()]);
	        	self.mainPlugin.ownerData(self.ownerData());
	            self.mainPlugin.config(config.main.config);
	            self.mainPlugin.render();
	        }
	        
	        var x = self.mainPlugin?self.mainPlugin.getBBox().x:0;
	        var y = self.mainPlugin?self.mainPlugin.getBBox().y:0;
	        var bw = self.backGroundPlugin?self.backGroundPlugin.actualWidth():0;
	        var mw = self.mainPlugin ? self.mainPlugin.actualWidth() : 0;
	        var width = bw>mw?bw:mw;
	        var bh = self.backGroundPlugin?self.backGroundPlugin.actualHeight():0;
	        var mh = self.mainPlugin ? self.mainPlugin.actualHeight() : 0;
	        var height = bh>mh?bh:mh;
	        self.resetBBox(x, y, width, height);
	
	        if(config.label) {
		        self.labelContainer = g.append("svg:g");
	            self.labelPlugin = ClassFactory.newPluginInstance(config.label.clazz,[self.labelContainer,self.data()]);
	            self.labelPlugin.config(config.label.config);
	            self.labelPlugin.render();
	    
	            labelLayout();
	        }
	
	        var plugins = config.plugins;
	        if(plugins && plugins.length>0){
	            plugins.forEach(function(d,i){
	                //!d.render ||
	                if(d.render==undefined || RegexUtil.replace(RegexUtil.dataRegex,d.render,self.data())=="true"){
	
	                    var plugin = ClassFactory.newPluginInstance(d.clazz,[g,self.data()]);
	                    plugin.config(d.config);
	                    plugin.render();
	                    // if(d.events){
	                    //     d.events.forEach(function(e){
	                    //         plugin.addEventListener(e,function(event){
	                    //             self.dispatch.call(e,this,new BaseEvent(self,{collapsed:event.data.collapsed,node:self.data()}));
	                    //         });
	                    //     });
	                    // }
	                    self.plugins.push(plugin);
	                    pluginLayout(plugin,d);
	                }
	            });
	        }
	    }
	
	    //override
	    this.bindEvents = function(g){
	        superBindEventsFunction(g);
	        g.on('mouseover', function(d) {
	        	var evt = EventUtil.createCustomEvent(BaseEvent.SHOW_TOOL_TIP, true, true);
	            d3.select(this).node().dispatchEvent(evt);
	            self.mouseOverHandler();
	        });
	        g.on('mousemove', function(d) {
	            var evt = EventUtil.createCustomEvent(BaseEvent.UPDATE_TOOL_TIP, true, true, d);
	            d3.select(this).node().dispatchEvent(evt);
	        });
	        g.on('mouseout', function(d) {
	        	var evt = EventUtil.createCustomEvent(BaseEvent.HIDE_TOOL_TIP, true, true);
	            d3.select(this).node().dispatchEvent(evt);
	            self.mouseOutHandler();
	        });
	        g.on('click', function(d) {
	        	var evt = EventUtil.createCustomEvent(BaseEvent.NODE_CLICK, true, true, d);
	            d3.select(this).node().dispatchEvent(evt);
	            // self.selected(!_selected);
	           });
	        g.on("dblclick.node",function(d){
	            if(self.config().events)
	                self.el.node().dispatchEvent(EventUtil.createCustomEvent(self.config().events,true,true,d));
	        });
	        self.dispatch.on("selectedChange."+self.nameSpace(),function(e){
	            self.selectedChange(e.data.selected);
	        });
	    }
	    
	    function pluginLayout(plugin,d){
	        var xPos = d.xPos,yPos = d.yPos,x=0,y=0;
	        var w = self.actualWidth(),
	            h  = self.actualHeight(),
	            rh = plugin.actualHeight(),
	            rw = plugin.actualWidth();
	        if(xPos=="left")x=-w/2-rw;
	        else if(xPos=="right")x=w/2;
	        else if(yPos=="top")y=-h/2-rh;
	        else if(yPos=="middle")y=0;
	        else if(yPos=="bottom")y=h/2;
	        plugin.transform("translate(" + [x,y] + ")");
	    }
	    
	    function labelLayout(){
	        var config = self.config();
	        var position = RegexUtil.replace(RegexUtil.dataRegex,config.label.position,self.data());
	        var rotate = RegexUtil.replace(RegexUtil.dataRegex,config.label.rotate,self.data());
	        var gap = RegexUtil.replace(RegexUtil.dataRegex,config.label.gap,self.data());
	        if(!position)position = 'bottom';
	        if(isNaN(gap))gap = 10;
	        var w = self.actualWidth(),
	            h  = self.actualHeight(),
	            rh = self.labelPlugin.actualHeight(),
	            rw = self.labelPlugin.actualWidth(),
	            point = [0,0];
	        if(position == 'top')
	            point = [-rw/2,(-h/2-rh-gap)];
	        else if(position == 'bottom')
	            point = [-rw/2,(h/2+gap)];
	        else if(position == 'left')
	            point = [(-rw-w/2),-rh/2];
	        else if(position == 'right')
	            point = [w/2,-rh/2];
	        else if(position == 'center')
	            point = [-rw/2,-rh/2];
	        else if(position == 'start')
	            point = [(-rw-w/2),-rh/2]
	        else if(position == 'end')
	            point = [w/2,-rh/2]
	        self.labelPlugin.transform("translate(" + point + ")");
	        self.labelContainer.attr("transform","rotate(" + rotate + ")");
	    }
	};
	
	Node.struct = function(ghca_charts) {
	    var Plugin = ghca_charts.view.elements.plugins.plugin;
	    Plugin.struct(ghca_charts);
	    Node.prototype = Object.create(Plugin.prototype);
	    Node.prototype.constructor = Node;
	};
	module.exports = Node;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {var PackNode = function (_element,_data,_parent) {
		
		// --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const ElementUtil = ghca_charts.view.util.elementUtil;
	    const ObjectUtil = ghca_charts.view.util.objectUtil;
	    const PackLabel = ghca_charts.view.elements.plugins.label.packLabel;
	    const BaseNode = ghca_charts.view.elements.plugins.nodes.baseNode;
	
	    BaseNode.apply(this,arguments);
	    
	    var self = this;
	    var arc, isPlayAnimation = false;
	    var defaulfConfig = {
	        clazz:'packNode',
	        //默认连线的颜色、类型属性等配置项
	        clazzProperties:{cornerRadius:0, padAngle:0, animation:true, labelPos:"inner"},
	        labelProperties:{'font-size':'0.8em',"pointer-events":"none", text:"{#d.name#}"},
	        //用户更改颜色连线的类型属性配置项
	        useProperties:{}
	    };
	    
		//--------------------------------------------------------------------------
	    //
	    //  Attributes
	    //
	    //--------------------------------------------------------------------------
	    
	    // ------------------------------
	    // parent
	    // ------------------------------
	
	    /**
	     * 父组件,baseChart实例
	     */
	    this.parent = function(value) {
	        return _parent;
	    };
	    
	    // ------------------------------
	    // startAngle
	    // ------------------------------
	
	    /**
	     * 开始弧度
	     */
	    var startAngle = 0;
	    this.startAngle = function(value) {
	        if (!arguments.length)
	            return startAngle;
	        startAngle = value;
	        return this;
	    };
	
	    // ------------------------------
	    // endAngle
	    // ------------------------------
	
	    /**
	     * 结束弧度
	     */
	    var endAngle = Math.PI * 2;
	    this.endAngle = function(value) {
	        if (!arguments.length)
	            return endAngle;
	        endAngle = value;
	        return this;
	    };
	
	    // ------------------------------
	    // cornerRadius
	    // ------------------------------
	
	    /**
	     * 弧圆角
	     */
	    var cornerRadius = 0;
	    this.cornerRadius = function(value) {
	        if (!arguments.length)
	            return cornerRadius;
	        cornerRadius = value;
	        return this;
	    };
	
	    // ------------------------------
	    // padAngle
	    // ------------------------------
	
	    /**
	     * 弧间隔
	     */
	    var padAngle = 0;
	    this.padAngle = function(value) {
	        if (!arguments.length)
	            return padAngle;
	        padAngle = value;
	        return this;
	    };
	    
	    // ------------------------------
	    // arcRadius
	    // ------------------------------
	
	    /**
	     * 弧半径百分比(0-1)
	     */
	    var arcRadiusPercent = 0;
	    this.arcRadiusPercent = function(value) {
	        if (!arguments.length)
	            return arcRadiusPercent;
	        arcRadiusPercent = value;
	        return this;
	    };
	    
	    // ------------------------------
	    // title
	    // ------------------------------
	
	    /**
	     * path元素的title内容字符串
	     */
	    var title = null;
	    this.title = function(value) {
	        if (!arguments.length)
	            return title;
	        title = value;
	        return this;
	    };
	
	    // ------------------------------
	    // titleFunction
	    // ------------------------------
	
	    /**
	     * title生成规则方法，若注册该方法，则按该方法返回的内容显示title，忽略title属性
	     */
	    var titleFunction = null;
	    this.titleFunction = function(value) {
	        if (!arguments.length)
	            return titleFunction;
	        titleFunction = value;
	        return this;
	    };
	    
	    // ------------------------------
	    // labelPos
	    // ------------------------------
	
	    /**
	     * 标签类型，outer|inner|innerRing(默认innerRing)
	     */
	    var labelPos = "innerRing";
	    this.labelPos = function(value) {
	        if (!arguments.length)
	            return labelPos;
	        labelPos = value;
	        return this;
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // public Methods
	    //
	    // --------------------------------------------------------------------------
	
	//    //override
	//    this.data = function(){
	//        return _data.data.data;
	//    }
	
	    //override
	    this.nameSpace = function(){
	        return "packNode";
	    }
	    
	    //override
	    this.setLegendColor = function(d) {
	    	var data = d ? d : self.data();
	        if(data.data && data.data.legendColor){
	            ElementUtil.setElementProperties(self.mainElement,{"fill":data.data.legendColor});
	        }
	    }
	    
	    //override
	    this.drawPlugin = function(g){
	    	if(!self.mainElemet) {
	    		if(!self.data().data.data) {
	    			self.data().data.data = ObjectUtil.cloneObj(defaulfConfig);
	    		}
	    		
	    		var nodeData = self.data().data.data.clazzProperties;
	    		self.refreshData(nodeData);
	    		
	    		self.mainElement = g.append("path")
	        		.attr("id", function(d) {
	                    return self.graph().getCustomId("pack-node-", d.data.id);
	                })
	            self.transform("translate(" + self.parent().xScale()(self.data().data.x) + "," + self.parent().yScale()(self.data().data.y) + ")");
	    		self.data().innerRadius = self.data().outerRadius * (1 - getArcRadiusPercent(self.data().data));
	    		var scaleK = self.parent().scaleK();
	    		arc = d3.arc()
	                .innerRadius(scaleK * self.data().innerRadius)
	                .outerRadius(scaleK * self.data().outerRadius)
	                .cornerRadius(self.cornerRadius())
	                .padAngle(self.padAngle());
	
	            ElementUtil.setElementProperties(self.mainElement, nodeData);
	            self.setLegendColor();
	            
	            //title
	            if(self.titleFunction()) {
	                self.mainElement.append("title").attr("class", "path-title").text(self.titleFunction());
	            } else if(self.title()) {
	                self.mainElement.append("title").attr("class", "path-title").text(self.formatStr(self.title()));
	            }
	            
	            //arc
	            var transition;
	            if(self.isChartFirstInit()) {
	            	transition = d3.transition().duration(self.animation() ? 1000 : 0).ease(d3.easeExpOut);
	                self.mainElement
	                    .attr("transform", "rotate(-179)scale(0.5)")
	                    .transition(transition)
	                    .attr("transform", "rotate(0)scale(1)")
	                    .on("start", function() {
	                        isPlayAnimation = true;
	                    })
	                    .on("end", function() {
	                        isPlayAnimation = false;
	                    })
	                    .attr("d", function(d){return arc(d);});
	                    
	            } else {
	            	transition = d3.transition().duration(self.animation() ? 500 : 0).ease(d3.easeExpOut);
	                self.mainElement
	                    .transition(transition)
	                    .on("start", function() {
	                        isPlayAnimation = true;
	                    })
	                    .on("end", function() {
	                        isPlayAnimation = false;
	                    })
	                    .attr("d", function(d){return arc(d);});
	            }
	            
	            //clip
	            var labelPos = self.labelPos();
	            if(labelPos === "outer") {
	                
	            } else if(labelPos === "innerRing") {
	            	self.defsCon = d3.select(self.mainElement.node().parentNode.parentNode.parentNode);
	            	var fontSize = getFontSize(self.data().data);
	            	var radius =  scaleK * self.data().outerRadius + fontSize/2 - 4;
	            	var pathArc = d3.arc()
	                    .startAngle(-Math.PI)
	                    .endAngle(Math.PI)
	//                    .innerRadius(radius)
	                    .outerRadius(radius)
	                    .padAngle(self.padAngle() + 0.02);
	                var defs = self.defsCon.select("defs").node() === null ? self.defsCon.append("defs") : self.defsCon.select("defs");
	            	var id = self.graph().getCustomId("#pack-node-path-", self.data().data.id);
	                var path = defs.select(id);
	                if(path.node() === null) {
	                    path = defs.append("path").attr("id", self.graph().getCustomId("pack-node-path-", self.data().data.id));
	                }
	                path.attr("d", pathArc(self.data().data));
	            } else {//inner
	            	g.append("clipPath")
	                    .attr("id", function(d) {
	                        return self.graph().getCustomId("pack-node-clip-", d.data.id);
	                    })
	                    .append("use").attr("xlink:href", function(d) {
	                        return self.graph().getCustomId("#pack-node-", d.data.id);
	                    });
	                g.attr("clip-path", function(d) {
	                    return "url(#" + self.graph().getCustomId("pack-node-clip", d.data.id) + ")";
	                });
	            }
	            
	            //label
	            if(self.data().data.data.labelProperties) {
	            	refreshArc();
	            	var labelCon = labelPos === "outer" ? d3.select(g.node().parentNode.parentNode) : g;
	            	self.label = new PackLabel(labelCon.append("g").attr("id", self.graph().getCustomId("labelCon_", self.data().data.id)), self.data().data, transition);
	                self.label.isChartFirstInit(self.isChartFirstInit());
	                self.label.graph(self.graph());
	                self.label.scaleK(scaleK);
	                self.label.render();
	                
	                //outer
	                if(labelPos === "outer" && !self.polyline) {
	                    self.polyline = labelCon.append("polyline").datum(self.data().data)
	                        .attr("id", self.graph().getCustomId("polyline_", self.data().data.id))
	                        .attr("opacity", 0.5)
	                        .attr("stroke", function(d) {
	                            return d.hasOwnProperty("legendColor") ? d.legendColor : "#000";
	                        })
	                        .attr("stroke-width", "1.5px")
	                        .attr("fill", "none");
	                
	                    self.polyline
	                        .transition(transition)
	                        .attrTween("points", polylineRenderTween);
	                }
	            }
	    	}
	    };
	    
	    //override
	    this.update = function() {
	    	if(!self.data().data.data) {
	    		return;
	    	}
	    	var ud = arguments[0] ? arguments[0] : self.data();
	    	var transition = self.el.transition().duration(self.animation() ? 500 : 0).ease(d3.easeExpOut);
	    	var scaleK = self.parent().scaleK();
	        if(self.mainElement) {
	        	self.mainElement.datum(self.data());
	        	var nodeData = self.data().data.data.clazzProperties;
	            self.refreshData(nodeData);
	            
	            transition.attr("transform", function(){
	                return "translate(" + self.parent().xScale()(ud.data.x) + "," + self.parent().yScale()(ud.data.y) + ")";
	            });
	            ud.innerRadius = ud.outerRadius * (1 - getArcRadiusPercent(ud.data));
	        	arc = d3.arc()
	                .innerRadius(scaleK * ud.innerRadius)
	                .outerRadius(scaleK * ud.outerRadius)
	                .cornerRadius(self.cornerRadius())
	                .padAngle(self.padAngle());
	
	            ElementUtil.setElementProperties(self.mainElement, nodeData);
	            self.setLegendColor(ud);
	            //title
	            if(self.titleFunction()) {
	                self.mainElement.select("title.path-title").text(self.titleFunction());
	            } else if(self.title()) {
	                self.mainElement.select("title.path-title").text(self.formatStr(self.title()));
	            }
	            
	            self.selectedChange(false);
	            
	            self.mainElement
	                .transition(transition)
	                .on("start", function() {
	                    isPlayAnimation = true;
	                })
	                .on("end", function() {
	                    isPlayAnimation = false;
	                })
	                .attr("d", function(d){return arc(d);});
	        }
	        //label
	        if(self.label) {
	            refreshArc(ud);
	            self.label.data(ud.data);
	            self.label.scaleK(scaleK);
	            self.label.update(transition);
	            //outer
	            if(self.labelPos() === "outer") {
	            	if(!self.polyline) {
	            		self.polyline = self.mainContainer().append("polyline").attr("id", self.graph().getCustomId("polyline_", ud.data.id));
	            	}
	                self.polyline.datum(ud.data)
	                    .attr("opacity", 0.5)
	                    .attr("stroke", function(d) {
	                        return d.hasOwnProperty("legendColor") ? d.legendColor : "#000";
	                    })
	                    .attr("stroke-width", "1.5px")
	                    .attr("fill", "none")
	                    .transition(transition)
	                    .attrTween("points", polylineUpdateTween);
	                    
	                self.defsCon = d3.select(self.mainElement.node().parentNode.parentNode.parentNode);
	                self.defsCon.select("defs").remove();
	            } else if(self.labelPos() === "innerRing") {
	                self.defsCon = d3.select(self.mainElement.node().parentNode.parentNode.parentNode);
	                var fontSize = getFontSize(ud.data);
	                var radius =  scaleK * ud.outerRadius + fontSize/2 - 4;
	                var pathArc = d3.arc()
	                    .startAngle(-Math.PI)
	                    .endAngle(Math.PI)
	//                    .innerRadius(radius)
	                    .outerRadius(radius)
	                    .padAngle(self.padAngle()+0.02);
	                var defs = self.defsCon.select("defs").node() === null ? self.defsCon.append("defs") : self.defsCon.select("defs");
	                var id = self.graph().getCustomId("#pack-node-path-", ud.data.id);
	                var path = defs.select(id);
	                if(path.node() === null) {
	                	path = defs.append("path").attr("id", self.graph().getCustomId("pack-node-path-", ud.data.id));
	                }
	                path.attr("d", pathArc(ud.data));
	                    
	                if(self.polyline) {
	                    self.polyline.remove();
	                    self.polyline = null;
	                }
	            } else {
	            	if(self.polyline) {
	            		self.polyline.remove();
	            		self.polyline = null;
	            	}
	            }
	        }
	    };
	
	    //override
	    this.mouseOverHandler = function() {
	    	var nodeData = self.data().data.data.clazzProperties;
	        ElementUtil.setElementProperties(self.mainElement, {stroke:nodeData.overStroke});
	    }
	    //override
	    this.mouseOutHandler = function() {
	    	var nodeData = self.data().data.data.clazzProperties;
	    	ElementUtil.setElementProperties(self.mainElement, {stroke:nodeData.stroke});
	    }
	
	    //override
	    this.selectedChange = function(seleced) {
	    }
	
	    /**
	     * 刷新传入配置数据到相应参数的方法
	     * @param data 配置数据
	     */
	    this.refreshData = function(data) {
	        if(data) {
	            for(var key in data) {
	                if(this.hasOwnProperty(key)) {
	                    this[key](data[key]);
	                }
	            }
	        }
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // priavte Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    var refreshArc = function(ud) {
	    	var ud = arguments[0] ? arguments[0] : self.data();
	    	if(self.labelPos() === "outer") {
	    		var ir = ud.innerRadius;
	    		var or = ud.outerRadius;
	            var distance = or * 0.2;
	            distance = distance < 10 ? 10 : (distance > 20 ? 20 : distance);
	            var outerArc1 = d3.arc().innerRadius(ir).outerRadius(or);
	            var outerArcRadius = or + distance;
	            var outerArc2 = d3.arc().innerRadius(outerArcRadius).outerRadius(outerArcRadius);
	            ud.data.outerArc1 = outerArc1;
	            ud.data.outerArc2 = outerArc2;
	            ud.data.lineSize = self.parent().layout().radius();
	    	} else {
	    		ud.data.arc = arc;
	    	}
	    }
	
	    var midAngle = function (d){
	        return d.startAngle + (d.endAngle - d.startAngle) / 2;
	    };
	    
	    var polylineRenderTween = function(d) {
	        this._current = this._current || d;
	        var interpolate = d3.interpolate({startAngle:this._current.startAngle, endAngle:this._current.endAngle}, d);
	        this._current = interpolate(0);
	        var outerArc1 = d.outerArc1;
	        var outerArc2 = d.outerArc2;
	        return function(t) {
	            var d2 = interpolate(t);
	            var startP = outerArc1.centroid(d2);
	            var centerP = outerArc2.centroid(d2);
	            var endP = outerArc2.centroid(d2);
	            centerP[1] = (centerP[1] - startP[1]) * t + startP[1];
	            endP[1] = (endP[1] - startP[1]) * t + startP[1];
	            endP[0] += d.lineSize * (midAngle(d2) < Math.PI ? 1 : -1);
	            return [startP, centerP, endP];
	        };          
	    };
	    
	    var polylineUpdateTween = function(d) {
	        this._current = this._current || d;
	        var interpolate = d3.interpolate({startAngle:this._current.startAngle, endAngle:this._current.endAngle}, d);
	        this._current = interpolate(0);
	        var outerArc1 = d.outerArc1;
	        var outerArc2 = d.outerArc2;
	        return function(t) {
	            var d2 = interpolate(t);
	            var pos = outerArc2.centroid(d2);
	            pos[0] += d.lineSize * (midAngle(d2) < Math.PI ? 1 : -1);
	            return [outerArc1.centroid(d2), outerArc2.centroid(d2), pos];
	        };        
	    };
	    
	    var getFontSize = function(d) {
	    	var fontSize = (d["fontSize"] || d["font-size"]);
	        if(ObjectUtil.isString(fontSize)) {
	            fontSize = parseInt(fontSize.split("px")[0]);
	        }
	        if(isNaN(fontSize)) {
	            fontSize = 12;
	        }
	        return fontSize;
	    };
	    
	    var getArcRadiusPercent = function(data) {
	         var percent = ObjectUtil.isString(self.arcRadiusPercent()) ? 
	           self.formatStr(self.arcRadiusPercent())(data) : self.arcRadiusPercent();
	         percent = parseFloat(percent);
	         if(isNaN(percent)) {
	         	percent = 0;
	         } else if(percent > 1) {
	         	percent = 1;
	         } else if(percent < 0) {
	            percent = 0;
	         }
	         return percent;
	    };
	};
	
	PackNode.struct = function(ghca_charts) {
		var BaseNode = ghca_charts.view.elements.plugins.nodes.baseNode;
		BaseNode.struct(ghca_charts);
	    PackNode.prototype = Object.create(BaseNode.prototype);
	    PackNode.prototype.constructor = BaseNode;
	};
	
	module.exports = PackNode;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 98 */
/***/ (function(module, exports) {

	var PathNode = function (_element,_data) {
		
		// --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const Plugin = ghca_charts.view.elements.plugins.plugin;
	    const PathElement = ghca_charts.view.elements.pathElement;
	    const ObjectUtil = ghca_charts.view.util.objectUtil;
	    const RegexUtil = ghca_charts.view.util.regexUtil;
	    const ClassFactory = ghca_charts.view.util.classFactory;
	    const Label = ghca_charts.view.elements.plugins.label.label;
	
	    Plugin.apply(this,arguments);
	    var self = this,
	        pathElement = _element,
	        groupElement = null,
	        label1 = null,
	        label2 = null,
	        nodesIns = [];
	
	    self.config({
	        lineLength:100,
	        nodePadding:10,
	        border:2,
	        borderColor:"black",
	        linecap:"butt"
	    });
	
	    //override
	    this.actualWidth = function(){
	       return pathElement ? pathElement.svgElement.node().getBBox().width : 0;
	    }
	    //override
	    this.actualHeight = function(){
	        return pathElement ? pathElement.svgElement.node().getBBox().height : 0;
	    }
	
	    //override
	    this.nameSpace = function(){
	        return "pathNode";
	    }
	    //override
	    this.update = function(g){
	    	var startX = 0, config = self.config();
	    	if(pathElement) {
	    		startX = refreshPath(config);
	    		pathElement.data(config);
	    		if(groupElement) {
	    			groupElement.attr("transform", "translate(" + [startX+config.nodePadding, -48/2-2] + ")");
	    		}
	    	}
	    	if(label1) {
	            label1.data(config.label1);
	            label1.el.attr("transform", "translate(" + [startX + 10,6] + ")");
	        }
	        if(label2) {
	            label2.data(config.label2);
	            var box = label2.el.node().getBBox();
	            label2.el.attr("transform", "translate(" + [startX + (self.actualWidth()-box.width)/2,6] + ")");
	        }
	    }
	    //override
	    this.drawPlugin = function(g){
	        var config = ObjectUtil.cloneObj(self.config());
	        config.color = RegexUtil.replace(RegexUtil.dataRegex,config.color,self.data());
	        config.borderColor = RegexUtil.replace(RegexUtil.dataRegex,config.borderColor,self.data());
	        var startX = refreshPath(config);
	        pathElement = new PathElement(g,config);
	        pathElement.render();
	        
	        groupElement = g.append("g");
	        groupElement.attr("transform", "translate(" + [startX+config.nodePadding, -48/2-2] + ")");
	        
	        label1 = new Label(g,self.data());
	        label1.config(config.label1);
	        label1.render();
	        label1.el.attr("transform", "translate(" + [startX + 10,6] + ")");
	        
	        label2 = new Label(g,self.data());
	        label2.config(config.label2);
	        label2.render();
	        var box = label2.el.node().getBBox();
	        label2.el.attr("transform", "translate(" + [startX + (self.actualWidth()-box.width)/2,6] + ")");
	        
	        var nodes = _data.data && _data.data.hasOwnProperty("nodes") ? _data.data.nodes : null;
	        if(nodes && nodes.length > 0) {
	        	for(var nodeData, i = 0, len = nodes.length; i < len; i++) {
	        		nodeData = nodes[i];
	        		var rendererConfig;
	                //获取节点渲染器配置
	                if(nodeData.nodeRenderer && self.ownerData()) {
	                    rendererConfig = self.ownerData().renderers[nodeData.nodeRenderer];
	                }
	
	                var nodeIns = ClassFactory.newNodeInstance(rendererConfig.clazz, [groupElement, nodeData]);
	                nodeIns.config(rendererConfig.config);
	                nodeIns.render();
	                nodeIns.el.attr("transform", "translate(" + [i*(48+30), 0] + ")");
	                nodeData.ins = nodeIns;
	                nodesIns.push(nodeIns);
	        	}
	        }
	    }
	    
	    var refreshPath = function(config) {
	    	var lineLength = RegexUtil.replace(RegexUtil.dataRegex,config.lineLength,self.data());
	        if(isNaN(lineLength)) {
	            lineLength = 100;
	        }
	        var targetX = self.data().x;
	        var sourceX = self.data().parent.x;
	        var startX = (sourceX - targetX) / 2;
	        var endX = startX + lineLength;
	        config.path = "M" + startX + " 0L " + endX + " 0";
	        return startX;
	    }
	};
	
	PathNode.struct = function(ghca_charts) {
		var Plugin = ghca_charts.view.elements.plugins.plugin;
		Plugin.struct(ghca_charts);
	    PathNode.prototype = Object.create(Plugin.prototype);
	    PathNode.prototype.constructor = PathNode;
	};
	
	module.exports = PathNode;

/***/ }),
/* 99 */
/***/ (function(module, exports) {

	var Rect = function (_element,_data) {
		
		// --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const Plugin = ghca_charts.view.elements.plugins.plugin;
	    const RectElement = ghca_charts.view.elements.rectElement;
	    const ObjectUtil = ghca_charts.view.util.objectUtil;
	    const RegexUtil = ghca_charts.view.util.regexUtil;
	
	    Plugin.apply(this,arguments);
	    
	    var self = this,
	        rectElement = _element;
	
	    self.config({
	        x:0,
	        y:0,
	        width:100,
	        height:10,
	        border:1,
	        borderColor:"green",
	        linecap:"butt",
	        color:"red"
	    });
	
	
	//    //override
	//    this.actualWidth = function(){
	//       return parseFloat(RegexUtil.replace(RegexUtil.dataRegex,self.config().width,self.data()));
	//    }
	//    //override
	//    this.actualHeight = function(){
	//        return parseFloat(RegexUtil.replace(RegexUtil.dataRegex,self.config().height,self.data()));
	//    }
	
	    //override
	    this.nameSpace = function(){
	        return "rect";
	    }
	    //override
	    this.update = function(g){
	    	var config = ObjectUtil.cloneObj(self.config());
	    	var data = self.data();
	    	config.color = RegexUtil.replace(RegexUtil.dataRegex,config.color,data);
	        config.borderColor = RegexUtil.replace(RegexUtil.dataRegex,config.borderColor,data);
	        config.x = 0;
	        config.y = 0;
	        config.width = RegexUtil.replace(RegexUtil.dataRegex,config.width,data);
	        config.height = RegexUtil.replace(RegexUtil.dataRegex,config.height,data);
	        rectElement.data(self.config());
	        self.resetBBox(config.x, config.y, config.width, config.height);
	    }
	    //override
	    this.drawPlugin = function(g){
	        var config = ObjectUtil.cloneObj(self.config());
	        var data = self.data();
	        config.color = RegexUtil.replace(RegexUtil.dataRegex,config.color,data);
	        config.borderColor = RegexUtil.replace(RegexUtil.dataRegex,config.borderColor,data);
	        config.x = 0;
	        config.y = 0;
	        config.width = RegexUtil.replace(RegexUtil.dataRegex,config.width,data);
	        config.height = RegexUtil.replace(RegexUtil.dataRegex,config.height,data);
	        rectElement = new RectElement(g,config);
	        rectElement.render();
	        self.resetBBox(config.x, config.y, config.width, config.height);
	    }
	};
	
	Rect.struct = function(ghca_charts) {
		var Plugin = ghca_charts.view.elements.plugins.plugin;
		Plugin.struct(ghca_charts);
	    Rect.prototype = Object.create(Plugin.prototype);
	    Rect.prototype.constructor = Rect;
	};
	
	module.exports = Rect;

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {var SankeyNode = function (_element,_data) {
		
		// --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const ElementUtil = ghca_charts.view.util.elementUtil;
	    const BaseLabel = ghca_charts.view.elements.plugins.label.baseLabel;
	    const ColorUtil = ghca_charts.view.util.colorUtil;
	    const BaseNode = ghca_charts.view.elements.plugins.nodes.baseNode;
	
	    BaseNode.apply(this,arguments);
	    
	    var self = this;
	        
	    //--------------------------------------------------------------------------
	    //
	    //  Attributes
	    //
	    //--------------------------------------------------------------------------
	    
	    // ------------------------------
	    // isDragable
	    // ------------------------------
	
	    /**
	     * 节点是否可拖动
	     */
	    var isDragable = false;
	    this.isDragable = function(value) {
	        if (!arguments.length)
	            return isDragable;
	        isDragable = value;
	        return this;
	    };
	    
	    //--------------------------------------------------------------------------
	    //
	    //  public Methods
	    //
	    //--------------------------------------------------------------------------
	    
	    //override
	    this.nameSpace = function(){
	        return "sankeyNode";
	    }
	    //override
	    this.data = function(){
	        return _data.data;
	    }
	
	    //override
	    this.setLegendColor = function(){
	        if(_data && _data.legendColor){
	            ElementUtil.setElementProperties(self.mainElement,{"fill":_data.legendColor});
	        }
	    }
	    //override
	    this.mouseOverHandler = function() {
	    	var color = _data.legendColor ? _data.legendColor : ColorUtil.getColor(0);
	    	self.mainElement
	        	.attr("stroke-width", 1)
	        	.attr("stroke", function(d) { return d3.rgb(color).darker(3); });
	    }
	    //override
	    this.mouseOutHandler = function() {
	    	var color = _data.legendColor ? _data.legendColor : ColorUtil.getColor(0);
	    	self.mainElement
	        	.attr("stroke-width", 1)
	        	.attr("stroke", function(d) { return d3.rgb(color).darker(1); });
	    }
	
	    //override
	    this.selectedChange = function(seleced) {
	    }
	    //override
	    this.drawPlugin = function(g){
	    	self.mainElement = ElementUtil.createRect(g, self.data().rectProperties);
	        var color = _data.legendColor ? _data.legendColor : ColorUtil.getColor(0);
	        var cursorStyle = self.isDragable() ? "move" : "default";
	        var duration = self.animation() ? 300 : 0;
	        self.mainElement
	            .style("cursor", cursorStyle)
	            .style("fill-opacity", 1)
	            .style("fill", function(d) { return color; })
	            .attr("height", function(d) { return d.dy; })
	            .attr("stroke", function(d) { return d3.rgb(color).darker(1); })
	            .style("transform", "scale(0,1)")
	            .transition().duration(duration).ease(d3.easeLinear)
	                .delay(function(d){
	                    return d.level * (duration - 10);
	                })
	                .style("transform", "scale(1,1)");
	            
	        self.setLegendColor();
	    }
	};
	
	SankeyNode.struct = function(ghca_charts) {
		var BaseNode = ghca_charts.view.elements.plugins.nodes.baseNode;
		BaseNode.struct(ghca_charts);
	    SankeyNode.prototype = Object.create(BaseNode.prototype);
	    SankeyNode.prototype.constructor = SankeyNode;
	};
	
	module.exports = SankeyNode;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {var SunburstNode = function (_element,_data,_parent) {
		
		// --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const ElementUtil = ghca_charts.view.util.elementUtil;
	    const ObjectUtil = ghca_charts.view.util.objectUtil;
	    const PieLabel = ghca_charts.view.elements.plugins.label.pieLabel;
	    const BaseNode = ghca_charts.view.elements.plugins.nodes.baseNode;
	
	    BaseNode.apply(this,arguments);
	    
	    var self = this;
	    var arc, isPlayAnimation = false;
	    var defaulfConfig = {
	        clazz:'sunburstNode',
	        //默认连线的颜色、类型属性等配置项
	        clazzProperties:{cornerRadius:0, padAngle:0, animation:true, labelPos:"inner"},
	        labelProperties:{'font-size':'0.8em',"pointer-events":"none", text:"{#d.name#}"},
	        //用户更改颜色连线的类型属性配置项
	        useProperties:{}
	    };
	    
		//--------------------------------------------------------------------------
	    //
	    //  Attributes
	    //
	    //--------------------------------------------------------------------------
	    
	    // ------------------------------
	    // parent
	    // ------------------------------
	
	    /**
	     * 父组件,baseChart实例
	     */
	    this.parent = function(value) {
	        return _parent;
	    };
	    
	    // ------------------------------
	    // startAngle
	    // ------------------------------
	
	    /**
	     * 开始弧度
	     */
	    var startAngle = 0;
	    this.startAngle = function(value) {
	        if (!arguments.length)
	            return startAngle;
	        startAngle = value;
	        return this;
	    };
	
	    // ------------------------------
	    // endAngle
	    // ------------------------------
	
	    /**
	     * 结束弧度
	     */
	    var endAngle = Math.PI / 2;
	    this.endAngle = function(value) {
	        if (!arguments.length)
	            return endAngle;
	        endAngle = value;
	        return this;
	    };
	
	    // ------------------------------
	    // cornerRadius
	    // ------------------------------
	
	    /**
	     * 弧圆角
	     */
	    var cornerRadius = 0;
	    this.cornerRadius = function(value) {
	        if (!arguments.length)
	            return cornerRadius;
	        cornerRadius = value;
	        return this;
	    };
	
	    // ------------------------------
	    // padAngle
	    // ------------------------------
	
	    /**
	     * 弧间隔
	     */
	    var padAngle = 0;
	    this.padAngle = function(value) {
	        if (!arguments.length)
	            return padAngle;
	        padAngle = value;
	        return this;
	    };
	
	    // ------------------------------
	    // title
	    // ------------------------------
	
	    /**
	     * path元素的title内容字符串
	     */
	    var title = null;
	    this.title = function(value) {
	        if (!arguments.length)
	            return title;
	        title = value;
	        return this;
	    };
	
	    // ------------------------------
	    // titleFunction
	    // ------------------------------
	
	    /**
	     * title生成规则方法，若注册该方法，则按该方法返回的内容显示title，忽略title属性
	     */
	    var titleFunction = null;
	    this.titleFunction = function(value) {
	        if (!arguments.length)
	            return titleFunction;
	        titleFunction = value;
	        return this;
	    };
	    
	    // ------------------------------
	    // labelPos
	    // ------------------------------
	
	    /**
	     * 标签类型，outer|inner(默认outer)
	     */
	    var labelPos = "outer";
	    this.labelPos = function(value) {
	        if (!arguments.length)
	            return labelPos;
	        labelPos = value;
	        return this;
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // public Methods
	    //
	    // --------------------------------------------------------------------------
	
	//    //override
	//    this.data = function(){
	//        return _data.data.data;
	//    }
	
	    //override
	    this.nameSpace = function(){
	        return "sunburstNode";
	    }
	    
	    //override
	    this.setLegendColor = function(d) {
	    	var data = d ? d : self.data();
	        if(data.data && data.data.legendColor){
	            ElementUtil.setElementProperties(self.mainElement,{"fill":data.data.legendColor});
	        }
	    }
	
	    //override
	    this.drawPlugin = function(g){
	    	if(!self.mainElemet) {
	    		if(!self.data().data.data) {
	    			self.data().data.data = ObjectUtil.cloneObj(defaulfConfig);
	    		}
	    		
	    		var nodeData = self.data().data.data.clazzProperties;
	    		self.refreshData(nodeData);
	    		
	    		self.mainElement = g.append("path")
	        		.attr("id", function(d) {
	                    return self.graph().getCustomId("sunburst-node-", d.data.id);
	                });
	    		
	    		arc = d3.arc()
	                .innerRadius(self.data().innerRadius)
	                .outerRadius(self.data().outerRadius)
	                .cornerRadius(self.cornerRadius())
	                .padAngle(self.padAngle());
	
	            ElementUtil.setElementProperties(self.mainElement, nodeData);
	            self.setLegendColor();
	            
	            //title
	            if(self.titleFunction()) {
	                self.mainElement.append("title").attr("class", "path-title").text(self.titleFunction());
	            } else if(self.title()) {
	                self.mainElement.append("title").attr("class", "path-title").text(self.formatStr(self.title()));
	            }
	            
	            //arc
	            var transition;
	            if(self.isChartFirstInit()) {
	            	transition = d3.transition().duration(self.animation() ? 1500 : 0).ease(d3.easeExpOut);
	                self.mainElement
	                    .attr("transform", "rotate(-179)scale(0.1)")
	                    .transition(transition)
	                    .attr("transform", "rotate(0)scale(1)")
	                    .on("start", function() {
	                        isPlayAnimation = true;
	                    })
	                    .on("end", function() {
	                        isPlayAnimation = false;
	                    })
	                    .attrTween("d", function (d) {
	                        var interpolate = d3.interpolate({startAngle:0, endAngle:d.endAngle - 0.5}, d);
	                        return function (t) {
	                            return arc(interpolate(t));
	                        };
	                    });
	                    
	            } else {
	            	transition = d3.transition().duration(self.animation() ? 500 : 0).ease(d3.easeExpOut);
	                self.mainElement
	                    .transition(transition)
	                    .on("start", function() {
	                        isPlayAnimation = true;
	                    })
	                    .on("end", function() {
	                        isPlayAnimation = false;
	                    })
	                    .attrTween("d", function (d) {
	                        var interpolate = d3.interpolate({startAngle:d.endAngle, endAngle:d.endAngle}, d);
	                        return function (t) {
	                            return arc(interpolate(t));
	                        };
	                    });
	            }
	            
	            //clip
	            var labelPos = self.labelPos();
	            if(labelPos === "outer") {
	                
	            } else if(labelPos === "innerRing" && !(self.data().innerRadius === 0 && self.data().startAngle === 0 && self.data().endAngle >= 6.283185307179586)) {
	            	self.defsCon = d3.select(self.mainElement.node().parentNode.parentNode.parentNode);
	            	var radius = (self.data().innerRadius + self.data().outerRadius - 12)/2;
	            	var pathArc = d3.arc()
	                    .innerRadius(radius)
	                    .outerRadius(radius)
	                    .padAngle(self.padAngle() + 0.02);
	                var defs = self.defsCon.select("defs").node() === null ? self.defsCon.append("defs") : self.defsCon.select("defs");
	            	var id = self.graph().getCustomId("#sunburst-node-path-", self.data().data.id);
	                var path = defs.select(id);
	                if(path.node() === null) {
	                    path = defs.append("path").attr("id", self.graph().getCustomId("sunburst-node-path-", self.data().data.id));
	                }
	                path.attr("d", pathArc(self.data().data));
	            } else {//inner
	            	g.append("clipPath")
	                    .attr("id", function(d) {
	                        return self.graph().getCustomId("sunburst-node-clip-", d.data.id);
	                    })
	                    .append("use").attr("xlink:href", function(d) {
	                        return self.graph().getCustomId("#sunburst-node-", d.data.id);
	                    });
	                g.attr("clip-path", function(d) {
	                    return "url(#" + self.graph().getCustomId("sunburst-node-clip", d.data.id) + ")";
	                });
	            }
	            
	            //label
	            if(self.data().data.data.labelProperties) {
	            	refreshArc();
	            	var labelCon = labelPos === "outer" ? d3.select(g.node().parentNode.parentNode) : g;
	            	self.label = new PieLabel(labelCon.append("g").attr("id", self.graph().getCustomId("labelCon_", self.data().data.id)), self.data().data, transition);
	                self.label.isChartFirstInit(self.isChartFirstInit());
	                self.label.graph(self.graph());
	                self.label.render();
	                
	                //outer
	                if(labelPos === "outer" && !self.polyline) {
	                    self.polyline = labelCon.append("polyline").datum(self.data().data)
	                        .attr("id", self.graph().getCustomId("polyline_", self.data().data.id))
	                        .attr("opacity", 0.5)
	                        .attr("stroke", function(d) {
	                            return d.hasOwnProperty("legendColor") ? d.legendColor : "#000";
	                        })
	                        .attr("stroke-width", "1.5px")
	                        .attr("fill", "none");
	                
	                    self.polyline
	                        .transition(transition)
	                        .attrTween("points", polylineRenderTween);
	                }
	            }
	    	}
	    };
	    
	    //override
	    this.update = function() {
	    	if(!self.data().data.data) {
	    		return;
	    	}
	    	var ud = arguments[0] ? arguments[0] : self.data();
	    	var transition = d3.transition().duration(self.animation() ? 500 : 0).ease(d3.easeExpOut);
	        if(self.mainElement) {
	        	self.mainElement.datum(self.data());
	        	var nodeData = self.data().data.data.clazzProperties;
	            self.refreshData(nodeData);
	            
	        	arc = d3.arc()
	                .innerRadius(ud.innerRadius)
	                .outerRadius(ud.outerRadius)
	                .cornerRadius(self.cornerRadius())
	                .padAngle(self.padAngle());
	
	            ElementUtil.setElementProperties(self.mainElement, nodeData);
	            self.setLegendColor(ud);
	            //title
	            if(self.titleFunction()) {
	                self.mainElement.select("title.path-title").text(self.titleFunction());
	            } else if(self.title()) {
	                self.mainElement.select("title.path-title").text(self.formatStr(self.title()));
	            }
	            
	            self.selectedChange(false);
	            
	            self.mainElement
	                .transition(transition)
	                .on("start", function() {
	                        isPlayAnimation = true;
	                    })
	                .on("end", function() {
	                    isPlayAnimation = false;
	                })
	                .attrTween("d", function(d) {
	                	this._current = this._current || ud;
	                    var interpolate = d3.interpolate({startAngle:this._current.startAngle, endAngle:this._current.endAngle}, ud);
	                    this._current = interpolate(0);
	                    return function (t) {
	                        return arc(interpolate(t));
	                    };
	                });
	        }
	        //label
	        if(self.label) {
	            refreshArc(ud);
	            self.label.data(ud.data);
	            self.label.update(transition);
	            //outer
	            if(self.labelPos() === "outer") {
	            	if(!self.polyline) {
	            		self.polyline = self.mainContainer().append("polyline").attr("id", self.graph().getCustomId("polyline_", ud.data.id));
	            	}
	                self.polyline.datum(ud.data)
	                    .attr("opacity", 0.5)
	                    .attr("stroke", function(d) {
	                        return d.hasOwnProperty("legendColor") ? d.legendColor : "#000";
	                    })
	                    .attr("stroke-width", "1.5px")
	                    .attr("fill", "none")
	                    .transition(transition)
	                    .attrTween("points", polylineUpdateTween);
	                    
	                self.defsCon = d3.select(self.mainElement.node().parentNode.parentNode.parentNode);
	                self.defsCon.select("defs").remove();
	            } else if(self.labelPos() === "innerRing" && !(ud.innerRadius === 0 && ud.startAngle === 0 && ud.endAngle >= 6.283185307179586)) {
	                self.defsCon = d3.select(self.mainElement.node().parentNode.parentNode.parentNode);
	                var radius = (ud.innerRadius + ud.outerRadius- 12)/2;
	                var pathArc = d3.arc()
	                    .innerRadius(radius)
	                    .outerRadius(radius)
	                    .padAngle(self.padAngle()+0.02);
	                var defs = self.defsCon.select("defs").node() === null ? self.defsCon.append("defs") : self.defsCon.select("defs");
	                var id = self.graph().getCustomId("#sunburst-node-path-", ud.data.id);
	                var path = defs.select(id);
	                if(path.node() === null) {
	                	path = defs.append("path").attr("id", self.graph().getCustomId("sunburst-node-path-", ud.data.id));
	                }
	                path.attr("d", pathArc(ud.data));
	                    
	                if(self.polyline) {
	                    self.polyline.remove();
	                    self.polyline = null;
	                }
	            } else {
	            	if(self.polyline) {
	            		self.polyline.remove();
	            		self.polyline = null;
	            	}
	            }
	        }
	    };
	
	    //override
	    this.mouseOverHandler = function(){
	    }
	    //override
	    this.mouseOutHandler = function(){
	    }
	
	    //override
	    this.selectedChange = function(seleced){
	    }
	
	    /**
	     * 刷新传入配置数据到相应参数的方法
	     * @param data 配置数据
	     */
	    this.refreshData = function(data) {
	        if(data) {
	            for(var key in data) {
	                if(this.hasOwnProperty(key)) {
	                    this[key](data[key]);
	                }
	            }
	        }
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // priavte Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    var refreshArc = function(ud) {
	    	var ud = arguments[0] ? arguments[0] : self.data();
	    	if(self.labelPos() === "outer") {
	    		var ir = ud.innerRadius;
	    		var or = ud.outerRadius;
	            var distance = or * 0.2;
	            distance = distance < 10 ? 10 : (distance > 20 ? 20 : distance);
	            var outerArc1 = d3.arc().innerRadius(ir).outerRadius(or);
	            var outerArcRadius = or + distance;
	            var outerArc2 = d3.arc().innerRadius(outerArcRadius).outerRadius(outerArcRadius);
	            ud.data.outerArc1 = outerArc1;
	            ud.data.outerArc2 = outerArc2;
	            ud.data.lineSize = self.parent().layout().radius();
	    	} else {
	    		ud.data.arc = arc;
	    	}
	    }
	
	    var midAngle = function (d){
	        return d.startAngle + (d.endAngle - d.startAngle) / 2;
	    };
	    
	    var polylineRenderTween = function(d) {
	        this._current = this._current || d;
	        var interpolate = d3.interpolate({startAngle:this._current.startAngle, endAngle:this._current.endAngle}, d);
	        this._current = interpolate(0);
	        var outerArc1 = d.outerArc1;
	        var outerArc2 = d.outerArc2;
	        return function(t) {
	            var d2 = interpolate(t);
	            var startP = outerArc1.centroid(d2);
	            var centerP = outerArc2.centroid(d2);
	            var endP = outerArc2.centroid(d2);
	            centerP[1] = (centerP[1] - startP[1]) * t + startP[1];
	            endP[1] = (endP[1] - startP[1]) * t + startP[1];
	            endP[0] += d.lineSize * (midAngle(d2) < Math.PI ? 1 : -1);
	            return [startP, centerP, endP];
	        };          
	    };
	    
	    var polylineUpdateTween = function(d) {
	        this._current = this._current || d;
	        var interpolate = d3.interpolate({startAngle:this._current.startAngle, endAngle:this._current.endAngle}, d);
	        this._current = interpolate(0);
	        var outerArc1 = d.outerArc1;
	        var outerArc2 = d.outerArc2;
	        return function(t) {
	            var d2 = interpolate(t);
	            var pos = outerArc2.centroid(d2);
	            pos[0] += d.lineSize * (midAngle(d2) < Math.PI ? 1 : -1);
	            return [outerArc1.centroid(d2), outerArc2.centroid(d2), pos];
	        };        
	    };
	};
	
	SunburstNode.struct = function(ghca_charts) {
		var BaseNode = ghca_charts.view.elements.plugins.nodes.baseNode;
		BaseNode.struct(ghca_charts);
	    SunburstNode.prototype = Object.create(BaseNode.prototype);
	    SunburstNode.prototype.constructor = BaseNode;
	};
	
	module.exports = SunburstNode;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 102 */
/***/ (function(module, exports) {

	var TreemapNode = function (_element,_data) {
	    
	    // --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const ElementUtil = ghca_charts.view.util.elementUtil;
	    const BaseLabel = ghca_charts.view.elements.plugins.label.baseLabel;
	    const ColorUtil = ghca_charts.view.util.colorUtil;
	    const BaseNode = ghca_charts.view.elements.plugins.nodes.baseNode;
	
	    BaseNode.apply(this,arguments);
	    
	    var self = this;
	        
	    //--------------------------------------------------------------------------
	    //
	    //  Attributes
	    //
	    //--------------------------------------------------------------------------
	    
	    // ------------------------------
	    // title
	    // ------------------------------
	
	    /**
	     * path元素的title内容字符串
	     */
	    var title = null;
	    this.title = function(value) {
	        if (!arguments.length)
	            return title;
	        title = value;
	        return this;
	    };
	
	    // ------------------------------
	    // titleFunction
	    // ------------------------------
	
	    /**
	     * title生成规则方法，若注册该方法，则按该方法返回的内容显示title，忽略title属性
	     */
	    var titleFunction = null;
	    this.titleFunction = function(value) {
	        if (!arguments.length)
	            return titleFunction;
	        titleFunction = value;
	        return this;
	    };
	
	    //--------------------------------------------------------------------------
	    //
	    //  public Methods
	    //
	    //--------------------------------------------------------------------------
	    
	    //override
	    this.nameSpace = function(){
	        return "treemapNode";
	    };
	    
	    //override
	    this.data = function(){
	        return _data.data;
	    };
	
	    //override
	    this.mouseOverHandler = function() {
	    	if(self.mainElement) {
	    		self.mainElement.attr("fill-opacity", 0.75);
	    	}
	    };
	    
	    //override
	    this.mouseOutHandler = function() {
	    	if(self.mainElement) {
	            self.mainElement.attr("fill-opacity", 1);
	        }
	    };
	
	    //override
	    this.selectedChange = function(seleced) {
	    };
	    
	    //override
	    this.drawPlugin = function(g) {
	        self.mainElement = g.append("rect");
	        self.mainElement
	            .attr("id", function(d) {
	                return d.data.id;
	            })
	            .attr("fill", function(d) {
	                return d.data &&　d.data.hasOwnProperty("legendColor") ? 
	                    d.data.legendColor : 
	                    ColorUtil.getColor(d.parent ? d.parent.data.id : "");
	            });
	        
	        //title
	        if(self.titleFunction()) {
	            self.mainElement.append("title").attr("class", "rect-title").text(self.titleFunction());
	        } else if(self.title()) {
	            self.mainElement.append("title").attr("class", "rect-title").text(self.formatStr(self.title()));
	        }
	        
	        //clip
	        g.append("clipPath")
	            .attr("id", function(d) {
	                return "treemap-node-clip-" + d.data.id;
	            })
	            .append("use").attr("xlink:href", function(d) {
	                return "#" + d.data.id;
	            });
	        g.attr("clip-path", function(d) {
	            return "url(#treemap-node-clip-" + d.data.id + ")";
	        });
	
	        self.mainElement
	            .attr("width", 0)
	            .attr("height", 0)
	            .transition().duration(self.animation() ? (self.isChartFirstInit() ? 1000 : 500) : 0)
	            .attr("width", function(d) {
	                return d.x1 - d.x0;
	            })
	            .attr("height", function(d) {
	                return d.y1 - d.y0;
	            });
	            
	        self.createLabel(g,_data);
	    };
	    
	    //override
	    this.update = function(ud) {
	    	if(self.mainElement) {
	    		self.mainElement
	        		.attr("fill", function(d) {
	                    return d.data &&　d.data.hasOwnProperty("legendColor") ? 
	                        d.data.legendColor : 
	                        ColorUtil.getColor(ud.parent ? ud.parent.data.id : "");
	                })
	    		    .transition().duration(self.animation() ? 500 : 0)
	                .attr("width", function(d) {
	                    return ud.x1 - ud.x0;
	                })
	                .attr("height", function(d) {
	                    return ud.y1 - ud.y0;
	                });
	            //title
	            if(self.titleFunction()) {
	                self.mainElement.select("title.rect-title").text(self.titleFunction());
	            } else if(self.title()) {
	                self.mainElement.select("title.rect-title").text(self.formatStr(self.title()));
	            }
	            if(self.label) {
	                var labelData = _data.data.data.label;
	                labelData.name = labelData.format ?　self.formatStr(labelData.format)(_data.data)　: _data.data.name;
	                self.label.update(labelData);
	                self.labelLayout(self.labelG, self.label, _data.data, true);
	            }
	    	}
	    };
	    
	     //override
	    this.createLabel = function(group, d) {
	        if(!d.data || !d.data.data || !d.data.data.label || d.data.name === null || d.data.name === undefined) {
	            return;
	        }
	        self.labelG = group.append("g").attr("pointer-events", "none");
	        var labelData = d.data.data.label;
	        labelData.name = labelData.format ?　self.formatStr(labelData.format)(d.data)　: d.data.name;
	        self.label =  new BaseLabel(self.labelG, labelData, self);
	        self.label.render();
	        self.labelLayout(self.labelG, self.label, d.data, false);
	    };
	    
	    //override
	    this.labelLayout = function(element, plugin, d, isUpdate) {
	    	if(!self.mainElement || !self.mainElement.node()) {
	    		return;
	    	}
	        var position = d.data.labelPosition;
	        if(!position) {
	        	position = 'center';
	        }
	        
	        var labelPosition = position.toLowerCase(),translate, tx = 0, ty = 0;
	        var labelBox = element.node().getBBox();
	        var md;
	        //这里只能从_element获取data数据，从element获取的数据是错误的
	        _element.each(function(ed) {
	            md = ed;
	        });
	        var nodeW = md.x1 - md.x0;
	        var nodeH = md.y1 - md.y0;
	        if(labelPosition == 'bottom') {
	            tx = labelBox.width / 2;
	            ty = nodeH - labelBox.height / 2;
	        } else if(labelPosition == 'left') {
	            tx = labelBox.width / 2;
	            ty = nodeH / 2;
	        } else if(labelPosition == 'right') {
	            tx = nodeW - labelBox.width / 2;
	            ty = nodeH / 2;
	        } else if(labelPosition == 'top') {
	            tx = labelBox.width / 2;
	            ty = labelBox.height / 2;
	        } else {
	            //default center
	            tx = nodeW / 2;
	            ty = nodeH / 2;
	        }
	        //水平边界判断
	        if(labelBox.width > nodeW) {
	        	tx = labelBox.width / 2;
	        }
	        if(isUpdate) {
	             element
	                .transition().duration(self.animation() ? 500 : 0)
	                .attr("transform", "translate("+tx+","+ty+")");
	        } else {
	             element
	                .transition().duration(self.animation() ? (self.isChartFirstInit() ? 1000 : 500) : 0)
	                .attr("transform", "translate("+tx+","+ty+")");
	        }
	    };
	};
	
	TreemapNode.struct = function(ghca_charts) {
	    var BaseNode = ghca_charts.view.elements.plugins.nodes.baseNode;
	    BaseNode.struct(ghca_charts);
	    TreemapNode.prototype = Object.create(BaseNode.prototype);
	    TreemapNode.prototype.constructor = TreemapNode;
	};
	
	module.exports = TreemapNode;

/***/ }),
/* 103 */
/***/ (function(module, exports) {

	var UsePlugin = function (_element,_data) {
	
	    // --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	
	    const Plugin = ghca_charts.view.elements.plugins.plugin;
	    const RegexUtil = ghca_charts.view.util.regexUtil;
	    Plugin.apply(this,arguments);
	    var self = this,
	        useElement = _element;
	
	    self.config({
	        "xlink":"#{data.image}",
	        "width":"{data.imageWidth}",
	        "height":"{data.imageHeight}"
	    });
	
	
	    //override
	    this.actualWidth = function(){
	        return RegexUtil.replace(RegexUtil.dataRegex,self.config().width,self.data());;
	    }
	    //override
	    this.actualHeight = function(){
	        return RegexUtil.replace(RegexUtil.dataRegex,self.config().height,self.data());
	    }
	
	    //override
	    this.nameSpace = function(){
	        return "usePlugin";
	    }
	    //override
	    this.update = function(g){
	        useElement.attr("xlink:href",RegexUtil.replace(RegexUtil.dataRegex,self.config().xlink,self.data()));
	    }
	    //override
	    this.drawPlugin = function(g){
	        useElement = g.append("use").attr("xlink:href", RegexUtil.replace(RegexUtil.dataRegex,self.config().xlink,self.data()));
	    }
	};
	
	UsePlugin.struct = function(ghca_charts) {
	    var Plugin = ghca_charts.view.elements.plugins.plugin;
	    Plugin.struct(ghca_charts);
	    UsePlugin.prototype = Object.create(Plugin.prototype);
	    UsePlugin.prototype.constructor = UsePlugin;
	};
	
	module.exports = UsePlugin;

/***/ }),
/* 104 */
/***/ (function(module, exports) {

	var VBarNode = function (_element,_data) {
	    
	    // --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const BaseLabel = ghca_charts.view.elements.plugins.label.baseLabel;
	    const BaseNode = ghca_charts.view.elements.plugins.nodes.baseNode;
	    const ElementUtil = ghca_charts.view.util.elementUtil;
	    const ColorUtil = ghca_charts.view.util.colorUtil;
	    const Constant = ghca_charts.view.util.constant;
	
	    BaseNode.apply(this,arguments);
	    
	    var self = this;
	        
	    //--------------------------------------------------------------------------
	    //
	    //  Attributes
	    //
	    //--------------------------------------------------------------------------
	    
	    // ------------------------------
	    // attribute
	    // ------------------------------
	
	    //--------------------------------------------------------------------------
	    //
	    //  public Methods
	    //
	    //--------------------------------------------------------------------------
	    
	    //override
	    this.nameSpace = function(){
	        return "vBarNode";
	    }
	    
	//    //override
	//    this.data = function(){
	//        return _data.data;
	//    }
	
	    //override
	    this.mouseOverHandler = function() {
	        self.mainElement
	            .attr("fill-opacity", 0.5);
	    }
	    
	    //override
	    this.mouseOutHandler = function() {
	    	self.mainElement
	            .attr("fill-opacity", 1);
	    }
	
	    //override
	    this.selectedChange = function(seleced) {
	    }
	    
	    //override
	    this.drawPlugin = function(g){
	    	var data = self.data().data;
	    	var p = data && data.hasOwnProperty("clazzProperties") ? data.clazzProperties : null;
	    	var eleConfig = {rx:4};
	    	if(p) {
	    		for(var k in p) {
	    			eleConfig[k] = p[k];
	    		}
	    	}
	        self.mainElement = g.append("rect");
	        self.mainElement
	            .attr("class", "bar-rect")
	            .attr("fill", function(d){
	                return d.legendColor;
	            })
	            .attr("x", function(d) {
	                return d.x;
	            })
	            .attr("width", function(d) {
	                return d.dx;
	            })
	            .attr("y", function(d) {
	                return d.startY;
	            })
	            .attr("height", 0);
	        ElementUtil.setElementProperties(self.mainElement, eleConfig);
	        //多个颜色设置线性渐变
	        var colors = eleConfig.fill;
	        if(colors instanceof Array)
	            ElementUtil.setElementProperties(self.mainElement,
	                {fill:"url(#"+ColorUtil.getLinearGradientDef(self.mainElement.node(),colors,null,Constant.HOR_DRAG_TYPE)+")"});
	
	        self.mainElement
	            .transition().duration(self.animation() ? 1000 : 0)
	            .attr("y", function(d) {
	                return d.y;
	            })
	            .attr("height", function(d) {
	                return d.dy;
	            });
	        self.createLabel(g,self.data());
	    }
	    
	    //override
	    this.update = function() {
	    	if(self.mainElement) {
	    		var data = self.data().data;
	    		var p = data && data.hasOwnProperty("clazzProperties") ? data.clazzProperties : null;
	            var eleConfig = {rx:4};
	            if(p) {
	                for(var k in p) {
	                    eleConfig[k] = p[k];
	                }
	            }
	    		self.mainElement.datum(self.data())
	    		    .transition().duration(self.animation() ? 500 : 0)
	    		    .attr("fill", function(d){
	                    return d.legendColor;
	                })
	                .attr("x", function(d) {
	                    return d.x;
	                })
	                .attr("width", function(d) {
	                    return d.dx;
	                })
	                .attr("y", function(d) {
	                    return d.y;
	                })
	                .attr("height", function(d) {
	                    return d.dy;
	                });
	            ElementUtil.setElementProperties(self.mainElement, eleConfig);
	    	}
	    	if(self.label) {
	    		var labelData = self.data().data.label;
	            labelData.name = labelData.format ?　self.formatStr(labelData.format)(self.data())　: self.data().value;
	            self.label.update(labelData);
	    		self.labelLayout(self.labelG, self.label, self.data(), true);
	    	}
	    };
	    
	    //override
	    this.createLabel = function(group, d) {
	        if(!d.data || !d.data.label || d.value === null || d.value === undefined) {
	            return;
	        }
	        self.labelG = group.append("g").attr("pointer-events", "none");
	        var labelData = d.data.label;
	        labelData.name = labelData.format ?　self.formatStr(labelData.format)(d)　: d.value;
	        self.label = new BaseLabel(self.labelG, labelData, self);
	        self.label.render();
	        self.labelLayout(self.labelG, self.label, d, false);
	    }
	    
	    //override
	    this.labelLayout = function(element, plugin, d, isUpdate){
	        var position = d.data.labelPosition;
	        if(position === 'none') {
	        	element.style("display", "none");
	        	return;
	        } else {
	        	element.style("display", "block");
	        }
	        if(!position)
	            position = 'top';
	        
	        var translate, labelPosition = position.toLowerCase(), tx = 0, ty = 0;
	        var labelBox = element.node().getBBox();
	        if(labelPosition == 'bottom') {
	            tx = d.x + d.dx / 2;
	            ty = d.y + d.dy + labelBox.height / 2;
	        } else if(labelPosition == 'left') {
	            tx = d.x - d.dx / 2;
	            ty = d.y + d.dy / 2;
	        } else if(labelPosition == 'right') {
	            tx = d.x + d.dx + d.dx / 2;
	            ty = d.y + d.dy / 2;
	        } else if(labelPosition == 'center') {
	            tx = d.x + d.dx / 2;
	            ty = d.y + d.dy / 2;
	        } else if(labelPosition == 'insidetop') {
	            tx = d.x + d.dx / 2;
	            ty = d.y + labelBox.height / 2;
	        } else if(labelPosition == 'insidebottom') {
	            tx = d.x + d.dx / 2;
	            ty = d.y + d.dy - labelBox.height / 2;
	        } else if(labelPosition == 'insideleft') {
	            tx = d.x + labelBox.width / 2;
	            ty = d.y + d.dy / 2;
	        } else if(labelPosition == 'insideright') {
	            tx = d.x + d.dx - labelBox.width / 2;
	            ty = d.y + d.dy / 2;
	        } else {
	        	//default top
	        	tx = d.x + d.dx / 2;
	            ty = d.y - labelBox.height / 2 - 1;
	        }
	        if(isUpdate) {
	        	 element
	                .transition().duration(self.animation() ? 500 : 0)
	                .attr("transform", "translate("+tx+","+ty+")");
	        } else {
	        	 element
	                .attr("transform", "translate("+tx+","+d.startY+")")
	                .transition().duration(self.animation() ? 1000 : 0)
	                .attr("transform", "translate("+tx+","+ty+")");
	        }
	    }
	};
	
	VBarNode.struct = function(ghca_charts) {
	    var BaseNode = ghca_charts.view.elements.plugins.nodes.baseNode;
	    BaseNode.struct(ghca_charts);
	    VBarNode.prototype = Object.create(BaseNode.prototype);
	    VBarNode.prototype.constructor = VBarNode;
	};
	
	module.exports = VBarNode;

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {var VerTool = function (_element,_data) {
	
	    // --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	
	    const Plugin = ghca_charts.view.elements.plugins.plugin;
	    const RegexUtil = ghca_charts.view.util.regexUtil;
	    const EventUtil = ghca_charts.view.util.eventUtil;
	
	    Plugin.apply(this,arguments);
	    var self = this;
	
	    self.config({
	        "xlink":"{xlink}",
	        "width":"{width}",
	        "height":"{height}",
	        "data":"{value}"
	    });
	    //override
	    this.actualWidth = function(){
	        return 0;
	    }
	    //override
	    this.actualHeight = function(){
	        return 0;
	    }
	
	    //override
	    this.nameSpace = function(){
	        return "VerTool";
	    }
	    //override
	    this.update = function(g){
	        this.drawPlugin(g);
	    }
	    //override
	    this.drawPlugin = function(g){
	
	        var data = RegexUtil.replace(RegexUtil.dataRegex,self.config().data,self.data());
	        if(data === self.config().data)data = [];
	
	        if(data instanceof Array){
	            var uses = g.selectAll("use")
	                .data(data,function(d){return d["xlink"];});
	            uses.exit().remove();
	            uses.enter().append("use")
	                .attr("xlink:href", function(d,i){
	                    return RegexUtil.replace(RegexUtil.dataRegex,self.config().xlink,d);
	                })
	                .attr("y", function(d,i){
	                    return RegexUtil.replace(RegexUtil.dataRegex,self.config().height,d)*i;
	                }).on("dblclick.verTool",function(d){
	                d3.event.stopPropagation();
	                self.el.node().dispatchEvent(EventUtil.createCustomEvent(self.config().events,true,true,d));
	            });
	        }
	    }
	};
	
	VerTool.struct = function(ghca_charts) {
	    var Plugin = ghca_charts.view.elements.plugins.plugin;
	    Plugin.struct(ghca_charts);
	    VerTool.prototype = Object.create(Plugin.prototype);
	    VerTool.prototype.constructor = VerTool;
	};
	
	module.exports = VerTool;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 106 */
/***/ (function(module, exports) {

	var Plugin = function (_element,_data) {
		
		// --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const ElementUtil = ghca_charts.view.util.elementUtil;
	    const RegexUtil = ghca_charts.view.util.regexUtil;
	
	    var self = this;
	    self.el = undefined;
	    
	    var isRender = false;
	    this.isRender = function(){
	        return isRender;
	    }
	    /**
	     * 配置
	     * @returns {string}
	     */
	    var config = {};
	    this.config = function(value){
	        if(!arguments.length)return config;
	        config = value;
	        return this;
	    }
	    
	    /**
	     * 唯一
	     * @returns {string}
	     */
	    this.nameSpace = function(){
	        return "plugin";
	    }
	    /**
	     * 设置是否可见
	     */
	    var visible = true;   var i = 1;
	    this.visible = function(_visible){
	        if(!arguments.length)return visible;
	        visible = _visible;
	        if(self.el){
	            if(_visible==true)
	                ElementUtil.setElementProperties(self.el,{display:"block"});
	            else
	                ElementUtil.setElementProperties(self.el,{display:"none"});
	        }
	        return this;
	    }
	    /**
	     * 获取渲染数据
	     */
	    var data = _data;
	    this.data = function(){
	        if(!arguments.length)return data;
	        data = arguments[0];
	        return this;
	    }
	    /**
	     * 获取渲染数据,因为data()在子类中被重写，返回的是_data.data,故用此方法获取原始渲染数据
	     */
	    this.itemData = function(){
	        return _data;
	    }
	    /**
	     * 是否开启动画效果
	     */
	    var animation = true;
	    this.animation = function(value) {
	        if (!arguments.length)
	            return animation;
	        animation = value;
	        return this;
	    };
	    /**
	     * 获取实际渲染宽度
	     */
	    this.actualWidth = function() {
	        return self.getBBox().width;
	    }
	    /**
	     * 获取实际渲染高度
	     */
	    this.actualHeight = function() {
	        return self.getBBox().height;
	    }
	    /**
	     * 所在图表组件是否是初次渲染
	     */
	    var isChartFirstInit = false;
	    this.isChartFirstInit = function(value){
	        if(!arguments.length)return isChartFirstInit;
	        isChartFirstInit = value;
	        return this;
	    }
	    
	    /**
	     * 所在图表组件数据
	     */
	    var ownerData = null;
	    this.ownerData = function(value){
	        if(!arguments.length)return ownerData;
	        ownerData = value;
	        return this;
	    }
	    
	    /**
	     * 所在graph实例
	     */
	    var graph = null;
	    this.graph = function(value){
	        if(!arguments.length)return graph;
	        graph = value;
	        return this;
	    }
	    
	    this.mainContainer = function() {
	        return self.el;
	    };
	    
	    /**
	     * 容器外接图形类别，用来判断和连线的交点。"rect"|"circle"(默认为矩形:"rect")
	     */
	    var boundType = "rect";
	    this.boundType = function(value){
	        if(!arguments.length) return boundType;
	        boundType = value ? value : "rect";
	        return this;
	    };
	    
	    
	    /**
	     * 缓存外接矩形
	     */
	    var bBox = {x:0, y:0, width:0, height:0};
	    this.getBBox = function() {
	        return bBox;
	    };
	    this.resetBBox = function(x, y, width, height) {
	        bBox.x =parseFloat(x);
	    	bBox.y = parseFloat(y);
	    	bBox.width = parseFloat(width);
	    	bBox.height = parseFloat(height);
	    };
	    
	    /**
	     * 替换字符串中的特殊字符串内容，比如{#d.name#}替换为渲染数据中的name属性的值,{##}中的内容是可执行的js
	     */
	     this.formatStr = function(str) {
	     	return function(d) {
	            return str.replace(RegexUtil.jsRegex, function() {
	                return arguments.length > 1 ? eval(arguments[1]) : "";
	            });
	        };
	     };
	
	    /**
	     * 渲染方法 ，变更时调用,供外部统一调用
	     * @param element 目标元素
	     */
	    this.render = function(){
	        if(isRender==true){
	            self.el.datum(_data);
	            self.update(self.el);
	//            self.resetBBox(self.el);
	            return;
	        }
	        self.el = _element.append("g").datum(_data);
	        self.el.classed(self.nameSpace(), true);
	        self.visible(self.visible());
	        self.drawPlugin(self.el);
	        self.bindEvents(self.el);
	//        self.resetBBox(self.el);
	        isRender = true;
	    }
	    /**
	     * 变更
	     * @param g
	     */
	    this.update = function(g){
	
	    }
	    /**
	     * 实际绘画方法
	     * @param g
	     */
	    this.drawPlugin = function(g){
	
	    }
	    /**
	     * 绑定事件方法
	     * @param g
	     */
	    this.bindEvents = function(g){
	
	    }
	
	    /**
	     * 设置位置
	     * @param g
	     */
	    this.transform = function(value){
	        if(!arguments.length){
	            if(self.el)
	                return  self.el.attr("transform");
	        }
	         if(self.el)
	             self.el.attr("transform",value);
	    }
	
	
	    this.addEventListener = function() {
	        var value = self.dispatch.on.apply(self.dispatch, arguments);
	        return value === self.dispatch ? self : value;
	    };
	
	};
	
	
	Plugin.struct = function(ghca_charts) {
	    Plugin.prototype.constructor = Plugin;
	};
	
	module.exports = Plugin;

/***/ }),
/* 107 */
/***/ (function(module, exports) {

	var PluginMap = function() {
	    
	    this.getMap = function() {
	        var map = {};
	        //注册内部插件类
	        map.percentageinfo = ghca_charts.view.elements.plugins.tool.percentageInfo;
	        map.tooltip = ghca_charts.view.elements.plugins.tool.toolTip;
	        map.label = ghca_charts.view.elements.plugins.label.label;
	        map.expandtool = ghca_charts.view.elements.plugins.nodes.expandTool;
	        map.circle = ghca_charts.view.elements.plugins.nodes.circle;
	        map.rect = ghca_charts.view.elements.plugins.nodes.rect;
	        map.imagenode = ghca_charts.view.elements.plugins.nodes.imageNode;
	        map.iconnode = ghca_charts.view.elements.plugins.nodes.IconNode;
	        map.topolabel = ghca_charts.view.elements.plugins.label.topoLabel;
	        map.demoimagenode = ghca_charts.view.elements.plugins.nodes.demoImageNode;
	        map.pathnode = ghca_charts.view.elements.plugins.nodes.pathNode;
	        map.vertool = ghca_charts.view.elements.plugins.nodes.verTool;
	        map.useplugin = ghca_charts.view.elements.plugins.nodes.usePlugin;
	        map.moretool = ghca_charts.view.elements.plugins.nodes.moreTool;
	        
	        //注册外部插件类
	        var outerMap = ghca_charts.global.outerPlugins && ghca_charts.global.outerPlugins.pluginMap;
	        if(outerMap) {
	            for(var name in outerMap) {
	                map[name] = outerMap[name];
	            }
	        }
	        
	        return map;
	    };
	};
	
	PluginMap.struct = function(ghca_charts) {
	    PluginMap.prototype.constructor = PluginMap;
	};
	
	module.exports = PluginMap;

/***/ }),
/* 108 */
/***/ (function(module, exports) {

	var PercentageInfo = function (_element,_data) {
		
		// --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const Label = ghca_charts.view.elements.plugins.label.label;
	    const Plugin = ghca_charts.view.elements.plugins.plugin;
	
	    Plugin.apply(this,arguments);
	    var self = this;
	    var label;
	    self.config({
	        label:{
	            clazz:"label",
	            config:{
	                text:"{value}",
	                maxWidth:100,
	                backGroundColor:"none",
	                backGroundOpacity:0.0,
	                borderRadius:4,
	                padding:4,
	                fontColor:"0x000000",
	                fontFamily:"宋体",
	                fontSize:12
	            }
	        }
	    });
	    //override
	    this.nameSpace = function(){
	        return "percentageInfo";
	    }
	
	    //override
	    this.update = function(g){
	        if(label){
	            var config = self.config();
	            label.config(config.label.config);
	            label.data(self.data());
	            label.render();
	            centerLabel();
	        }
	    }
	    //override
	    this.drawPlugin = function(g){
	        var config = self.config();
	        label = new Label(g,self.data());
	        label.config(config.label.config);
	        label.render();
	        centerLabel();
	    }
	
	    function  centerLabel(){
	        var w = label.actualWidth(),
	            h = label.actualHeight();
	        label.transform("translate("+ (-w/2)+","+ (-h/2)+")");
	    }
	};
	
	PercentageInfo.struct = function(ghca_charts) {
		var Plugin = ghca_charts.view.elements.plugins.plugin;
		Plugin.struct(ghca_charts);
	    PercentageInfo.prototype = Object.create(Plugin.prototype);
	    PercentageInfo.prototype.constructor = PercentageInfo;
	};
	
	module.exports = PercentageInfo;

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {var ToolTip = function (_element,_data) {
		
		// --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const Plugin = ghca_charts.view.elements.plugins.plugin;
	    const Label = ghca_charts.view.elements.plugins.label.label;
	
	    Plugin.apply(this,arguments);
	    var self = this;
	    var label;
	    self.config({
	        visible:false,
	        fadeInSpeed:1000,
	        label:{
	            text:"{name}:{value}",
	            maxWidth:60,
	            backGroundColor:"green",
	            backGroundOpacity:.3,
	            borderRadius:4,
	            padding:4,
	            fontColor:"0x000000",
	            fontFamily:"宋体",
	            fontSize:12
	        }
	    });
	
	    var toolTipFunc;
	    this.toolTipFunc = function(value){
	        if(!arguments.length)return;
	        toolTipFunc = value;
	    }
	    /**
	     * 唯一
	     * @returns {string}
	     */
	    this.nameSpace = function(){
	        return "toolTip";
	    }
	
	    /**
	     * 变更
	     * @param g
	     */
	    this.update = function(g){
	        g.style("opacity", 0);
	        label.data(self.data());
	        label.render();
	    }
	    /**
	     * 实际绘画方法
	     * @param g
	     */
	    this.drawPlugin = function(g){
	        self.visible(self.config().visible);
	        label = new Label(g,self.data());
	        label.config(self.config().label);
	        if(toolTipFunc)
	            label.textFunc(toolTipFunc);
	        label.render();
	    }
	
	    this.showTooltip = function(g) {
	        var fadeInSpeed = self.config().fadeInSpeed;
	        self.el.transition()
	            .duration(fadeInSpeed)
	            .style("opacity", function() { return 1; });
	        self.moveTooltip(g);
	    };
	
	    this.moveTooltip = function(g) {
	        self.el.attr("transform", function(d) {
	            var mouseCoords = d3.mouse(this.parentNode);
	             var x = Number(mouseCoords[0])+5,
	                 y  = Number(mouseCoords[1] - label.actualHeight() - 2);
	            return "translate(" + x +","+ y + ")";
	        });
	    };
	
	    this.hideTooltip = function(g) {
	        var fadeOutSpeed = self.config().fadeInSpeed;
	        self.el.transition()
	            .duration(fadeOutSpeed)
	            .style("opacity", function() { return 0; });
	        // self.el.style("opacity", function() { return 0; });
	    }
	};
	
	ToolTip.struct = function(ghca_charts) {
		var Plugin = ghca_charts.view.elements.plugins.plugin;
		Plugin.struct(ghca_charts);
	    ToolTip.prototype = Object.create(Plugin.prototype);
	    ToolTip.prototype.constructor = ToolTip;
	};
	
	module.exports = ToolTip;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 110 */
/***/ (function(module, exports) {

	var RectElement = function (_element,_data) {
		
		// --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const BaseElement = ghca_charts.view.elements.baseElement;
	
	    BaseElement.apply(this,arguments);
	    var self  = this;
	    self.svgElement = _element.append("rect");
	    var superRenderFunc = this.render;
	    /**
	     * border形状终结butt，round，square
	     */
	    var linecap="butt";
	    this.linecap = function(value){
	        if (!arguments.length)
	            return linecap;
	        linecap = value;
	        return this;
	    }
	
	
	    /**
	     * 透明度
	     * @type {number}
	     */
	    var opacity=1;
	    this.opacity = function(value){
	        if (!arguments.length)
	            return opacity;
	        opacity = value;
	        return this;
	    }
	    /**
	     * border透明度
	     * @type {number}
	     */
	    var borderOpacity=1;
	    this.borderOpacity = function(value){
	        if (!arguments.length)
	            return borderOpacity;
	        borderOpacity = value;
	        return this;
	    }
	    /**
	     * @type {number}
	     */
	    var x = 0;
	    this.x = function(value){
	        if (!arguments.length)
	            return x;
	        x = value;
	        return this;
	    }
	    /**
	     * @type {number}
	     */
	    var y = 0;
	    this.y = function(value){
	        if (!arguments.length)
	            return y;
	        y = value;
	        return this;
	    }
	    /**
	     * 圆角
	     * @type {number}
	     */
	    var ry;
	    this.ry = function(value){
	        if (!arguments.length)
	            return ry;
	        ry = value;
	        return this;
	    }
	
	
	    /**
	     * 圆角
	     * @type {number}
	     */
	    var rx;
	    this.rx = function(value){
	        if (!arguments.length)
	            return rx;
	        rx = value;
	        return this;
	    }
	
	    /**
	     * 高度
	     * @type {number}
	     */
	    var height = 0;
	    this.height = function(value){
	        if (!arguments.length)
	            return height;
	        height = value;
	        return this;
	    }
	
	
	    /**
	     * 宽度
	     * @type {number}
	     */
	    var width = 0;
	    this.width = function(value){
	        if (!arguments.length)
	            return width;
	        width = value;
	        return this;
	    }
	    /**
	     * 线宽
	     * @type {number}
	     */
	    var border = 0;
	    this.border = function(value){
	        if (!arguments.length)
	            return border;
	        border = value;
	        return this;
	    }
	    /**
	     * 线的间隔
	     * @type {number or %}
	     */
	    var dashoffset;
	    this.dashoffset = function(value){
	        if (!arguments.length)
	            return dashoffset;
	        dashoffset = value;
	        return this;
	    }
	    /**
	     * 线的段长 ary
	     * @type {string}
	     */
	    var dasharray;
	    this.dasharray = function(value){
	        if (!arguments.length)
	            return dasharray;
	        dasharray = value;
	        return this;
	    }
	    /**
	     * 边框颜色
	     * @type {string}
	     */
	    var borderColor="none";
	    this.borderColor = function(value){
	        if (!arguments.length)
	            return borderColor;
	        borderColor = value;
	        return this;
	    }
	    /**
	     * 背景颜色 默认无背景
	     * @type {string}
	     */
	    var color="none";
	    this.color = function(value){
	        if (!arguments.length)
	            return color;
	        color = value;
	        return this;
	    }
	    //override
	    this.render = function(){
	        superRenderFunc();
	
	        self.svgElement.style("stroke",self.borderColor())
	            .style("stroke-linecap",self.linecap())
	            .style("stroke-width",self.border())
	            .style("stroke-opacity",self.borderOpacity())
	            .style("fill",self.color())
	            .style("fill-opacity",self.opacity());
	            if(self.dasharray())
	                self.svgElement.style("stroke-dasharray",self.dasharray());
	            if(self.dashoffset())
	                self.svgElement.style("stroke-dashoffset",self.dashoffset());
	        
	        self.svgElement.attr("ry",self.ry())
	            .attr("rx",self.rx())
	            .attr("height",self.height())
	            .attr("x",self.x())
	            .attr("y",self.y())
	            .attr("width",self.width());
	        
	        self.resetBBox(self.x(), self.y(), self.width(), self.height());
	    }
	    //override
	    this.dataChangeHandler = function(event){
	        self.render();
	    }
	};
	
	RectElement.struct = function(ghca_charts) {
		var BaseElement = ghca_charts.view.elements.baseElement;
		BaseElement.struct(ghca_charts);
	    RectElement.prototype = Object.create(BaseElement.prototype);
	    RectElement.prototype.constructor = RectElement;
	};
	
	module.exports = RectElement;

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {var BaseShape = function (_element, _data) {
	    
	    // --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
		
		const ObjectUtil = ghca_charts.view.util.objectUtil;
		const BaseEvent = ghca_charts.events.BaseEvent;
	    const EventUtil = ghca_charts.view.util.eventUtil;
	    const RegexUtil = ghca_charts.view.util.regexUtil;
	    
	    var self  = this;
	    
	    // --------------------------------------------------------------------------
	    //
	    // Attributes
	    //
	    // --------------------------------------------------------------------------
	        
	    // ------------------------------
	    // mainContainer
	    // ------------------------------
	    
	    /**
	     * 放置所有内容的最外层容器
	     */
	    var mainContainer = null;
	    this.mainContainer = function(value) {
	        if (!arguments.length) {
	            return mainContainer;
	        }
	        mainContainer = value;
	        return this;
	    };
	        
	     //------------------------------
	    //  className
	    //------------------------------
	    
	    /**
	     * 类名称，默认作为该容器的css样式名称，比如<g class='mainContainer'>
	     */
	    var className = "mainContainer";
	    this.className = function(value){
	       if (!arguments.length) {
	            return className;                
	        }
	        className = value;
	        return this;
	    }
	    
	    // ------------------------------
	    // data
	    // ------------------------------
	
	    /**
	     * 配置数据
	     */
	    var data = _data;
	    this.data = function(value) {
	        if (!arguments.length) {
	            return data;                
	        }
	        data = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  defaultConfig
	    //------------------------------
	    
	    /**
	     * 默认配置
	     */
	    var defaultConfig = null;
	    this.defaultConfig = function(value) {
	        if (!arguments.length)
	            return defaultConfig;
	        defaultConfig = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  animation
	    //------------------------------
	    
	    /**
	     * 是否开启动画效果
	     */
	    var animation = true;
	    this.animation = function(value) {
	        if (!arguments.length)
	            return animation;
	        animation = value;
	        return this;
	    };
	    
	    //------------------------------
	    //  boundType
	    //------------------------------
	    
	    /**
	     * 容器外接图形类别，用来判断和连线的交点。"rect"|"circle"(默认为矩形:"rect")
	     */
	    var boundType = "rect";
	    this.boundType = function(value){
	        if(!arguments.length)
	            return boundType;
	        boundType = value ? value : "rect";
	        return this;
	    };
	    
	    //------------------------------
	    //  getMainCon
	    //------------------------------
	    
	    this.getMainCon = function() {
	        return self.mainContainer();
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // public Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    this.render = function() {
	        if(!_element || !_data) {
	        	return;
	        }
	        self.renderChildren();
	        self.parseConfig(_data);
	        self.update();
	        self.addListeners();
	    };
	    
	    this.addListeners = function() {
	        var shape = self.mainContainer();
	    	if(shape) {
	    	   shape.on('mouseover', function(d) {
	               var evt = EventUtil.createCustomEvent(BaseEvent.SHOW_TOOL_TIP, true, true);
	               d3.select(this).node().dispatchEvent(evt);
	               self.mouseOverHandler();
	           });
	           shape.on('mousemove', function(d) {
	               var evt = EventUtil.createCustomEvent(BaseEvent.UPDATE_TOOL_TIP, true, true, _data);
	               d3.select(this).node().dispatchEvent(evt);
	           });
	           shape.on('mouseout', function(d) {
	               var evt = EventUtil.createCustomEvent(BaseEvent.HIDE_TOOL_TIP, true, true);
	               d3.select(this).node().dispatchEvent(evt);
	               self.mouseOutHandler();
	           });
	           shape.on('click', function(d) {
	                var evt = EventUtil.createCustomEvent(BaseEvent.NODE_CLICK, true, true, d);
	                d3.select(this).node().dispatchEvent(evt);
	           });
	    	}
	    };
	    
	    this.mouseOverHandler = function() {
	    	var shape = self.mainContainer();
	    	if(shape) {
	            shape.attr("opacity", 0.5);
	    	}
	    };
	    
	    this.mouseOutHandler = function() {
	        var shape = self.mainContainer();
	        if(shape) {
	            shape.attr("opacity", 1);
	        }
	    };
	    
	    this.renderChildren = function() {
	    };
	    
	    this.update = function(){
	    };
	    
	    /**
	     * 根据读取的配置信息和默认配置信息创建新的配置信息
	     */
	    this.parseConfig = function(d) {
	        if(!d || !d.data || !d.data.config) {
	            return;
	        }
	        var config = d.data.config;
	        for(var k in config) {
	            if(k === "style") {
	                for(var m in config.style) {
	                    if(!defaultConfig.style) {
	                        defaultConfig.style = {};
	                    }
	                    defaultConfig.style[m] = self.scriptRun(d, config.style[m]);
	                }
	            } else {
	                defaultConfig[k] = self.scriptRun(d, config[k]);
	            }
	        }
	        if(d.hasOwnProperty("legendColor")) {
	        	defaultConfig.style.fill = d.legendColor;
	        }
	    };
	    
	    /**
	     * 运行配置中的js代码
	     */
	    this.scriptRun = function(d, str) {
	        return (ObjectUtil.isString(str) && str) ? str.replace(RegexUtil.jsRegex, function() {
	            return arguments.length > 1 ? eval(arguments[1]) : "";
	        }) : str;
	    };
	    
	    /**
	     * 设置d3对象集合对应标签样式
	     */
	    this.setGroupStyle = function(group, styleConfig) {
	        if(!group.node() || !styleConfig) {
	            return;
	        }
	        var obj;
	        group.each(function() {
	            obj = this;
	            //这样写兼容"stroke-Width"和"strokeWidth"写法
	            for(var k in styleConfig) {
	                obj.style[k] = styleConfig[k];
	            }
	        });
	    };
	    
	    /**
	     * 销毁本类实例的方法
	     */
	    this.destroy = function() {
	        if(self.mainContainer()) {
	            self.mainContainer().remove();
	        }
	    };
	};
	
	BaseShape.struct = function(ghca_charts) {
	    BaseShape.prototype.constructor = BaseShape;
	};
	
	module.exports = BaseShape;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 112 */
/***/ (function(module, exports) {

	var CircleShape = function (_element, _data) {
	    
	    // --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
		
		const BaseShape = ghca_charts.view.elements.shape.baseShape;
		
		BaseShape.apply(this, arguments);
	    
	    var self  = this;
	    
	    self.defaultConfig({
	    	cx:0,
	    	cy:0,
	    	r:3,
	    	style:{
	    		"fill":"steelblue",
	    		"stroke":"#aaa",
	    		"stroke-opacity":1,
	    		"stroke-width":1,
	    		"fill-opacity":1
	    	}
	    });
	    
	    self.boundType("circle");
	    
	    // --------------------------------------------------------------------------
	    //
	    // Attributes
	    //
	    // --------------------------------------------------------------------------
	        
	    // ------------------------------
	    // attribute
	    // ------------------------------
	    
	    // --------------------------------------------------------------------------
	    //
	    // public Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    this.renderChildren = function() {
	        if(!self.mainContainer()) {
	            var shape = _element.append("circle").attr("class", self.className());
	            self.mainContainer(shape);
	        }
	    };
	    
	    this.update = function(isUpdate) {
	    	var shape = self.mainContainer();
	    	if(!shape) {
	    		return;
	    	}
	    	self.parseConfig(self.data());
	    	var defaultConfig = self.defaultConfig();
	    	
	    	if(!isUpdate) {
	    		shape.attr("r", 0);
	    	}
	    	shape
	            .attr("cx", defaultConfig.x)
	            .attr("cy", defaultConfig.y)
	            .transition().duration(self.animation() ? (isUpdate ? 500 : 1000) : 0)
	            .attr("r", defaultConfig.r);
	            
	        self.setGroupStyle(shape, defaultConfig.style);
	    }
	};
	
	CircleShape.struct = function(ghca_charts) {
		var BaseShape = ghca_charts.view.elements.shape.baseShape;
	    BaseShape.struct(ghca_charts);
	    CircleShape.prototype = Object.create(BaseShape.prototype);
	    CircleShape.prototype.constructor = CircleShape;
	};
	
	module.exports = CircleShape;

/***/ }),
/* 113 */
/***/ (function(module, exports) {

	var RectShape = function (_element, _data) {
	    
	    // --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
		
		const BaseShape = ghca_charts.view.elements.shape.baseShape;
	    
		BaseShape.apply(this, arguments);
		
	    var self  = this;
	    
	    self.defaultConfig({
	    	x:0,
	    	y:0,
	    	width:5,
	    	height:5,
	        style:{
	            "fill":"steelblue",
	            "stroke":"#aaa",
	            "stroke-opacity":1,
	            "stroke-width":1,
	            "fill-opacity":1
	        }
	    });
	    
	    // --------------------------------------------------------------------------
	    //
	    // Attributes
	    //
	    // --------------------------------------------------------------------------
	        
	    // ------------------------------
	    // attribute
	    // ------------------------------
	    
	    // --------------------------------------------------------------------------
	    //
	    // public Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    this.renderChildren = function() {
	    	if(!self.mainContainer()) {
	            var shape = _element.append("rect").attr("class", self.className())
	            self.mainContainer(shape)
	        }
	    };
	    
	    this.update = function(isUpdate){
	    	var shape = self.mainContainer();
	    	if(!shape) {
	    		return;
	    	}
	    	
	    	self.parseConfig(self.data());
	        var defaultConfig = self.defaultConfig();
	        
	    	if(!isUpdate) {
	    		shape.attr("width", 0).attr("height", 0);
	    	}
	    	shape
	            .attr("x", defaultConfig.x)
	            .attr("y", defaultConfig.y)
	            .transition().duration(self.animation() ? (isUpdate ? 500 : 1000) : 0)
	            .attr("width", defaultConfig.width)
	            .attr("height", defaultConfig.height);
	            
	        self.setGroupStyle(shape, defaultConfig.style);
	    }
	};
	
	RectShape.struct = function(ghca_charts) {
		var BaseShape = ghca_charts.view.elements.shape.baseShape;
	    BaseShape.struct(ghca_charts);
	    RectShape.prototype = Object.create(BaseShape.prototype);
	    RectShape.prototype.constructor = RectShape;
	};
	
	module.exports = RectShape;

/***/ }),
/* 114 */
/***/ (function(module, exports) {

	//绘制类
		
	/**
	 * 构造方法 
	 * @param _ele 绘制容器对象或者容器id，比如一个div 
	 * @param _config 渲染配置数据
	 */
	var Graph = function (_ele, _config) {
		
		// --------------------------------------------------------------------------
	    // import
	    // --------------------------------------------------------------------------
	    
	    const BaseComponent = ghca_charts.view.component.baseComponent;
	    const Chart = ghca_charts.view.component.charts.chart;
	    const SVG = ghca_charts.view.component.svg;
	    const UUID = ghca_charts.view.util.UUIDUtil;
	    const ObjectUtil = ghca_charts.view.util.objectUtil;
	    const DataParser = ghca_charts.view.util.dataParser;
	    const Global = ghca_charts.global;
	    
	    if (arguments.length != 2) {
	        throw new Error('传入参数个数错误,当前个数' + arguments.length + ",应传入两个参数。");
	    }
	    
	    if (typeof(_ele) == 'string') {
	        _ele = document.getElementById(_ele);
	    }
	    if (!_ele) {
	        throw new Error('Graph构造方法中传入的容器_ele:' + _ele + "无法找到。");
	    }
	    
	    var self = this;
	    
	    //--------------------------------------------------------------------------
	    //
	    //  Attributes
	    //
	    //--------------------------------------------------------------------------
	    
	    // ------------------------------
	    // id
	    // ------------------------------
	
	    /**
	     * graph id
	     */
	    var id = UUID.generateUUID();
	    this.id = function(value) {
	    	if (!arguments.length)
	            return id;
	    	id = value;
	        return this;
	    };
	    
	    // ------------------------------
	    // config
	    // ------------------------------
	
	    /**
	     * 渲染配置数据
	     */
	    var config = _config;
	    this.config = function(value) {
	        if (!arguments.length)
	            return config;
	        config = value;
	        return this;
	    };
	    
	    // ------------------------------
	    // parentWidth
	    // ------------------------------
	    
	    /**
	     * 父容器宽度
	     */
	    this.parentWidth = function() {
	        return _ele ? _ele.clientWidth : 0;
	    };
	    
	    // ------------------------------
	    // parentHeight
	    // ------------------------------
	    
	    /**
	     * 父容器高度
	     */
	    this.parentHeight = function() {
	        return _ele ? _ele.clientHeight : 0;
	    };
	    
	    //------------------------------
	    //  children
	    //------------------------------
	    
	    /**
	     * 该类实例的子类实例引用数组，只有非svg组件才有值
	     */
	    var children = [];
	    this.children = function(value) {
	        if (!arguments.length) {
	            return self.topComponent instanceof BaseComponent ? 
	                self.topComponent.children() : children;
	        }
	        children = value;
	        return this;
	    };
	    
	    // ------------------------------
	    // width
	    // ------------------------------
	    
	    /**
	     * 当前graph创建的顶层svg或者g元素的宽度，默认为父容器宽度
	     */
	    var width = NaN;
	    this.width = function(value) {
	         if (!arguments.length)
	            return isNaN(width) ? self.parentWidth() : width;
	        width = value;
	        return this;
	    };
	    
	    // ------------------------------
	    // height
	    // ------------------------------
	    
	    /**
	     * 当前graph创建的顶层svg或者g元素的高度，默认为父容器高度
	     */
	    var height = NaN;
	    this.height = function(value) {
	        if (!arguments.length)
	            return isNaN(height) ? self.parentHeight() : height;
	        height = value;
	        return this;
	    };
	    
	    // ------------------------------
	    // scaleX
	    // ------------------------------
	    
	    /**
	     * 当前graph外层容器的scaleX
	     */
	    var scaleX = 1;
	    this.scaleX = function() {
	        return scaleX;
	    };
	    
	    // ------------------------------
	    // scaleY
	    // ------------------------------
	    
	    /**
	     * 当前graph外层容器的scaleY
	     */
	    var scaleY = 1;
	    this.scaleY = function() {
	        return scaleY;
	    };
	    
	    // ------------------------------
	    // scaleZ
	    // ------------------------------
	    
	    /**
	     * 当前graph外层容器的scaleZ
	     */
	    var scaleZ = 1;
	    this.scaleZ = function() {
	        return scaleZ;
	    };
	    
	    // ------------------------------
	    // autoResize
	    // ------------------------------
	    
	    /**
	     * 是否自适应容器改变(默认为true)
	     */
	    var autoResize = true;
	    this.autoResize = function(value) {
	        if (!arguments.length)
	            return autoResize;
	        autoResize = value;
	        return this;
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // listeners
	    //
	    // --------------------------------------------------------------------------
	    
	    /**
	     * 父容器尺寸改变监听处理
	     */
	    this.resizeHandler = function() {
	        self.resize.call(self);
	    };
	    
	    // --------------------------------------------------------------------------
	    //
	    // private Methods
	    //
	    // --------------------------------------------------------------------------
	    
	    /**
	     * 初始化方法
	     */
	    var init = function() {
	        if(Global.isDebug) {
	            console.log("Graph.init()");
	        }
	    	
	        self.parent = _ele;
	        
	        //解析渲染配置数据
	        parseConfig();
	        
	        //初始化传入的配置属性
	        self.refreshAttributes(self.config());
	        
	        //添加监听
	        addListeners();
	    };
	    
	    /**
	     * 解析渲染配置数据
	     */
	    var parseConfig = function() {
	        if(Global.isDebug) {
	            console.log("Graph.parseConfig()");
	        }
	    	var config = self.config();
	    	//若传入配置为json字符串，则解析为js对象
	    	if(ObjectUtil.isString(config)) {
	    		config = JSON.parse(config);
	    		self.config(config);
	    	}
	    	//使用相关解析器解析config数据内容
	    	DataParser.parse(config);
	    };
	    
	    /**
	     * 添加监听
	     */
	    var addListeners = function() {
	    	if(self.autoResize()) {
	    		window.addEventListener('resize', self.resizeHandler, false);
	    	}
	    };
	    
	    /**
	     * 渲染顶层组件，若父容器为baseComponent元素，或者要渲染的容器为非svg容器，则直接使用该父容器；
	     * 若父容器为其他元素，则在该容器中创建一个svg元素以显示图表内容；
	     */
	    var renderTopComponent = function(parent, config) {
	        if(Global.isDebug) {
	            console.log("Graph.renderTopComponent()");
	        }
	        if(parent instanceof BaseComponent || 
	        config.type === "table" || 
	        config.type === "linkButton" || 
	        config.type === "comboBox" || 
	        config.type === "textLabel"||
	        config.type === "multiTextLabel"||
	        config.type === "gisMap"||
	        config.type === "iFrame"||
	        config.type === "dateTimeBox") {
	            self.topComponent = parent;
	        } else {
	            var svg = new SVG(parent);
	            svg.graph(self);
	            svg.render();
	            self.topComponent = svg;
	        }
	    };
	    
	    /**
	     * 根据配置渲染多个组件
	     */
	    var renderComponents = function(parent, config) {
	        if(Global.isDebug) {
	            console.log("Graph.renderComponents()");
	        }
	        var instance;
	        if(config.hasOwnProperty("type")) {
	            if(config.type === "chart") {
	                //作为图表组件渲染
	                instance = renderChart(parent, config);
	            } else {
	                //作为普通组件渲染
	                instance = renderComponent(parent, config);
	            }
	        }
	        //渲染子级内容
	        if(config.hasOwnProperty("children") 
	        && ObjectUtil.isArray(config.children)
	        && config.children.length > 0) {
	            var children = config.children;
	            for(var i = 0, len = children.length; i < len; i++) {
	                renderComponents(instance, children[i]);
	            }
	        }
	    };
	    
	    /**
	     * 根据配置渲染单个组件
	     */
	    var renderComponent = function(parent, config) {
	        if(Global.isDebug) {
	            console.log("Graph.renderComponent()");
	        }
	        var ComponentClass, isImportCom = false;
	        var outerPlugins = ghca_charts.global.outerPlugins;
	        //检查外部注册的组件类
	        ComponentClass = outerPlugins && outerPlugins.componentMap && outerPlugins.componentMap[config.type];
	        //若没有查到则检查内部组件类
	        if(!ComponentClass) {
	        	switch(config.type) {
	        		/*custom svg components*/
	                case "component":
	                    ComponentClass = BaseComponent;
	                    break;
	                case "eagleEyeContainer":
	                    ComponentClass = ghca_charts.view.component.eagleEyeContainer;
	                    break;
	                case "tagContainer":
	                    ComponentClass = ghca_charts.view.component.tagContainer;
	                    break;
	                case "svgCanvas":
	                    ComponentClass = ghca_charts.view.component.svgCanvas;
	                    break;
	                /*import div components*/
	                case "table":
	                    isImportCom = true;
	                    ComponentClass = ghca_charts.view.component.table;
	                    break;
	                case "linkButton":
	                    isImportCom = true;
	                    ComponentClass = ghca_charts.view.component.importcomponents.linkButton;
	                    break;
	                case "comboBox":
	                    isImportCom = true;
	                    ComponentClass = ghca_charts.view.component.importcomponents.comboBox;
	                    break;
	                case "dateTimeBox":
	                    isImportCom = true;
	                    ComponentClass = ghca_charts.view.component.importcomponents.dateTimeBox;
	                    break;
	                case "textLabel":
	                    isImportCom = true;
	                    ComponentClass=ghca_charts.view.component.importcomponents.textLabel;
	                    break;
	                case "multiTextLabel":
	                    isImportCom = true;
	                    ComponentClass=ghca_charts.view.component.importcomponents.multiTextLabel;
	                    break;
	                case "gisMap":
	                    isImportCom = true;
	                    ComponentClass=ghca_charts.view.component.gis.gisMap;
	                    break;
	                case "iFrame":
	                    isImportCom = true;
	                    ComponentClass = ghca_charts.view.component.importcomponents.iFrame;
	                    break;
	                /*custom util components*/
	                case "timer":
	                    ComponentClass = ghca_charts.view.component.utilcomponents.timer;
	                    break;
	                case "evDataDispatcher":
	                    ComponentClass = ghca_charts.view.component.utilcomponents.evDataDispatcher;
	                    break;
	                default:
	                    break;
	            }
	        }
	        if(!ComponentClass) {
	            throw new Error('当前传入的组件类型' + config.type + "尚未支持。");
	        }
	        var component;
	        if(isImportCom) {
	        	component = new ComponentClass(parent, config);
	        	component.render();
	        	self.children().push(component);
	        } else {
	        	component = new ComponentClass(config);
	            parent.addChild(component);
	        }
	        component.graph(self);
	        return component;
	    };
	    
	    /**
	     * 根据配置渲染单个图表组件
	     */
	    var renderChart = function(parent, config) {
	        if(Global.isDebug) {
	            console.log("Graph.renderChart()");
	        }
	        var chart = new Chart(config);
	        chart.graph(self);
	        parent.addChild(chart);
	        return chart;
	    };
	    
	    /**
	     * 重新计算布局
	     */
	    var relayout = function(parent) {
	        if(!(parent instanceof BaseComponent)) {
	            return;
	        }
	        //计算除图表布局以外的所有布局
	        var layout = parent.layout();
	        if(layout && !layout.isChartLayout()) {
	            layout.measure();
	        }
	        //计算子容器布局
	        var children = parent.children();
	        if(children !== null && children.length > 0) {
	            for(var i = 0, len = children.length; i < len; i++) {
	                relayout(children[i]);
	            }
	        }
	    };
	    
	    //--------------------------------------------------------------------------
	    //
	    //  public Methods
	    //
	    //--------------------------------------------------------------------------
	    
	    /**
	     * 根据传入的前缀和后缀，生成graph全局唯一的自定义id
	     */
	    this.getCustomId = function(prefix, suff) {
	        return (ObjectUtil.isString(prefix) || ObjectUtil.isNumber(prefix) ? prefix : "") + 
	                self.id() + "_" + 
	               (ObjectUtil.isString(suff) || ObjectUtil.isNumber(suff) ? suff : "");
	    };
	    
	    /**
	     * 渲染内容
	     */
	    this.render = function() {
	        if(Global.isDebug) {
	            console.log("Graph.render()");
	            var ot = new Date().getTime();
	        }
	        
	        //渲染顶层元素
	        renderTopComponent(self.parent, self.config());
	        //根据配置渲染所有元素
	        renderComponents(self.topComponent, self.config());
	        //计算所有容器布局
	        relayout(self.topComponent);
	        if(Global.isDebug) {
	            var nt = new Date().getTime();
	            console.log("Graph.render() is cost time : " + (nt-ot) + " ms.");
	        }
	    };
	    
	    /**
	     * 更新内容
	     */
	    this.update = function() {
	        var topCom = self.topComponent;
	        if(topCom instanceof BaseComponent) {
	            topCom.update();
	        }
	    };
	    
	    /**
	     * 容器尺寸变化后自适应内容
	     */
	    this.resize = function() {
	        var topCom = self.topComponent;
	        if(topCom instanceof BaseComponent) {
	            topCom.width(self.width());
	            topCom.height(self.height());
	            topCom.resize();
	        } else if(children) {
	        	for(var child, i = 0, len = children.length ; i < len; i++) {
	        		child = children[i];
	        		if(child.resize) {
	        			child.resize();
	        		}
	        	}
	        }
	    };
	    
	    /**
	     * 刷新传入配置数据到本类相应属性的方法
	     * @param data 布局配置数据
	     */
	    this.refreshAttributes = function(data) {
	        if(!data) {
	           return;
	        }
	        for(var key in data) {
	            if(self.hasOwnProperty(key)) {
	                this[key](data[key]);
	            }
	        }
	    };
	    
	    /**
	     * 设置该graph下的所有组件主题
	     * @param value 主题名称，或者主题json字符串内容；若不传则使用默认主题
	     */
	    this.setTheme = function(value) {
	    	
	    };
	    
	    /**
	     * 设置配置属性值
	     * @param key 属性键值(包括从该组件到属性的路径，比如legend.xPos或者legend.domain[0])
	     * @param value 属性值
	     * @return 返回是否设置成功
	     */
	    this.setConfigProperty = function(key, value) {
	    	var chart = self.getChildChart();
	    	return chart ? chart.setConfigProperty(key, value) : false;
	    };
	    
	    /**
	     * 设置数据内容
	     * @param value 数据内容，格式为：{data:[]}或者{nodes:[],links:[]}(支持字符串或者object格式),
	     *              或者'[[],...,[]]'(line,area,bar支持，配合seriesConfig设置使用，只支持字符串格式)等
	     * @param seriesIndex 更新数据所在图表的series索引值，默认为0
	     * @return 返回是否设置成功
	     */
	    this.setData = function(value, seriesIndex) {
	    	var chart = self.getChildChart();
	    	if(!chart) {
	    		return false;
	    	}
	        
	    	//若传入数据为字符串内容，则根据内容判断是否需要解析；若为非字符串内容则直接使用
	    	var config = chart.data();
	    	var isChart = config.type === "chart";
	        if(ObjectUtil.isString(value)) {
	        	var isShareSeries = false;
	            try {
	                //是否为数组json字符串或者对象格式
	                if(value.indexOf("[") === 0 || value.indexOf("{") === 0) {
	                    value = JSON.parse(value);
	                }
	                if(chart.data().hasOwnProperty("seriesConfig") || (ObjectUtil.isArray(value) && isChart)) {
	                	isShareSeries = true;
	                }
	            } catch(e) {
	                isShareSeries = false;
	            }
	            //解析共享series模式数据，格式为数组
	            if(isShareSeries) {
	            	var parent = chart.parent();
	            	parent.removeChild(chart);
	            	var data = chart.data();
	            	var series = [];
	            	data.series = series;
	            	//传入的是数组数据
	            	if(ObjectUtil.isArray(value)) {
	            		//若传入的是一维数组，则包装成二维数组
	            		if(value.length > 0 && !ObjectUtil.isArray(value[0])) {
	                        value = [value];
	                    }
	            	} else if(ObjectUtil.isObject(value) && value.hasOwnProperty("data")) {//传入的是对象数据
	            		value = [value.data];
	            	}
	            	for(var i = 0, len = value.length; i < len; i++) {
	            		series.push({data:[]});
	            	}
	            	DataParser.parse(data);
	            	renderChart(parent, data);
	            	for(var i = 0, len = value.length; i < len; i++) {
	                    var result = self.setData({data:value[i]}, i);
	                    if(!result) {
	                    	return false;
	                    }
	                }
	                DataParser.parse(chart.data());
	            	return true;
	            }
	        }
	        //普通series模式
	        var childrenCharts = isChart ? chart.children() : [chart];
	        if(childrenCharts.length === 0) {
	            return false;
	        }
	    	if(isNaN(seriesIndex) || seriesIndex < 0) {
	    		seriesIndex = 0;
	    	}
	    	if(seriesIndex > childrenCharts.length - 1) {
	    		seriesIndex = childrenCharts.length - 1;
	    	}
	    	var baseChart = childrenCharts[seriesIndex];
	        return baseChart.setData(value);
	    };
	    
	    /**
	     * 设置配置属性值成功后更新组件内容
	     * @param key 属性键值(包括从该组件到属性的路径，比如legend.xPos或者legend.domain[0])
	     * @param value 属性值
	     * @return 返回是否设置成功
	     */
	    this.setConfigPropertyAndUpdate = function(key, value) {
	        if(self.setConfigProperty(key, value)) {
	        	var chart = self.getChildChart();
	        	DataParser.parse(chart.data());
	            chart.update();
	            return true;
	        }
	        return false;
	    };
	    
	    /**
	     * 设置数据内容成功后更新组件内容
	     * @param value 数据内容，格式为：{data:[]}或者{nodes:[],links:[]}(支持字符串或者object格式),
	     *              或者'[[],...,[]]'(仅line,area,bar支持，配合seriesConfig设置使用，只支持字符串格式)等
	     * @param seriesIndex 更新数据所在图表的series索引值，默认为0
	     * @return 返回是否设置成功
	     */
	    this.setDataAndUpdate = function(value, seriesIndex) {
	        if(self.setData(value, seriesIndex)) {
	        	var chart = self.getChildChart();
	            chart.update();
	            return true;
	        }
	        return false;
	    };
	    
	    /**
	     * 获取唯一的子图表实例，若存在多个子图表实例，则返回第0个；若没有则返回null。
	     */
	    this.getChildChart = function() {
	        if(self.topComponent instanceof BaseComponent && self.topComponent.children().length > 0) {
	            return self.topComponent.children()[0];
	        } else if (self.topComponent && self.children().length > 0) {
	        	return self.children()[0];
	        }
	        return null;
	    };
	    
	    /**
	     * 获取所有子图表实例列表；若没有则返回空数组。
	     */
	    this.getChildCharts = function() {
	    	var charts = [];
	        if(self.topComponent instanceof BaseComponent) {
	            var children = self.topComponent.children();
	            for(var child, i = 0, len = children.length; i < len; i++) {
	            	child = children[i];
	            	if(child instanceof Chart) {
	            		charts.push(child);
	            	}
	            }
	        }
	        return charts;
	    };
	    
	    /**
	     * 若外层容器有scale，则必须调用该方法设置scale值，否则渲染位置和交互操作可能会出错
	     * @sX 不传默认为1
	     * @sY 不传默认为1
	     * @sZ 不传默认为1
	     */
	    this.setScale = function(sX, sY, sZ) {
	    	scaleX = isNaN(sX) ? 1 : sX;
	    	scaleY = isNaN(sY) ? 1 : sY;
	    	scaleZ = isNaN(sZ) ? 1 : sZ;
	    }
	    
	    /**
	     * 销毁基于该graph渲染的所有容器
	     */
	    this.destroy = function() {
	        var topCom = self.topComponent;
	        if(topCom instanceof BaseComponent) {
	            topCom.destroy();
	        }
	    };
	    
	    // 初始化
	    init();
	};
	
	Graph.struct = function(ghca_charts) {
	    Graph.prototype.constructor = Graph;
	};
	
	module.exports = Graph;


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {// 类工厂类
		
	// --------------------------------------------------------------------------
	// import
	// --------------------------------------------------------------------------
	
	var nodeMap = null;
	var linkMap = null;
	var pluginMap = null;
	var chartMap = null;
	
	var ClassFactory = {};
	
	// --------------------------------------------------------------------------
	//
	// static public Methods
	//
	// --------------------------------------------------------------------------
	
	ClassFactory.newPluginInstance = function(clazzName, args) {
	    if(!clazzName) {
	        return null;
	    }
	    if(pluginMap === null) {
	        pluginMap = new ghca_charts.view.elements.plugins.pluginMap().getMap();
	    }
	    var generator = pluginMap[clazzName.toLowerCase()];
	    var instance = generator ? new generator(args[0], args[1]) : null;
	    return instance;
	};
	
	ClassFactory.newChartInstance = function(clazzName, args) {
		if(!clazzName) {
			return null;
		}
		if(chartMap === null) {
	        chartMap = new ghca_charts.view.component.chartMap().getMap();
	    }
	    var generator = chartMap[clazzName.toLowerCase()];
	    var instance = generator ? new generator(args[0], args[1]) : null;
	    return instance;
	};
	
	ClassFactory.instanceofChart = function(ins) {
		if(!ins) {
			return false;
		}
		if(chartMap === null) {
	        chartMap = new ghca_charts.view.component.chartMap().getMap();
	    }
	    var c = ins.constructor;
	    return c.hasOwnProperty("clazzName") && chartMap.hasOwnProperty(c.clazzName.toLowerCase());
	};
	
	ClassFactory.newLinkInstance = function(clazzName, args) {
		if(!clazzName) {
	        return null;
	    }
		if(linkMap === null) {
	        linkMap = new ghca_charts.view.elements.plugins.linkMap().getMap();
	    }
		var generator = linkMap[clazzName.toLowerCase()];
	    var instance = generator ? new generator(args[0], args[1]) : null;   
	    return instance;
	};
	
	ClassFactory.newNodeInstance = function(clazzName, args) {
		if(!clazzName) {
	        return null;
	    }
		if(nodeMap === null) {
	        nodeMap = new ghca_charts.view.elements.plugins.nodeMap().getMap();
	    }
	    var generator = nodeMap[clazzName.toLowerCase()];
	    var instance = generator ? new generator(args[0], args[1], args[2]) : null;
	    return instance;
	};
	
	ClassFactory.newRenderersInstanceByData = function(parent, chart, className, itemsData, isNode, colorPropertyName, plugInCallBack) {
		if(!className || !itemsData || !parent || !chart) {
			return null;
		}
		if(isNode === undefined || isNode === null) {
	        isNode = true;
	    }
		if(!colorPropertyName) {
			colorPropertyName = "fill";
	    }
	    
		//只用当前可见的项作为渲染数据源
	    var d, itemData, itemIns, rendererConfig,
	        itemsIns = [], 
	        BaseComponent = ghca_charts.view.component.baseComponent;
	    for(var i = 0, len = itemsData.length; i < len; i++) {
	    	itemData = itemsData[i];
	    	rendererConfig = chart.getRendererConfig(itemData, colorPropertyName);
	    	
	    	//shape作为渲染器
	    	if(rendererConfig.type && rendererConfig.type.toLowerCase() === "shape") {
	    		//若节点渲染器是一个shape容器
	            var itemContent = ClassFactory.newNodeInstance(rendererConfig.clazz, [parent.mainContainer(), itemData]);
	            itemContent.className(className);
	            if(plugInCallBack) {
	                plugInCallBack.call(null, itemContent);
	            }
	            itemContent.render();
	            parent.normalChild(itemContent);
	            itemData.ins = itemContent;
	            itemData.legendIns = itemContent;
	            itemData.dragIns = itemContent;
	            continue;
	    	}
	    	
	    	//非shape作为渲染器
	        //创建节点容器
	        itemIns = new BaseComponent();
	        itemIns.className(className);
	        itemIns.isLight(true);
	        itemIns.title(itemData.title ? itemData.title : null);
	    	parent.addChild(itemIns);
	        //若节点渲染器是一个组件，则渲染该组件
	        if(rendererConfig.type && rendererConfig.type.toLowerCase() === "chart") {
	        	//绑定数据
	            itemIns.mainContainer().data([itemData]);
	            //实例化图表渲染器
	            var itemChart = new ClassFactory.newChartInstance(rendererConfig.type, [rendererConfig, null]);
	            itemChart.isRenderer(true);
	            itemIns.addChild(itemChart);
	            itemsIns.push(itemIns);
	            itemData.ins = itemChart;
	            itemData.legendIns = itemChart;
	            itemData.dragIns = itemIns;
	        } else {
	        	//若节点渲染器是一个plugin容器，则绑定数据，并刷新节点容器
	        	var itemUpdate = itemIns.mainContainer().data([itemData]);
	            itemUpdate.each(function (d, i) {
	            	var fn = isNode ? ClassFactory.newNodeInstance : ClassFactory.newLinkInstance;
	                var itemContent = fn(rendererConfig.clazz, [d3.select(this), d]);
	                if(plugInCallBack) {
	                	plugInCallBack.call(null, itemContent);
	                }
	                if(itemContent.config) {
	                	itemContent.config(rendererConfig.config);
	                }
	                // var ot=new Date().getTime();
	                itemContent.render();
	                // console.log("isNode:"+isNode+" "+(new Date().getTime()-ot));
	                itemIns.normalChild(itemContent);
	                itemsIns.push(itemIns);
	                d.ins = itemContent;
	                d.legendIns = itemContent;
	                d.dragIns = itemIns;
	            });
	        }
	    }
	    
	    return itemsIns;
	};
	
	module.exports = ClassFactory;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {//颜色工具类
	
	var ColorUtil = {};
	
	ColorUtil.d3Scheme20Colors = d3.schemeCategory20;
	ColorUtil.d3Scheme10Colors = d3.schemeCategory10;
	ColorUtil.echartColors = [
	    '#ff7f50','#87cefa','#da70d6','#32cd32','#6495ed',
	    '#ff69b4','#ba55d3','#cd5c5c','#ffa500','#40e0d0',
	    '#1e90ff','#ff6347','#7b68ee','#00fa9a','#ffd700',
	    '#6699FF','#ff6666','#3cb371','#b8860b','#30e0e0'
	];
	ColorUtil.defaultColors = ColorUtil.d3Scheme20Colors;
	var colorsFn = d3.scaleOrdinal(ColorUtil.defaultColors);
	
	// --------------------------------------------------------------------------
	//
	// static public Methods
	//
	// --------------------------------------------------------------------------
	
	/**
	 * 获取颜色
	 * @param index 该颜色在range中的索引值
	 * @param range 自定义颜色range数组，若不传则使用当前的colorsFn获取
	 * @return 返回颜色值
	 */
	ColorUtil.getColor = function(index, range) {
	    return (Object.prototype.toString.call(range) === "[object Array]" && range.length > 0) ? 
	        range[index % range.length] : 
	        colorsFn(index);
	};
	
	/**
	 * 设置颜色透明度
	 * @param color 颜色对象，如"#fff","white","rgb(255,255,255)"等格式
	 * @param alpha 透明度[0-1]
	 * @return 返回颜色值,rgba格式
	 */
	ColorUtil.setAlpha = function(color, alpha) {
		var d3Color = d3.color(color);
		if(!d3Color) {
			return color;
		}
	    var rgbaColor = d3.color(color).rgb();
	    rgbaColor.opacity = alpha;
	    return rgbaColor;
	};
	
	/**
	 * 设置颜色枚举序列数组，用法如下:
	 * <pre>
	 * const ColorUtil = ghca_charts.view.util.colorUtil;
	 * ColorUtil.setColors(ColorUtil.echartColors);
	 * graph.update();//必须刷新才能有效果
	 * </pre>
	 * @param value 颜色枚举序列数组，数组元素支持如"#fff","white","rgb(255,255,255)"等格式，若不传则使用defaultColors
	 */
	ColorUtil.setColors = function(colors) {
	    colorsFn = d3.scaleOrdinal(
	        (Object.prototype.toString.call(colors) === "[object Array]" && colors.length > 0) ? 
	        colors : ColorUtil.defaultColors);
	};
	
	/**
	 * 获取线性渐变定义
	 * @param svgNode svg元素
	 * @param colors 颜色数组
	 * @param opacitys 透明度数组，默认[1, 1]
	 * @param offsets 渐变偏移量数组，默认["0%", "100%"]
	 * @param isHor 渐变方向，默认true
	 */
	ColorUtil.getLinearGradientDef = function (svgNode, colors, opacitys, offsets, isHor) {
	    var UUIDUtil = ghca_charts.view.util.UUIDUtil;
	    var Constant = ghca_charts.view.util.constant;
	
	    var svg = d3.select(svgNode.ownerSVGElement);
	    var defs = svg.select("svg defs");
	    if(defs.node() === null) {
	        defs = svg.append("defs");
	    }
	    var length = colors.length,
	        rate = Math.floor(100/length),
	        id = UUIDUtil.generateUUID();
	    var lg = defs.append("svg:linearGradient").attr("id",id);
	    if(Constant.HOR_DRAG_TYPE === direction) {
	    	lg.attr("y1",1).attr("y2",1).attr("x1",0).attr("x2",1);
	    } else {
	    	lg.attr("y1",0).attr("y2",1).attr("x1",1).attr("x2",1);
	    }
	    colors.forEach(function (color, i){
	        var stop = lg.append("stop").attr("stop-color",color);
	        if(i==length-1)
	            stop.attr("offset","100%");
	        else
	            stop.attr("offset",i*rate+"%");
	    });
	    return id;
	}
	
	module.exports = ColorUtil;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 117 */
/***/ (function(module, exports) {

	// 一般工具类
	
	var CommonUtil = {};
	
	// --------------------------------------------------------------------------
	//
	// static public Methods
	//
	// --------------------------------------------------------------------------
	
	/**
	 * 获取当前浏览器类型
	 * 
	 * @return 返回浏览器类型
	 */
	CommonUtil.getBrowserType = function() {
	    var userAgent = navigator.userAgent; // 取得浏览器的userAgent字符串
	    // 判断是否Opera浏览器
	    var isOpera = userAgent.indexOf("Opera") > -1;
	    if (isOpera) {
	        return "Opera"
	    }; 
	    // 判断是否IE11以下浏览器
	    if (userAgent.indexOf("compatible") > -1 && userAgent.indexOf("MSIE") > -1 && !isOpera) {
	        return "IE";
	    };
	    // 判断是否Edge浏览器
	    if (userAgent.indexOf("Edge") > -1) {
	        return "Edge";
	    } 
	    // 判断是否IE11浏览器
	    if (window.ActiveXObject || "ActiveXObject" in window) {
	        return "IE";
	    }
	    // 判断是否Firefox浏览器
	    if (userAgent.indexOf("Firefox") > -1) {
	        return "Firefox";
	    } 
	    // 判断是否Safari浏览器
	    if (userAgent.indexOf("Safari") > -1 && userAgent.indexOf("Chrome") == -1) {
	        return "Safari";
	    }
	    // 判断是否Chrome浏览器
	    if (userAgent.indexOf("Chrome") > -1 && userAgent.indexOf("Safari") > -1) {
	        return "Chrome";
	    }
	};
	
	CommonUtil.browserType = CommonUtil.getBrowserType();
	
	CommonUtil.isIE = function() {
	    return "IE" === CommonUtil.browserType;
	};
	
	CommonUtil.isFirefox = function() {
	    return "Firefox" === CommonUtil.browserType;
	};
	
	CommonUtil.isChrome = function() {
	    return "Chrome" === CommonUtil.browserType;
	};
	
	CommonUtil.isOpera = function() {
	    return "Opera" === CommonUtil.browserType;
	};
	
	CommonUtil.isSafari = function() {
	    return "Safari" === CommonUtil.browserType;
	};
	
	CommonUtil.isEdge = function() {
	    return "Edge" === CommonUtil.browserType;
	};
	
	/**
	 * 根据读取的配置信息和默认配置信息创建新的配置信息
	 * @param defaultConfig 默认配置对象
	 * @param config 从配置文件中获取的配置对象
	 */
	CommonUtil.createConfig = function(defaultConfig, config) {
	    if(!defaultConfig || !config) {
	        return null;
	    }
	    for(var k in config) {
	        if(k === "style") {
	            for(var m in config.style) {
	                if(!defaultConfig.style) {
	                    defaultConfig.style = {};
	                }
	                defaultConfig.style[m] = config.style[m];
	            }
	        } else {
	            defaultConfig[k] = config[k];
	        }
	    }
	    return defaultConfig;
	};
	
	/**
	 * 设置d3元素集合样式
	 * @param group d3元素集合，如d3.selectAll(".className")
	 * @param styleConfig style配置对象
	 */
	CommonUtil.setGroupStyle = function(group, styleConfig) {
	    if(!group||!group.node() || !styleConfig) {
	        return;
	    }
	    var obj;
	    group.each(function() {
	        obj = this;
	        //这样写兼容"stroke-Width"和"strokeWidth"写法
	        for(var k in styleConfig) {
	            obj.style[k] = styleConfig[k];
	        }
	    });
	};
	
	/**
	 * 设置d3元素集合属性
	 * @param group d3元素集合，如d3.selectAll(".className")
	 * @param attrConfig attr配置对象
	 */
	CommonUtil.setGroupAttr = function(group, attrConfig) {
	    if(!group||!group.node() || !attrConfig) {
	        return;
	    }
	    for(var k in attrConfig) {
	        group.attr(k, attrConfig[k]);
	    }
	};
	
	module.exports = CommonUtil;


/***/ }),
/* 118 */
/***/ (function(module, exports) {

	//常量类
	var Const = {};
	
	// --------------------------------------------------------------------------
	//
	// static public Const
	//
	// --------------------------------------------------------------------------
	
	Const.NO_SCALE_TYPE                 = -1;   //禁止缩放
	Const.COMPONENT_SCALE_TYPE          = 0;    //组件整体缩放
	Const.LAYOUT_SCALE_TYPE             = 1;    //布局关系缩放
	Const.LAYOUT_HOR_SCALE_TYPE         = 2;    //布局关系缩放，只对水平方向缩放
	Const.LAYOUT_VER_SCALE_TYPE         = 3;    //布局关系缩放，只对垂直方向缩放
	
	Const.HOR_DRAG_TYPE     = "hor";    //仅水平方向可拖动
	Const.VER_DRAG_TYPE     = "ver";    //仅垂直方向可拖动
	Const.FREE_DRAG_TYPE    = "free";   //任意方向拖动
	Const.FIX_DRAG_TYPE     = "fix";    //不能拖动
	Const.TREE_RADIAL_TYPE  = "radial";
	Const.TREE_HOR_TYPE     = "hor";
	Const.TREE_VER_TYPE     = "ver";
	
	Const.SORT_DESC = "desc";   //降序
	Const.SORT_ASC  = "asc";    //升序
	Const.SORT_NONE = "none";   //禁用排序
	
	module.exports = Const;

/***/ }),
/* 119 */
/***/ (function(module, exports) {

	//数据解析器类
	var DataParser = {};
	
	// --------------------------------------------------------------------------
	//
	// static public Methods
	//
	// --------------------------------------------------------------------------
	
	/**
	 * 解析数据
	 * @param data 数据对象
	 * @param isSeries 是否是series元素
	 * @param seriesConfig 图表序列对象统一的配置数据，若序列对象单独设置了自己的配置内容，则按序列自己的设置渲染
	 */
	DataParser.parse = function(data, isSeries, seriesConfig) {
		if(!data) {
			return;
		}
		replacePercentPosAndSize(data);
		parseSeriesConfig(data, isSeries, seriesConfig);
		parseChildrenOrSeries(data);
	};
	
	/**
	 * 解析非图表子对象或者图表series子对象
	 */
	const parseChildrenOrSeries = function(data) {
		var ObjectUtil = ghca_charts.view.util.objectUtil;
		//只有chart类型才有series
		var isSeries = data.type === "chart";
		var children = isSeries ? data.series : data.children;
		var seriesConfig = isSeries ? data.seriesConfig : null;
		if(ObjectUtil.isArray(children)) {
			for(var child, i = 0, len = children.length; i < len; i++) {
				child = children[i];
				//seriesConfig图表补全series中二维数组中第一维元素的data结构,即series:[[],[]]变为series:[{data:[]},{data:[]}]
				if(isSeries && seriesConfig && !ObjectUtil.isArray(child.data)) {
					children[i] = {data:children[i]};
				}
				DataParser.parse(children[i], isSeries, seriesConfig);
			}
		}
	};
	
	/**
	 * 解析配置中x、y、z、width、height属性中的百分比类型值
	 */
	const replacePercentPosAndSize = function(data) {
		var ObjectUtil = ghca_charts.view.util.objectUtil;
	    var RegexUtil = ghca_charts.view.util.regexUtil;
		var replaceFn = function(d, sourceKey, targetKey) {
			if(!d.hasOwnProperty(sourceKey)) {
				return;
			}
	        var value = d[sourceKey];
	        if(!ObjectUtil.isString(value)) {
	        	return;
	        }
	        var result = value.match(RegexUtil.percentRegex);
	        if(result === null) {
	        	return;
	        }
	        var pv = parseFloat(result[1]);
	        if(isNaN(pv)) {
	        	return;
	        }
	        d[targetKey] = pv;
		};
		replaceFn(data, "x", "percentX");
		replaceFn(data, "y", "percentY");
		replaceFn(data, "z", "percentZ");
		replaceFn(data, "width", "percentWidth");
		replaceFn(data, "height", "percentHeight");
	};
	
	/**
	 * 解析并补全设置配置中图表序列共用属性
	 * @param data 数据对象
	 * @param isSeries 是否是series元素
	 * @param seriesConfig 若图表数据含有共享序列配置，则图表序列对象统一使用该共享配置数据
	 */
	const parseSeriesConfig = function(data, isSeries, seriesConfig) {
		if(!isSeries) {
			return;
		}
		//复制seriesConfig到每个serie
		if(data.useSeriesConfig !== false && seriesConfig) {
			var ObjectUtil = ghca_charts.view.util.objectUtil;
			var config = ObjectUtil.cloneObj(seriesConfig);
			//复制属性
			for(var key in config) {
				data[key] = config[key];
			}
			//复制渲染器名称到对应数据项
			var d = data.data;
			if(ObjectUtil.isArray(d) && d.length > 0 && data.renderers) {
				var renderers = data.renderers;
				for(var rendererName in renderers) {
					break;
				}
				if(rendererName) {
					for(var i = 0, len = d.length; i < len; i++) {
						d[i].renderer = rendererName;
					}
				}
			}
		}
		//根据chart type补全默认布局
		if(!data.type) {
			return;
		}
		var layoutData = data.layout;
	    if(!layoutData || !layoutData.type) {
	    	layoutData = {};
	    	data.layout = layoutData;
	    	var type;
	        switch(data.type.toLowerCase()) {
	            case "topo":
	                type = "topoLayout";
	                break;
	            case "tree":
	                type = "treeLayout";
	                break;
	            case "sankey":
	                type = "sankeyLayout";
	                break;
	            case "pie":
	                type = "pieLayout";
	                break;
	            case "sunburst":
	                type = "sunburstLayout";
	                break;
	            case "scatter":
	            case "line":
	            case "area":
	                type = "scatterLayout";
	                break;
	             case "bar":
	                type = "barLayout";
	                break;
	            case "treemap":
	                type = "treemapLayout";
	                break;
	            case "calendar":
	                type = "calendarLayout";
	                break;
	            case "pack":
	                type = "packLayout";
	                break;
	            case "progressBar":
	                type = "progressBarLayout";
	                break;
	            default:
	                type = "layout";
	                break;
	        }
	        if(type) {
	        	layoutData.type = type;
	        }
	    }
	};
	
	
	/**
	 * pie图表要组装的数据结构如下 
	 * {
	 *     type:"pie",
	 *     data:[
	 *         {renderer:'1', id:1, value:3},
	 *         {renderer:'1', id:2, value:1}
	 *     ]
	 * }
	 */
	DataParser.createPieData = function(chartData, itemData) {
		if(chartData.key && chartData.key !== "") {
	        var key = chartData.key;
	        var keyPath = chartData.keyPath;
	        var renderer = chartData.itemRenderer;
	        if(!renderer) {
	            for(var k in itemData.renderers) {
	                renderer = k;
	            }
	        }
	        if((keyPath === "" && itemData.hasOwnProperty(key)) || 
	        (keyPath !== "" && eval("itemData." + keyPath) && eval("itemData." + keyPath)[key])) {
	            var keyPath;
	            if(chartData.keyPath && chartData !== "") {
	                keyPath = chartData.keyPath;
	            }
	            var data = keyPath ? itemData[keyPath][key] : itemData[key];
	            var result = [];
	            var i = 1;
	            //若value是一个对象，则把对象的所有属性打散设置的Pie的itemData里面，
	            //若不是，则直接在itemData里动态添加itemData.value = value
	            data.forEach(function(value) {
	            	if(value !== null &&　value　!== undefined) {
	            		var hasPorperty = false, item = {};
	            		for(var k in value) {
	            			item[k] = value[k];
	            			hasPorperty = true;
	            		}
	            		if(!hasPorperty) {
	            			item.value = value;
	            		}
	            		item.id = i++;
	            		if(renderer !== undefined) {
	            			item.renderer = renderer;
	            		}
	                    result.push(item);
	            	}
	            });
	            chartData.data = result;
	        }
	    }
	    return chartData;
	}
	
	/**
	 * 创建图表数据
	 * @param chartData 配置中的图表原始数据
	 * @param itemData 配置中的该图表的上一级图表作为子图表项的数据
	 * @return 返回组装好的图表数据
	 */
	DataParser.createChartData = function(chartData, itemData) {
		if(!chartData || !itemData) {
			return null
		}
		
		switch(chartData.type.toLowerCase()) {
			case "pie":
			case "area":
			case "line":
			case "bar":
			case "scatter":
	            chartData = DataParser.createPieData(chartData, itemData);
	            break;
			default:
	            break;
		}
		return chartData;
	};
	
	module.exports = DataParser;

/***/ }),
/* 120 */
/***/ (function(module, exports) {

	var ElementUtil = {};
	
	ElementUtil.setElementProperties = function(element,properties){
	    if(element && properties){
	        for (var key in properties) {
	            element.attr(key,properties[key]);
	        }
	    }
	};
	ElementUtil.setElementStyles = function(element,properties){
	    if(element && properties){
	        for (var key in properties) {
	            element.style(key,properties[key]);
	        }
	    }
	};
	ElementUtil.createText = function(element,properties){
	    var text = element.append("text");
	    ElementUtil.setElementProperties(text,properties);
	    return text;
	};
	
	ElementUtil.createRect = function(element,properties){
	    var text = element.append("rect");
	    ElementUtil.setElementProperties(text,properties);
	    return text;
	};
	ElementUtil.createCircle = function(element,properties){
	    var text = element.append("circle");
	    ElementUtil.setElementProperties(text,properties);
	    return text;
	};
	ElementUtil.createPath = function(element,properties){
	    var text = element.append("path");
	    ElementUtil.setElementProperties(text,properties);
	    return text;
	};
	
	module.exports = ElementUtil;

/***/ }),
/* 121 */
/***/ (function(module, exports) {

	// 事件工具类
	
	var EventUtil = {};
	
	// --------------------------------------------------------------------------
	//
	// static public Methods
	//
	// --------------------------------------------------------------------------
	
	/**
	 * 获取自定义事件实例
	 * 支持EventUtil.createCustomEvent(type, bubble, cancelable, detail)和
	 * EventUtil.createCustomEvent(type, {bubble:bubble, cancelable:cancelable, detail:detail})参数传入模式
	 * 
	 */
	EventUtil.createCustomEvent = function(type, bubble, cancelable, detail) {
		var event;
		if(ghca_charts.view.util.commonUtil.isIE()) {
	        var event = document.createEvent("CustomEvent");
	        if(arguments.length > 1 && Object.prototype.toString.call(arguments[1]) === "[object Object]") {
	        	var obj = arguments[1];
	            event.initCustomEvent(type, obj.bubble, obj.cancelable, obj.detail);
	        } else {
	            event.initCustomEvent(type, bubble, cancelable, detail);
	        }
		} else {
			if(arguments.length > 1 && Object.prototype.toString.call(arguments[1]) === "[object Object]") {
	            event = new CustomEvent(type, arguments[1]);
	        } else {
	            event = new CustomEvent(type, {bubbles:bubble, cancelable:cancelable, detail:detail});
	        }
		}
		return event;
	};
	
	/**
	 * 获取事件实例
	 * 支持EventUtil.createEvent(type, bubble, cancelable)和
	 * EventUtil.createEvent(type, {bubble:bubble, cancelable:cancelable})参数传入模式
	 * 
	 */
	EventUtil.createEvent = function(type, bubble, cancelable) {
	    var event;
	    if(ghca_charts.view.util.commonUtil.isIE()) {
	        var event = document.createEvent("Event");
	        if(arguments.length > 1 && Object.prototype.toString.call(arguments[1]) === "[object Object]") {
	            var obj = arguments[1];
	            event.initEvent(type, obj.bubble, obj.cancelable);
	        } else {
	            event.initEvent(type, bubble, cancelable);
	        }
	    } else {
	        if(arguments.length > 1 && Object.prototype.toString.call(arguments[1]) === "[object Object]") {
	            event = new Event(type, arguments[1]);
	        } else {
	            event = new Event(type, {bubbles:bubble, cancelable:cancelable});
	        }
	    }
	    return event;
	};
	
	/**
	 * 抛出dom事件，要传自定义数据，写法如下：
	 * var evt = EventUtil.createCustomEvent("event type", true, true, your data);
	 * EventUtil.dispatchEvent(node, evt);
	 * function(e) {
	 *     e.detail : your data,
	 *     this : node,
	 * }
	 */
	EventUtil.dispatchEvent = function() {
	    var node = arguments[0];
	    if(!node){
	        return;
	    }
	    var fn = node.dispatchEvent;
	    if(fn && arguments.length > 1) {
	        var evt = arguments[1];
	        fn.apply(node, [evt]);
	    }
	};
	
	module.exports = EventUtil;


/***/ }),
/* 122 */
/***/ (function(module, exports) {

	var FileUtil={};
	var fileID=0;
	var loadMap={};//加载信息
	var loadedMap={};//已加载
	var loadingMap={};//正在加载
	var errorMap={};//错误记录
	/**
	 * 按配置顺序加载文件列表到dom上
	 */
	FileUtil.loadFiles=function(files, callback) {
	    if(!files||!files.length){
	        callback&&callback();
	        return;
	    }
	    fileID++;
	    var loadInfo={
	        id:"loadFile"+fileID,
	        files:files,//加载列表
	        loadedNum:0,//已加载数量
	        targetNum:files.length,//目标数量
	        completeHandler:callback,//完成回调
	        isWaiting:false,//是否等待加载
	    }
	
	    loadMap[loadInfo.id]=loadInfo;
	    
	    loadFile(loadInfo);
	};
	
	/**
	 * 按配置id替换dom上指定文件
	 */
	FileUtil.replaceFile=function(id,file,callback){
	    if(file.indexOf(".css") !== -1) {
	        replaceCSS(id,file,callback);
	    } else if(file.indexOf(".js") !== -1) {
	        replaceJS(id,file,callback);
	    }
	}
	
	function replaceCSS(id,file,callback){
	    var css = document.createElement('link');
	    css.rel = 'stylesheet';
	    css.type = 'text/css';
	    css.href = file;
	    css.id=id;
	    var url=css.url;
	    css.onload=function(){
	        if(callback){
	            callback();
	        }
	        loadedMap[url]=true;
	    };
	    var target=document.getElementById(id);
	    if(target){
	        if(target.href===url){//一致
	            loadedMap[url]=true;
	            if(callback){
	                callback();
	            }
	        }else{
	            target.parentNode.replaceChild(css,target);
	        }
	    }else{
	        var head = getHead();
	        head.appendChild(css);
	    }
	}
	
	function replaceJS(id,file,callback){
	    var script = document.createElement('script');
	    script.type = 'text/javascript';
	    script.charset = "utf-8"
	    script.src = file;
	    script.id=id;
	    script.onload=function(){
	        if(callback){
	            callback();
	        }
	        loadedMap[script.src]=true;
	    };
	    var target=document.getElementById(id);
	    if(target){
	        if(target.src===script.src){
	            loadedMap[script.src]=true;
	            if(callback){
	                callback();
	            }
	        }else{
	            target.parentNode.replaceChild(script,target);
	        }
	    }else{
	        var head = getHead();
	        head.appendChild(script);
	    }
	}
	
	function loadFile(loadInfo){
	    var file=loadInfo.files[loadInfo.loadedNum];
	    if(file.indexOf(".css") !== -1) {
	        loadCss(loadInfo);
	    } else if(file.indexOf(".js") !== -1) {
	        loadJs(loadInfo);
	    }
	}
	
	function loadCss(loadInfo){
	    var css = document.createElement('link');
	    css.rel = 'stylesheet';
	    css.type = 'text/css';
	    css.href=loadInfo.files[loadInfo.loadedNum];
	    addFileTag(css,css.href,loadInfo)
	}
	
	function loadJs(loadInfo){
	    var script = document.createElement('script');
	    script.type = 'text/javascript';
	    script.charset = "utf-8"
	    script.src = loadInfo.files[loadInfo.loadedNum];
	    addFileTag(script,script.src,loadInfo)
	
	}
	
	function addFileTag(tag,url,loadInfo){
	    if(isLoaded(url)){
	        loadInfo.isWaiting=false;      
	        loadInfo.loadedNum=loadInfo.loadedNum+1;
	        completeByLoadInfo(loadInfo);
	
	    }else if(isLoading(url)){
	        loadInfo.isWaiting=true;        
	    }else{
	        loadInfo.isWaiting=false;  
	        addHandles(tag,loadInfo);
	        loadingMap[url]=true;
	        var head = getHead();
	        head.appendChild(tag);
	    }
	}
	
	function isLoaded(url){
	    return loadedMap[url];
	}
	
	function isLoading(url){
	    return loadingMap[url];
	}
	
	function getHead() {
	    var head = document.getElementsByTagName('head').item(0);
	    if(!head) {
	        head = document.createElement('head');
	        document.appendChild(head);
	    }
	    return head;
	};
	
	function addHandles(tag, loadInfo) {
	    var url;
	    if(tag.type==="text/javascript"){
	        url=tag.src;
	    }else if(tag.type==="text/css"){
	        url=tag.href;
	    }
	    tag.onload = function() {     
	    	ghca_charts.global.isDebug && console.log("onload:",url);
	        loadedMap[url]=true;
	        delete loadingMap[url];
	        loadInfo.loadedNum=loadInfo.loadedNum+1;
	        completeByLoadInfo(loadInfo);
	        removeWaitingInfo();
	    };
	
	    var errorNum=errorMap[url]?errorMap[url]:0;
	    tag.onerror = function() {
	        errorNum++;
	        errorMap[url]=errorNum;
	        
	        if(errorNum >= 2) {//超过两次直接丢弃
	            delete loadingMap[url];            
	            delete  errorMap[url];            
	            loadInfo.loadedNum=loadInfo.loadedNum+1;
	            completeByLoadInfo(loadInfo);
	            removeWaitingInfo();
	        } else {//加载错误次数小于2次，则重新尝试加载            
	            loadFile(loadInfo);
	        }
	    };
	};
	
	function completeByLoadInfo(loadInfo){
	    if(loadInfo.loadedNum===loadInfo.targetNum){//所有加载完成并且无等待加载
	        delete loadMap[loadInfo.id];//删除记录
	        loadInfo.completeHandler();//执行回调
	    }
	    if(loadInfo.loadedNum<loadInfo.targetNum){
	        loadFile(loadInfo);
	    }
	}
	
	function removeWaitingInfo(){
	   for (var key in loadMap) {
	      var loadInfo=loadMap[key];      
	      if(loadInfo.isWaiting){//加载等待中的
	        loadFile(loadInfo);//重新加载
	      }
	   }
	}
	
	module.exports=FileUtil;

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {/**
	 * Contains a collection of mathematical functions with some additional data
	 * used for WebVOWL.
	 */
	
	var math = {};
	
	math.TWO_PI = Math.PI * 2;
	
	/**
	 * 获取指定角度，及半径 坐标
	 * @param radius
	 * @param angle
	 * @param point  中点坐标
	 * @returns {*[]}
	 */
	math.circumferencePoint = function(radius,angle,point){
		if(arguments.length<3)point={x:0,y:0};
		return [point.x+radius * Math.cos(angle), point.y+radius * Math.sin(angle)];
	}
	
	math.radialLinkAngle = function(source,target){
		var spoint = math.circumferencePoint(source.y,(source.x - 90) / 180 * Math.PI),
			epoint = math.circumferencePoint(target.y,(target.x - 90) / 180 * Math.PI);
		return math.linkAngle({x:spoint[0],y:spoint[1]},{x:epoint[0],y:epoint[1]});
	}
	
	math.radialCenterPoint = function(source,target){
		var spoint = math.circumferencePoint(source.y,(source.x - 90) / 180 * Math.PI),
		epoint = math.circumferencePoint(target.y,(target.x - 90) / 180 * Math.PI);
		return math.calculateCenter({x:spoint[0],y:spoint[1]},{x:epoint[0],y:epoint[1]});
	}
	
	math.radialLinkPath = function(source,target){
		//以x坐标为角度，y坐标为半径获取坐标
		var cxy = {x:source.cx,y:source.cy};
		return "M" + math.circumferencePoint(source.r,source.angle,cxy)
			+ "C" + math.circumferencePoint((source.r + target.r) / 2,source.angle,cxy)
			+ " " + math.circumferencePoint((source.r + target.r) / 2,target.angle,cxy)
			+ " " + math.circumferencePoint(target.r,target.angle,cxy)
		// return "M" + math.circumferencePoint(source.y,(source.x - 90) / 180 * Math.PI)
		// 	+ "C" + math.circumferencePoint((source.y + target.y) / 2,(source.x - 90) / 180 * Math.PI)
		// 	+ " " + math.circumferencePoint((source.y + target.y) / 2,(target.x - 90) / 180 * Math.PI)
		// 	+ " " + math.circumferencePoint(target.y,(target.x - 90) / 180 * Math.PI)
	}
	
	/**
	 * 获取折线路径
	 * @param source 起点{x:x, y:y}
	 * @param target 终点{x:x, y:y}
	 * @param isVer  是否是垂直方向
	 * @param addSize  折线中段两端额外伸出的线段长度
	 */
	math.polylinePath = function(source,target,isVer,addSize){
		var dx = target.x - source.x;
		var dy = target.y - source.y;
		if(dx === 0 || dy === 0) {
			return "M" + [source.x, source.y] + "L" + [target.x, target.y];
		}
		var halfX = source.x + dx/2;
		var halfY = source.y + dy/2;
		addSize = isNaN(addSize) ? 0 : addSize;
		if(isVer) {
			addSize = source.x < target.x ? -addSize : addSize;
			return "M" + [source.x, source.y] + 
	           "L" + [source.x, halfY] + 
	           "L" + [source.x+addSize, halfY] + 
	           "L" + [target.x, halfY] + 
	           "L" + [target.x, target.y];
		}
		addSize = source.y < target.y ? -addSize : addSize;
	    return "M" + [source.x, source.y] + 
	           "L" + [halfX, source.y] + 
	           "L" + [halfX, source.y+addSize] + 
	           "L" + [halfX, target.y] + 
	           "L" + [target.x, target.y];
	}
	
	math.besselLinkPath = function(source,target,x){
		var p0 = source,
			p3 = target,m;
		var path = d3.path();
		path.moveTo(p0.x,p0.y);
		if(x){
			m = (p0.x + p3.x) / 2;
			path.bezierCurveTo(Math.round(m),Math.round(p0.y),Math.round(m),Math.round(p3.y),Math.round(p3.x),Math.round(p3.y));
		}else{
			m = (p0.y + p3.y) / 2;
			path.bezierCurveTo(Math.round(p0.x),Math.round(m),Math.round(p3.x),Math.round(m),Math.round(p3.x),Math.round(p3.y));
		}
		return path.toString();
	}
	
	math.quadraticCurveLinkPath = function(source,target,offset,num,cx,cy){
		var controlX, controlY;
		if(cx !== undefined && cy !== undefined) {
			controlX = cx;
	        controlY = cy;
		} else {
			var array = math.parallelDeviationPoint(source,target,offset,num);
	        controlX = array[1].x;
			controlY = array[1].y;
		}
		var path  = d3.path();
		path.moveTo(Math.round(source.x),Math.round(source.y));
		path.quadraticCurveTo(Math.round(controlX),Math.round(controlY),Math.round(target.x),Math.round(target.y));
		return path.toString();
	};
	
	math.quadraticCurveLinkPathWithControlPoint = function(source,target,cx,cy){
	    // var array = math.parallelDeviationPoint(source,target,offset,num);
	    var path  = d3.path();
	    path.moveTo(source.x,source.y);
	    path.quadraticCurveTo(cx,cy,target.x,target.y);
	    return path.toString();
	};
	
	math.baseLinkPath = function(source,target){
		var path  = d3.path();
		path.moveTo(source.x,source.y);
		path.lineTo(target.x,target.y);
		return path.toString();
	};
	/**
	 * Calculates the normal vector of the path between the two nodes.
	 * @param source the first node
	 * @param target the second node
	 * @param length the length of the calculated normal vector
	 * @returns {{x: number, y: number}}
	 */
	math.calculateNormalVector = function (source, target, length) {
		var dx = target.x - source.x,
			dy = target.y - source.y;
	
		var nx = -dy,
			ny = dx;
	
		var vlength = Math.sqrt(nx * nx + ny * ny);
	
		var ratio = vlength !== 0 ? length / vlength : 0;
	
		return {"x": nx * ratio, "y": ny * ratio};
	};
	
	/**
	 * @param angle
	 * @returns {number} the radian of the angle
	 */
	function calculateRadian(angle) {
		angle = angle % 360;
		if (angle < 0) {
			angle = angle + 360;
		}
		return (Math.PI * angle) / 180;
	}
	
	/**
	 * @param radian
	 * @returns {number} the angle of the radian
	 */
	function calculateAngle(radian) {
		return radian * (180 / Math.PI);
	}
	
	/**
	 * Calculates the point where the link between the source and target node
	 * intersects the border of the target node.
	 * @param source the source node
	 * @param target the target node
	 * @param additionalDistance additional distance the
	 * @returns {{x: number, y: number}}
	 */
	math.calculateIntersection = function (source, target, additionalDistance) {
		var dx = target.x - source.x,
			dy = target.y - source.y,
			length = Math.sqrt(dx * dx + dy * dy);
	
		console.info("length"+length);
	
		if (length === 0) {
			return {x: source.x, y: source.y};
		}
	
		// var innerDistance = target.distanceToBorder(dx, dy);
		innerDistance = 188;
	
		var ratio =2,//= (length - (innerDistance + additionalDistance)) / length,
			x = dx * ratio + source.x,
			y = dy * ratio + source.y;
	
		return {x: x, y: y};
	};
	
	/**
	 * Calculates the position between the two points.
	 * @param firstPoint
	 * @param secondPoint
	 * @returns {{x: number, y: number}}
	 */
	math.calculateCenter = function (firstPoint, secondPoint) {
		return {
			x: (firstPoint.x + secondPoint.x) / 2,
			y: (firstPoint.y + secondPoint.y) / 2
		};
	};
	/**
	 * 获取两点连线的角度值
	 * @param _source
	 * @param _target
	 * @returns {number}
	 */
	math.linkAngle = function(_source,_target){
		var source = _target.y > _source.y?_target: _source;
		var target = _target.y > _source.y?_source: _target;
		//计算直角三角形长度
		var xylength = Math.sqrt(Math.pow(source.x-target.x,2)+Math.pow(source.y-target.y,2));
		//获取直角三角形x轴长度
		var xlength  = source.x>target.x?source.x - target.x:target.x-source.x;
		//获取角度
		var a = xylength === 0 ? 0 : Math.asin(xlength/xylength)/Math.PI*180;
		var angle = 0;
		var areaAngle = 90;
		source.x>target.x? (angle = areaAngle-a):(angle=areaAngle+a);
		//计算位置时选择y值大的当做起始节点，so
		if(_source.x>_target.x && _source.y<_target.y)angle+=180;
		if(_source.x<_target.x && _source.y>_target.y)angle-=180;
		return angle;
	}
	
	/**
	 * 树形图的贝塞尔曲线
	 * @param d
	 * @param i
	 * @returns {string}
	 */
	math.treeBessel = function diagonal(d, i,hlayout) {
		var p0 = d,
			p3 = i,m,p;
		var path = d3.path();
		path.moveTo(p0.x,p0.y);
		if(hlayout){
			m = (p0.x + p3.x) / 2;
			path.bezierCurveTo(m,p0.y,m,p3.y,p3.x,p3.y);
		}else{
			m = (p0.y + p3.y) / 2;
			path.bezierCurveTo(p0.x,m,p3.x,m,p3.x,p3.y);
		}
		return path.toString();
	}
	/**
	 * 折线坐标
	 * @param source
	 * @param target
	 * @param direction折线方向
	 * @param offset
	 * @param index
	 * @returns {*[]}
	 */
	math.foldLinkPoint = function(source,target,direction,offset,index){
		if (source.x==target.x||source.y==target.y) return [source, target];
		var Constant = ghca_charts.view.util.constant;
		var points = [];
		var level = index%2==0?Math.floor(index/2):Math.ceil(index/2);
		var x, y,
			gap=index%2==0?level*offset:-level*offset;
		return Constant.HOR_DRAG_TYPE == direction ? (x = target.x + gap, y = source.y - gap, points.push({
			x: source.x,
			y: y
		}), points.push({
			x: x,
			y: y
		}), points.push({
			x: x,
			y: target.y
		})) : (x = source.x + gap, y = target.y - gap, points.push({
			x: x,
			y: source.y
		}), points.push({
			x: x,
			y: y
		}), points.push({
			x: target.x,
			y: y
		})),points;
	}
	/**
	 * @param source 源{x,t}
	 * @param target  目标{x,t}
	 * @param offset {偏移量} 默认5， 5的倍数
	 * @param index  偏移计数
	 * @returns {Array}
	 */
	math.parallelDeviationPoint = function(source,target,offset,index){
		//算出连线角度
		var angle = math.linkAngle(source,target);
		//算出层级
		var level = index%2==0?Math.floor(index/2):Math.ceil(index/2);
		//获取以连线角度为起始角度的两边直角的度数
		var angle = index%2==0?angle+270:angle+90;
		//获得半径
		var r = level*offset;
		//获得偏移的起始结束坐标
		var sary = math.circumferencePoint(r,angle *   Math.PI   /180,source);
		var eary = math.circumferencePoint(r,angle *   Math.PI   /180,target);
		return [{"x":sary[0],"y":sary[1]},{"x":(sary[0]+eary[0])/2,"y":(sary[1]+eary[1])/2},{"x":eary[0],"y":eary[1]}];
	}
	
	/**
	 * 求两条线段交点坐标，若相交返回[x,y],若不相交则返回null
	 * @param x1,y1,x2,y2 一条线段的两个端点坐标
	 * @param x3,y3,x4,y4 另外一条线段的两个端点坐标
	 */
	math.getCrossPointInTwoSegments = function(x1,y1,x2,y2,x3,y3,x4,y4) {
	    if(isRectCross(x1,y1,x2,y2,x3,y3,x4,y4)) {
	        if (isLineSegmentCross(x1,y1,x2,y2,x3,y3,x4,y4)) {
	            //求交点
	            var x,y,tmpLeft,tmpRight;
	            tmpLeft = (x4 - x3) * (y1 - y2) - (x2 - x1) * (y3 - y4);
	            tmpRight = (y1 - y3) * (x2 - x1) * (x4 - x3) + x3 * (y4 - y3) * (x2 - x1) - x1 * (y2 - y1) * (x4 - x3);
	
	            x = tmpRight/tmpLeft;
	
	            tmpLeft = (x1 - x2) * (y4 - y3) - (y2 - y1) * (x3 - x4);
	            tmpRight = y2 * (x1 - x2) * (y4 - y3) + (x4- x2) * (y4 - y3) * (y1 - y2) - y4 * (x3 - x4) * (y2 - y1); 
	            y = tmpRight/tmpLeft;
	            return [x,y];
	        }
	    }
	    return null;
	};
	
	/**
	 * 求矩形与一条线段从起点到终点的第一个交点坐标，若相交返回[x,y],若不相交则返回null
	 * @param rx,ry,w,h 矩形数据
	 * @param px1,py1,px2,py2 另外一条线段的两个端点坐标
	 */
	math.getCrossPointInRectAndSegment = function(rx,ry,w,h,px1,py1,px2,py2) {
		var cp, 
		    rx1 = rx, ry1 = ry, 
		    rx2 = rx +　w, ry2 = ry1, 
		    rx3 = rx2, ry3 = ry + h, 
		    rx4 = rx1, ry4 = ry3,
		    //top
		    cp = math.getCrossPointInTwoSegments(rx1, ry1, rx2, ry2, px1, py1, px2, py2);
		    if(cp) {
		    	return cp;
		    }
		    //right
	        cp = math.getCrossPointInTwoSegments(rx2, ry2, rx3, ry3, px1, py1, px2, py2);
	        if(cp) {
	            return cp;
	        }
	        //bottom
	        cp = math.getCrossPointInTwoSegments(rx3, ry3, rx4, ry4, px1, py1, px2, py2);
	        if(cp) {
	            return cp;
	        }
	        //left
	        cp = math.getCrossPointInTwoSegments(rx4, ry4, rx1, ry1, px1, py1, px2, py2);
	        if(cp) {
	            return cp;
	        }
	        return null;
	};
	
	//排斥实验
	var isRectCross = function(x1,y1,x2,y2,x3,y3,x4,y4) {
	    return Math.min(x1,x2) <= Math.max(x3,x4) &&
	           Math.min(x3,x4) <= Math.max(x1,x2) &&
	           Math.min(y1,y2) <= Math.max(y3,y4) &&
	           Math.min(y3,y4) <= Math.max(y1,y2);
	};
	
	//跨立判断
	var isLineSegmentCross = function(x1,y1,x2,y2,x3,y3,x4,y4) {
	    var line1,line2;
	    line1 = x1 * (y3 - y2) + x2 * (y1 - y3) + x3 * (y2 - y1);
	    line2 = x1 * (y4 - y2) + x2 * (y1 - y4) + x4 * (y2 - y1);
	    if (((line1 ^ line2) >= 0) && !(line1 == 0 && line2 == 0))
	        return false;
	
	    line1 = x3 * (y1 - y4) + x4 * (y3 - y1) + x1 * (y4 - y3);
	    line2 = x3 * (y2 - y4) + x4 * (y3 - y2) + x2 * (y4 - y3);
	    if (((line1 ^ line2) >= 0) && !(line1 == 0 && line2 == 0))
	        return false;
	    return true;
	};
	
	/**
	 * 判断某个点是否在矩形区域内
	 * @param x 点x坐标
	 * @param y 点y坐标
	 * @param rect 矩形
	 */
	math.isPointInsideBBox = function(x, y, rect) {
		return x >= rect.x && x <= (rect.x + rect.width) && 
		       y >= rect.y && y <= (rect.y + rect.height);
	}
	
	/**
	 * 判断两个矩形是否发生碰撞
	 * @param rect1 矩形1 rect:{x, y, width, height}
	 * @param rect2 矩形2
	 */
	math.isCollisionInTwoRects = function(rect1, rect2) {
	    return  rect1.x < rect2.x + rect2.width &&
	            rect1.x + rect1.width > rect2.x &&
	            rect1.y < rect2.y + rect2.height &&
	            rect1.height + rect1.y > rect2.y;
	};
	
	/**
	 * SVG Path rounding function. Takes an input path string and outputs a path
	 * string where all line-line corners have been rounded. Only supports absolute
	 * commands at the moment.
	 * 
	 * @param pathString The SVG input path
	 * @param radius The amount to round the corners, either a value in the SVG 
	 *               coordinate space, or, if useFractionalRadius is true, a value
	 *               from 0 to 1, else 0 to 100.
	 * @param useFractionalRadius If true, the curve radius is expressed as a
	 *               fraction of the distance between the point being curved and
	 *               the previous and next points.
	 * @returns A new SVG path string with the rounding
	 */
	math.roundPathCorners = function(pathString, radius, useFractionalRadius) {
	  function moveTowardsLength(movingPoint, targetPoint, amount) {
	    var width = (targetPoint.x - movingPoint.x);
	    var height = (targetPoint.y - movingPoint.y);
	    
	    var distance = Math.sqrt(width*width + height*height);
	    
	    return moveTowardsFractional(movingPoint, targetPoint, Math.min(1, amount / distance));
	  }
	  function moveTowardsFractional(movingPoint, targetPoint, fraction) {
	    return {
	      x: movingPoint.x + (targetPoint.x - movingPoint.x)*fraction,
	      y: movingPoint.y + (targetPoint.y - movingPoint.y)*fraction
	    };
	  }
	  
	  // Adjusts the ending position of a command
	  function adjustCommand(cmd, newPoint) {
	    if (cmd.length > 2) {
	      cmd[cmd.length - 2] = newPoint.x;
	      cmd[cmd.length - 1] = newPoint.y;
	    }
	  }
	  
	  // Gives an {x, y} object for a command's ending position
	  function pointForCommand(cmd) {
	    return {
	      x: parseFloat(cmd[cmd.length - 2]),
	      y: parseFloat(cmd[cmd.length - 1])
	    };
	  }
	  
	  // Split apart the path, handing concatonated letters and numbers
	  var pathParts = pathString
	    .split(/[,\s]/)
	    .reduce(function(parts, part){
	      var match = part.match("([a-zA-Z])(.+)");
	      if (match) {
	        parts.push(match[1]);
	        parts.push(match[2]);
	      } else {
	        parts.push(part);
	      }
	      
	      return parts;
	    }, []);
	  
	  // Group the commands with their arguments for easier handling
	  var commands = pathParts.reduce(function(commands, part) {
	    if (parseFloat(part) == part && commands.length) {
	      commands[commands.length - 1].push(part);
	    } else {
	      commands.push([part]);
	    }
	    
	    return commands;
	  }, []);
	  
	  // The resulting commands, also grouped
	  var resultCommands = [];
	  
	  if (commands.length > 1) {
	    var startPoint = pointForCommand(commands[0]);
	    
	    // Handle the close path case with a "virtual" closing line
	    var virtualCloseLine = null;
	    if (commands[commands.length - 1][0] == "Z" && commands[0].length > 2) {
	      virtualCloseLine = ["L", startPoint.x, startPoint.y];
	      commands[commands.length - 1] = virtualCloseLine;
	    }
	    
	    // We always use the first command (but it may be mutated)
	    resultCommands.push(commands[0]);
	    
	    var prevCmd, curCmd, nextCmd, prevPoint, curPoint, nextPoint, curveStart, 
	        curveEnd, startControl, endControl, curveCmd;
	    for (var cmdIndex = 1, len = commands.length; cmdIndex < len; cmdIndex++) {
	      prevCmd = resultCommands[resultCommands.length - 1];
	      curCmd = commands[cmdIndex];
	      
	      // Handle closing case
	      nextCmd = (curCmd == virtualCloseLine)
	        ? commands[1]
	        : commands[cmdIndex + 1];
	      
	      // Nasty logic to decide if this path is a candidite.
	      if (nextCmd && prevCmd && (prevCmd.length > 2) && curCmd[0] === "L" && nextCmd.length > 2 && nextCmd[0] === "L") {
	        // Calc the points we're dealing with
	        prevPoint = pointForCommand(prevCmd);
	        curPoint = pointForCommand(curCmd);
	        nextPoint = pointForCommand(nextCmd);
	        
	        // The start and end of the cuve are just our point moved towards the previous and next points, respectivly
	        if (useFractionalRadius) {
	          curveStart = moveTowardsFractional(curPoint, prevCmd.origPoint || prevPoint, radius);
	          curveEnd = moveTowardsFractional(curPoint, nextCmd.origPoint || nextPoint, radius);
	        } else {
	          curveStart = moveTowardsLength(curPoint, prevPoint, radius);
	          curveEnd = moveTowardsLength(curPoint, nextPoint, radius);
	        }
	        
	        // Adjust the current command and add it
	        adjustCommand(curCmd, curveStart);
	        curCmd.origPoint = curPoint;
	        resultCommands.push(curCmd);
	        
	        // The curve control points are halfway between the start/end of the curve and
	        // the original point
	        startControl = moveTowardsFractional(curveStart, curPoint, .5);
	        endControl = moveTowardsFractional(curPoint, curveEnd, .5);
	  
	        // Create the curve 
	        curveCmd = ["C", startControl.x, startControl.y, endControl.x, endControl.y, curveEnd.x, curveEnd.y];
	        // Save the original point for fractional calculations
	        curveCmd.origPoint = curPoint;
	        resultCommands.push(curveCmd);
	      } else {
	        // Pass through commands that don't qualify
	        resultCommands.push(curCmd);
	      }
	    }
	    
	    // Fix up the starting point and restore the close path if the path was orignally closed
	    if (virtualCloseLine) {
	      var newStartPoint = pointForCommand(resultCommands[resultCommands.length-1]);
	      resultCommands.push(["Z"]);
	      adjustCommand(resultCommands[0], newStartPoint);
	    }
	  } else {
	    resultCommands = commands;
	  }
	  
	  return resultCommands.reduce(function(str, c){ return str + c.join(" ") + " "; }, "");
	};
	
	/**
	 * 根据提供的一些点，获取这些点中的顶点带圆角的凸包路径
	 * @param points 点数组[[x,y],...,[x,y]]
	 * @param radius 凸包路径圆角半径
	 * @param useFractionalRadius 是否使用fractional radius,若使用则radius值范围[0,1],否则为[0,100]。
	 *                            参考math.roundPathCorners注释
	 * @return 凸包路径字符串
	 */
	math.pointsToPolygonHullRoundPath = function(points, radius, useFractionalRadius) {
		if(points.length < 2) {
			return "";
		} else if(points.length === 2) {
			return "M"+ points[0] + " L" + points[1];
		} else {
	        //获取凸包顶点数组
			points = d3.polygonHull(points);
			var line = " L", space = " ";
			var pathString = "M" + points[0][0] + space + points[0][1];
			for(var p, i = 1, len = points.length; i < len; i++) {
	            p = points[i];
			 	pathString += line + p[0] + space + p[1];
			}
			pathString += " Z";
			//获取顶点带圆角的凸包路径
			var path = math.roundPathCorners(pathString, radius, useFractionalRadius);
			return path;
		}
	};
	/**
	 * 根据二次贝塞尔曲线信息获取指定时间刻度的坐标点
	 * @param {*} cp 控制点
	 * @param {*} sp 起点
	 * @param {*} ep 结束点
	 * @param {*} t 时间[0-1]
	 */
	math.calcBezCurvePointWithTime=function(cp,sp,ep,t){
		var tp={x:0,y:0};
		tp.x=(1-t)*(1-t)*sp.x+2*t*(1-t)*cp.x+t*t*ep.x;
		tp.y=(1-t)*(1-t)*sp.y+2*t*(1-t)*cp.y+t*t*ep.y;
		return tp;
	}
	
	
	
	/**
	 * 获取二次贝塞尔曲线和一条线段的交点
	 * @param p1 二次贝塞尔曲线起点，格式为{x:x, y:y}
	 * @param p2 二次贝塞尔曲线控制点
	 * @param p3 二次贝塞尔曲线终点
	 * @param a1 线段起点
	 * @param a2 线段终点
	 * @return 返回交点，格式为[[x,y],...,[x,y]]，若没有交点，则返回空数组。
	 */
	math.calcQBezCurveAndLineIntersects = function(p1, p2, p3, a1, a2) {
		// linear interpolation utility
	    var lerp = function(a,b,x) { 
	        return(a+x*(b-a)); 
	    };
	    
		var intersections = [];
	
		// inverse line normal
		var normal = {
			x : a1.y - a2.y,
			y : a2.x - a1.x
		};
	
		// Q-coefficients
		var c2 = {
			x : p1.x + p2.x * -2 + p3.x,
			y : p1.y + p2.y * -2 + p3.y
		};
	
		var c1 = {
			x : p1.x * -2 + p2.x * 2,
			y : p1.y * -2 + p2.y * 2
		};
	
		var c0 = {
			x : p1.x,
			y : p1.y
		};
	
		// Transform to line
		var coefficient = a1.x * a2.y - a2.x * a1.y;
		var a = normal.x * c2.x + normal.y * c2.y;
		var b = (normal.x * c1.x + normal.y * c1.y) / a;
		var c = (normal.x * c0.x + normal.y * c0.y + coefficient) / a;
	
		// solve the roots
		var roots = [];
		d = b * b - 4 * c;
		if (d > 0) {
			var e = Math.sqrt(d);
			roots.push((-b + Math.sqrt(d)) / 2);
			roots.push((-b - Math.sqrt(d)) / 2);
		} else if (d == 0) {
			roots.push(-b / 2);
		}
	
		// calc the solution points
		for (var i = 0, len = roots.length; i < len; i++) {
			var minX = Math.min(a1.x, a2.x);
			var minY = Math.min(a1.y, a2.y);
			var maxX = Math.max(a1.x, a2.x);
			var maxY = Math.max(a1.y, a2.y);
			var t = roots[i];
			if (t >= 0 && t <= 1) {
				// possible point -- pending bounds check
				var point = [
					lerp(lerp(p1.x, p2.x, t), lerp(p2.x, p3.x, t), t),
					lerp(lerp(p1.y, p2.y, t), lerp(p2.y, p3.y, t), t)
				]
				var x = point[0];
				var y = point[1];
				// bounds checks
				if (a1.x == a2.x && y >= minY && y <= maxY) {
					// vertical line
					intersections.push(point);
				} else if (a1.y == a2.y && x >= minX && x <= maxX) {
					// horizontal line
					intersections.push(point);
				} else if (x >= minX && y >= minY && x <= maxX && y <= maxY) {
					// line passed bounds check
					intersections.push(point);
				}
			}
		}
		return intersections;
	};
	
	/**
	 * 获取二次贝塞尔曲线和矩形的交点
	 * @param p1 二次贝塞尔曲线起点，格式为{x:x, y:y}
	 * @param p2 二次贝塞尔曲线控制点
	 * @param p3 二次贝塞尔曲线终点
	 * @param rect 矩形信息{x:x, y:y, width:width, height:height}
	 * @return 返回交点，格式为[[x,y],...,[x,y]]，若没有交点，则返回空数组。
	 */
	math.calcQBezCurveAndRectIntersects = function(p1, p2, p3, rect) {
		var add = function(points, result) {
			for(var i = 0, len = points.length; i < len; i++) {
				result.push(points[i]);
			}
		};
		
		var a1 = {x:rect.x, y:rect.y}, 
		    a2 = {x:rect.x + rect.width, y:rect.y},
		    a3 = {x:rect.x + rect.width, y:rect.y + rect.height},
		    a4 = {x:rect.x, y:rect.y + rect.height};
		var top = math.calcQBezCurveAndLineIntersects(p1, p2, p3, a1, a2);
	    var right = math.calcQBezCurveAndLineIntersects(p1, p2, p3, a2, a3);
	    var bottom = math.calcQBezCurveAndLineIntersects(p1, p2, p3, a3, a4);
	    var left = math.calcQBezCurveAndLineIntersects(p1, p2, p3, a4, a1);
	    
	    add(right, top);
	    add(bottom, top);
	    add(left, top);
	    
	    return top;
	};
	
	module.exports = math;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {// 鼠标工具类
	
	var MouseUtil = {};
	
	// --------------------------------------------------------------------------
	//
	// static public Methods
	//
	// --------------------------------------------------------------------------
	
	/**
	 * 获取当前鼠标相对某个元素的相对位置坐标数组,用d3.mouse()定位，chrome60以下getScreenCTM()方法返回矩阵不带额外的缩放系数，导致定位出错
	 * 
	 * @param node 目标元素对象
	 * @return 返回鼠标相对目标元素的相对位置坐标数组
	 */
	MouseUtil.mouse = function(node) {
	    var event = sourceEvent();
	    if (event.changedTouches) 
	        event = event.changedTouches[0];
	    return point(node, event);
	};
	
	// --------------------------------------------------------------------------
	//
	// private Methods
	//
	// --------------------------------------------------------------------------
	
	var sourceEvent = function() {
		var current = d3.event, source;
		while (source = current.sourceEvent)
			current = source;
		return current;
	};
	
	var point = function(node, event) {
		var svg = node.ownerSVGElement || node;
	
		if (svg.createSVGPoint) {
			var point = svg.createSVGPoint();
			point.x = event.clientX; 
			point.y = event.clientY;
			/*CTM矩阵是局部坐标系(即指定对象内部坐标系，只有svg支持改方法)到屏幕坐标系的转换系数矩阵
			局部坐标矩阵*CTM = 屏幕坐标矩阵
			屏幕坐标矩阵*CTM逆矩阵(即screenCTM.inverse()) = 局部坐标矩阵
			*/
			var screenCTM = node.getScreenCTM();
			//根据屏幕坐标计算局部坐标
			point = point.matrixTransform(screenCTM.inverse());
			return [point.x, point.y];
		}
	
		var rect = node.getBoundingClientRect();
		return [event.clientX - rect.left - node.clientLeft,
				event.clientY - rect.top - node.clientTop];
	};
	
	module.exports = MouseUtil;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 125 */
/***/ (function(module, exports) {

	//对象工具类
	
	var ObjectUtil = {};
	
	// --------------------------------------------------------------------------
	//
	// static public Methods
	//
	// --------------------------------------------------------------------------
	ObjectUtil.contains = function(array, object) {
	    var i = array.length;
	    while (i--) {
	        if (array[i] === object) {
	            return true;
	        }
	    }
	    return false;
	}
	/**
	 * 深度克隆对象
	 * @param obj 要克隆的对象
	 * @return 返回克隆对象
	 */
	ObjectUtil.cloneObj = function(obj) {
	    var str, newobj = obj.constructor === Array ? [] : {};
	    if(typeof obj !== 'object') {
	        return obj;
	    } else if(window.JSON) {
	        str = JSON.stringify(obj), //序列化对象
	        newobj = JSON.parse(str); //还原
	    } else {
	        for(var i in obj) {
	            newobj[i] = typeof obj[i] === 'object' ? cloneObj(obj[i]) : obj[i]; 
	        }
	    }
	    return newobj;
	};
	
	ObjectUtil.isObject = function(obj) {
	    return Object.prototype.toString.call(obj) === "[object Object]";
	};
	
	ObjectUtil.isString = function(obj) {
		return Object.prototype.toString.call(obj) === "[object String]";
	};
	
	ObjectUtil.isArray = function(obj) {
	    return Object.prototype.toString.call(obj) === "[object Array]";
	};
	
	ObjectUtil.isNumber = function(obj) {
	    return Object.prototype.toString.call(obj) === "[object Number]";
	};
	
	ObjectUtil.isBoolean = function(obj) {
	    return Object.prototype.toString.call(obj) === "[object Boolean]";
	};
	
	ObjectUtil.isFunction = function(obj) {
	    return Object.prototype.toString.call(obj) === "[object Function]";
	};
	
	ObjectUtil.isUndefined = function(obj) {
	    return Object.prototype.toString.call(obj) === "[object Undefined]";
	};
	
	ObjectUtil.isNull = function(obj) {
	    return Object.prototype.toString.call(obj) === "[object Null]";
	};
	
	/** 
	 * 判断是否为dom实例。
	 * 首先要对HTMLElement进行类型检查，因为即使在支持HTMLElement 的浏览器中，
	 * 类型却是有差别的，在Chrome,Opera中HTMLElement的类型为function，此时就不能用它来判断了
	 */
	ObjectUtil.isDom = (typeof HTMLElement === 'object') ?
	    function(obj){
	        return obj instanceof HTMLElement;
	    } :
	    function(obj){
	        return obj && typeof obj === 'object' && obj.nodeType === 1 && typeof obj.nodeName === 'string';
	    };
	
	ObjectUtil.isDomByTagName = function(obj, tagName) {
	    return ObjectUtil.isDom(obj) && tagName && obj.tagName && 
	        obj.tagName.toLowerCase() === tagName.toLowerCase();
	};
	
	module.exports = ObjectUtil;


/***/ }),
/* 126 */
/***/ (function(module, exports) {

	var RegexUtil = {};
	
	RegexUtil.dataRegex         = /\{([\w.]+)\}/g;
	RegexUtil.jsRegex           = /{#(((?!#}).)*)#}/ig;     //匹配配置中可以运行的js脚本内容,即{#...#}中...部分
	RegexUtil.percentRegex      = /^([-+]?[0-9.]+)%$/;      //匹配百分比字符串
	RegexUtil.pxRegex           = /^([0-9.]+)px$/;          //匹配px字符串
	RegexUtil.whiteSpaceRegex   = /^[ ]*$/;                 //匹配多个空格或者空字符串
	RegexUtil.arrayFormatRegex  = /^([^.]+)\[([^.]+)\]$/;   //匹配数组表示字符串
	RegexUtil.translateRegex    = /translate\((.*?)\)/;     //匹配translate样式表示字符串
	RegexUtil.scaleRegex        = /scale\((.*?)\)/;         //匹配scale样式表示字符串
	RegexUtil.rotateRegex       = /rotate\((.*?)\)/;        //匹配rotate样式表示字符串
	
	RegexUtil.replace = function(regex,str,data){
	   /* var replace = function()  {
	        return function(match) {
	            var placeholder = arguments[1];
	            var result = placeholder.toString().split(".");
	            var count = !result ? 0 : result.length;
	            var data = d;
	            for(var i=0;i<count;i++){
	                if (data.hasOwnProperty(result[i])) {
	                    data = data[result[i]];
	                } else {
	                    data = arguments[0];
	                }
	            }
	            return data;
	        };
	    };*/
	    if(!str || !ghca_charts.view.util.objectUtil.isString(str))return str;
	    var matchAry = str.match(regex);
	    var object = null;
	    if(matchAry == null) {
	    	return str;
	//    	//识别是否有js表达式字符串
	//        return str.replace(RegexUtil.jsRegex, function() {
	//            return arguments.length > 1 ? eval(arguments[1]) : "";
	//        });
	    }
	    matchAry.forEach(function(d){
	        var array = new RegExp(regex).exec(d);
	        var placeholder = array[1];
	        var da= data;
	        if(placeholder != "this"){
	            var result = placeholder.toString().split(".");
	            var count = !result ? 0 : result.length;
	            for(var i=0;i<count;i++){
	                if (da.hasOwnProperty(result[i])) {
	                    da = da[result[i]];
	                } else {
	                    da = array[0];
	                }
	            }
	        }
	        if(da instanceof Object)
	            object = da;
	        str = str.replace(array[0], da)
	    });
	    if(object)return object;
	    return str;
	    // return str.replace(regex, replace(d));
	};
	
	RegexUtil.translate = function(str) {
		try {
			var reg = RegexUtil.translateRegex;
			var xy = str.match(reg)[1].split(",");
			if (xy.length < 2)//IE
				xy = str.match(reg)[1].split(" ");
			return xy.length < 2 ? [xy[0], 0] : xy;
		} catch (e) {
		}
		return [0, 0];
	};
	
	RegexUtil.scale = function(str) {
		try {
			//IE
			var scale = str.match(RegexUtil.scaleRegex)[1].split(",");
			return scale.length < 2 ? [scale[0], scale[0]] : scale;
		} catch (e) {
		}
		return [1, 1];
	};
	
	RegexUtil.rotate = function(str) {
		try {
			return str.match(RegexUtil.rotateRegex)[1];
		} catch (e) {
		}
		return [0];
	};
	
	RegexUtil.px = function(str) {
		try {
			return parseInt(str.match(RegexUtil.pxRegex)[1]);
		} catch (e) {
		}
		return 0;
	};
	
	module.exports = RegexUtil;

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(d3) {// 选择控制工具类
	
	var SelectUtil = {};
	var childNodes = [];//当前画板内包含的dom图形节点数组
	var selectedNodes = [];//当前画板内选中的dom图形节点数组
	
	var controlCon, selectCon, moveArea, tlP, trP, brP, blP, tcP, rcP, bcP, lcP, rotateP, line, topLine, leftLine, bottomLine, rightLine,
	    r = 3.5, rotateGap = 20, lineGap = 1, pointStroke = "#cc4c14", pointFill = "#ff7f00", minWidth = 10, minHeight = 10,
	    fixedNum = 1,
	    resizeCursorList = ["n-resize", "ne-resize", "e-resize", "se-resize", "s-resize", "sw-resize", "w-resize", "nw-resize"];
	    
	// --------------------------------------------------------------------------
	//
	// static public Methods
	//
	// --------------------------------------------------------------------------
	    
	/**
	 * 图标资源路径
	 */
	var iconPath = "../image/svg_canvas/";
	SelectUtil.iconPath = function(value) {
	    if (!arguments.length) 
	        return iconPath;
	    iconPath = value;
	    return this;
	};
	
	SelectUtil.rotateUrl = function() {
	    return "url(" + SelectUtil.iconPath() + "rotate_cursor.ico) 8 8,auto";
	};
	
	SelectUtil.rotateCursor = function() {
	    return "cursor:" + SelectUtil.rotateUrl();
	};
	    
	SelectUtil.addNode = function(node, nodeData) {
	    if(!node || findNodeObjByNode(node)) {
	        return;
	    }
	    var box = node.getBBox();
	    //定义元素对应数据模型对象
	    if(nodeData) {
	    	nodeData.path = getNodePath(node);
	    } else {
	    	nodeData = {
	            x:box.x,                //当前x坐标
	            y:box.y,                //当前y坐标
	            width:box.width,        //元素外接矩形宽度
	            height:box.height,      //元素外接矩形高度
	            tx:0,                   //元素水平方向位移
	            ty:0,                   //元素垂直方向位移
	            rotate:0,               //元素外接矩形旋转角度
	            path:getNodePath(node)  //元素路径
	        };
	    }
	    d3.select(node).datum(nodeData);
	    node.setAttribute("z-index", childNodes.length);
	    childNodes.push(node);
	};
	
	SelectUtil.removeSelectedNodes = function() {
		while(selectedNodes.length > 0) {
	        SelectUtil.removeNode(selectedNodes[0]);
		}
	};
	
	SelectUtil.removeNode = function(node) {
	     if(!node) {
	        return;
	     }
	     var index = getIndexByNode(node, childNodes);
	     if(index !== -1) {
	        childNodes.splice(index, 1);
	     }
	     index = getIndexByNode(node, selectedNodes);
	     if(index !== -1) {
	        selectedNodes.splice(index, 1);
	     }
	     d3.select(node).remove();
	};
	
	SelectUtil.removeAllNodes = function() {
	    childNodes.length = 0;
	    selectedNodes.length = 0;
	};
	
	SelectUtil.getAllNodes = function() {
	    return childNodes;
	};
	
	SelectUtil.getSelectedNodes = function() {
		return selectedNodes;
	};
	
	SelectUtil.getSelectedNodesInBBox = function(box) {
	    var result = [];
	    if(!box || childNodes.length === 0) {
	        return result;
	    }
	    var x = box.x,
	        y = box.y,
	        width = box.width,
	        height = box.height;
	    for(var i = 0, len = childNodes.length; i < len; i++) {
	        var node = childNodes[i];
	        var data = node.__data__;
	        if(isContain(box, data)) {
	            result.push(node);
	        } else {
	            var rectPath = "M"+x+","+y +
	                " L"+(x+width)+","+y+
	                " L"+(x+width)+","+(y+height)+
	                " L"+(x)+","+(y+height) + "Z";
	            var intersections = Raphael.pathIntersection(data.path, rectPath);
	            if(intersections.length > 0) {
	                result.push(node);
	            }
	        }
	    }
	    return result;
	};
	
	SelectUtil.showControlPoints = function(con, nodes, graph) {
	    if(!con ||　nodes.length === 0) {
	        return;
	    }
	    selectedNodes = nodes;
	    initControlPoints(con, nodes, graph);
	    updateNodesProperies(nodes);
	    
	    //translate
	    addTranslateListeners(nodes, graph);
	    //resize
	    addResizeListeners(nodes, graph);
	    //rotate
	    addRotateListeners(con, nodes, graph);
	}
	
	SelectUtil.removeControlPoints = function(con) {
		updateNodesProperies();
	    if(con) {
	        d3.select(con).selectAll("*").remove();
	    }
	    if(controlCon) {
	        controlCon.remove();
	    }
	    selectedNodes.length = 0;
	}
	
	SelectUtil.validateNodes = function(nodes, oldRects) {
		for(var node, d, i = 0, len = nodes.length; i < len; i++) {
	        node = nodes[i];
	        d = node.__data__;
	        var oldRect = (oldRects && i < oldRects.length) ? oldRects[i] : getRect(d);
	        //把tx/ty转移到dx/dy中
	        d.x += d.tx;
	        d.y += d.ty;
	        d.tx = 0;
	        d.ty = 0;
	        redrawNode(node, oldRect);
	    }
	    updateNodes(nodes);
	};
	
	/**
	 * 移动选中的元素
	 * @param direction 移动方向0.up;1.right;2.down;3.left;
	 */
	SelectUtil.moveNodes = function(direction, moveStep) {
		if(selectedNodes.length === 0) {
			return;
		}
	    var dx = 0, dy = 0, moveStep = moveStep === undefined ? 5 : moveStep;
	    if(direction === 0) {//up
	        dy = -moveStep;
	    } else if(direction === 1) {//right
	        dx = moveStep;
	    } else if(direction === 2) {//down
	        dy = moveStep;
	    } else if(direction === 3) {//left
	        dx = -moveStep;
	    }
	    var cd = controlCon.datum();
	    cd.tlX += dx;
	    cd.tlY += dy;
	    cd.brX += dx;
	    cd.brY += dy;
	    refreshControlPoints(selectedNodes, cd, false);
	    for(var node, d, i = 0, len = selectedNodes.length; i < len; i++) {
	        node = selectedNodes[i];
	        d = node.__data__;
	        var oldRect = getRect(d);
	        d.x += dx;
	        d.y += dy;
	        redrawNode(node, oldRect);
	    }
	    updateNodes(selectedNodes);
	}
	
	// --------------------------------------------------------------------------
	//
	// private Methods
	//
	// --------------------------------------------------------------------------
	
	//获取resize相关光标,type为resizeCursorList中定义的值
	var getResizeCursor = function(type) {
	    if(type === undefined || !controlCon) {
	        return null;
	    }
	    var index = resizeCursorList.indexOf(type);
	    if(index === -1) {
	        return null;
	    }
	    var cd = controlCon.datum();
	    var n = Math.floor(((cd.rotate % 360 + 360) % 360 + 27.5) / 45);
	    index = (index + n) % 8;
	    return resizeCursorList[index];
	};
	
	var updateNodes = function(nodes) {
		updateNodesPath(nodes);
		updateNodesProperies(nodes);
	};
	    
	var updateNodesPath = function(nodes) {
	    if(!nodes || nodes.length === 0) {
	    	return;
	    }
	    for(var i = 0, len = nodes.length; i < len; i++) {
	        updateNodePath(nodes[i]);
	    }
	};
	
	var updateNodesProperies = function(nodes) {
		if(!selectCon) {
			return;
		}
		var EventUtil = ghca_charts.view.util.eventUtil;
	    var BaseEvent = ghca_charts.events.BaseEvent;
	    var evt = (nodes && nodes.length === 1) ? 
	        EventUtil.createCustomEvent(BaseEvent.UPDATE_PROPERTIES, true, true, nodes[0]) : 
	        EventUtil.createCustomEvent(BaseEvent.HIDDEN_PROPERTIES, true, true);
	    selectCon.ownerSVGElement.dispatchEvent(evt);
	};
	
	var updateNodePath = function(node) {
		if(!node) {
	        return;
	    }
	    var node = findNodeObjByNode(node);
	    if(node) {
	        var data = node.__data__;
	        data.x = toFixed(data.x);
	        data.y = toFixed(data.y);
	        data.width = toFixed(data.width);
	        data.height = toFixed(data.height);
	        data.rotate = toFixed(data.rotate);
	        data.path = getNodePath(node);
	    } else {
	        SelectUtil.addNode(node);
	    }
	};
	
	//获取元素路径的方法，若该元素还包括变换(transform)，则把该变换也转换到路径中
	var getNodePath = function(node) {
		var tagName = node.tagName;
		var path = null;
		if(tagName === "circle") {
			var r = parseFloat(node.getAttribute("r"));
			path = "M " + node.getAttribute("cx") + " " + node.getAttribute("cy") + 
			  "m " + (-r) + " " + 0 + 
			  "a " + r + "," + r + " 0 1,0 " + (r * 2) + ",0" + 
			  "a " + r + "," + r + " 0 1,0 " + (-r * 2) + ",0";
		} else if(tagName === "ellipse") {
	        var k = .5522848,
	            x = parseFloat(node.getAttribute("cx"));
	            y = parseFloat(node.getAttribute("cy"));
	            a = parseFloat(node.getAttribute("rx"));
	            b = parseFloat(node.getAttribute("ry"));
	            ox = a * k, // 水平控制点偏移量
	            oy = b * k; // 垂直控制点偏移量
	    
	       //从椭圆的左端点开始顺时针绘制四条三次贝塞尔曲线
	       var p = d3.path();
	       p.moveTo(x - a, y);
	       p.bezierCurveTo(x - a, y - oy, x - ox, y - b, x, y - b);
	       p.bezierCurveTo(x + ox, y - b, x + a, y - oy, x + a, y);
	       p.bezierCurveTo(x + a, y + oy, x + ox, y + b, x, y + b);
	       p.bezierCurveTo(x - ox, y + b, x - a, y + oy, x - a, y);
	       p.closePath();
	       path = p.toString();
		} else if(tagName === "line") {
	        var x1 = parseFloat(node.getAttribute("x1")),
	            y1 = parseFloat(node.getAttribute("y1")),
	            x2 = parseFloat(node.getAttribute("x2")),
	            y2 = parseFloat(node.getAttribute("y2"));
	        path = "M"+x1+","+y1+" L"+x2+","+y2;
	    } else if(tagName === "polyline" || tagName === "polygon") {
	        var points = node.getAttribute('points').split(/\s+|,/);
	        var x0 = points.shift(), 
	            y0 = points.shift();
	        path = 'M'+x0+','+y0+'L'+points.join(' ');
	        if(tagName === "polygon") {
	            path += 'Z';
	        }
	    } else if(tagName === "path") {
			path = node.getAttribute("d");
		} else {//其他类型都当做矩形处理
	        var x = parseFloat(node.getAttribute("x")),
	            y = parseFloat(node.getAttribute("y")),
	            width = parseFloat(node.getAttribute("width")),
	            height = parseFloat(node.getAttribute("height"));
	        path =  "M"+x+","+y +
	                " L"+(x+width)+","+y+
	                " L"+(x+width)+","+(y+height)+
	                " L"+(x)+","+(y+height) + "Z";
	    } 
	    //若该元素还包括变换，则把该变换也转换到路径中
	    var transformArray = node.__data__ ? node.__data__.transformArray : null;
	    if (transformArray && transformArray.length > 0) {
	        path = Raphael.transformPath(path, transformArray).join(" ");
	    }
		return path;
	};
	
	var redrawNode = function(node, oldRect) {
	    var tagName = node.tagName;
	    var d = node.__data__;
	    var halfW = toFixed(d.width / 2);
	    var halfH = toFixed(d.height / 2);
	    var cx = toFixed(d.x + halfW);
	    var cy = toFixed(d.y + halfH);
	    if(tagName === "circle") {
			var r = toFixed((d.width < d.height ? d.width : d.height) / 2);
			node.setAttribute("cx", cx);
			node.setAttribute("cy", cy);
			node.setAttribute("r", r);
	    } else if(tagName === "ellipse") {
			node.setAttribute("cx", cx);
			node.setAttribute("cy", cy);
			node.setAttribute("rx", halfW);
			node.setAttribute("ry", halfH);
	    } else if(tagName === "line") {
	        var x1 = parseFloat(node.getAttribute("x1")),
	            y1 = parseFloat(node.getAttribute("y1")),
	            x2 = parseFloat(node.getAttribute("x2")),
	            y2 = parseFloat(node.getAttribute("y2"));
	            points = getRedrawPoints([x1,y1,x2,y2], d, oldRect);
	        node.setAttribute("x1", points[0]);
	        node.setAttribute("y1", points[1]);
	        node.setAttribute("x2", points[2]);
	        node.setAttribute("y2", points[3]);
	    } else if(tagName === "polyline" || tagName === "polygon") {
	       var points = node.getAttribute('points').split(/\s+|,/);
	       points = getRedrawPoints(points, d, oldRect);
	       node.setAttribute("points", points);
	    } else if(tagName === "path") {
	    	var points = node.getAttribute("d").split(/[^0-9.-]+/);
	    	points.shift();
	    	points = getRedrawPoints(points, d, oldRect);
	    	var x0 = points.shift(), 
	            y0 = points.shift();
	        for(var i = 0, len = points.length; i < len; i+=2) {
	        	points[i] = " L "+points[i]+" ";
	        }
	        var path = 'M '+x0+' '+y0+points.join('');
	    	node.setAttribute("d", path);
	    } else {//其他类型都当做矩形处理
	    	node.setAttribute("x", d.x);
	        node.setAttribute("y", d.y);
	        node.setAttribute("width", d.width);
	        node.setAttribute("height", d.height);
	    }
	    //svg不支持transform-origin,且为了兼容ie,所以在rotate(degree transform-origin-x, transform-origin-y)中设置
	    d3.select(node).attr("transform", "translate("+d.tx+","+d.ty+")rotate("+d.rotate+" "+cx+" "+cy+")");
	    d.transformArray = ["t", d.tx, d.ty, "r", d.rotate, cx, cy];
	};
	
	//points = [x1,y1,...,xn,yn]
	var getRedrawPoints = function(points, newRect, oldRect) {
		var x = newRect.x,
	        y = newRect.y,
	        width = newRect.width,
	        height = newRect.height,
	        ox = oldRect.x,
	        oy = oldRect.y,
	        oWidth = oldRect.width,
	        oHeight = oldRect.height;
	        sx = width/oWidth;
	        sy = height/oHeight;
	    for(var i = 0, len = points.length; i < len; i++) {
	    	points[i] = toFixed((points[i]-ox)*sx + x);
	    	i++;
	    	points[i] = toFixed((points[i]-oy)*sy + y);
	    }
	    return points;
	};
	
	var initControlPoints = function(con, nodes, graph) {
	    var node, data, boundRect, boundX, boundY, boundW, boundH,
	        tlX = NaN,
	        tlY = NaN,
	        brX = NaN,
	        brY = NaN,
	        tx = 0,
	        ty = 0,
	        rotate = 0,
	        len = nodes.length;
	    selectCon = con,
	    con = d3.select(con);
	    //若只有一个元素，则直接使用元素的矩形数据；若有多个元素，找出所有元素共有的最小外接矩形
	    if(len === 1) {
	    	//若选中单个图形，则从该图形相关联的数据中取出已经记录的数据；若选中多个图形，则控制点数据使用初始化数据
	    	node = nodes[0];
	        data = node.__data__;
	        boundX = data.x;
	        boundY = data.y;
	        boundW = data.width;
	        boundH = data.height;
	        if(isNaN(tlX) ||　boundX < tlX) {
	            tlX = boundX;
	        }
	        if(isNaN(tlY) ||　boundY < tlY) {
	            tlY = boundY;
	        }
	        if(isNaN(brX) ||　boundX + boundW > brX) {
	            brX = boundX + boundW;
	        }
	        if(isNaN(brY) ||　boundY + boundH > brY) {
	            brY = boundY +　boundH;
	        }
	        tx = data.tx;
	        ty = data.ty;
	        rotate = data.rotate;
	    } else {
	    	var scaleX = graph.scaleX();
	    	var scaleY = graph.scaleY();
	    	//用于获得DOM元素到浏览器可视范围的距离（不包含文档卷起的部分）
	    	const SvgUtil = ghca_charts.view.util.svgUtil;
	    	conRect = SvgUtil.getBoundingClientRect(con.node(), scaleX, scaleY);
		    for(var i = 0; i < len; i++) {
	            node = nodes[i];
	            data = node.__data__;
	            boundRect = SvgUtil.getBoundingClientRect(node, scaleX, scaleY);
	            boundX = boundRect.left - conRect.left;
	            boundY = boundRect.top - conRect.top;
	            boundW = boundRect.right - boundRect.left;
	            boundH = boundRect.bottom - boundRect.top;
	            if(isNaN(tlX) ||　boundX < tlX) {
	                tlX = boundX;
	            }
	            if(isNaN(tlY) ||　boundY < tlY) {
	                tlY = boundY;
	            }
	            if(isNaN(brX) ||　boundX + boundW > brX) {
	                brX = boundX + boundW;
	            }
	            if(isNaN(brY) ||　boundY + boundH > brY) {
	                brY = boundY +　boundH;
	            }
	//            //画元素外接矩形(测试用)
	//            con.append("rect")
	//                .attr("x", boundX).attr("y", boundY)
	//                .attr("width", boundW).attr("height", boundH)
	//                .attr("stroke", "blue").attr("fill", "none");
	        }
	    }
	    //添加控制点和移动区域
	    var selectRectData = {
	        tlX:tlX,        //矩形左上角x坐标
	        tlY:tlY,        //矩形左上角y坐标
	        brX:brX,        //矩形右下角x坐标
	        brY:brY,        //矩形右下角y坐标
	        tx:tx,          //矩形水平方向位移
	        ty:ty,          //矩形垂直方向位移
	        rotate:rotate   //矩形旋转角度
	    };
	    controlCon = con.append("g").datum(selectRectData);
	    moveArea = controlCon.append("rect").attr("class", "moveArea").attr("x", tlX).attr("y", tlY).attr("width", brX-tlX)
	       .attr("height", brY-tlY).attr("stroke", "none").attr("fill", pointFill).attr("fill-opacity", "0").attr("cursor", "move");//move area
	    var isShowPoints = (nodes.length === 1 && nodes[0].tagName === "text") ? "none" : "block";
	    tlP = controlCon.append("circle").attr("display", isShowPoints).attr("cx", tlX).attr("cy", tlY).attr("r", r).attr("stroke", pointStroke).attr("fill", pointFill).attr("cursor", getResizeCursor("nw-resize"));//top left
	    trP = controlCon.append("circle").attr("display", isShowPoints).attr("cx", brX).attr("cy", tlY).attr("r", r).attr("stroke", pointStroke).attr("fill", pointFill).attr("cursor", getResizeCursor("ne-resize"));//top right
	    brP = controlCon.append("circle").attr("display", isShowPoints).attr("cx", brX).attr("cy", brY).attr("r", r).attr("stroke", pointStroke).attr("fill", pointFill).attr("cursor", getResizeCursor("se-resize"));//bottom right
	    blP = controlCon.append("circle").attr("display", isShowPoints).attr("cx", tlX).attr("cy", brY).attr("r", r).attr("stroke", pointStroke).attr("fill", pointFill).attr("cursor", getResizeCursor("sw-resize"));//bottom left
	    tcP = controlCon.append("circle").attr("display", isShowPoints).attr("cx", tlX+(brX-tlX)/2).attr("cy", tlY).attr("r", r).attr("stroke", pointStroke).attr("fill", pointFill).attr("cursor", getResizeCursor("n-resize"));//top center
	    rcP = controlCon.append("circle").attr("display", isShowPoints).attr("cx", brX).attr("cy", tlY+(brY-tlY)/2).attr("r", r).attr("stroke", pointStroke).attr("fill", pointFill).attr("cursor", getResizeCursor("e-resize"));//right center
	    bcP = controlCon.append("circle").attr("display", isShowPoints).attr("cx", tlX+(brX-tlX)/2).attr("cy", brY).attr("r", r).attr("stroke", pointStroke).attr("fill", pointFill).attr("cursor", getResizeCursor("s-resize"));//bottom center
	    lcP = controlCon.append("circle").attr("display", isShowPoints).attr("cx", tlX).attr("cy", tlY+(brY-tlY)/2).attr("r", r).attr("stroke", pointStroke).attr("fill", pointFill).attr("cursor", getResizeCursor("w-resize"));//left center
	    rotateP = controlCon.append("circle").attr("cx", tlX+(brX-tlX)/2).attr("cy", tlY-rotateGap).attr("r", r).attr("stroke", pointStroke).attr("fill", "yellow").attr("style", SelectUtil.rotateCursor());//rotate
	    line = controlCon.insert("line", "*").attr("x1", tlX+(brX-tlX)/2).attr("y1", tlY).attr("x2", tlX+(brX-tlX)/2).attr("y2", tlY-rotateGap).attr("stroke", pointStroke);
	    topLine = controlCon.insert("line", "*").attr("x1", tlX-lineGap).attr("y1", tlY-lineGap).attr("x2", brX+lineGap).attr("y2", tlY-lineGap).attr("stroke", pointStroke).attr("stroke-dasharray", "4,4");
	    leftLine = controlCon.insert("line", "*").attr("x1", tlX-lineGap).attr("y1", tlY-lineGap).attr("x2", tlX-lineGap).attr("y2", brY+lineGap).attr("stroke", pointStroke).attr("stroke-dasharray", "4,4");
	    bottomLine = controlCon.insert("line", "*").attr("x1", tlX-lineGap).attr("y1", brY+lineGap).attr("x2", brX+lineGap).attr("y2", brY+lineGap).attr("stroke", pointStroke).attr("stroke-dasharray", "4,4");
	    rightLine = controlCon.insert("line", "*").attr("x1", brX+lineGap).attr("y1", tlY-lineGap).attr("x2", brX+lineGap).attr("y2", brY+lineGap).attr("stroke", pointStroke).attr("stroke-dasharray", "4,4");
	    refreshControlPoints(nodes, selectRectData, false);
	};
	
	var refreshResizeCursor = function() {
		tlP.attr("cursor", getResizeCursor("nw-resize"));//top left
	    trP.attr("cursor", getResizeCursor("ne-resize"));//top right
	    brP.attr("cursor", getResizeCursor("se-resize"));//bottom right
	    blP.attr("cursor", getResizeCursor("sw-resize"));//bottom left
	    tcP.attr("cursor", getResizeCursor("n-resize"));//top center
	    rcP.attr("cursor", getResizeCursor("e-resize"));//right center
	    bcP.attr("cursor", getResizeCursor("s-resize"));//bottom center
	    lcP.attr("cursor", getResizeCursor("w-resize"));//left center
	};
	
	var setAllCursor = function(type) {
		if(!type) {//default cursor
			refreshResizeCursor();
			rotateP.attr("style", SelectUtil.rotateCursor());
	        moveArea.attr("cursor", "move");
	        line.attr("cursor", "");
	        topLine.attr("cursor", "");
	        leftLine.attr("cursor", "");
	        bottomLine.attr("cursor", "");
	        rightLine.attr("cursor", "");
	        document.body.style.cursor = "";
		} else {
			tlP.attr("cursor", type)
	        trP.attr("cursor", type);
	        brP.attr("cursor", type);
	        blP.attr("cursor", type);
	        tcP.attr("cursor", type);
	        rcP.attr("cursor", type);
	        bcP.attr("cursor", type);
	        lcP.attr("cursor", type);
	        rotateP.attr("style", "cursor:"+type);
	        moveArea.attr("cursor", type);
	        line.attr("cursor", type);
	        topLine.attr("cursor", type);
	        leftLine.attr("cursor", type);
	        bottomLine.attr("cursor", type);
	        rightLine.attr("cursor", type);
	        document.body.style.cursor = type;
		}
	};
	
	var refreshControlPoints = function(nodes, d, isUpdateTranslate, cx, cy, isSaveTranslate) {
		var rotate = d.rotate;
	    var tlX = d.tlX;
	    var tlY = d.tlY;
	    var brX = d.brX;
	    var brY = d.brY;
	    moveArea.attr("x", tlX).attr("y", tlY).attr("width", brX-tlX).attr("height", brY-tlY);//move area
	    tlP.attr("cx", tlX).attr("cy", tlY).attr("r", r);//top left
	    trP.attr("cx", brX).attr("cy", tlY).attr("r", r);//top right
	    brP.attr("cx", brX).attr("cy", brY).attr("r", r);//bottom right
	    blP.attr("cx", tlX).attr("cy", brY).attr("r", r);//bottom left
	    tcP.attr("cx", tlX+(brX-tlX)/2).attr("cy", tlY).attr("r", r);//top center
	    rcP.attr("cx", brX).attr("cy", tlY+(brY-tlY)/2).attr("r", r);//right center
	    bcP.attr("cx", tlX+(brX-tlX)/2).attr("cy", brY).attr("r", r);//bottom center
	    lcP.attr("cx", tlX).attr("cy", tlY+(brY-tlY)/2).attr("r", r);//left center
	    rotateP.attr("cx", tlX+(brX-tlX)/2).attr("cy", tlY-rotateGap).attr("r", r);//rotate
	    line.attr("x1", tlX+(brX-tlX)/2).attr("y1", tlY).attr("x2", tlX+(brX-tlX)/2).attr("y2", tlY-rotateGap);
	    topLine.attr("x1", tlX-lineGap).attr("y1", tlY-lineGap).attr("x2", brX+lineGap).attr("y2", tlY-lineGap);
	    leftLine.attr("x1", tlX-lineGap).attr("y1", tlY-lineGap).attr("x2", tlX-lineGap).attr("y2", brY+lineGap);
	    bottomLine.attr("x1", tlX-lineGap).attr("y1", brY+lineGap).attr("x2", brX+lineGap).attr("y2", brY+lineGap);
	    rightLine.attr("x1", brX+lineGap).attr("y1", tlY-lineGap).attr("x2", brX+lineGap).attr("y2", brY+lineGap);
	    
	    var newCx = d.tlX + (d.brX-d.tlX)/2;
	    var newCy = d.tlY + (d.brY-d.tlY)/2;
	    var tx = d.tx;
	    var ty = d.ty;
	    if(isUpdateTranslate && cx !== undefined && cy !== undefined) {
	    	var dx = newCx - cx;
	    	var dy = newCy - cy;
	    	var l = Math.sqrt(dx*dx+dy*dy);
	    	var origRad = Math.atan2(dy, dx);
	    	var rad = origRad + rotate*Math.PI/180;
	    	dx = (cx + Math.round(l*Math.cos(rad))) - newCx;
	    	dy = (cy + Math.round(l*Math.sin(rad))) - newCy;
	    	tx += dx;
	    	ty += dy;
	    	//记录位移数据到相关选中的对象对应的data
	    	for(var node, data, i = 0, len = nodes.length; i < len; i++) {
	            node = nodes[i];
	            data = node.__data__;
	            data.tx = dx;
	            data.ty = dy;
	        }
	    	//记录位移数据到控制点数据
	    	if(isSaveTranslate) {
	            d.tx = tx;
	            d.ty = ty;
	            
	            //元素旋转完毕后，把本次旋转产生的tx/ty转移到dx/dy中
	            for(var node, d, i = 0, len = nodes.length; i < len; i++) {
	                node = nodes[i];
	                d = node.__data__;
	                var oldRect = getRect(d);
	                d.x += d.tx;
	                d.y += d.ty;
	                d.tx = 0;
	                d.ty = 0;
	                redrawNode(node, oldRect);
	            }
	        }
	    }
	    controlCon.attr("transform", "translate("+tx+","+ty+")rotate("+rotate+" "+newCx+" "+newCy+")");
	};
	
	var getRect = function(d) {
		return {x:d.x, y:d.y, width:d.width, height:d.height};
	};
	
	var toFixed = function(n, f) {
		if(f === undefined) {
			f = fixedNum;
		}
		return parseFloat(n.toFixed(f));
	};
	
	var addTranslateListeners = function(nodes, graph) {
		var w = d3.select(window);
		var cd = controlCon.datum();
	    moveArea.on("mousedown.translate", function() {
	        d3.event.stopImmediatePropagation();
	        setAllCursor("move");
	        var previousEvent = d3.event;
	        w.on("mousemove.translate", function() {
	        	d3.event.stopImmediatePropagation();
	            var dx = toFixed((d3.event.movementX||(d3.event.screenX - previousEvent.screenX))/graph.scaleX());//chrome/firefox||兼容ie
	            var dy = toFixed((d3.event.movementY||(d3.event.screenY - previousEvent.screenY))/graph.scaleX());
	            previousEvent = d3.event;
	            cd.tlX += dx;
	            cd.tlY += dy;
	            cd.brX += dx;
	            cd.brY += dy;
	            refreshControlPoints(nodes, cd, false);
	            for(var node, d, i = 0, len = nodes.length; i < len; i++) {
	                node = nodes[i];
	                d = node.__data__;
	                var oldRect = getRect(d);
	                d.x += dx;
	                d.y += dy;
	                redrawNode(node, oldRect);
	            }
	        });
	        w.on("mouseup.translate", function() {
	        	d3.event.stopImmediatePropagation();
	            w.on("mousemove.translate", null);
	            w.on("mouseup.translate", null);
	            setAllCursor();
	            updateNodes(nodes);
	        });
	    });
	};
	
	var addRotateListeners = function(con, nodes, graph) {
	    var w = d3.select(window);
	    var cd = controlCon.datum();
	    rotateP.on("mousedown.rotate", function() {
	        d3.event.stopImmediatePropagation();
	        setAllCursor(SelectUtil.rotateUrl());
	        var cx = cd.tlX + (cd.brX-cd.tlX)/2 + cd.tx;
	        var cy = cd.tlY + (cd.brY-cd.tlY)/2 + cd.ty;
	        var oldRotate = cd.rotate;
	        var oldR = cd.rotate;
	        var cp = controlCon.append("circle").attr("r", 2).attr("cx", cx - cd.tx).attr("cy", cy - cd.ty).attr("fill", "black");
	        w.on("mousemove.rotate", function() {
	        	d3.event.stopImmediatePropagation();
	        	const MouseUtil = ghca_charts.view.util.mouseUtil;
	            var m = MouseUtil.mouse(con, graph);
	            var rotate = toFixed(Math.atan2(m[1]-cy, m[0]-cx)*180/Math.PI+90);
	            cd.rotate = rotate;
	            refreshControlPoints(nodes, cd, false);
	            cp.attr("cx", cx - cd.tx).attr("cy", cy - cd.ty);
	            var len = nodes.length;
	            if(len === 1) {
	            	for(var node, d, i = 0, len; i < len; i++) {
	                    node = nodes[i];
	                    d = node.__data__;
	                    var oldRect = getRect(d);
	                    d.rotate = rotate;
	                    redrawNode(node, oldRect);
	                }
	            } else if(len > 1) {
	            	var deltaRotate = cd.rotate - oldRotate;
	            	oldRotate = cd.rotate;
	            	var rad1 = (cd.rotate - oldR)/180*Math.PI;
	                for(var node, d, i = 0; i < len; i++) {
	                    node = nodes[i];
	                    d = node.__data__;
	                    d.rotate += deltaRotate;
	                    var x1 = d.x + d.width/2 - cx;
	                    var y1 = d.y + d.height/2 - cy;
	                    var rad2 = Math.atan2(y1,x1);
	                    var rad = rad1 + rad2;
	                    var l = Math.sqrt(x1*x1+y1*y1);
	                    var x2 = l*Math.cos(rad);
	                    var y2 = l*Math.sin(rad);
	                    var tx = x2 - x1;
	                    var ty = y2 - y1;
	                    var deltaTx = tx - (d.oldTx === undefined ? 0 : d.oldTx);
	                    var deltaTy = ty - (d.oldTy === undefined ? 0 : d.oldTy);
	                    d.oldTx = tx;
	                    d.oldTy = ty;
	                    d.tx += deltaTx;
	                    d.ty += deltaTy;
	                    redrawNode(node, getRect(d));
	                }
	            }
	        });
	        w.on("mouseup.rotate", function() {
	        	d3.event.stopImmediatePropagation();
	            w.on("mousemove.rotate", null);
	            w.on("mouseup.rotate", null);
	            setAllCursor();
	            refreshControlPoints(nodes, cd, false);
	            refreshResizeCursor();
	            //多个元素旋转完毕后，把本次旋转产生的tx/ty转移到dx/dy中
	            if(nodes.length > 1) {
	            	for(var node, d, i = 0, len = nodes.length; i < len; i++) {
	                    node = nodes[i];
	                    d = node.__data__;
	                    var deltaTx = d.oldTx === undefined ? 0 : d.oldTx;
	                    var deltaTy = d.oldTy === undefined ? 0 : d.oldTy;
	                    d.tx -= deltaTx;
	                    d.ty -= deltaTy;
	                    var oldRect = getRect(d);
	                    d.x += deltaTx;
	                    d.y += deltaTy;
	                    redrawNode(node, oldRect);
	                    delete d.oldTx;
	                    delete d.oldTy;
	                }
	            }
	            updateNodes(nodes);
	            cp.remove();
	        });
	    });
	};
	
	var addResizeListeners = function(nodes, graph) {
		var w = d3.select(window);
		var cd = controlCon.datum();
	    //等比缩放
	    tlP.on("mousedown.tlP", function() {
	        d3.event.stopImmediatePropagation();
	        setAllCursor(getResizeCursor("nw-resize"));
	        var dw = cd.brX-cd.tlX;
	        var dh = cd.brY-cd.tlY;
	        var ratio = dw/dh;
	        var cx = cd.tlX + dw/2;
	        var cy = cd.tlY + dh/2;
	        var rad = cd.rotate/180*Math.PI;
	        var dx,dy;
	        var previousEvent = d3.event;
	        w.on("mousemove.tlP", function() {
	        	d3.event.stopImmediatePropagation();
	            var mx = (d3.event.movementX||(d3.event.screenX - previousEvent.screenX))/graph.scaleX();//chrome/firefox||兼容ie
	            var my = (d3.event.movementY||(d3.event.screenY - previousEvent.screenY))/graph.scaleY();
	            previousEvent = d3.event;
	            var l = Math.sqrt(mx*mx+my*my);
	            var theta = Math.atan2(my,mx) - rad;
	            var fx = Math.round(l*Math.cos(theta));
	            var fy = Math.round(l*Math.sin(theta));
	            if(fx === 0 || fy === 0 || fx*fy < 0) {//xy同号
	                return;
	            } else if(fx/fy > ratio) {
	                dx = fy*ratio;
	                dy = fy;
	            } else {
	                dx = fx;
	                dy = fx/ratio;
	            }
	            //整体最小尺寸判断
	            if (cd.brX - cd.tlX - dx <= minWidth || cd.brY - cd.tlY - dy <= minHeight) {
	                return;
	            }
	            //每个元素最小尺寸判断
	            var cdw = cd.brX-cd.tlX;
	            var cdh = cd.brY-cd.tlY;
	            if(nodes.length > 1) {
	            	for(var d, i = 0, len = nodes.length; i < len; i++) {
	                    d = nodes[i].__data__;
	                    var nodeDx = dx * d.width/cdw;
	                    var nodeDy = dy * d.height/cdh;
	                    if(d.width - nodeDx <= minWidth || d.height - nodeDy <= minHeight) {
	                    	return;
	                    }
	                }   
	            }
	            cd.tlX += dx;
	            cd.tlY += dy;
	            refreshControlPoints(nodes, cd, true, cx, cy);
	            //每个元素进行等比缩放,缩放中心点为右下角
	            for(var node, d, i = 0, len = nodes.length; i < len; i++) {
	                node = nodes[i];
	                d = node.__data__;
	                var oldRect = getRect(d);
	                if(len === 1) {
						d.x += dx;
	                	d.y += dy;
	                	d.width -= dx;
	                	d.height -= dy;
	                } else {
	                	var nodeDx = dx * d.width/cdw;
	                	var nodeDy = dy * d.height/cdh;
	                	d.x = (d.x-cd.brX)*(cdw-dx)/cdw+cd.brX;
	                	d.y = (d.y-cd.brY)*(cdh-dy)/cdh+cd.brY;
	                	d.width -= nodeDx;
	                	d.height -= nodeDy;
	                }
	                redrawNode(node, oldRect);
	            }
	        });
	        w.on("mouseup.tlP", function() {
	        	d3.event.stopImmediatePropagation();
	            w.on("mousemove.tlP", null);
	            w.on("mouseup.tlP", null);
	            setAllCursor();
	            refreshControlPoints(nodes, cd, true, cx, cy, true);
	            updateNodes(nodes);
	        });
	    });
	    
	    trP.on("mousedown.trP", function() {
	        d3.event.stopImmediatePropagation();
	        setAllCursor(getResizeCursor("ne-resize"));
	        var dw = cd.brX-cd.tlX;
	        var dh = cd.brY-cd.tlY;
	        var ratio = dw/dh;
	        var cx = cd.tlX + dw/2;
	        var cy = cd.tlY + dh/2;
	        var rad = cd.rotate/180*Math.PI;
	        var dx,dy;
	        var previousEvent = d3.event;
	        w.on("mousemove.trP", function() {
	        	d3.event.stopImmediatePropagation();
	            var mx = (d3.event.movementX||(d3.event.screenX - previousEvent.screenX))/graph.scaleX();//chrome/firefox||兼容ie
	            var my = (d3.event.movementY||(d3.event.screenY - previousEvent.screenY))/graph.scaleY();
	            previousEvent = d3.event;
	            var l = Math.sqrt(mx*mx+my*my);
	            var theta = Math.atan2(my,mx) - rad;
	            var fx = Math.round(l*Math.cos(theta));
	            var fy = Math.round(l*Math.sin(theta));
	            if(fx === 0 || fy === 0 || fx*fy > 0) {//xy反号
	                return;
	            } else if(-fx/fy > ratio) {
	                dx = -fy*ratio;
	                dy = fy;
	            } else {
	            	dx = fx;
	                dy = -fx/ratio;
	            }
	            //整体最小尺寸判断
	            if(cd.brX - cd.tlX + dx <= minWidth || cd.brY - cd.tlY - dy <= minHeight) {
	                return;
	            }
	            //每个元素最小尺寸判断
	            var cdw = cd.brX-cd.tlX;
	            var cdh = cd.brY-cd.tlY;
	            if(nodes.length > 1) {
	                for(var d, i = 0, len = nodes.length; i < len; i++) {
	                    d = nodes[i].__data__;
	                    var nodeDx = dx * d.width/cdw;
	                    var nodeDy = dy * d.height/cdh;
	                    if(d.width + nodeDx <= minWidth || d.height - nodeDy <= minHeight) {
	                        return;
	                    }
	                }   
	            }
	            cd.brX += dx;
	            cd.tlY += dy;
	            refreshControlPoints(nodes, cd, true, cx, cy);
	            //每个元素进行等比缩放,缩放中心点为左下角
	            for(var node, d, i = 0, len = nodes.length; i < len; i++) {
	                node = nodes[i];
	                d = node.__data__;
	                var oldRect = getRect(d);
	                if(len === 1) {
	                	d.y += dy;
	                	d.width += dx;
	                	d.height -= dy;
					} else {
						var nodeDx = dx * d.width/cdw;
	                	var nodeDy = dy * d.height/cdh;
	                	d.x = (d.x-cd.tlX)*(cdw+dx)/cdw+cd.tlX;
	                	d.y = (d.y-cd.brY)*(cdh-dy)/cdh+cd.brY;
	                	d.width += nodeDx;
	                	d.height -= nodeDy;
					}
	                redrawNode(node, oldRect);
	            }
	        });
	        w.on("mouseup.trP", function() {
	        	d3.event.stopImmediatePropagation();
	            w.on("mousemove.trP", null);
	            w.on("mouseup.trP", null);
	            setAllCursor();
	            refreshControlPoints(nodes, cd, true, cx, cy, true);
	            updateNodes(nodes);
	        });
	    });
	    
	    brP.on("mousedown.brP", function() {
	        d3.event.stopImmediatePropagation();
	        setAllCursor(getResizeCursor("se-resize"));
	        var dw = cd.brX-cd.tlX;
	        var dh = cd.brY-cd.tlY;
	        var ratio = dw/dh;
	        var cx = cd.tlX + dw/2;
	        var cy = cd.tlY + dh/2;
	        var rad = cd.rotate/180*Math.PI;
	        var dx,dy;
	        var previousEvent = d3.event;
	        w.on("mousemove.brP", function() {
	        	d3.event.stopImmediatePropagation();
	            var mx = (d3.event.movementX||(d3.event.screenX - previousEvent.screenX))/graph.scaleX();//chrome/firefox||兼容ie
	            var my = (d3.event.movementY||(d3.event.screenY - previousEvent.screenY))/graph.scaleY();
	            previousEvent = d3.event;
	            var l = Math.sqrt(mx*mx+my*my);
	            var theta = Math.atan2(my,mx) - rad;
	            var fx = Math.round(l*Math.cos(theta));
	            var fy = Math.round(l*Math.sin(theta));
	            if(fx === 0 || fy === 0 || fx*fy < 0) {//xy同号
	                return;
	            } else if(fx/fy > ratio) {
	                dx = fy*ratio;
	                dy = fy;
	            } else {
	                dx = fx;
	                dy = fx/ratio;
	            }
	            //整体最小尺寸判断
	            if (cd.brX - cd.tlX + dx <= minWidth || cd.brY - cd.tlY + dy <= minHeight) {
	                return;
	            }
	            //每个元素最小尺寸判断
	            var cdw = cd.brX-cd.tlX;
	            var cdh = cd.brY-cd.tlY;
	            if(nodes.length > 1) {
	                for(var d, i = 0, len = nodes.length; i < len; i++) {
	                    d = nodes[i].__data__;
	                    var nodeDx = dx * d.width/cdw;
	                    var nodeDy = dy * d.height/cdh;
	                    if(d.width + nodeDx <= minWidth || d.height + nodeDy <= minHeight) {
	                        return;
	                    }
	                }   
	            }
	            cd.brX += dx;
	            cd.brY += dy;
	            refreshControlPoints(nodes, cd, true, cx, cy);
	            //每个元素进行等比缩放,缩放中心点为左上角
	            for(var node, d, i = 0, len = nodes.length; i < len; i++) {
	                node = nodes[i];
	                d = node.__data__;
	                var oldRect = getRect(d);
	                if(len === 1) {
	                	d.width += dx;
	                	d.height += dy;
					} else {
						var nodeDx = dx * d.width/cdw;
	                	var nodeDy = dy * d.height/cdh;
	                	d.x = (d.x-cd.tlX)*(cdw+dx)/cdw+cd.tlX;
	                	d.y = (d.y-cd.tlY)*(cdh+dy)/cdh+cd.tlY;
	                	d.width += nodeDx;
	                	d.height += nodeDy;
					}
	                redrawNode(node, oldRect);
	            }
	        });
	        w.on("mouseup.brP", function() {
	        	d3.event.stopImmediatePropagation();
	            w.on("mousemove.brP", null);
	            w.on("mouseup.brP", null);
	            setAllCursor();
	            refreshControlPoints(nodes, cd, true, cx, cy, true);
	            updateNodes(nodes);
	        });
	    });
	    
	    blP.on("mousedown.blP", function() {
	        d3.event.stopImmediatePropagation();
	        setAllCursor(getResizeCursor("sw-resize"));
	        var dw = cd.brX-cd.tlX;
	        var dh = cd.brY-cd.tlY;
	        var ratio = dw/dh;
	        var cx = cd.tlX + dw/2;
	        var cy = cd.tlY + dh/2;
	        var rad = cd.rotate/180*Math.PI;
	        var dx,dy;
	        var previousEvent = d3.event;
	        w.on("mousemove.blP", function() {
	        	d3.event.stopImmediatePropagation();
	            var mx = (d3.event.movementX||(d3.event.screenX - previousEvent.screenX))/graph.scaleX();//chrome/firefox||兼容ie
	            var my = (d3.event.movementY||(d3.event.screenY - previousEvent.screenY))/graph.scaleY();
	            previousEvent = d3.event;
	            var l = Math.sqrt(mx*mx+my*my);
	            var theta = Math.atan2(my,mx) - rad;
	            var fx = Math.round(l*Math.cos(theta));
	            var fy = Math.round(l*Math.sin(theta));
	            if(fx === 0 || fy === 0 || fx*fy > 0) {//xy反号
	                return;
	            } else if(-fx/fy > ratio) {
	                dx = -fy*ratio;
	                dy = fy;
	            } else {
	                dx = fx;
	                dy = -fx/ratio;
	            }
	            //整体最小尺寸判断
	            if (cd.brX - cd.tlX - dx <= minWidth || cd.brY - cd.tlY + dy <= minHeight) {
	                return;
	            }
	            //每个元素最小尺寸判断
	            var cdw = cd.brX-cd.tlX;
	            var cdh = cd.brY-cd.tlY;
	            if(nodes.length > 1) {
	                for(var d, i = 0, len = nodes.length; i < len; i++) {
	                    d = nodes[i].__data__;
	                    var nodeDx = dx * d.width/cdw;
	                    var nodeDy = dy * d.height/cdh;
	                    if(d.width - nodeDx <= minWidth || d.height + nodeDy <= minHeight) {
	                        return;
	                    }
	                }   
	            }
	            cd.tlX += dx;
	            cd.brY += dy;
	            refreshControlPoints(nodes, cd, true, cx, cy);
	            //每个元素进行等比缩放,缩放中心点为右上角
	            for(var node, d, i = 0, len = nodes.length; i < len; i++) {
	                node = nodes[i];
	                d = node.__data__;
	                var oldRect = getRect(d);
	                if(len === 1) {
	                	d.x += dx;
	                	d.width -= dx;
	                	d.height += dy
					} else {
						var nodeDx = dx * d.width/cdw;
	                	var nodeDy = dy * d.height/cdh;
	                	d.x = (d.x-cd.brX)*(cdw-dx)/cdw+cd.brX;
	                	d.y = (d.y-cd.tlY)*(cdh+dy)/cdh+cd.tlY;
	                	d.width -= nodeDx;
	                	d.height += nodeDy;
					}
	                redrawNode(node, oldRect);
	            }
	        });
	        w.on("mouseup.blP", function() {
	        	d3.event.stopImmediatePropagation();
	            w.on("mousemove.blP", null);
	            w.on("mouseup.blP", null);
	            setAllCursor();
	            refreshControlPoints(nodes, cd, true, cx, cy, true);
	            updateNodes(nodes);
	        });
	    });
	    
	    //非等比缩放
	    tcP.on("mousedown.tcP", function() {
	        d3.event.stopImmediatePropagation();
	        setAllCursor(getResizeCursor("n-resize"));
	        var cx = cd.tlX + (cd.brX-cd.tlX)/2;
	        var cy = cd.tlY + (cd.brY-cd.tlY)/2;
	        var rad = -cd.rotate/180*Math.PI;
	        var cosRad = Math.cos(rad);
	        var sinRad = Math.sin(rad);
	        var previousEvent = d3.event;
	        w.on("mousemove.tcP", function() {
	        	d3.event.stopImmediatePropagation();
	            var mx = (d3.event.movementX||(d3.event.screenX - previousEvent.screenX))/graph.scaleX();//chrome/firefox||兼容ie
	            var my = (d3.event.movementY||(d3.event.screenY - previousEvent.screenY))/graph.scaleY();
	            previousEvent = d3.event;
	            var dx = Math.round(mx*cosRad + my*sinRad);
	            var dy = Math.round(my*cosRad + mx*sinRad);
	            //整体最小尺寸判断
	            if (cd.brY - cd.tlY - dy <= minHeight) {
	                return;
	            }
	            //每个元素最小尺寸判断
	            var cdh = cd.brY-cd.tlY;
	            if(nodes.length > 1) {
	                for(var d, i = 0, len = nodes.length; i < len; i++) {
	                    d = nodes[i].__data__;
	                    var nodeDy = dy * d.height/cdh;
	                    if(d.height - nodeDy <= minHeight) {
	                        return;
	                    }
	                }   
	            }
	            cd.tlY += dy;
	            refreshControlPoints(nodes, cd, true, cx, cy);
	            //对每个元素除底边外的部分进行缩放
	            for(var node, d, i = 0, len = nodes.length; i < len; i++) {
	                node = nodes[i];
	                d = node.__data__;
	                var oldRect = getRect(d);
	                if(len === 1) {
	                	d.y += dy;
	                	d.height -= dy;
					} else {
						var nodeDy = dy * d.height/cdh;
	                	d.y = (d.y-cd.brY)*(cdh-dy)/cdh+cd.brY;
	                	d.height -= nodeDy;
					}
	                redrawNode(node, oldRect);
	            }
	        });
	        w.on("mouseup.tcP", function() {
	        	d3.event.stopImmediatePropagation();
	            w.on("mousemove.tcP", null);
	            w.on("mouseup.tcP", null);
	            setAllCursor();
	            refreshControlPoints(nodes, cd, true, cx, cy, true);
	            updateNodes(nodes);
	        });
	    });
	    
	    rcP.on("mousedown.rcP", function() {
	        d3.event.stopImmediatePropagation();
	        setAllCursor(getResizeCursor("e-resize"));
	        var cx = cd.tlX + (cd.brX-cd.tlX)/2;
	        var cy = cd.tlY + (cd.brY-cd.tlY)/2;
	        var rad = cd.rotate/180*Math.PI;
	        var cosRad = Math.cos(rad);
	        var sinRad = Math.sin(rad);
	        var previousEvent = d3.event;
	        w.on("mousemove.rcP", function() {
	        	d3.event.stopImmediatePropagation();
	            var mx = (d3.event.movementX||(d3.event.screenX - previousEvent.screenX))/graph.scaleX();//chrome/firefox||兼容ie
	            var my = (d3.event.movementY||(d3.event.screenY - previousEvent.screenY))/graph.scaleY();
	            previousEvent = d3.event;
	            var dx = Math.round(mx*cosRad + my*sinRad);
	            var dy = Math.round(my*cosRad + mx*sinRad);
	            //整体最小尺寸判断
	            if (cd.brX - cd.tlX + dx <= minWidth) {
	                return;
	            }
	            //每个元素最小尺寸判断
	            var cdw = cd.brX-cd.tlX;
	            var cdh = cd.brY-cd.tlY;
	            if(nodes.length > 1) {
	                for(var d, i = 0, len = nodes.length; i < len; i++) {
	                    d = nodes[i].__data__;
	                    var nodeDx = dx * d.width/cdw;
	                    if(d.width + nodeDx <= minWidth) {
	                        return;
	                    }
	                }   
	            }
	            cd.brX += dx;
	            refreshControlPoints(nodes, cd, true, cx, cy);
	            //对每个元素除左边外的部分进行缩放
	            for(var node, d, i = 0, len = nodes.length; i < len; i++) {
	                node = nodes[i];
	                d = node.__data__;
	                var oldRect = getRect(d);
	                if(len === 1) {
	                	d.width += dx;
					} else {
						var nodeDx = dx * d.width/cdw;
	                	d.x = (d.x-cd.tlX)*(cdw+dx)/cdw+cd.tlX;
	                	d.width += nodeDx;
					}
	                redrawNode(node, oldRect);
	            }
	        });
	        w.on("mouseup.rcP", function() {
	        	d3.event.stopImmediatePropagation();
	            w.on("mousemove.rcP", null);
	            w.on("mouseup.rcP", null);
	            setAllCursor();
	            refreshControlPoints(nodes, cd, true, cx, cy, true);
	            updateNodes(nodes);
	        });
	    });
	    
	    bcP.on("mousedown.bcP", function() {
	        d3.event.stopImmediatePropagation();
	        setAllCursor(getResizeCursor("s-resize"));
	        var cx = cd.tlX + (cd.brX-cd.tlX)/2;
	        var cy = cd.tlY + (cd.brY-cd.tlY)/2;
	        var rad = -cd.rotate/180*Math.PI;
	        var cosRad = Math.cos(rad);
	        var sinRad = Math.sin(rad);
	        var previousEvent = d3.event;
	        w.on("mousemove.bcP", function() {
	        	d3.event.stopImmediatePropagation();
	            var mx = (d3.event.movementX||(d3.event.screenX - previousEvent.screenX))/graph.scaleX();//chrome/firefox||兼容ie
	            var my = (d3.event.movementY||(d3.event.screenY - previousEvent.screenY))/graph.scaleY();
	            previousEvent = d3.event;
	            var dx = Math.round(mx*cosRad + my*sinRad);
	            var dy = Math.round(my*cosRad + mx*sinRad);
	            //整体最小尺寸判断
	            if (cd.brY - cd.tlY + dy <= minHeight) {
	                return;
	            }
	            //每个元素最小尺寸判断
	            var cdh = cd.brY-cd.tlY;
	            if(nodes.length > 1) {
	                for(var d, i = 0, len = nodes.length; i < len; i++) {
	                    d = nodes[i].__data__;
	                    var nodeDy = dy * d.height/cdh;
	                    if(d.height + nodeDy <= minHeight) {
	                        return;
	                    }
	                }   
	            }
	            cd.brY += dy;
	            refreshControlPoints(nodes, cd, true, cx, cy);
	            //对每个元素除顶边外的部分进行缩放
	            for(var node, d, i = 0, len = nodes.length; i < len; i++) {
	                node = nodes[i];
	                d = node.__data__;
	                var oldRect = getRect(d);
	                if(len === 1) {
	                	d.height += dy;
					} else {
						var nodeDy = dy * d.height/cdh;
	                	d.y = (d.y-cd.tlY)*(cdh+dy)/cdh+cd.tlY;
	                	d.height += nodeDy;
					}
	                redrawNode(node, oldRect);
	            }
	        });
	        w.on("mouseup.bcP", function() {
	        	d3.event.stopImmediatePropagation();
	            w.on("mousemove.bcP", null);
	            w.on("mouseup.bcP", null);
	            setAllCursor();
	            refreshControlPoints(nodes, cd, true, cx, cy, true);
	            updateNodes(nodes);
	        });
	    });
	    
	    lcP.on("mousedown.lcP", function() {
	        d3.event.stopImmediatePropagation();
	        setAllCursor(getResizeCursor("w-resize"));
	        var cx = cd.tlX + (cd.brX-cd.tlX)/2;
	        var cy = cd.tlY + (cd.brY-cd.tlY)/2;
	        var rad = cd.rotate/180*Math.PI;
	        var cosRad = Math.cos(rad);
	        var sinRad = Math.sin(rad);
	        var previousEvent = d3.event;
	        w.on("mousemove.lcP", function() {
	        	d3.event.stopImmediatePropagation();
	            var mx = (d3.event.movementX||(d3.event.screenX - previousEvent.screenX))/graph.scaleX();//chrome/firefox||兼容ie
	            var my = (d3.event.movementY||(d3.event.screenY - previousEvent.screenY))/graph.scaleY();
	            previousEvent = d3.event;
	            var dx = Math.round(mx*cosRad + my*sinRad);
	            var dy = Math.round(my*cosRad + mx*sinRad);
	            //整体最小尺寸判断
	            if (cd.brX - cd.tlX - dx <= minWidth) {
	                return;
	            }
	            //每个元素最小尺寸判断
	            var cdw = cd.brX-cd.tlX;
	            if(nodes.length > 1) {
	                for(var d, i = 0, len = nodes.length; i < len; i++) {
	                    d = nodes[i].__data__;
	                    var nodeDx = dx * d.width/cdw;
	                    if(d.width - nodeDx <= minWidth) {
	                        return;
	                    }
	                }   
	            }
	            cd.tlX += dx;
	            refreshControlPoints(nodes, cd, true, cx, cy);
	            //对每个元素除右边外的部分进行缩放
	            for(var node, d, i = 0, len = nodes.length; i < len; i++) {
	                node = nodes[i];
	                d = node.__data__;
	                var oldRect = getRect(d);
	                if(len === 1) {
	                	d.x += dx;
	                	d.width -= dx;
					} else {
						var nodeDx = dx * d.width/cdw;
	                	d.x = (d.x-cd.brX)*(cdw-dx)/cdw+cd.brX;
	                	d.width -= nodeDx;
					}
	                redrawNode(node, oldRect);
	            }
	        });
	        w.on("mouseup.lcP", function() {
	        	d3.event.stopImmediatePropagation();
	            w.on("mousemove.lcP", null);
	            w.on("mouseup.lcP", null);
	            setAllCursor();
	            refreshControlPoints(nodes, cd, true, cx, cy, true);
	            updateNodes(nodes);
	        });
	    });
	};
	
	/**
	 * 判断一个矩形rect1是否包含另外一个矩形rect2
	 * @param rect1 矩形1 rect:{x, y, width, height}
	 * @param rect2 矩形2
	 */
	var isContain = function(rect1, rect2) {
		var rect2X = rect2.hasOwnProperty("tx") ? rect2.x + rect2.tx : rect2.x;
		var rect2Y = rect2.hasOwnProperty("ty") ? rect2.y + rect2.ty : rect2.y;
	    return  rect1.x < rect2X &&
	            rect1.y < rect2Y &&
	            rect1.x + rect1.width > rect2X +　rect2.width &&
	            rect1.y + rect1.height > rect2Y +　rect2.height;
	};
	
	var findNodeObjByNode = function(node) {
		for(var i = 0, len = childNodes.length; i < len; i++) {
	        if(childNodes[i] === node) {
	        	return childNodes[i];
	        }
		}
		return null;
	}
	
	var getIndexByNode = function(node, source) {
	    for(var i = 0, len = source.length; i < len; i++) {
	        if(source[i] === node) {
	            return i;
	        }
	    }
	    return -1;
	}
	
	module.exports = SelectUtil;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 128 */
/***/ (function(module, exports) {

	// 字符串工具类
	
	var StringUtil = {};
	
	var canvas = document.createElement("canvas");//用于字体尺寸度量
	var ctx = canvas.getContext("2d");
	
	// --------------------------------------------------------------------------
	//
	// static public Methods
	//
	// --------------------------------------------------------------------------
	
	/**
	 * 根据行数切割文本
	 * @param text 文本内容
	 * @param width 行宽度(px)
	 * @param fontsize 文本字号(px)
	 * @param textLine 文本行数
	 * @return 返回切割后的文本数组，每个元素代表一行内容
	 */
	StringUtil.splitByLine = function(text, width, fontsize, textLine) {
	    if (width == 0 || text == undefined)
	        return [text];
	    var curLen = 0, line = 1;
	    var result = [];
	    var start = 0, end = 0;
	    for (var i = 0; i < text.length; i++) {
	        var code = text.charCodeAt(i);
	        var pixelLen = code > 255 ? fontsize : fontsize / 2;
	        curLen += pixelLen;
	        if (curLen > width) {
	            end = i;
	            if (line === textLine) {
	                end > 1 ? end -= 2 : end = 1;
	                result.push(text.substring(start, end) + "...");
	                break;
	            }
	            result.push(text.substring(start, end));
	            start = i;
	            curLen = 0;
	            line++;
	        }
	        if (i === text.length - 1) {
	            result.push(text.substring(start, text.length));
	        }
	    }
	    return result;
	};
	
	/**
	 * 测量文本尺寸
	 * @param texts 文本字符串内容或者多行文本字符串内容，多行文本用数组[line1String,...,linenString]这种形式，
	 *              不支持"\n"形式换行的多行文本测量。
	 * @param fontSize 文本字号(px)
	 * @param fontFamily 文本字体
	 * @param isBold 是否粗体（默认false）
	 * @param isItalic 是否斜体（默认false）
	 * @return 返回文本尺寸,格式为{width:width, height:height}
	 */
	StringUtil.measureText = function(texts, fontSize, fontFamily, isBold, isItalic) {
		fontSize = !isNaN(fontSize) ? parseInt(fontSize) : ghca_charts.view.util.regexUtil.px(fontSize);
		ctx.font = (isItalic ? "italic " : "") + (isBold ? "bold " : "") + fontSize + "px " + fontFamily;
		ctx.textBaseline = 'top';
		var width = 0, height;
		if(texts.length) {
			for(var w, i = 0, len = texts.length; i < len; i++) {
				w = Math.round(ctx.measureText(texts[i]).width);
				if(w > width) {
					width = w;
				}
			}
	        heigth = Math.round(fontSize * texts.length * 1.25);
		} else {
			width = Math.round(ctx.measureText(texts).width);
	        heigth = Math.round(fontSize * 1.25);
		}
		return {width:width, height:heigth};
	}
	
	/**
	 * 保留svg text元素中文本的空格显示(默认会把多个连续空格合并成一个空格显示)
	 * @param ele svg text元素
	 * @param spaceWidth 空格宽度(em)，默认0.5em
	 */
	StringUtil.fixTextSpace = function(ele, spaceWidth) {
	    var content = ele.textContent;
	    var dx = [];
	    var i = -1;
	    var counter = 0;
	    spaceWidth = spaceWidth || 0.5;
	    while(++i < content.length) {
	        if (content[i] === ' ') {
	            //空格判断
	            counter++;
	        } else {
	            dx.push(counter * spaceWidth + 'em');
	            counter = 0;
	        }
	    }
	    ele.textContent = content.replace(/ /g, '');    //空格字符排除掉
	    ele.setAttribute('dx', dx.join(','));           //设置字符水平偏移量
	};
	
	/**
	 * 解析百分比字符串
	 * @param value 要解析的字符串
	 * @return 返回解析出的百分比数字部分，若格式错误，则返回value
	 */
	StringUtil.parsePercent = function(value) {
		if(!ghca_charts.view.util.objectUtil.isString(value)) {
	        return value;
	    }
	    var result = value.match(ghca_charts.view.util.regexUtil.percentRegex);
	    if(result === null) {
	        return value;
	    }
	    var pv = parseFloat(result[1]);
	    if(isNaN(pv)) {
	        return value;
	    }
	    return pv;
	};
	
	/**
	 * 解析数组字符串
	 * @param value 要解析的字符串
	 * @return 返回解析出的数组，若格式错误，则返回value
	 */
	StringUtil.parseArray = function(value) {
		if(!ghca_charts.view.util.objectUtil.isString(value)) {
	        return value;
	    }
	    var result;
	    try {
	    	result = eval(value);
	    } catch(e) {
	    	return value;
	    }
	    return ghca_charts.view.util.objectUtil.isArray(result) ? result : value;
	};
	
	module.exports = StringUtil;


/***/ }),
/* 129 */
/***/ (function(module, exports) {

	// svg工具类
	var SvgUtil = {};
	
	// --------------------------------------------------------------------------
	//
	// static public Methods
	//
	// --------------------------------------------------------------------------
	
	/**
	 * 移除某个dom元素的所有子元素
	 * 
	 * @param {elements} elements 一个DOM节点对象
	 */
	SvgUtil.removeAllChildren = function(element) {
		//element.innerHTML = ""这样的写法ie与非ie执行效果不一致
		if(element) {
			while(element.hasChildNodes()) {  
	            element.removeChild(element.firstChild);  
	        }  
		}
	};
	
	/**
	 * 解析SVG元素z-index属性，并根据其值定义元素的层级 规则：z-index越大，层级越高
	 * 
	 * @param {elements} elements 一个包含DOM节点的类数组对象或者数组
	 * @param {isIterator} isIterator 是否递归子节点排序
	 * @return {void}
	 */
	SvgUtil.sortByZIndex = function(elements, isIterator) {
		var elements_arr = [];
		// 遍历节点列表，初始化一些设置
		for (var i = 0, len = elements.length; i < len; i++) {
			var elem = elements[i];
			// 某些类型的节点可能没有getAttribute属性，你也可以根据nodeType属性来判断
			if (!elem.getAttribute)
				continue;
	
			// 递归子节点
			if (isIterator && elem.childNodes) {
				SvgUtil.sortByZIndex(elem.childNodes);
			}
			// 默认所有元素都处于第0级
			if (!elem.getAttribute("z-index")) {
				elem.setAttribute("z-index", 0);
			}
			elements_arr.push(elem);
		}
	
		if (elements_arr.length === 0) {
			return;
		}
	
		// 根据z-index属性进行排序
		elements_arr.sort(function(e1, e2) {
			var z1 = parseInt(e1.getAttribute("z-index"));
			var z2 = parseInt(e2.getAttribute("z-index"));
			if (z1 === z2) {
				return 0;
			} else if (z1 < z2) {
				return -1;
			} else {
				return 1;
			}
		});
		// 排序完成后，按顺序移动这些元素
		var parent = elements_arr[0] && elements_arr[0].parentNode;
		for (var i = 0, len = elements_arr.length; i < len; i++) {
			var elem = elements_arr[i];
			// 提示：appendChild里的elem节点如果在页面中已经存在
			// 那么表示这个节点从原来的地方移动到parent最后的地方，而不是以一个新节点插入
			parent.appendChild(elem);
		}
	};
	
	SvgUtil.hasElementInDefs = function (svg, id) {
	    if(!svg) {
	        return false;
	    }
	    var defs = getDefs(svg);
	    if(!defs) {
	        return false;
	    }
	    return defs.select("#" + id).node() !== null;
	};
	
	SvgUtil.createDefElement = function(svg,data){
		if(SvgUtil.hasElementInDefs(svg, data.id)) {
			SvgUtil.deleteDefsElement(svg, data.id);
		}
	    var defs = getDefs(svg);
	    if(!defs) {
	    	defs = createDefs(svg);
	    }
	    switch(data.clazz){
	        case "image":{
	            var config = data.config;
	            var g = defs.append("g").attr("id",data.id);
	            g.append("image").attr("width",config.imageWidth)
	                .attr("height",config.imageHeight)
	                .attr("xlink:href",config.url)
	                .attr("x",-config.imageWidth/2)
	                .attr("y",-config.imageHeight/2);
	            break;
	        }
	        case "ref":{
	            var config = data.config;
	            var defsNode = defs.node();
	            var html = config && config.html;
	            if(Object.prototype.toString.call(html) === "[object String]") {
	            	html = html.replace(" ", " id='" + data.id + "' ");
	            	defsNode.innerHTML += html;
	            }
	            break;
	        }
	    }
	};
	
	
	SvgUtil.createRectMask = function(svg, id, x, y, width, height, rx, ry) {
		if(isNaN(rx) && isNaN(ry)) {
			rx = 0;
			ry = 0;
		} else if(!isNaN(rx) && isNaN(ry)) {
	        ry = rx;
	    } else if(isNaN(rx) && !isNaN(ry)) {
	        rx = ry;
	    }
		
		if(SvgUtil.hasElementInDefs(svg, id)) {
			svg.select("#" + id + " rect")
				.attr("x", x)
	            .attr("y", y)
	            .attr("width", width)
	            .attr("height", height)
	            .attr("rx", rx)
	            .attr("ry", ry);
			
			return null;
		}
		var defs = createDefs(svg);
		var mask = defs.append("mask")
	        .attr("id", id)
	        .attr("maskUnits", "userSpaceOnUse")
	        .append("rect")
	        .attr("x", x)
	        .attr("y", y)
	        .attr("width", width)
	        .attr("height", height)
	        .attr("rx", rx)
	        .attr("ry", ry)
	        .attr("fill", "#fff");
	        
	    return mask;
	};
	
	SvgUtil.deleteDefsElement = function(svg, id) {
	    var defs = getDefs(svg);
	    if(defs) {
	    	defs.select("#" + id).remove();
	    }
	};
	
	/**
	 * 用于获得DOM元素到浏览器可视范围的距离（不包含文档卷起的部分）
	 * 
	 * @param {node} DOM元素
	 * @param {scaleX} 当前水平缩放值
	 * @param {scaleY} 当前垂直缩放值
	 * @return 返回DOM元素到浏览器可视范围的距离（不包含文档卷起的部分）
	 */
	SvgUtil.getBoundingClientRect = function(node, scaleX, scaleY) {
	    var rect = node.getBoundingClientRect();
	    //这样设置是因为rect属性为只读
	    return {
	    	left:   rect.left/scaleX,
	        right:  rect.right/scaleX,
	        top:    rect.top/scaleY,
	        bottom: rect.bottom /scaleY
	    };
	};
	
	/**
	 * 用于获得全局坐标到SVG元素本地坐标值
	 * 
	 * @param {node} SVG元素
	 * @param {x} 全局x坐标
	 * @param {y} 全局y坐标
	 * @return 返回SVG元素本地坐标值{x:x, y:y}
	 */
	SvgUtil.globalToLocal = function(node, x, y) {
		var svg = node.ownerSVGElement || node;
	    if (svg.createSVGPoint) {
	        var point = svg.createSVGPoint();
	        point.x = x; 
	        point.y = x;
	        /*CTM矩阵是局部坐标系(即指定对象内部坐标系，只有svg支持改方法)到屏幕坐标系的转换系数矩阵
	                                局部坐标矩阵*CTM = 屏幕坐标矩阵
	                                屏幕坐标矩阵*CTM逆矩阵(即screenCTM.inverse()) = 局部坐标矩阵
	        */
	        var screenCTM = node.getScreenCTM();
	        //根据屏幕坐标计算局部坐标
	        point = point.matrixTransform(screenCTM.inverse());
	        return {x:point.x, x:point.y};
	    }
	    return {x:x, y:y};
	};
	
	/**
	 * 用于获得SVG元素本地坐标带到全局坐标值
	 * 
	 * @param {node} SVG元素
	 * @param {x} SVG元素本地x坐标
	 * @param {y} SVG元素本地y坐标
	 * @return 返回全局坐标值{x:x, y:y}
	 */
	SvgUtil.localToGlobal = function(node, x, y) {
	    var svg = node.ownerSVGElement || node;
	    if (svg.createSVGPoint) {
	        var point = svg.createSVGPoint();
	        point.x = x; 
	        point.y = x;
	        /*CTM矩阵是局部坐标系(即指定对象内部坐标系，只有svg支持改方法)到屏幕坐标系的转换系数矩阵
	                                局部坐标矩阵*CTM = 屏幕坐标矩阵
	                                屏幕坐标矩阵*CTM逆矩阵(即screenCTM.inverse()) = 局部坐标矩阵
	        */
	        var screenCTM = node.getScreenCTM();
	        //根据屏幕坐标计算局部坐标
	        point = point.matrixTransform(screenCTM);
	        return {x:point.x, x:point.y};
	    }
	    return {x:x, y:y};
	};
	
	// --------------------------------------------------------------------------
	//
	// private Methods
	//
	// --------------------------------------------------------------------------
	
	const getDefs = function(svg) {
	    if(!svg) {
	        return null;
	    }
	    var defs = svg.select("defs");
	    if(defs.node() === null) {
	        return null;
	    }
	    return defs;
	}
	
	const createDefs = function(svg) {
	    var defs = getDefs(svg);
	    if(!defs) {
	        defs = svg.insert("defs", "svg.svgContainer g.bgContainer");
	    }
	    return defs;
	}
	
	const deleteDefs = function(svg) {
	    var defs = getDefs(svg);
	    if(defs) {
	        defs.remove();
	    }
	}
	
	module.exports = SvgUtil;

/***/ }),
/* 130 */
/***/ (function(module, exports) {

	//表格的格式化
	var TableColFormatterUtil = {};
	
	TableColFormatterUtil.parseFormatter=function(data,colFormatter){  
	    var cols=data.columns;
	    if(!cols){
	        return;
	    }
	    var len=cols.length;
	    for(var i=0;i<len;i++){
	        var colData=cols[i];
	        setColFormatter(colData,colFormatter);
	    }
	}
	
	//custom progressbar formatter
	const customPbFormatter = function(cell, formatterParams, onRendered) {
	    //cell - the cell component
	    //formatterParams - parameters set for the column
	    //onRendered - function to call when the formatter has been rendered
	
		//create and style render
		var pbStyle = formatterParams ? formatterParams.pbStyle : '';
		var pbBgStyle = formatterParams ? formatterParams.pbBgStyle : '';
		var valueTextStyle = formatterParams ? formatterParams.valueTextStyle : '';
		var percentTextStyle = formatterParams ? formatterParams.percentTextStyle : '';
		var value = cell.getValue();
		var min = isNaN(formatterParams.min) ? 0 : parseFloat(formatterParams.min);
		var max = isNaN(formatterParams.max) ? value : parseFloat(formatterParams.max);
		max < min && (max = min);
		isNaN(value) && (value = 0);
		value = parseFloat(value);
		value < min && (value = min);
		value > max && (value = max);
		var pbBgWidthPercent = 100;
		var pbWidthPercent = value / max * pbBgWidthPercent;
		var percentLabel = Math.round(value / max * 100) + "%";
		pbStyle += "width:" + pbWidthPercent + "%;";
		pbBgStyle += "width:" + pbBgWidthPercent + "%;";
	    var render = $("<div>" +
			    			"<div style='" + pbBgStyle + "'>" +
			    				"<div style='" + pbStyle + "'/>" +
			    				"<div style='" + valueTextStyle + "'>" + value + "</div>" +
			    				"<div style='" + percentTextStyle + "'>" + percentLabel + "</div>" +
							"</div>" +
						"</div>");
	    render.css({
	        "padding":"3px",
	        "width":"100%",
	        "box-sizing":"border-box"
	    });
	
	    //Set value of render to the current value of the cell
	    render.val(cell.getValue());
	    
	    //return the editor element
	    return render;
	};
	
	const setColFormatter=function (colData,colFormatter){
	    var len=colFormatter.length;
	    if(colData.field){
	        for(var i=0;i<len;i++){
	            var formatter=colFormatter[i];
	            if(formatter.field===colData.field){
	                if(TableColFormatterUtil.Formatter[formatter.formatter]){//设置为配置的格式器
	                    colData.formatter=TableColFormatterUtil.Formatter[formatter.formatter];
	                    colData.customeFormatter=formatter.formatter;
	                    if(formatter.formatterParams){
	                        colData.formatterParams=formatter.formatterParams;
	                    }
	                    return;
	                }else if(colData.customeFormatter){
	                    colData.formatter=null;
	                    colData.customeFormatter=null;
	                }
	            }
	        }
	    }else if(colData.columns){
	        TableColFormatterUtil.parseFormatter(colData,colFormatter);
	    }
	}
	
	TableColFormatterUtil.Formatter={
	    cssFormater:function(cell, formatterParams) {//css格式化
	              cell.getElement().css(formatterParams);
	        return cell.getValue();
	    },
	    customPbFormatter:customPbFormatter//自定义进度条
	}
	
	module.exports = TableColFormatterUtil;

/***/ }),
/* 131 */
/***/ (function(module, exports) {

	var UUID = {};
	var reg = /[xy]/g;
	var templete = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx-xxxx';
	UUID.generateUUID = function () {
	    var d = new Date().getTime();
	    var uuid = templete.replace(reg, function(c) {
	        var r = (d + Math.random()*16)%16 | 0;
	        d = Math.floor(d/16);
	        return (c==='x' ? r : (r&0x3|0x8)).toString(16);
	    });
	    // var uuid = 'xxxxxxxx'.replace(/[xy]/g, function(c) {
	    //     var r = (d + Math.random()*16)%16 | 0;
	    //     d = Math.floor(d/16);
	    //     return (c=='x' ? r : (r&0x3|0x8)).toString(16);
	    // });
	    return uuid;
	};
	module.exports = UUID;

/***/ })
/******/ ]);
//# sourceMappingURL=ghca_charts.js.map